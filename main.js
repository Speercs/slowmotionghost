(function (exports) {

	var Segments = /*#__PURE__*/Object.freeze({
		__proto__: null,
		get run () { return run$14; },
		get ready () { return ready; },
		get access () { return access; },
		get save () { return save; },
		get saveAllPendingSegmentData () { return saveAllPendingSegmentData; },
		get requestDefence () { return requestDefence; },
		get requestResource () { return requestResource; },
		get removeResourceRequest () { return removeResourceRequest; },
		get removeDefenceRequest () { return removeDefenceRequest; },
		get getRoadPositions () { return getRoadPositions; },
		get setRoadPositions () { return setRoadPositions; }
	});
	var RoleModules = /*#__PURE__*/Object.freeze({
		__proto__: null,
		get ambushCollector () { return ambushCollector; },
		get ambusher () { return ambusher; },
		get attacker () { return attacker; },
		get bucket () { return bucket; },
		get builder () { return builder; },
		get bulkTrader () { return bulkTrader; },
		get caravanHauler () { return caravanHauler; },
		get claimer () { return claimer; },
		get claimMedic () { return claimMedic; },
		get colonist () { return colonist; },
		get colonistMiner () { return colonistMiner; },
		get convoyAmbusher () { return convoyAmbusher; },
		get coreHauler () { return coreHauler; },
		get coreKiller () { return coreKiller; },
		get decoy () { return decoy; },
		get depositBlocker () { return depositBlocker; },
		get depositCarry () { return depositCarry; },
		get depositMiner () { return depositMiner; },
		get donor () { return donor; },
		get dozer () { return dozer; },
		get exitBlocker () { return exitBlocker; },
		get filler () { return filler; },
		get fixer () { return fixer; },
		get gnat () { return gnat; },
		get guard () { return guard; },
		get harasser () { return harasser; },
		get harvester () { return harvester; },
		get hybrid () { return hybrid; },
		get medic () { return medic; },
		get miner1 () { return miner1; },
		get Mminer () { return Mminer; },
		get monk () { return monk; },
		get mover () { return mover; },
		get observer () { return observer; },
		get powermover () { return powermover; },
		get prayerSupport () { return prayerSupport; },
		get pTransfer () { return pTransfer; },
		get puller () { return puller; },
		get RCattack () { return RCattack; },
		get recycle () { return recycle; },
		get reinforcer () { return reinforcer; },
		get relocator () { return relocator; },
		get remotefixer () { return remotefixer; },
		get remoteminer () { return remoteminer; },
		get remoteMinerDeputy () { return remoteMinerDeputy; },
		get reserve () { return reserve; },
		get scoreCollector () { return scoreCollector; },
		get scoreDropper () { return scoreDropper; },
		get scoreMiner () { return scoreMiner; },
		get scout () { return scout; },
		get shardAttack () { return shardAttack; },
		get shardMedic () { return shardMedic; },
		get signer () { return signer; },
		get skirmisher () { return skirmisher; },
		get SKMineralMiner () { return SKMineralMiner; },
		get SKMineralMover () { return SKMineralMover; },
		get sniper () { return sniper; },
		get soldier () { return soldier; },
		get staticFiller () { return staticFiller; },
		get staticUpgrader () { return staticUpgrader; },
		get symbolDecoder () { return symbolDecoder; },
		get testTrader () { return testTrader; },
		get thief () { return thief; },
		get thoriumBaseHauler () { return thoriumBaseHauler; },
		get thoriumMineFiller () { return thoriumMineFiller; },
		get thoriumMineHauler () { return thoriumMineHauler; },
		get thoriumMineOverseer () { return thoriumMineOverseer; },
		get thoriumMiner () { return thoriumMiner; },
		get thoriumMineWorker () { return thoriumMineWorker; },
		get thoriumReactorHauler () { return thoriumReactorHauler; },
		get trader () { return trader; },
		get transfer () { return transfer; },
		get upgrader () { return upgrader; },
		get upHauler () { return upHauler; },
		get vision () { return vision; },
		get wallBuilder () { return wallBuilder; },
		get wallRemover () { return wallRemover; },
		get yak () { return yak; }
	});

	//access config in code by global.config.x
	if (Game.shard.name.slice(0, 5) != 'shard');
	let config$1 = {
			activeShards: [],
			// the size of the difference after which an transport of resources intershard is possible (variable*energyprice)
			//adjusted ally - normal ally except remotes are defended from them - detects armed creeps in danger rooms
			adjustedAllies:[],
			alliedSegments: [],
			allies: [],
			//allies also get nearby rooms tolerated - whitelist if you just want to not attack, whitelist will be auto revoked if hostile actions in room
			//whitelist does not apply in rooms, where as ally does - if you want whitelist in rooms then you can use allow in
			allowCivRoomAccess:[],
			allowedProximity:{
					//how close other players are allowed to settle at this distance
			},
			allPublicRamps: false,
			alwaysGuard: [],
			attackAll: true,
			attackRooms:[],
			autoAttackEnemies:false,
			autoClear:2,
			autoExpand: true,
			autoHarassEnemies:false,
			blackList: [],
			blockPraise:false,
			blockSafemode:[],
			bombard: [],
			boostLevels: {
					1: ['ZH', 'LO', 'UH', 'KO', 'ZO'],
					2: ['ZH2O', 'LHO2', 'UH2O', 'KHO2', 'ZHO2'],
					3: ['ZH2O', 'GHO2', 'LHO2', 'UH2O', 'KHO2', 'ZHO2'],
					4: ['XZH2O', 'XGHO2', 'XLHO2', 'XUH2O', 'XKHO2', 'XZHO2'],
					5: ['XZH2O', 'XGHO2', 'XLHO2', 'XUH2O', 'XKHO2', 'XZHO2'],
					6: ['LO','ZO','ZH','UH'],
					6.1:['LO','KO'],
					7: ['LO'],
					8:  ['LHO2','ZO','ZH','UH2O'],
					9: ['LHO2'],
					10:  ['GHO2','XZH2O', 'XLHO2', 'XZHO2','KHO2']
			},
			breakHighwayWalls: [],
			brigade: false,
			buildVer: 'v3',
			canShare: false,
			canTransfer: true,
			commodityConst: 200,
			conserveCpu: true,
			dangerousEnemies:[],
			decoderSharingList: [],
			depositBoostedCooldown: 217,
			depositMaxCooldown: 119,
			depositMine: false,
			desiredRoomSpacing:5,
			detailedLog: true,
			display:false,
			enemies: [],
			energyDonorMinLevel:6,
			energyReserve: 150000,
			excess: 15000,
			factoryOperatorSchema: {
					1: {opLevel: 3, fillerPowers: [13, 3, 2, 14, 6]},
					2: {opLevel: 3, fillerPowers: [13, 3, 2, 14, 6]},
					3: {opLevel: 4, fillerPowers: [13, 3, 2, 14, 6]},
					4: {opLevel: 4, fillerPowers: [13, 3, 2, 14, 6]},
					5: {opLevel: 5, fillerPowers: [13, 3, 2, 14, 6]},
					'alert':{opLevel:5,fillerPowers:[3,2,17,13,6,14]}
			},
			factoryRatio: {
					1: 26,
					2: 24,
					3: 20,
					4: 16,
					5: 12
			},
			factoryRooms: {
					1: [],
					2: [],
					3: [],
					4: [],
					5: []
			},
			fixRemotes: {
					//'E29N1':['E29N2']
			},
			forceEnergyTarget:undefined,
			highSymbolBound: 100000,
			highwayWalls: false,
			hitList: [],
			ignoreAutoAttackTarget:[],
			ignoreRemotes: [],
			//how much to send of each commodity
			interShardPriceVariable: 5,
			level5Commodities: ['essence', 'machine', 'organism', 'device'],
			level7max:false,
			levels: {
					//term val is how much of items should be stored in term before being moved to storage
					termVal: 5000
			},
			logEnergy: true,
			logStats: true,
			lowCPU: false,
			lowLevelWalls: 100000,
			lowSymbolBound: 50000,
			mapVisual: false,
			marketActive:true,
			maxCredits: 5000,
			maxSiteNumber: 50,
			minCredits: 500,
			mineralCollection: true,
			mineralCollectionLevel:8,
			minerals: ['H', 'O', 'U', 'L', 'K', 'Z', 'X'],
			mineralTarget: 5000,
			//warboosts and desired quantity
			minWalls: {
					1:0,
					2:0,
					3:0,
					4:50000,
					5:200000,
					6:500000,
					7:1000000,
					8:2000000
			},
			multipleHarvesters: false,
			needVision: [],
			nextClaims: [],
			official: false,
			operations: {
			},
			pauseRemoteRoads:[],
			portalTravelEnabled:false,
			powerCollection: false,
			powerCreepSchema: {
					//'season':{levels:[1,2,1,2,3,17,3,1,2],allRooms:true,minLevel:4}
			},
			powerStoreMax:12000,
			publicRamps: [],
			private:false,
			processPower:false,
			profileFunctions:false,
			rampartAdjust:1.5,
			remotesCanCrossHighways:false,
			requestEnergyRoom: [],
			requestEnergyRoomLocal:[],
			resources: {},
			saveRoutes:true,
			scouts: true,
			season: false,
			segmentId: 98,
			shareList: ['H', 'O', 'U', 'L', 'K', 'Z', 'X', 'G', 'OH', 'ops', 'XZH2O', 'XGHO2', 'XLHO2', 'XUH2O', 'XKHO2', 'XZHO2', 'XLH2O', 'energy'],
			SKMine:true,
			squadBoostTypes: {
					'attack': ['UH', 'UH2O', 'XUH2O'],
					'ranged_attack': ['KO', 'KHO2', 'XKHO2'],
					'heal': ['LO', 'LHO2', 'XLHO2'],
					'move': ['ZO', 'ZHO2', 'XZHO2'],
					'tough': ['GO', 'GHO2', 'XGHO2'],
					'work': ['ZH', 'ZH2O', 'XZH2O']
			},
			superColonists: false,
			swc:true,
			swampyGround: false,
			symbolCollection: false,
			totalWhiteList: [],
			wallAdjust: 3,
			wallTarget: 5000000,
			warboosts: {
					'XUH2O': 10000,
					'XLH2O': 5000,
					'XZH2O': 5000,
					'XGHO2': 10000,
					'XLHO2': 10000,
					'XZHO2': 10000,
					'XKHO2': 5000,
					'UH2O': 3000,
					'ZHO2': 3000,
					'ZH2O': 3000,
					'GHO2': 3000,
					'LHO2': 3000,
					'KHO2': 3000,
					'ZH': 5000,
					'LO': 5000,
					'LH': 5000,
					'UH': 5000,
					'KO': 5000,
					'ZO': 5000,
					'GO':5000
			},
			//single room sources are x2
			weirdSources: false,
			//desired level of each resource in each room
			whiteList: [],
			whiteListAll: false
	};

	let playerHeap = {};
	playerHeap.roomTerrainCache = {};
	playerHeap.SKMatrixCache = {};
	playerHeap.SKAvoidLists = {};
	playerHeap.roomStatus = {};
	playerHeap.highwayMine = {};
	playerHeap.towerPowerMatrixCache = {};
	playerHeap.structureMatrixCache = {};
	playerHeap.defenceMatrixCache = {};
	playerHeap.hostileStructureMatrixCache = {};
	playerHeap.roadMatrixCache = {};
	playerHeap.lastSpawnAll = {};
	playerHeap.sourceExtensionCache = {};
	playerHeap.roomCache = {};
	playerHeap.creepCache = {};
	playerHeap.boostedCreeps = {};
	playerHeap.renewList = {};

	playerHeap.bodyCache = {};
	function cacheBody( role, key, body){
			if (!playerHeap.bodyCache[role]){
					playerHeap.bodyCache[role] = {};
			}
			playerHeap.bodyCache[role][key] = body;
	}
	function getCachedBody(role,key){
			if (!playerHeap.bodyCache[role]){
					return
			}
			return playerHeap.bodyCache[role][key];
	}

	function run$1l(creep){

		if (creep.home && creep.home.memory && creep.home.memory.ambushCollection){
			let targetRoom = Game.rooms[creep.home.memory.ambushCollection];
			if (creep.memory.dropping){
				let store = creep.home.storage;
				if (store && !creep.pos.isNearTo(store)){
					creep.moveTo(store, {range: 1});
				} else {
					for (let i in creep.store){
						creep.transfer(store, i);
					}
				}
				if (creep.store.getUsedCapacity() === 0){
					if (creep.ticksToLive < 400){
						creep.suicide();
					}
					delete creep.memory.dropping;
				}
			} else {
				if (creep.home.memory.ambushCollection && ((targetRoom && creep.room.name != targetRoom.name) || !targetRoom)){
					creep.goTo(new RoomPosition(25, 25, creep.home.memory.ambushCollection));
				} else {
					var drop = creep.room.find(FIND_DROPPED_RESOURCES)[0];
					var tomb = creep.room.find(FIND_TOMBSTONES, {filter: (s) => _.sum(s.store) > 0})[0];
					if (drop && _.sum(creep.store) < creep.store.getCapacity()){
						if (!creep.pos.isNearTo(drop)){
							creep.moveTo(drop);
						} else {
							creep.pickup(drop);
						}
					} else if (tomb && _.sum(creep.store) < creep.store.getCapacity()){
						if (!creep.pos.isNearTo(tomb)){
							creep.moveTo(tomb);
						} else {
							for (let i in tomb.store){
								creep.withdraw(tomb, i);
							}
						}
					} else {
						if (!tomb){
							console.log('ambush', creep.pos);
							delete creep.home.memory.ambushCollection;
						}
						creep.memory.dropping = true;
					}
				}
			}
		} else if (_.sum(creep.store) > 0){
			let store = creep.home.storage;
			if (creep.room.name != store.room.name){
				creep.goTo(store.room);
			} else if (store && !creep.pos.isNearTo(store)){
				creep.moveTo(store, {range: 1});
			} else {
				for (let i in creep.store){
					creep.transfer(store, i);
				}
			}
		} else {
			creep.memory.reason = 'redundant';
			creep.memory.role = 'recycle';
		}
	}
	let spawnCode$L = {
		priority: (room, countFunction) => {
			let priority = 60;
			return priority
		},
		isRequired: (room, countFunction) => {
			if (!room.ecoStable || room.armedHostiles || room.memory.defcon < 5){
				return false
			}
			let ambushCollectorCount = 0;
			if (room.memory.ambush && room.memory.ambush.room){
				if (Memory.convoys && Memory.convoys[room.memory.ambush.room]){
					if (Memory.convoys[room.memory.ambush.room][2]){
						ambushCollectorCount = Memory.convoys[room.memory.ambush.room][2];
					} else {
						Memory.convoys[room.memory.ambush.room][2] = 0;
						ambushCollectorCount = Memory.convoys[room.memory.ambush.room][2];
					}
				}
			}
			if (ambushCollectorCount > 10){
				return 10
			}
			return countFunction('ambushCollector', room) < ambushCollectorCount;
		},
		spawn: (room, role, body) => {
			//decide if we need any other options
			if (body){
				//options -> TTL, creepnumber
				room.spawnCreep(role, body);
			}
		},
		body: (room, countFunction) => {
			if (room.memory.roadsDown === undefined){
				room.memory.roadsDown = false;
			}
			let key = room.energyCapacityAvailable + ':' + room.memory.roadsDown;
			if (getCachedBody('ambushCollector',key)){
				return getCachedBody('ambushCollector',key)
			}
			let bodyObject = {
				body: [],
				cost: 0
			};
			//decide on what body to have
			bodyObject.body = room.makeBody([CARRY, CARRY, MOVE], false, {noMove: true});

			if (bodyObject.body && bodyObject.body.length > 0){
				bodyObject.cost += Game.getBodyCost(bodyObject.body);
			}
			cacheBody('ambushCollector', key, bodyObject);
			return bodyObject
		}
	};

	var ambushCollector = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$1l,
		spawnCode: spawnCode$L
	});

	function run$1k(creep){
		console.log('ambush', creep.pos);
		var homeRoom = Game.rooms[creep.name.split(' ')[2]];
		creep.name.split(' ')[1];
			let mem = homeRoom.memory.ambush;
			if (creep.room.memory.hostiles){
			delete creep.memory.idle;
		}
		if (mem && !creep.memory.idle){
			let targetRoom = Game.rooms[mem.room];
			let hos = null;
			if (creep.room.memory.hostiles){
				if (!mem.hostile){
					hos = creep.pos.findClosestByRange(FIND_HOSTILE_CREEPS, {filter: (c) => c.getType() == 'tougher'});
				} else {
					hos = Game.getObjectById(mem.hostile);
				}
			}
			if (hos){
				creep.skirmish(hos);
			}
			if (!targetRoom || creep.room.name != targetRoom.name){
				creep.goTo(new RoomPosition(25, 25, mem.room));
			} else {
				if (creep.hits < creep.hitsMax){
					creep.heal(creep);
				} else if (hos){
					let friend = creep.pos.lookAround(LOOK_CREEPS, 3, {filter: (c) => c.my && c.hits < c.hitsMax});
					if (friend && creep.pos.isNearTo(friend)){
						creep.heal(friend);
					} else if (friend){
						creep.rangedHeal(friend);
					}
				}
				if (hos); else if (!creep.room.memory.hostiles && creep.pos.getRangeTo(new RoomPosition(25, 25, mem.room)) > 4){
					creep.moveTo(new RoomPosition(25, 25, mem.room));
				} else {
					creep.memory.idle = true;
				}
				if (Game.time % 10 == 0);

			}
		}
	}



	let spawnCode$K = {
		priority: (room, countFunction) => {
			let priority = 60;
			return priority
		},
		isRequired: (room, countFunction) => {
			if (Game.energyCrisis || !room.ecoStable || room.armedHostiles || room.memory.defcon < 5 || Game.shard !== 'shard2' || !config.official){
				return false
			}
			let ambushCount = 0;
			if (room.memory.ambush && room.memory.ambush.room){
				if (Memory.convoys && Memory.convoys[room.memory.ambush.room]){
					if (Memory.convoys[room.memory.ambush.room][1]){
						ambushCount = Memory.convoys[room.memory.ambush.room][1];
					} else {
						Memory.convoys[room.memory.ambush.room][1] = 0;
						ambushCount = Memory.convoys[room.memory.ambush.room][1];
					}
				}
			}
			return countFunction('ambusher', room) < ambushCount;
		},
		spawn: (room, role, body) => {
			//decide if we need any other options
			if (body){
				//options -> TTL, creepnumber
				room.spawnCreep(role, body);
			}
		},
		body: (room, countFunction) => {
			if (room.memory.roadsDown === undefined){
				room.memory.roadsDown = false;
			}
			let key = room.energyCapacityAvailable + ':' + room.memory.roadsDown;
			if (getCachedBody('ambusher',key)){
					return getCachedBody('ambusher',key)
			}
			let bodyObject = {
				body: [],
				cost: 0
			};
			//decide on what body to have
			bodyObject.body = room.makeBody([RANGED_ATTACK, HEAL], false, {sort: true});

			if (bodyObject.body && bodyObject.body.length > 0){
				bodyObject.cost += Game.getBodyCost(bodyObject.body);
			}
				cacheBody('ambusher',key,bodyObject);
			return bodyObject
		}
	};

	var ambusher = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$1k,
		spawnCode: spawnCode$K
	});

	function run$1j (creep){
		if (!creep.home){
			return
		}
		if (!creep.memory.squad){
			let rally = Game.flags['rally' + creep.home.name];
			if (rally && !creep.pos.inRangeTo(rally, 3)){
				creep.moveTo(rally.pos, {range: 3});
			} else {
				creep.startNap(3);
			}
		}

	}

	function getBody$6(room,level,type){
		let body;
		let energyCap = room.energyCapacityAvailable;
			let fixedSection = [];
			if (level && config.boostLevels[level] && (config.boostLevels[level].includes('GO') || config.boostLevels[level].includes('GHO2')||
					config.boostLevels[level].includes('XGHO2'))){
					fixedSection = [TOUGH, MOVE, TOUGH, MOVE, TOUGH, MOVE,TOUGH,TOUGH,TOUGH,TOUGH,TOUGH,MOVE,MOVE,MOVE,MOVE,MOVE];
			}  else if (type && (type === 'SKM' || type === 'SKE') && room.controller.level > 6){
					fixedSection = [HEAL,HEAL,HEAL,HEAL,HEAL,RANGED_ATTACK,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE];
					if (type === 'SKM'){
							fixedSection = [HEAL,HEAL,RANGED_ATTACK,MOVE,MOVE,MOVE];
					}
					body = room.makeBody([ATTACK], false, {sort: true,level:level,fixedSection:fixedSection});

			}
		if (type === 'T'){
			body = ['attack', 'move'];
		} else if (level > 0){
			body = bodies$4[level];
		}
		if (!body){
				body = room.makeBody([ATTACK, ATTACK, ATTACK, RANGED_ATTACK], false, {sort: true,level:level,fixedSection:fixedSection});
		}
		if ( (!body || room.controller.level < 5 || (!level && (type === 'P' || type === 'C')) || body.length === 1|| Game.getBodyCost(body) > energyCap)){
			body = room.makeBody([ATTACK], false, {sort: true,level:level});
		}
		if (Game.getBodyCost(body) > energyCap){
			return false
		}
		return body
	}
	const bodies$4 = {
		1:(_.repeat('move ', 16) + _.repeat('attack ', 25)  + _.repeat('ranged_attack ', 8) + 'move').split(' '),
		2:(_.repeat('move ', 12) + _.repeat('attack ', 35) + _.repeat('ranged_attack ', 2)+ 'move').split(' '),
		3:(_.repeat('tough ', 10) + _.repeat('move ', 12) + _.repeat('ranged_attack ', 2) + _.repeat('attack ', 25) + 'move').split(' '),
		4:(_.repeat('tough ', 5) + _.repeat('move ', 9) + _.repeat('tough ', 3) + _.repeat('ranged_attack ', 2) + _.repeat('attack ', 30) + 'move').split(' '),
		5:(_.repeat('tough ', 12) + _.repeat('move ', 9) + _.repeat('tough ', 3) + _.repeat('ranged_attack ', 2) + _.repeat('attack ', 23) + 'move').split(' ')
	};

	var attacker = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$1j,
		getBody: getBody$6
	});

	let block = {};
	function runBrigade(room){
			if (room.class === 'normal'){
					manageRemoteBrigade(room);
			}
	}
	function manageRemoteBrigade(room){
			let remoteContainers = room.memory.remoteContainers;
			let newSources = [];
			let sourcePositions = [];
			if (!config.brigade){
					delete room.memory.brigade;
					delete room.memory.bucket;
					return
			}
			if (!config.conserveCpu && Game.cpu.bucket > 6000 && (!block[room.name] || block[room.name] < Game.time) && room.memory.fixedBaseOrigin){
					if (room.memory.brigade && !room.memory.brigade.storage && room.storage){
							delete room.memory.brigade;
					}
					clearPaths(room);
					for (let i in remoteContainers){
							let contMem = remoteContainers[i];
							if (contMem && contMem.expiry && contMem.expiry > Game.time && contMem.pos){
									sourcePositions.push(contMem.pos.toPos());
									newSources.push(contMem.pos);
									if (room.memory.brigade && room.memory.brigade.paths && !room.memory.brigade.paths[contMem.pos]){
											delete room.memory.brigade;
									}
							}
					}
					let origin = room.memory.fixedBaseOrigin.toPos();
					let paths = [];
					if (!room.memory.brigade){
							if (room.memory.sourcePositions){
									for (let i in room.memory.sourcePositions){
											newSources.splice(0, 0, room.memory.sourcePositions[i].pos);
									}
							}
							if (newSources.length == 0){
									return
							}
							for (let i in newSources){
									let sourcePosStr = newSources[i];
									let start;
									if (sourcePosStr.toPos()){
											start = sourcePosStr;
									} else {
											continue
									}
									if (start && start.toPos()){
											let target = origin;
											let range = 0;
											if (room.storage){
													target = room.storage.pos;
													range = 1;
											}
											let pathObj = PathFinder.search(start.toPos(), {range: range, pos: target}, {
													roomCallback: function (roomName){
															let thisRoom = Game.rooms[roomName];
															let matrix = new PathFinder.CostMatrix;
															if (thisRoom){
																	matrix = thisRoom.structureMatrix;
															}
															if (pathedPos[roomName]){
																	for (let p in pathedPos[roomName]){
																			let xy = p.split(',');
																			let x = xy[0];
																			let y = xy[1];
																			if (pathedPos[roomName][p] >= 3){
																					matrix.set(x, y, 30);
																			} else {
																					matrix.set(x, y, 1);
																			}
																			if (x <= 1 || x >= 48 || y <= 1 || y >= 48){
																					//discourage merges on the edge
																					let pos = new RoomPosition(x, y, roomName);
																					let neighbours = pos.neighbours(1);
																					for (let n in neighbours){
																							let cost = matrix.get(neighbours[n].x, neighbours[n].y);
																							if (cost !== 1 && cost < 20 && neighbours[n].getTerrain() != 'wall'){
																									matrix.set(neighbours[n].x, neighbours[n].y, 20);
																							}
																					}
																			}
																	}
															}
															if (sourcePositions){
																	for (let s in sourcePositions){
																			let spos = sourcePositions[s];
																			let neighbours = spos.neighbours(1);
																			for (let n in neighbours){
																					let cost = matrix.get(neighbours[n].x, neighbours[n].y);
																					if (cost < 20 && neighbours[n].getTerrain() != 'wall'){
																							matrix.set(neighbours[n].x, neighbours[n].y, 20);
																					}
																			}
																	}
															}
															if (thisRoom){
																	let exits = thisRoom.find(FIND_EXIT);
																	for (let i in exits){
																			let exit = exits[i];
																			let cost = matrix.get(exit.x, exit.y);
																			if (cost < 5){
																					matrix.set(exit.x, exit.y, 5);
																			}
																	}
															}
															if (roomName == room.name){
																	if (Game.flags['rally' + room.name]){
																			let neighbours = Game.flags['rally' + room.name].pos.neighbours(3, true);
																			for (let n in neighbours){
																					let cost = matrix.get(neighbours[n].x, neighbours[n].y);
																					if (cost < 20 && neighbours[n].getTerrain() != 'wall'){
																							matrix.set(neighbours[n].x, neighbours[n].y, 20);
																					}
																			}
																	}
																	let sources = room.find(FIND_SOURCES);
																	if (sources && sources.length > 0){
																			for (let s in sources){

																					let spos = sources[s].pos;
																					let neighbours = spos.neighbours(2, true);
																					for (let n in neighbours){
																							let cost = matrix.get(neighbours[n].x, neighbours[n].y);
																							if (cost < 20 && neighbours[n].getTerrain() != 'wall'){
																									matrix.set(neighbours[n].x, neighbours[n].y, 20);
																							}
																					}
																			}
																	}
															}
															return matrix
													},
													plainCost: 3,
													swampCost: 10
											});
											if (pathObj && pathObj.path){
													pathObj.sourcePosStr = sourcePosStr;
													paths.push(pathObj);
											}
									}
							}
							room.memory.brigade = {
									sources: room.memory.finalSources,
									paths: {}
							};
							if (room.storage){
									room.memory.brigade.storage = true;
							}
							generateBrigadePaths(room,paths);
							// for (let i in pathedPos){
							// 		for (let j in pathedPos[i]){
							// 				let xy = j.split(',')
							// 				let x = xy[0]
							// 				let y = xy[1]
							// 				let pos = new RoomPosition (x,y,i)
							// 				switch (pathedPos[i][j]){
							// 						case 1:
							// 								pos.highlight('yellow')
							// 								break;
							// 						case 2:
							// 								pos.highlight('orange');
							// 								break;
							// 						case 3:
							// 								pos.highlight('red')
							// 								break;
							// 				}
							// 		}
							// }
					}
			} else {
					console.log('conditions not met, deleting brigade mem');
					delete room.memory.brigade;
			}
	}
	function clearPaths(room){
			if (room.memory.brigade && room.memory.brigade.paths){
					//clear old creeps from the array
					for (let p in room.memory.brigade.paths){
							let pathObj = room.memory.brigade.paths[p];
							let creepArr = pathObj.creeps;
							if (creepArr[0] && !Game.getObjectById(creepArr[0])){
									creepArr.shift();
							}
							for (let c = creepArr.length - 1; c > -1; c--){
									if (!creepArr[c] || !Game.getObjectById(creepArr[c])){
											creepArr.splice(c, 1);
									} else {
											let creep = Game.getObjectById(creepArr[c]);
											if (!creep.memory.assignedPath || creep.memory.assignedPath != p ||
													(creep.role !== 'bucket' && creep.role !== 'thoriumMineHauler')){
													creepArr.splice(c, 1);
											}
									}
							}
					}
			}
	}
	function generateBrigadePaths(room,paths,gap){
			//paths is an array of vanilla pathObjects returned from pathfinder.search, with source pos string saved to it
			let pathedPos = {
					//roomname:{ 'x,y': number of times pathed over}
			};
			let processedPaths = {};
			for (let i in paths){
					if (!paths[i].sourcePosStr){
							continue
					}
					let pathObj = paths[i];
					let thisPath = [];
					for (let j in pathObj.path){
							let pos = pathObj.path[j];
							let key = pos.x + ',' + pos.y;
							if (!pathedPos[pos.roomName]){
									pathedPos[pos.roomName] = {};
							}
							if (pathedPos[pos.roomName][key]){
									pathedPos[pos.roomName][key]++;
							} else if (!pathedPos[pos.roomName][key]){
									thisPath.push(pos);
									pathedPos[pos.roomName][key] = 1;
							}
					}
					//remove the start pos from the path and use as the start when serializing
					let startPos = thisPath[0];
					thisPath.shift();
					processedPaths[paths[i].sourcePosStr] = {
							start: startPos,
							path: thisPath,
							container: paths[i].sourcePosStr
					};
			}
			let colours = ['red', 'blue', 'green', 'yellow', 'pink', 'purple', 'black', 'grey'];
			let count = 0;
			let buckets = 0;
			for (let i in processedPaths){
					buckets++;
					let pathObj = processedPaths[i];
					let start = pathObj.start;
					let path = pathObj.path;
					let creepPositions = [start];
					let current = 1;
					//current is 1 because we are one gap from the start
					let startKey = start.x + ',' + start.y;
					let level = pathedPos[start.roomName][startKey];
					let last = start;
					for (let i in path){
							let pos = path[i];
							let key = pos.x + ',' + pos.y;
							let thisLevel = pathedPos[pos.roomName][key];
							if (thisLevel > 3){
									thisLevel = 3;
							}
							if (gap && gap <= 3){
									thisLevel = 4-gap;
							}
							if ( level != thisLevel || current > 4 - thisLevel || pos.onEdge() || last.onEdge()){
									current = 1;
									buckets++;
									creepPositions.push(pos);
							} else {
									current++;
							}
							level = thisLevel;
							path[i] = path[i].toString();
							last = pos;
					}
					for (let p in creepPositions){
							let colour = colours[count];
							if (!colour){
									colour = 'white';
							}
							creepPositions[p].highlight(colour);
					}
					count++;
					for (let i in creepPositions){
							creepPositions[i] = creepPositions[i].toString();
					}
					room.memory.brigade.paths[i] = {
							creepPositions: creepPositions,
							path: path,
							creeps: [],
							containerPos: pathObj.container
					};
			}
			room.memory.buckets = buckets;
	}
	function assignToBrigade(creep){
			if (creep.memory.assignedPath){
					return
			}
			//use an array, new creeps just get pushed onto the array,
			// then each bucket will move towards source with the creeppos matching it as the furthest point it goes to
			let room = creep.home;
			if (room.memory.brigade && room.memory.brigade.paths){
					for (let p in room.memory.brigade.paths){
							let pathObj = room.memory.brigade.paths[p];
							if (pathObj.creeps && pathObj.creeps.length < pathObj.creepPositions.length){
									pathObj.creeps.push(creep.id);
									creep.memory.assignedPath = p;
									break
							}
					}
			}
	}

	function furthestPos(creep){
			if (!creep.memory.assignedPath){
					assignToBrigade(creep);
					return
			}
			let room = creep.home;
			if (room.memory.brigade && room.memory.brigade.paths){
					let pathObj = room.memory.brigade.paths[creep.memory.assignedPath];
					if (!pathObj){
							return
					}
					let index = pathObj.creeps.indexOf(creep.id);
					if (!index === -1){
							delete creep.memory.assignedPath;
							assignToBrigade(creep);
					}
					if (topOnPath(creep)){
							console.log('top',creep,creep.pos);
							index = 0;
					}
					if (index !== undefined && index !== -1 && pathObj.creepPositions[index] && pathObj.creepPositions[index].toPos()){
							return pathObj.creepPositions[index].toPos()
					}
			}
	}

	function index(creep){
			let room = creep.home;
			if (room.memory.brigade && room.memory.brigade.paths){
					let pathObj = room.memory.brigade.paths[creep.memory.assignedPath];
					if (!pathObj){
							return false
					}
					let index = pathObj.creeps.indexOf(creep.id);
					if (index !== undefined && index !== -1){
							return index
					}
			}
			return false
	}

	function atFurthest(creep){
			let furthest = furthestPos(creep);
			if (furthest && creep.pos.isEqualTo(furthest)){
					return true
			}
			return false
	}

	function findNextPosDown(creep){
			if (!creep.memory.assignedPath){
					assignToBrigade(creep);
					return
			}
			let room = creep.home;
			if (room.memory.brigade && room.memory.brigade.paths){
					let strPos = creep.pos.toString();
					if (creep.pos.onEdge()){
							strPos = creep.pos.oppositeEdge().toString();
					}
					let pathObj = room.memory.brigade.paths[creep.memory.assignedPath];
					for (let i = 0; i < pathObj.path.length; i++){
							if (pathObj.creepPositions[0] === strPos){
									return pathObj.path[0]
							}
							if (pathObj.path[i] === strPos){
									creep.pathIndex = i;
									let road = creep.pos.lookAround(LOOK_STRUCTURES,0,{filter:(s)=>s.structureType === 'road'})[0];
									if (creep.countParts('work')>0){
											if (road && road.hits < road.hitsMax*0.8){
													creep.repair(road);
											} else if (creep.home.memory.buildRoads && creep.home.memory.buildRoads > Game.time){
													let site = creep.pos.lookAround(LOOK_CONSTRUCTION_SITES,1,{filter:(s)=>s.structureType === 'road'})[0];
													if (site){
															creep.home.memory.buildRoads = Game.time+500;
															creep.build(site);
													} else {
															creep.pos.createConstructionSite('road');
													}
											}
									} else if ((!road || road.hits < road.hitsMax*0.35) && !creep.pos.onEdge()){
											creep.home.memory.buildRoads = Game.time+500;
									} else if (road && !creep.pos.onEdge() && creep.room.name === creep.home.name &&
											creep.home.class === 'thoriumMine' && road.hits < road.hitsMax*0.5){
											creep.home.memory.roads = road.id;
									}
									//creep.say(i)
									if (i%2===0){
											return pathObj.path[i + 1]
									} else {
											//look ahead and don't move if next available position taken
											if (pathObj.path[i + 2]){
													let pos = pathObj.path[i + 2].toPos();
													if (!pos.lookAround(LOOK_CREEPS)[0]){
															return pathObj.path[i + 1]
													} else {
															return false
													}
											}
									}
							}
					}
					let creepIndex = index(creep);
					if (creepIndex && pathObj.creepPositions[creepIndex]){
							return pathObj.creepPositions[creepIndex]
					}
					//not on the path - go to the end of the path and join the queue
					return pathObj.path[0]
			}
			return false
	}
	function currentPositionOnPathIndex(creep){
			if (!creep.memory.assignedPath){
					assignToBrigade(creep);
					return
			}
			if (creep.pathIndex){
					return creep.pathIndex
			}
			let room = creep.home;
			if (room.memory.brigade && room.memory.brigade.paths){
					let strPos = creep.pos.toString();
					if (creep.pos.onEdge()){
							strPos = creep.pos.oppositeEdge().toString();
					}
					let pathObj = room.memory.brigade.paths[creep.memory.assignedPath];
					for (let i = 0; i < pathObj.path.length; i++){
							if (pathObj.path[i] === strPos){
									return i
							}
					}
					let creepIndex = index(creep);
					if (creepIndex && pathObj.creepPositions[creepIndex]){
							return pathObj.creepPositions[creepIndex]
					}
			}
			return false
	}
	function relayDownPathToDrop(creep){
			if (creep.acted){
					return
			}
			let room = creep.home;
			let origin;
			let spawn;
			if (creep.home.memory.fixedBaseOrigin){
					origin = creep.home.memory.fixedBaseOrigin.toPos();
			}
			if (creep.home.class === 'thoriumMine' && creep.home.memory.spawn && Game.spawns[creep.home.memory.spawn]){
					spawn = Game.spawns[creep.home.memory.spawn];
					origin = Game.spawns[creep.home.memory.spawn].pos;
					if (!origin || !spawn){
							return
					}
			}
			if (!room.memory.brigade || !room.memory.brigade.paths || !creep.memory.assignedPath || !room.memory.brigade.paths[creep.memory.assignedPath]){
					//console.log('no mem location down')
					delete creep.memory.assignedPath;
					assignToBrigade(creep);
					return false
			}
			let pathObj = room.memory.brigade.paths[creep.memory.assignedPath];
			creep.acted = true;
			if (creep.movedDown){
					return
			}
			creep.movedDown = true;
			let nextPos = findNextPosDown(creep);
			if (spawn){
					if (creep.pos.isNearTo(spawn)){
							if (spawn.store.getFreeCapacity('energy')>0){
									if (spawn.store.getFreeCapacity()>=creep.store['energy']){
											moveUpPath(creep);
									}
									creep.transfer(spawn, 'energy');
							} else {
									let nearCreeps = creep.pos.lookAround(LOOK_CREEPS,1,{filter:(c)=>c.role === 'thoriumMineWorker' && !c.store['energy']})[0];
									if (nearCreeps){
											creep.transfer(nearCreeps, 'energy');
									}
							}

							return
					}
			} else if (room.storage){
					if (creep.pos.isNearTo(room.storage)){
							creep.transfer(room.storage, 'energy');
							moveUpPath(creep);
							return
					}
			} else if (origin && creep.pos.isEqualTo(origin)){
					creep.drop('energy');
					moveUpPath(creep);
			}
			if (nextPos && nextPos.toPos() && nextPos.toPos().isEqualTo(origin) && !room.storage){
					if (room.memory.storeCont){
							let storeCont = Game.getObjectById(room.memory.storeCont);
							if (storeCont && creep.pos.isNearTo(storeCont)){
									creep.transfer(storeCont, 'energy');
									moveUpPath(creep);
									return
							}
					}
			}
			let pathIndex = currentPositionOnPathIndex(creep);
			let stopWalking = false;
			if (pathIndex && pathIndex < pathObj.path.length-2){
					let pos2Ahead = pathObj.path[pathIndex+2];
					if (pos2Ahead){
							let pos = pos2Ahead.toPos();
							let creep2SpacesAhead = pos.lookAround(LOOK_CREEPS,0,{filter:(c)=>c.my && c.role === creep.role && c.store['energy']})[0];
							if (creep2SpacesAhead){
									stopWalking = true;
							}
					}
			}
			if (nextPos && nextPos.toPos()){
					let pos = nextPos.toPos();
					//pos.highlight
					if (pos && creep.pos.isNearTo(pos)){
							new RoomVisual(creep.pos.roomName).line(creep.pos,pos);
							if (pos && !pos.isWalkable()){
									if (spawn && spawn.pos && pos.isEqualTo(spawn.pos)){
											return
									}
									delete creep.home.memory.brigade;
									creep.home.memory.badDownPathPos = pos.toString();
									console.log(pos, 'bad down path, deleting brigade mem');
									return
							}
							let nextPosCreep = pos.lookAround(LOOK_CREEPS, 0, {
									filter: (c) => c.my && c.role === creep.role
							})[0];
							let dir = creep.pos.getDirectionTo(pos);
							if (nextPosCreep){
									if (nextPosCreep.store['energy'] > 0){
											let myIndex = index(creep);
											let nextIndex = index(nextPosCreep);
											let swap = false;
											if (nextIndex-myIndex === 1 && nextPosCreep.ticksToLive - creep.ticksToLive > 30){
													//swap to order by TTL
													pathObj.creeps[myIndex] = nextPosCreep.id;
													pathObj.creeps[nextIndex] = creep.id;
													swap = true;
											}
											if (myIndex > nextIndex || swap){
													if (!creep.pos.onEdge() || true){
															nextPosCreep.pos.highlight('blue');
															if (nextPosCreep.acted){
																	nextPosCreep.cancelOrder('move');
															}
															nextPosCreep.move(nextPosCreep.pos.getDirectionTo(creep));
															nextPosCreep.acted = true;
															creep.move(creep.pos.getDirectionTo(nextPosCreep));
													}
											} else {
													moveUpPath(creep);
											}
									} else if ((!nextPosCreep.memory.assignedPath || index(nextPosCreep) > index(creep) || nextPosCreep.pos.isEqualTo(origin))){
											creep.transfer(nextPosCreep, 'energy');
											creep.say('pass');
											if (!nextPosCreep.pos.onEdge()){
													nextPosCreep.cancelOrder('move');
													nextPosCreep.acted = false;
													relayDownPathToDrop(nextPosCreep);
											} else {
													nextPosCreep.cancelOrder('move');
													nextPosCreep.acted = true;
											}
											if (nextPosCreep.store.getFreeCapacity()>= creep.store['energy']){
													if (!creep.pos.onEdge()){
															moveUpPath(creep);
													}
											}
									} else if (dir){
											if (creep.isMoving){
													creep.pos.highlight('red');
													creep.cancelOrder('move');
											}
											nextPosCreep.move(dir.map8(4));
											creep.move(dir);
									}
							} else if (!stopWalking){
									if (creep.isMoving){
											creep.pos.highlight('red');
											creep.cancelOrder('move');
									}
									creep.move(dir);
							}
					} else if (creep.pos.onEdge() && creep.pos.oppositeEdge().isEqualTo(pos)){
							creep.pos.highlight('purple');
					} else if (creep.pos.onEdge() && creep.pos.oppositeEdge().isNearTo(pos)){
							creep.pos.highlight('pink');
					} else if (!stopWalking){
							creep.pos.highlight('yellow');
							let range = 0;
							if (creep.home.class === 'thoriumMine' && !pos.isWalkable()){
									range = 1;
							}
							creep.moveTo(pos, {range: range});
					}
			} else if (creep.pos.isNearTo(origin)){
					let transferred = false;
					if (creep.home.memory.storeCont){
							let storeCont = Game.getObjectById(creep.home.memory.storeCont);
							if (storeCont && storeCont.store.getFreeCapacity() > 50){
									transferred = true;
									creep.transfer(storeCont, 'energy');
									moveUpPath(creep);
							}
					} else {
							let originBucket = origin.lookAround(LOOK_CREEPS, 0, {filter: (c) => c.my && c.role == 'bucket' && c.store.getUsedCapacity() == 0})[0];
							if (originBucket && creep.transfer(originBucket, 'energy') == 0){
									transferred = true;
							}
					}
					if (!transferred){
							creep.move(creep.pos.getDirectionTo(origin));
					}
			} else if (creep.memory.assignedPath){
					let nearBuckets = creep.pos.lookAround(LOOK_CREEPS, 1, {
							filter: (c) => c.my && c.store['energy'] == 0
									&& c.role == 'bucket' && c.memory.assignedPath && c.memory.assignedPath != creep.memory.assignedPath
					});
					if (nearBuckets[0]){
							creep.transfer(nearBuckets[0], 'energy');
							relayDownPathToDrop(nearBuckets[0]);
							moveUpPath(creep);
							return
					}
					creep.pos.highlight('purple');
					//console.log('error brigade move down',nextPos,creep)
			}
	}

	function findNextPosUp(creep, furthest){
			if (!creep.memory.assignedPath){
					assignToBrigade(creep);
					return
			}
			if (!furthest){
					console.log('error no furthest');
					return false
			}
			let room = creep.home;
			let furthestStr = furthest.toString();
			if (room.memory.brigade && room.memory.brigade.paths){
					let strPos = creep.pos.toString();
					if (creep.pos.onEdge()){
							strPos = creep.pos.oppositeEdge().toString();
					}
					let pathObj = room.memory.brigade.paths[creep.memory.assignedPath];
					for (let i = pathObj.path.length - 1; i > -1; i--){
							if (pathObj.path[i] === furthestStr){
									return pathObj.path[i]
							}
							if (i == 0){
									return pathObj.creepPositions[0]
							}
							if (pathObj.path[i] === strPos){
									return pathObj.path[i - 1]
							}
					}
					return pathObj.path[pathObj.path.length - 1]
			}
			return false
	}
	function topOnPath (creep){
			let room = creep.home;
			if (room.memory.brigade && room.memory.brigade.paths){
					let pathObj = room.memory.brigade.paths[creep.memory.assignedPath];
					if (!pathObj){
							return false
					}
					if (!room.topOfBrigadePath){
							room.topOfBrigadePath = {};
					}
					if (room.topOfBrigadePath[creep.memory.assignedPath]){
							let val = room.topOfBrigadePath[creep.memory.assignedPath];
							if (val === creep.id){
									return true
							} else {
									return false
							}
					}
					if (pathObj.containerPos){
							let pos = pathObj.containerPos.toPos();
							//new RoomVisual(pos.roomName).text(p,pos)
							let found = pos.lookAround(LOOK_CREEPS,1,{filter:(c)=>c.role === creep.role})[0];
							if (found){
									room.topOfBrigadePath[creep.memory.assignedPath] = found.id;
									found.say('top');
									if (found.id === creep.id){
											return true
									}
									return false
							}
					}
					for (let p = 0; p < pathObj.path[p].length-1;p++){
							let pos = pathObj.path[p].toPos();
							//new RoomVisual(pos.roomName).text(p,pos)
							let found = pos.lookAround(LOOK_CREEPS,0,{filter:(c)=>c.role === creep.role})[0];
							if (found){
									room.topOfBrigadePath[creep.memory.assignedPath] = found.id;
									found.say('top');
									if (found.id === creep.id){
											return true
									}
									return false
							}
					}
					return false
			}
	}
	function moveUpPath(creep){
			let furthest = furthestPos(creep);
			let nextPos = findNextPosUp(creep, furthest);
			if (nextPos && nextPos.toPos()){
					let pos = nextPos.toPos();
					if (pos && creep.pos.isNearTo(pos)){
							let dir = creep.pos.getDirectionTo(pos);
							creep.move(dir);
					}
			}
	}
	function relayUpPath(creep){
			let room = creep.home;
			let furthest = furthestPos(creep);
			if (!room.memory.brigade || !room.memory.brigade.paths || !creep.memory.assignedPath || !room.memory.brigade.paths[creep.memory.assignedPath] || !furthest){
					console.log('no mem location',creep.memory.assignedPath,furthest);
					creep.pos.highlight('#710101');
					delete creep.memory.assignedPath;
					assignToBrigade(creep);
					return false
			}
			let pathObj = room.memory.brigade.paths[creep.memory.assignedPath];
			creep.acted = true;
			if (creep.movedUp){
					return
			}
			creep.movedUp = true;
			if ((furthest && creep.pos.isEqualTo(furthest))){
					let ret = checkContainer();
					if (!ret){
							creep.acted = false;
					}
					creep.pos.highlight('green');
					return
			} else if (topOnPath(creep)){
					let ret = checkContainer();
					if (ret){
							creep.pos.highlight('blue');
							return
					}
			}
			function checkContainer(){
					let endPos = pathObj.containerPos;
					if (endPos){
							endPos = endPos.toPos();
					}
					if (endPos && creep.pos.isNearTo(endPos)){
							let container = endPos.lookAround(LOOK_STRUCTURES, 0, {filter: (s) => (s.structureType === STRUCTURE_CONTAINER || s.structureType === STRUCTURE_LINK) && s.store['energy'] >= 50})[0];
							if (container){
									creep.withdraw(container, 'energy');
									creep.memory.container = container.id;
									relayDownPathToDrop(creep);
									return true
							} else {
									let drop = endPos.lookAround(LOOK_RESOURCES, 0, {filter: (r) => r.resourceType == 'energy' && r.amount >= 50})[0];
									if (drop){
											creep.pickup(drop);
											relayDownPathToDrop(creep);
									}
									return true
							}
					}
			}
			creep.pos.highlight('orange');
			let nextPos = findNextPosUp(creep, furthest);
			if (nextPos && nextPos.toPos()){
					let pos = nextPos.toPos();
					if (pos && creep.pos.isNearTo(pos)){
							if (pos && !pos.isWalkable()){
									let spawn = Game.spawns[creep.home.memory.spawn];
									if (spawn && spawn.pos && pos.isEqualTo(spawn.pos)){
											creep.rally(1);
											return
									}
									delete creep.home.memory.brigade;
									creep.home.memory.badPathPos = pos.toString();
									console.log(pos, 'bad path, deleting brigade mem');
							}
							let nextPosCreep = pos.lookAround(LOOK_CREEPS, 0, {filter: (c) => c.my})[0];
							let dir = creep.pos.getDirectionTo(pos);
							if (nextPosCreep && nextPosCreep.role == creep.role && atFurthest(nextPosCreep)){
									nextPosCreep.move(dir.map8(4));
							} else if (nextPosCreep && nextPosCreep.role == creep.role&& nextPosCreep.store['energy'] > 0
									&& !nextPosCreep.memory.assignedPath != creep.memory.assignedPath){
									nextPosCreep.transfer(creep, 'energy');
							} else if (nextPosCreep && Memory.inWayCreeps && nextPosCreep.role != 'remoteminer' && nextPosCreep.role != 'harvester'){
									Memory.inWayCreeps.push([nextPosCreep.id, dir.map8(4)]);
							}
							creep.move(dir);
					} else {
							creep.pos.highlight('orange');
							creep.moveTo(pos, {range: 0});
					}
			} else {
					console.log('error brigade move up', nextPos, creep);
					creep.pos.highlight('red');
					creep.say('END');
			}
	}

	function run$1i(creep){
		if (creep.acted){
			return
		}
		if (config$1 && !config$1.brigade){
			creep.suicide();
		}
		if (!creep.memory.assignedPath){
			assignToBrigade(creep);
		}
		if (!creep.memory.assignedPath){
			let rally = Game.flags['rally' + creep.home.name];
			if (rally && !creep.pos.inRangeTo(rally, 2)){
				creep.moveTo(rally, {range: 2});
			} else {
				creep.startNap(2);
			}
		}
		if (creep.store['energy'] === 0){
			relayUpPath(creep);
		} else {
			relayDownPathToDrop(creep);
		}
	}


	//put this in the role under the runPCs function, to control the spawning for that role

	let spawnCode$J = {
		priority: (room, countFunction) => {
			let priority = 42;
			return priority
		},
		isRequired: (room, countFunction) => {
			let numberRequired = 0;
			if (!config$1.brigade){
				return false
			}
			if (room.memory.buckets){
				numberRequired = room.memory.buckets;
			}
			return countFunction('bucket', room) < numberRequired;
		},
		spawn: (room, role, body) => {
			//decide if we need any other options
			if (body){
				//options -> TTL, creepnumber
				room.spawnCreep(role, body);
			}
		},
		body: (room, countFunction) => {
			if (room.memory.roadsDown === undefined){
				room.memory.roadsDown = false;
			}
			let key = room.energyCapacityAvailable + ':' + room.memory.roadsDown;
			if (getCachedBody('bucket',key)){
					return getCachedBody('bucket',key)
			}
			let bodyObject = {
				body: [],
				cost: 0
			};
			//decide on what body to have
			bodyObject.body = [CARRY, MOVE];

			if (bodyObject.body && bodyObject.body.length > 0){
				bodyObject.cost += Game.getBodyCost(bodyObject.body);
			}
			cacheBody('bucket', key, bodyObject);
			return bodyObject
		}
	};

	var bucket = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$1i,
		spawnCode: spawnCode$J
	});

	playerHeap.savedBodies = {};
	function getBody$5(energyAvailable,room, roadsDown, role, maxBody,storeAvailable,options){
			let lifeTime = CREEP_LIFE_TIME;
			if (!maxBody){
					maxBody = MAX_CREEP_SIZE;
			}
			if (room && (Game.cpu.bucket < 100 || Game.cpu.getUsed() > 300 || Game.cpu.getUsed() > Game.cpu.bucket)){
					return room.makeBody(['work','carry'],true,{maxParts:maxBody})
			}
			if (!energyAvailable){
					energyAvailable = room.energyAvailable;
			}
			if (energyAvailable < 300){
					energyAvailable = 300;
			}
			let targetWorkParts = undefined;
			if (options && options.targetWorkParts){
					targetWorkParts = options.targetWorkParts;
			}
			if ((!room.sourceExtensions || !room.memory.sourceExtensionsTime || room.memory.sourceExtensionsTime !== Game.time) && room.memory.sourcePositions){
					let positions = [];
					let extensions = [];
					for (let sourceId in room.memory.sourcePositions){
							let source = room.memory.sourcePositions[sourceId];
							if (source.e1){
									positions.push(source.e1.toPos());
							}
							if (source.e2){
									positions.push(source.e2.toPos());
							}
					}
					for (let p in positions){
							let extension = positions[p].lookAround(LOOK_STRUCTURES, 0, {filter: (s) => s.structureType === STRUCTURE_EXTENSION})[0];
							if (extension){
									extensions.push(extension);
							}
					}
					room.sourceExtensions = extensions;
					room.memory.sourceExtensionsTime = Game.time;
			}
			if (room.sourceExtensions && room.sourceExtensions.length > 0){
					energyAvailable -= (4 * EXTENSION_ENERGY_CAPACITY[room.controller.level]);
					for (let e in room.sourceExtensions){
							energyAvailable += room.sourceExtensions[e].store['energy'];
					}
			}
			let key = energyAvailable+','+roadsDown+','+role+','+maxBody+','+storeAvailable;
			if (playerHeap.savedBodies[key]){
					return  playerHeap.savedBodies[key]
			}
			let workModifier = 1;
			switch (role){
					case 'builder':
							workModifier = BUILD_POWER;
							break
					case 'colonist':
							workModifier = BUILD_POWER;
							break
					case 'fixer':
							workModifier = REPAIR_POWER * 0.01;
							break
					case 'upgrader':
							workModifier = UPGRADE_CONTROLLER_POWER;
							break
					case 'wallBuilder':
							workModifier = REPAIR_POWER * 0.01;
							break
			}
			let BODYPART_COST = {
					"move": 50,
					"work": 100,
					"attack": 80,
					"carry": 50,
					"heal": 250,
					"ranged_attack": 150,
					"tough": 10,
					"claim": 600
			};
			let data = {};
			let maxDist = 70;
			let minDist = 5;
			if (storeAvailable && role !== 'colonist'){
					maxDist = 30;
					minDist = 0;
					if (role === 'fixer' || role === 'builder'){
							maxDist = 10;
					}
			}
			for (let dist = minDist; dist < maxDist; dist++){
					let best = undefined;
					let bestEnergy = 0;
					for (let i = 1; i < (maxBody / 2); i++){
							let currentCost = 0;
							let work = 0;
							let carry = 0;
							let move = 0;
							let count = 0;
							while (currentCost < energyAvailable){
									if (targetWorkParts && work >= targetWorkParts){
											break
									}
									let addMove = false;
									let addWork = false;
									let potentialCost = currentCost;
									let potentialParts = work + carry + move + 1;
									if (carry < i){
											potentialCost += BODYPART_COST['carry'];
									} else {
											addWork = true;
											potentialCost += BODYPART_COST['work'];
									}
									if (count === 0 || count % 2 == 0 || !roadsDown){
											potentialParts++;
											potentialCost += BODYPART_COST['move'];
											addMove = true;
									}
									if (potentialParts > maxBody){
											break
									}
									if (potentialCost <= energyAvailable){
											if (addWork){
													work++;
											} else {
													carry++;
											}
											if (addMove){
													move++;
											}
											currentCost = potentialCost;
									} else if (addWork && BODYPART_COST['carry'] < BODYPART_COST['work']
											&& (potentialCost - energyAvailable) <= (BODYPART_COST['work'] - BODYPART_COST['carry'])){
											//can't afford to add a work part but can add a carry
											carry++;
											if (addMove){
													move++;
											}
											currentCost = potentialCost;
									} else {
											break
									}
									count++;
							}
							//first work out different possible bodies, then see which performs best on average
							let energyProcessed = calculateEnergyProcessed(dist, carry, work);
							if (!best || energyProcessed > bestEnergy){
									best = [carry, work, move];
									bestEnergy = energyProcessed;
							}
					}
					if (!data[best]){
							data[best] = 1;
					} else {
							data[best]++;
					}
			}
			let best, bestNumber;
			for (let i in data){
					if (!best || bestNumber < data[i]){
							best = i;
							bestNumber = data[i];
					}
			}
			let body = [];
			let carry, work, move;
			let arr = best.split(',');
			carry = Number.parseInt(arr[0]);
			work = Number.parseInt(arr[1]);
			move = Number.parseInt(arr[2]);
			while (carry > 0){
					body.push('carry');
					carry--;
			}
			while (work > 0){
					body.push('work');
					work--;
			}
			while (move > 0){
					body.push('move');
					move--;
			}
			if (key && body && playerHeap.savedBodies){
					playerHeap.savedBodies[key] = body;
			}
			return body

			function calculateEnergyProcessed(distance, carry, work){
					let currentLife = lifeTime;
					let currentStore = false;
					let capacity = carry * CARRY_CAPACITY;
					let energyProcessed = 0;
					while (currentLife > 0){
							if (currentStore == 0){
									if (role === 'wallBuilder'){
											currentStore = capacity;
											continue
									}
									//go to and from energy source
									if (role === 'colonist'){
											//add time to mine the energy
											currentLife -= Math.ceil(capacity / (work * HARVEST_POWER));
									}
									currentLife -= distance * 2;
									currentStore = capacity;
							} else {
									let energyOnTick = work * workModifier;
									if (currentStore < energyOnTick){
											energyOnTick = currentStore;
									}
									currentStore -= energyOnTick;
									energyProcessed += energyOnTick;
									currentLife--;
							}
					}
					return energyProcessed
			}
	}

	//these are the active roles, spawning and role execution is based on this list
	let roles = [
		'ambushCollector', 'ambusher', 'archer',
		'bowMedic', 'builder', 'bucket','bulkTrader',
			'claimer',
		'colonist', 'coreHauler','coreKiller', 'depositCarry',
		'depositMiner', 'donor','exitBlocker', 'filler', 'fixer',
		'guard', 'harasser', 'harvester',
		'miner1', 'Mminer', 'monk',
		'mover', 'observer', 'powermover',
		'prayerSupport', 'pTransfer',
		'puller', 'RCattack',
		'reinforcer', 'remotefixer', 'remoteminer','remoteMinerDeputy',
		'reserve', 'scoreCollector', 'scoreMiner',
		'scout', 'shardAttack', 'shardMedic',
		'skirmisher', 'SKMineralMiner', 'SKMineralMover',
		'soldier','staticUpgrader','staticFiller', 'thief','testTrader', 'trader',
			'thoriumBaseHauler','thoriumMiner','thoriumMineFiller','thoriumMineHauler','thoriumMineOverseer','thoriumMineWorker','thoriumReactorHauler',
		'transfer', 'upgrader', 'upHauler',
		'wallRemover', 'wallBuilder', 'yak'
	];

	let functionData = {};
	function profileAllFunctions(){
			if (config.official && Game.shard.name !== 'shard2'){
					return
			}
			for (let functionName in functionData){
					let total = 0;
					let list = [];
					for (let chunk in functionData[functionName]){
							if (!functionData[functionName][chunk].currentDif && functionData[functionName][chunk].currentDif !== 0){
									console.log('currentDif',functionData[functionName][chunk].currentDif);
									functionData[functionName][chunk].currentDif = 0;
							}
							if (functionData[functionName][chunk].lastDif === undefined){
									functionData[functionName][chunk].average = Number.parseFloat(functionData[functionName][chunk].currentDif);
							} else {
									let newAv = Number.parseFloat(((functionData[functionName][chunk].average*99)+functionData[functionName][chunk].currentDif)/100);
									if (!Number.isNaN(newAv)){
											functionData[functionName][chunk].average = newAv;
									}
							}
							total += functionData[functionName][chunk].average;
							functionData[functionName][chunk].lastDif =  Number.parseFloat(functionData[functionName][chunk].currentDif);
							list.push([chunk,functionData[functionName][chunk].average,functionData[functionName][chunk].currentDif]);
							functionData[functionName][chunk].currentDif = 0;
					}
					list.sort((a,b)=>b[1]-a[1]);
					list = list.slice(0,6);
					list = list.join('\n');
					console.log('PROFILE:',functionName,total,'\n',list);
			}
	}

	function run$1h(creep){
			let homeRoom = creep.home;
			delete creep.memory.role;
			let room = creep.home;
			let stores = creep.home.storage;
			let creepNum = creep.num;
			let limit;
			if (homeRoom.memory.reserve){
					limit = homeRoom.memory.reserve + 3000;
			} else {
					limit = 31000;
			}
			if (room.memory.adjustedLowWallHits && room.memory.adjustedLowWallHits < config.minWalls[room.controller.level]){
					limit -= 5000;
			}
			if ((room.memory.alert && room.memory.alert == 'high') || room.isShardTradeRoom){
					limit -= 20000;
			}
			if (creep.isBoosted()){
					limit *= 0.5;
			}
			if (creep.home.renewDefenceCreeps && !creep.memory.role && (creep.memory.renewing || creep.ticksToLive < 300)){
					let ret = creep.renew();
					if (ret){
							return;
					}
			}
			if (creep.home.memory.restructuring || (Memory.toMoveStore && Memory.toMoveStore == creep.home.name && !creep.home.storage)){
					creep.memory.role = 'builder';
					return
			}
			if (creep.home.memory.armedHostiles != null){
					var hostiles = true;
					limit = 5000;
			} else {
					var hostiles = false;
			}
			if (homeRoom.memory.walls && homeRoom.memory.walls < 10000); else if (homeRoom.memory.walls && homeRoom.memory.walls < 10000000){
					homeRoom.memory.walls;
			} else ;
			if (creep.home.memory.bunker && creep.room.name !== creep.home.name){
					creep.goTo(creep.home.name);
			}
			let sblab;
			if (room.memory.sites && creep.memory.role && room.controller.safeMode){
					delete creep.memory.role;
			}
			if (room.memory.armedHostiles){
					if (Game.time % 15 === 0){
							delete creep.memory.target;
					}
					if (creep.home.memory.armedHostiles){
							if (!creep.memory.seenHostile || creep.memory.seenHostile <= Game.time){
									delete creep.memory.target;
									delete creep.memory.customPathData;
							}
							creep.memory.seenHostile = Game.time + 25;
					}
					if (room.memory.defenceMatrix && creep.memory.seenHostile && creep.memory.seenHostile > Game.time && creep.home.controller.level > 4){
							if (creep.hits < creep.hitsMax){
									let nearBy = creep.pos.lookAround(LOOK_CREEPS, 3, {filter: (c) => !c.my});
									if (nearBy.length > 0){
											let dir = nearBy[0].pos.getDirectionTo(creep);
											creep.move(dir);
											delete creep.memory.target;
											if (!room.memory.dangerSpots){
													room.memory.dangerSpots = [];
											}
											if (!room.memory.dangerSpots.includes(creep.pos.toString())){
													room.memory.dangerSpots.push(creep.pos.toString());
											}
									}
							}
					}
			}
			if (creep.hits < creep.hitsMax * 0.8){
					creep.memory.lastHit = Game.time + 300;
			}
			let boost = undefined;
			if (creep.ticksToLive > 1400 && !creep.memory.boosted && stores
					&& (creep.home.total('energy') > limit || creep.home.memory.defcon < 4 || homeRoom.memory.armedHostiles ||
							Game.flags['fort' + creep.home.name] || (creep.home.isShardTradeRoom && creep.home.total('LH') > 2000)
							|| (Game.flags['defend' + creep.home.name] && creep.home.total('LH') > 2000) ||
							(homeRoom.memory.alert && homeRoom.memory.alert == 'high' && homeRoom.total('energy') > limit)) &&
					(room.memory.armedHostiles || room.total('energy')>limit*0.6)&& creep.home.memory.sboostlab){
					if (creep.home.memory.sboostlab['XLH2O']){
							boost = 'XLH2O';
					} else if (creep.home.memory.sboostlab['LH']){
							boost = 'LH';
					}
					sblab = Game.getObjectById(creep.home.memory.sboostlab[boost]);
			}
			if (!creep.memory.boosted && sblab && boost){
					if (sblab && sblab.boostCreep(creep) == -9){
							creep.moveTo(sblab, {range: 1});
							return
					}
					if (!sblab || (boost && sblab.store[boost] < 500) || sblab.store['energy'] < 500){
							creep.memory.boosted = true;
					}
					if (creep.isBoosted()){
							creep.memory.boosted = true;
					}
			}
			if (creep.memory.fixing && creep.store['energy'] == 0){
					creep.memory.fixing = false;
					creep.say('collecting');
			}
			if (!creep.memory.fixing && creep.store['energy'] == creep.store.getCapacity()){
					creep.memory.fixing = true;
					creep.say('fixing');
			}
			if (creep.hits < creep.hitsMax && creep.home.ecoStable && !creep.home.memory.armedHostiles){
					creep.towerHeal(creep.home);
			}
			let term = creep.home.terminal;
			if (term && term.pos.lookFor(LOOK_FLAGS).length > 0){
					if (_.sum(creep.store) === 0 && stores && _.sum(stores.store) > 0){
							if (!creep.pos.isNearTo(stores)){
									creep.moveTo(stores, {
											range: 1
									});
							} else {
									if (term.store['energy'] < 10000 && stores.store['energy'] > 0){
											creep.withdraw(stores, 'energy');
									} else {
											for (var r in stores.store){
													creep.withdraw(stores, r);
											}
									}

							}
					} else {
							if (!creep.pos.isNearTo(term)){
									creep.moveTo(term, {
											range: 1
									});
							} else {
									for (var r in creep.store){
											creep.transfer(term, r);
									}
							}
					}
					return
			}
			let spawnval = config.minWalls[creep.home.controller.level]*3;
			if (creep.home.controller.level > 7){
					spawnval = 11000000;
			}
			if (config.swc && Game.gcl.level > 4 && creep.home.controller.level > 6){
					spawnval = 30000000;
			}
			if (spawnval < 50000){
					spawnval = 50000;
			}
			if (creep.memory.fixing){
					var repairs = Game.getObjectById(homeRoom.memory.repairs);
					var cont = Game.getObjectById(homeRoom.memory.contrep);
					var spawnRampart = Game.getObjectById(homeRoom.memory.spawnRampart);
					let ramps;
					if (creep.home.memory.defcon < 5){
							ramps = creep.home.find(FIND_CONSTRUCTION_SITES, {filter: (s) => s.structureType === 'rampart'})[0];
					}
					let roads;
					if (Game.cpu.bucket > 9000 && !creep.home.memory.armedHostiles){
							roads = creep.pos.lookAround(LOOK_STRUCTURES, 3, {filter: (s) => s.structureType == STRUCTURE_ROAD && s.hits < s.hitsMax * 0.7})[0];
					} else if (Game.cpu.bucket > 8000 && !creep.home.memory.armedHostiles){
							roads = creep.pos.lookAround(LOOK_STRUCTURES, 1, {filter: (s) => s.structureType == STRUCTURE_ROAD && s.hits < s.hitsMax * 0.7})[0];
					}
					if (roads && !creep.home.memory.armedHostiles){
							creep.repair(roads);
							return
					}
					let site;
					if (creep.home.memory.sites){
							site = Game.getObjectById(creep.home.memory.sites);
					}
					if (hostiles || (creepNum != 1 && (creep.home.class === 'normal' || creep.home.memory.adjustedLowWallHits < config.minWalls[7]))){
							Game.flags['supplyLink' + room.name];

							var lowwall = homeRoom.memory.lowWall;
							if (!creep.memory.target && creep.num % 2 === 0 && room.memory.weakPointPos){
									let weakPointPos = room.memory.weakPointPos.toPos();
									if (weakPointPos && weakPointPos.roomName){
											let ramp = weakPointPos.lookAround(LOOK_STRUCTURES, 0, {filter: (s) => s.structureType === STRUCTURE_RAMPART})[0];
											if (ramp){
													creep.memory.target = ramp.id;
											}
									}
							}
							if (!creep.memory.target){
									creep.memory.target = lowwall;
							}

							let target = Game.getObjectById(creep.memory.target);
							if (!target){
									delete creep.memory.target;
							}
							if (target){
									new RoomVisual(creep.home.name).line(target.pos,creep.pos);
							}
							if (ramps){
									creep.say('ramps');
									if (creep.build(ramps) == ERR_NOT_IN_RANGE){
											creep.moveTo(ramps, {
													range: 3
											});
									}
							} else if (site && site.structureType === 'terminal' && creep.home.class === 'bunker'){
									if (creep.build(site) == ERR_NOT_IN_RANGE){
											creep.moveTo(site, {
													range: 3
											});
									}
							} else if (target){
									if (creep.pos.getRangeTo(target)>3){
											creep.say('move');
											creep.moveTo(target,{range:3});
									} else if (target.hits < room.memory.adjustedLowWallHits*0.8 || target.hits < config.minWalls[creep.home.controller.level]
											|| room.total('energy') > room.memory.reserve || Memory.excessEnergy > 50000){
											//so we dont burn through all our energy
											let rep = creep.repair(target);
											if (rep !== 0){
													delete creep.memory.target;
											}
									} else {
											creep.say('hmm');
									}
							} else {
									delete creep.memory.target;
							}
					} else if (cont && cont.hits < cont.hitsMax * 0.8 && creep.num === 1){
							creep.say('cont repair');
							if (creep.repair(cont) == ERR_NOT_IN_RANGE){
									creep.moveTo(cont, {range: 3});
							}
					} else if (config.requestEnergyRoom && config.requestEnergyRoom.includes(creep.home.name) &&
							homeRoom.memory.adjustedLowWallHits && homeRoom.memory.adjustedLowWallHits > config.minWalls[creep.home.controller.level]){
							let up = creep.upgradeController(creep.home.controller);
							if (up === -9){
									creep.moveTo(creep.home.controller, {range: 3});
							}
					} else if (spawnRampart && spawnRampart.hits < spawnval && Math.floor(Game.time / 1000) % 2 == 0){
							creep.say('spawn');
							if (creep.repair(spawnRampart) == ERR_NOT_IN_RANGE){
									creep.moveTo(spawnRampart, {range: 3});
							}
					} else if (repairs && repairs.hits < repairs.hitsMax){
							creep.say('repairing');
							if (creep.repair(repairs) == ERR_NOT_IN_RANGE){
									creep.moveTo(repairs, {range: 3});
							}
					} else if (creep.home.class === 'bunker' &&
							homeRoom.memory.adjustedLowWallHits && homeRoom.memory.adjustedLowWallHits > config.minWalls[7]){
							let up = creep.upgradeController(creep.home.controller);
							if (up === -9){
									creep.moveTo(creep.home.controller, {range: 3});
							}
					} else if (site && site.structureType === 'terminal' && creep.home.class === 'bunker'){
							if (creep.build(site) == ERR_NOT_IN_RANGE){
									creep.moveTo(site, {
											range: 3
									});
							}
					} else {
							let lowwall = homeRoom.memory.lowWall;
							// creep.say('walls')
							if (!creep.memory.target && lowwall && Game.getObjectById(lowwall)){
									creep.memory.target = lowwall;
							}
							let target = Game.getObjectById(creep.memory.target);
							if (target){
									let range = creep.pos.getRangeTo(target);
									if (range <= 3){
											creep.repair(target);
									} else {
											creep.moveTo(target, {range: 3});
									}
							} else if (!creep.memory.target){
									if (room.controller.ticksToDowngrade < CONTROLLER_DOWNGRADE[room.controller.level] * 0.5){
											creep.memory.role = 'upgrader';
									} else {
											creep.rally(1, 5);
									}
							} else {
									delete creep.memory.target;
							}
					}
			} else {
					delete creep.memory.target;
					if (room.memory.requestEnergyRoom){
							limit = room.memory.reserve*1.3;
					}
					if (creep.home.class === 'bunker' && !room.memory.armedHostiles && room.memory.defcon === 5 &&
							homeRoom.memory.adjustedLowWallHits && homeRoom.memory.adjustedLowWallHits > config.minWalls[7]  &&
							countRole('staticUpgrader',room) < 4){
							let uplink;
							if (room.memory.uplink){
									uplink = Game.getObjectById(room.memory.uplink);
							}
							if (uplink && uplink.store['energy'] > 0 && creep.pos.inRangeTo(uplink,5)){
									creep.goAndWithdraw(uplink,'energy');
									return;
							}
					}
					let wallTarget = config.wallTarget;
					if (creep.home.class === 'bunker' && creep.home.controller.level < 8){
							wallTarget = config.minWalls[7];
					}
					if (stores && (room.total('energy') > limit || (creep.home.ecoStable && creep.home.memory.adjustedLowWallHits && creep.home.memory.adjustedLowWallHits < wallTarget) ||
							creep.home.memory.contrep || room.memory.armedHostiles || (creep.home.memory.defcon < 4 && creep.home.memory.adjustedLowWallHits && creep.home.memory.adjustedLowWallHits < config.minWalls[creep.home.controller.level]
									&& (creep.home.memory.adjustedLowWallHits < 200000 || !Memory.energyCrisis || (creep.home.memory.walls && creep.home.memory.adjustedLowWallHits && creep.home.memory.adjustedLowWallHits < creep.home.memory.walls*0.7)))
							|| (creep.home.total('energy') > 10000 && Game.flags['defend' + creep.home.name]))){
							if (creep.withdraw(stores, RESOURCE_ENERGY) == ERR_NOT_IN_RANGE){
									//define destination
									creep.moveTo(stores, {range: 1});
							}
					} else if (stores && creep.store['energy'] > 0){
							creep.memory.fixing = true;
					} else if (creep.home.controller.level < 7){
							creep.findEnergyTarget();
					} else {
							let room = creep.home;
							if (room.controller.ticksToDowngrade < CONTROLLER_DOWNGRADE[room.controller.level] * 0.5){
									creep.memory.role = 'upgrader';
							} else {
									creep.rally(1, 10);
							}
					}
			}


	}
	let spawnCode$I = {
			priority: (room, countFunction) => {
					let priority = 50;
					if (room.memory.armedHostiles || (room.memory.alert && room.memory.alert == 'high') || room.isShardTradeRoom || Game.flags['defend' + room.name]){
							priority = 20;
					} else if (room.memory.defcon < 4 || (room.memory.contrep && countFunction('fixer', room) < 1)){
							priority = 30;
					} else if (room.memory.activateRamparts && room.memory.adjustedLowWallHits && room.memory.adjustedLowWallHits < config.minWalls[room.controller.level]){
							priority = 45;
					}
					if (room.class === 'bunker'){
							priority = 30;
					}
					priority += countFunction('fixer', room) * 3;
					return priority
			},
			isRequired: (room, countFunction,idleSpawn,returnPartsNeeded) => {
					let numberRequired = 0;
					let partsRequired = 0;
					if (!room){
							console.log('no room fixer spawn',room);
							return
					}
					if (Game.flags['upgrade'+room.name] && room.controller.level < 6){
							return false
					}
					if (room.controller.level < 4 && !room.memory.contrep){
							return false
					}
					let limit = room.memory.reserve;
					if (room.memory.requestEnergyRoom){
							limit = room.memory.reserve*1.3;
					}
					let minWalls = config.minWalls[room.controller.level];
					if ((!room.ecoStable || Game.energyCrisis) && !room.memory.contrep && !room.memory.armedHostiles && !Game.flags['defend' + room.name] && room.memory.defcon === 5 && room.memory.adjustedLowWallHits > minWalls){
							return false
					}
					if (((room.storage && room.total('energy') < 10000) || !room.memory.lotsOfDroppedEnergy) && countFunction('fixer', room) > 3){
							return false
					}
					if (room.memory.contrep || room.controller.level < 8 || (room.memory.adjustedLowWallHits && room.memory.adjustedLowWallHits < minWalls)){
							partsRequired = 3;
							if (room.memory.rampartAmount){
									let repairNeeded = room.memory.rampartAmount*(RAMPART_DECAY_AMOUNT/RAMPART_DECAY_TIME);
									let partsNeededByRampartAmount = (repairNeeded/REPAIR_POWER)*2.5;
									//we * here to account for not all parts being work parts, and not all time spent repairing
									if (partsNeededByRampartAmount && partsNeededByRampartAmount >= 3){
											partsRequired = Math.round(partsNeededByRampartAmount);
									} else if (partsNeededByRampartAmount){
											partsRequired = 3;
									}
							}
							if (room.storage && room.total('energy') > limit * 1.5 && !Memory.priorityEnergyRoomName && (room.memory.adjustedLowWallHits && room.memory.adjustedLowWallHits < minWalls*0.9)){
									partsRequired += 5;
							} else if (room.memory.adjustedLowWallHits && room.memory.adjustedLowWallHits < minWalls*0.9 && room.total('energy')>room.memory.reserve*1.4){
									partsRequired += 2;
							}
							if (partsRequired < 5 && Game.gcl.level > 2){
									partsRequired = 5;
							}
							if (!room.memory.activateRamparts){
									partsRequired = 2;
							}
							if (config.official || Game.gcl.level > 4 || room.controller.level === 8 || (config.level7max && room.controller.level === 7)){
									//post gcl much more likely to be attacked - increase fixer parts
									partsRequired += 3;
							} else if (room.controller.level === 7) {
									partsRequired += 2;
							}
					}
					if ((room.terminal && room.terminal.pos.lookFor(LOOK_FLAGS).length > 0) || Game.flags['fort' + room.name] || (((room.memory.alert && room.memory.alert == 'high') || room.isShardTradeRoom) && room.memory.adjustedLowWallHits && room.memory.adjustedLowWallHits < config.minWalls[8])
							|| Game.flags['defend' + room.name] || Game.flags['caution' + room.name] || room.memory.nukeDefence || room.memory.defcon < 4 ||
							(room.memory.armedHostiles && !room.justInvader && Game.getObjectById(room.memory.armedHostiles) && Game.getObjectById(room.memory.armedHostiles).body.length > 10)
							|| (room.armedHostileList && !room.justInvader && room.armedHostileList.length > 2) ||
							(room.controller && room.controller.safeMode && room.controller.safeMode > 3000 && room.memory.defcon && room.memory.defcon < 4)){
							partsRequired = 30;
							if (room.controller.level > 6){
									partsRequired = 60;
							} else if (room.controller.level > 7){
									partsRequired = 80;
							}
							if (room.memory.defcon < 4){
									partsRequired += 30;
							}
					}
					if (!room.memory.armedHostiles && room.memory.defcon === 5 && partsRequired > 75 && room.total('energy')<limit){
							partsRequired = 30;
							if (room.total('energy')<(limit-10000)){
									if (room.total('energy')<(limit-20000) && room.memory.adjustedLowWallHits >= config.wallTarget){
											return false
									}
									partsRequired = 15;
							}
					}
					if (returnPartsNeeded){
							return partsRequired
					}
					if (room.class !== 'bunker' && partsRequired  && (partsRequired > 50 || (partsRequired*2) > room.energyCapacityAvailable/100)){
							//if parts needed is enough to warrant more than one creep
							numberRequired = Game.bodySizeToNumberNeeded(partsRequired, spawnCode$I.body(room, countFunction,{partsRequired:partsRequired}).body, WORK);
					} else if (partsRequired){
							numberRequired = 1;
					}
					let lowWallHits = room.memory.adjustedLowWallHits;
					if (numberRequired > 1 && (room.isEnergyDonor && room.total('energy') <= limit * 1.3) && lowWallHits > config.minWalls[room.controller.level]*0.5){
							numberRequired = 1;
					}
					let defend = false;
					if ((room.memory.armedHostiles && !room.justInvader && (lowWallHits < config.minWalls[room.controller.level]*0.9 || room.memory.defcon < 4 || countRole('fixer',room)<2))
							|| (room.memory.alert && room.memory.alert === 'high' && lowWallHits < config.minWalls[8]) || Game.flags['defend' + room.name]){
							defend = true;
					}
					if (!defend && !room.memory.contrep && !room.ecoStable && lowWallHits >= minWalls){
							return false
					}
					if (lowWallHits > minWalls && (lowWallHits < config.wallTarget) && (Game.energyCrisis || Game.energyCaution || config.conserveCpu) &&
							numberRequired > 1 && !defend){
							numberRequired = 1;
					}
					if (room.total('energy') < limit && room.memory.defcon == 5 && !defend && numberRequired > 2 && !Game.energyCrisis){
							numberRequired = 2;
					}
					if (numberRequired > 1 && lowWallHits > config.wallTarget && !defend){
							numberRequired = 1;
					} else if (lowWallHits < config.minWalls[7] && numberRequired && numberRequired < 1){
							numberRequired = 1;
					}
					if (!defend && config.conserveCpu && room.controller.level > 7 && lowWallHits > minWalls && numberRequired > 1){
							numberRequired = 1;
					}
					if (!defend && room.memory.defcon === 5 && (config.requestEnergyRoom && config.requestEnergyRoom.length > 0) && lowWallHits > 500000){
							numberRequired = 0;
					}
					if (numberRequired < 1 && config.alwaysGuard && config.alwaysGuard.includes(room.name) && room.controller.level > 5){
							numberRequired = 1;
							if (lowWallHits && lowWallHits < config.minWalls[room.controller.level] && room.total('energy')>(limit*1.2) && !room.memory.requestEnergyRoom && !room.memory.priorityEnergyRoom){
									numberRequired = 2;
							}
					}
					if (room.memory.defcon === 5 && room.memory.boostingRequired && numberRequired > 2){
							numberRequired = 2;
					}
					if (!defend && config.conserveCpu && room.controller.level === 8 && Game.cpu.bucket < 3000 && numberRequired > 1 && lowWallHits > config.minWalls[7]){
							numberRequired = 1;
							if (Memory.excessEnergy < 0){
									numberRequired = 0;
							}
					}
					if (!defend && (room.controller.level < 5 || Game.gcl.level < 2) && numberRequired > 1){
							numberRequired = 1;
					}
					if (!room.memory.armedHostiles && room.memory.defcon === 5 && room.memory.adjustedLowWallHits && (room.memory.adjustedLowWallHits > config.minWalls[room.controller.level]*0.9 || Memory.excessEnergy < Memory.myRooms.length*5000)
							&& room.class === 'normal' && numberRequired > 1){
							numberRequired = 1;
					}
					if (countFunction('fixer',room)>1 && !room.memory.lowWall && !room.memory.hostile){
							return false
					}
					if (room.class === 'bunker' && room.storage && room.controller.level > 5){
							numberRequired = 2;
							if (config.official && lowWallHits && lowWallHits < config.minWalls[7] && !Game.energyCrisis){
									numberRequired = 4;
							} else if (lowWallHits && lowWallHits < config.minWalls[7]&& !Game.energyCaution){
									numberRequired = 3;
							}
					} else if (room.class === 'bunker' && room.storage && room.controller.level > 3){
							numberRequired = 1;
							if (config.official && lowWallHits && lowWallHits < config.minWalls[7] && !Game.energyCrisis){
									numberRequired = 4;
							} else if (lowWallHits && lowWallHits < config.minWalls[7] && !Game.energyCaution){
									numberRequired = 3;
							}
					}
					if (numberRequired === 0 && room.total('energy')>room.memory.reserve*2){
							numberRequired = 1;
					}
					if (!room.memory.activateRamparts && !defend && room.class !== 'bunker' && numberRequired > 1){
							numberRequired = 1;
					}
					return countFunction('fixer', room) < numberRequired;
			},
			spawn: (room, role, body) => {
					//decide if we need any other options
					if (body){
							//options -> TTL, creepnumber
							room.spawnCreep(role, body);
					}
			},
			body: (room, countFunction,options) => {
					let forBunker;
					if (options && options.forBunker){
							forBunker = true;
					}
					if (room.memory.roadsDown === undefined){
							room.memory.roadsDown = false;
					}
					let bodyObject = {
							body: [],
							cost: 0
					};
					let max = 50;
					let workPartsMax;
					if (options && options.partsRequired){
							//use this to prevent looping between isRequired and body
							workPartsMax = options.partsRequired;
					} else {
							workPartsMax = spawnCode$I.isRequired(room,countFunction,undefined,true);
					}
					if (room.class === 'bunker' || forBunker){
							workPartsMax = 50;
					}
					if (workPartsMax && workPartsMax > 50){
							workPartsMax = 50;
					}
					if (workPartsMax && max > workPartsMax*3){
							max = Math.round(workPartsMax*3);
					}
					//decide on what body to have
					bodyObject.body = getBody$5(room.energyCapacityAvailable,room, room.memory.roadsDown, 'fixer', max,room.storage,{targetWorkParts:workPartsMax});
					if (room.class === 'bunker'){
							bodyObject.body = getBody$5(room.energyCapacityAvailable,room, false, 'fixer', 50,room.storage);
					}
					if (bodyObject.body && bodyObject.body.length > 0){
							bodyObject.cost += Game.getBodyCost(bodyObject.body);
					}
					return bodyObject
			}
	};

	var fixer = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$1h,
		spawnCode: spawnCode$I
	});

	playerHeap.allCreepCounts = {};
	const nonIdleRoles = ['remoteminer'];
	const stopIfIdle = ['yak', 'fixer', 'upgrader','staticUpgrader', 'builder', 'remotefixer', 'upHauler','thoriumMineFiller'];
	const bunkerRoles = ['upHauler','yak','miner1','remoteminer','reserve','puller','remotefixer','upgrader','builder','harvester','guard','fixer','transfer',
	'claimer','colonist','staticUpgrader','mover','Mminer','scout'];
	const bunkerAcquireRoles = ['guard','fixer','transfer'];
	const roleIntervals = {
			'reserve':15,
			'remoteminer':25
	};
	let checkRoles = [];
	let time$3 = 0;
	let roomCache$1 = {};
	let lastSpawnList = {};
	function countRole(role, room){
			countCreeps();
			if (!playerHeap.allCreepCounts[room.name]){
					//console.log('no count for',room.name)
					return 0
			}
			let a = playerHeap.allCreepCounts[room.name][role];
			if (a){
					return a
			} else {
					return 0
			}
	}
	function countRoleAdjustingForParts(role,room,body,part){
			if (body.body){
					body = body.body;
			}
			if (room.roleList && room.roleList[role]){
					let parts = 0;
					for (let i in room.roleList[role]){
							if (room.roleList[role][i].body){
									if (part){
											parts += room.roleList[role][i].countParts(part);
									} else {
											parts += room.roleList[role][i].body.length;
									}
							}
					}
					if (body && body.length){
							let length = body.length;
							if (part){
									length = 0;
									for (let i in body){
											if (body[i] == part){
													length++;
											}
									}
							}
							return Math.round(parts/length)
					}
			}
	}
	function runSpawnManager(room){
			if (!lastSpawnList[room.name]){
					lastSpawnList[room.name] = Game.time;
			}
			let spawningRequired = false;
			countCreeps();
			if (!roomCache$1[room.name]){
					roomCache$1[room.name] = {
							energyTarget: 0,
							timeTarget: Game.time
					};
			}
			let request;
			let cache = roomCache$1[room.name];
			if (lastSpawnList[room.name] < Game.time-100 && room.class === 'normal'){
					try {
							emergencyReboot(room);
					} catch (err){
							console.log(err.stack.split("at"));
					}
			}
			if (!room.armedHostiles && room.memory.defcon == 5 && config.conserveCpu){
					if ((!cache.energyTarget || room.energyAvailable < cache.energyTarget) && cache.timeTarget && Game.time < cache.timeTarget){
							//time target to ensure we don't get stuck
							room.display(`spawn paused to await energy target, ${cache.energyTarget} ${cache.timeTarget} ${cache.role}`);
							if (room.memory.spawnStats){
									if (!room.memory.spawnStats.lowEnergy){
											room.memory.spawnStats.lowEnergy = 0;
									}
									room.memory.spawnStats.lowEnergy++;
							}
							if (!cache.energyTarget){
									return 'nothing queue block'
							}
							return 'await energy'
					}
			}
			if (room.squadSpawningBlockCivs){
					return 'blockCivs'
			}
			//main spawn logic
			let priorityList = [];
			let noRoleModule = [];
			for (let i in roles){
					let role = roles[i];
					let roleModule;
					try {
							roleModule = RoleModules[role];
					} catch (err){
							noRoleModule.push(role);
					}
					if (roleModule && roleModule.spawnCode){
							if (checkRoles.includes(role)){
									console.log(`checking ${role} is required`, room.name, roleModule.spawnCode.isRequired(room, countRole), roleModule.spawnCode.priority(room, countRole),'alive:',countRole(role,room));
							}
							let priority = roleModule.spawnCode.priority(room, countRole);
							if (priority && room.idleList && room.idleList[role] && !nonIdleRoles.includes(role)){
									priority += 50;
							}
							if (roleIntervals && roleIntervals[role] && room.controller.level > 2 && priority > 15){
									let lastSpawn = room.getTimeLastSpawned(role);
									if (lastSpawn){
											let dif = Game.time-lastSpawn;
											if (dif < roleIntervals[role]){
													priority += (roleIntervals[role]-dif);
													//console.log('new prio',priority,role)
											}
									}
							}
							if (priority < 5 && role !== 'harvester' && role !== 'miner1'){
									//prevent other creeps trying to spawn and this causing crash
									priority = 5;
							}
							if (priority && (room.class === 'normal' || (room.class === 'bunker' && bunkerRoles.includes(role)))){
									priorityList.push([role, priority, roleModule]);
							}
					} else {
							noRoleModule.push(role);
					}
			}
			if (noRoleModule && noRoleModule.length > 0 && Game.time % 500 === 0){
					console.log(room.name, ': no role module or no spawn code for the following roles:', noRoleModule);
			}
			priorityList.sort((a, b) => {
					return a[1] - b[1]
			});
			//console.log('priority:')
			let tried = [];
			for (let i in priorityList){
					try {
							let cpu = Game.cpu.getUsed();
							let role = priorityList[i][0];
							let priority = priorityList[i][1];
							let module = priorityList[i][2];
							tried.push(role);
							if (stopIfIdle && stopIfIdle.includes(role) && room.idleList && room.idleList[role]){
									//console.log(room.name,'not spawning idle',role)
									continue
							}
							if (module && module.spawnCode.isRequired(room, countRole)){
									room.memory.prioritySpawn = priority < 15;
									let ret = requestSpawnCreep(room,role,module);
									if (role === 'fixer'){
											room.memory.fixerSpawnLastPartsNeeded =  spawnCode$I.isRequired(room,countRole,false,true);
									}
									if (ret){
											request = ret;
											break
											if (!Memory.stats.creepSpawningCPU[role]){
													Memory.stats.creepSpawningCPU[role] = Game.cpu.getUsed()-cpu;
											} else {
													Memory.stats.creepSpawningCPU[role] += (Game.cpu.getUsed()-cpu);
											}
									}
							}
							if (!Memory.stats.creepSpawningCPU[role]){
									Memory.stats.creepSpawningCPU[role] = Game.cpu.getUsed()-cpu;
							} else {
									Memory.stats.creepSpawningCPU[role] += (Game.cpu.getUsed()-cpu);
							}
					} catch (err){
							console.log('error with spawning', priorityList[i][0], ':', err.stack.split('at'));
					}
			}
			//console.log(room.name,tried)
			if (!spawningRequired && !room.requestedToSpawnCreep && room.class === 'normal' && (!config.conserveCpu || Game.cpu.bucket > 9000 || room.controller.level < 4) && Game.cpu.bucket > 1000){
					//preventing spawn idling by pushing through extra of certain creeps
					if (!room.storage || room.storage.store['energy']>room.memory.reserve*1.5 || room.memory.lotsOfDroppedEnergy){
							if (!spawningRequired && (!room.idleList || !room.idleList['upgrader']) && countRole('staticUpgrader',room) < 1 &&
									(!room.memory.upCont || !Game.getObjectById(room.memory.upCont) || (room.storage && room.total('energy')>room.memory.reserve*1.5))){
									console.log('up idle try more');
									let module = upgrader;
									if (module && module.spawnCode.isRequired(room,countRole,true)){
											request = requestSpawnCreep(room,'upgrader',module);
									}
							}
					}
					if (!spawningRequired && (!room.idleList || !room.idleList['yak']) && room.storage && Game.cpu.bucket > 3000){
							let module = yak;
							if (module && module.spawnCode.isRequired(room,countRole,true)){
									request = requestSpawnCreep(room,'yak',module);
							}
					}
			}
			if (!spawningRequired){
					cache.energyTarget = 0;
					let timeAdd = 30;
					if (!config.conserveCpu || Game.cpu.bucket >= 6000){
							timeAdd = 3;
					} else if (Game.cpu.bucket >= 3000){
							timeAdd = 9;
					}
					room.nothingQueued = true;
					cache.timeTarget = Game.time + timeAdd;
					if (room.memory.spawnStats){
							if (!room.memory.spawnStats.nothingQueued){
									room.memory.spawnStats.nothingQueued = 0;
							}
							room.memory.spawnStats.nothingQueued+=timeAdd;
					}
					if (!room.memory.spawnPartsWasted){
							room.memory.spawnPartsWasted = {
									logStart:Game.time,
									partsWasted:0
							};
					}
					let partsPerTick = 1/3;
					if (room.controller.level === 7){
							partsPerTick = 2/3;
					} else if (room.controller.level === 8){
							partsPerTick = 1;
					}
					room.memory.spawnPartsWasted.partsWasted += (timeAdd*partsPerTick);
					return 'nothing queued'
			} else {
					return `spawning requested + ${request}`
			}
			function emergencyReboot (room){
					let creepList = room.creepList;
					if (!creepList || creepList.length < 5){
							console.log('try emergency reboot',room.name);
							if (spawnCode$l.isRequired(room,countRole)){
									requestSpawnCreep(room,'harvester',harvester);
							} else if (spawnCode$h.isRequired(room,countRole)){
									requestSpawnCreep(room,'harvester',miner1);
							}
					}
			}
			function requestSpawnCreep(room,role,module){
					let nearRoom,requestingRoomName;
					let options = {};
					if (room.class === 'bunker'){
							options.forBunker = true;
							if (bunkerAcquireRoles.includes(role)){
									console.log('acquire role',role,room.name);
									if (room.memory.supportRooms && room.memory.supportRooms.rooms){
											let count = 0;
											for (let i in room.memory.supportRooms.rooms){
													let supportRoom = Game.rooms[i];
													if (supportRoom && supportRoom.spawnFree && supportRoom.controller && supportRoom.controller.level > 6 && supportRoom.ecoStable){
															nearRoom = supportRoom;
															break
													} else if (count === 0 && supportRoom.ecoStable && !supportRoom.memory.armedHostiles && supportRoom.memory.defcon === 5
													&& supportRoom.creepList && supportRoom.creepList.length > 10){
															supportRoom.memory.spawnBlockTime = Game.time+5;
													}
													count++;
											}
									} else {
											console.log('no supportrooms');
											return false
									}
									if (!nearRoom){
											console.log('no rooms near free');
											return false
									}
							} else if (!room.spawnFree){
									return  false
							}
					}
					if (nearRoom){
							requestingRoomName = room.name;
							room = nearRoom;
					}
					//console.log(role,bodyObj.body,bodyObj.cost)
					let bodyObj = module.spawnCode.body(room, countRole,options);
					if (nearRoom){
							room.display('spawning for other room ' + role + ' ' + bodyObj.body);
					} else {
							room.display('trying to spawn ' + role + ' ' + bodyObj.body);
					}
					if (!bodyObj || (bodyObj && (!bodyObj.body || bodyObj.body.length === 0 || bodyObj.cost > room.energyCapacityAvailable))){
							console.log('spawning error for', room, role, JSON.stringify(bodyObj));
							return false
					}
					spawningRequired = true;
					if (bodyObj && bodyObj.cost && room.energyAvailable >= bodyObj.cost && (!room.nukeTime || room.nukeTime > (bodyObj.body.length * 6))){
							if (!nearRoom){
									module.spawnCode.spawn(room, role, bodyObj.body);
							} else {
									lastSpawnList[room.name] = Game.time;
									room.spawnCreep(role,bodyObj.body,{assignedHomeName:requestingRoomName});
							}
					} else if (bodyObj && bodyObj.cost){
							room.display('cant afford');
							cache.timeTarget = Game.time + 30;
							cache.energyTarget = bodyObj.cost;
							cache.role = role;
					}

					return true
			}
	}
	function incrementCreepCount(roomName,role){
			if (playerHeap.allCreepCounts[roomName]){
					if (!playerHeap.allCreepCounts[roomName][role]){
							playerHeap.allCreepCounts[roomName][role] =0;
					}
					playerHeap.allCreepCounts[roomName][role]++;
			}
	}
	function countCreeps(){
			if (time$3 && time$3 > Game.time){
					return
			}
			playerHeap.allCreepCounts = {};
			let num = 10;
			if (Game.cpu.bucket === 10000){
					num = 1;
			}
			time$3 = Game.time+num;
			for (let i in Game.creeps){
					let creep = Game.creeps[i];
					let roomName = creep.name.split(' ')[2];
					let role = creep.name.split(' ')[0];
					if (!roomName || !role || (role != 'bucket' && creep.ticksToLive <= creep.TTLRespawnDue && !creep.spawning)){
							continue
					}
					if (!playerHeap.allCreepCounts[roomName]){
							playerHeap.allCreepCounts[roomName] = {};
					}
					if (!playerHeap.allCreepCounts[roomName][role]){
							playerHeap.allCreepCounts[roomName][role] = 1;
					} else {
							playerHeap.allCreepCounts[roomName][role]++;
					}
			}
	}

	var spawnManager = /*#__PURE__*/Object.freeze({
		__proto__: null,
		roleIntervals: roleIntervals,
		countRole: countRole,
		countRoleAdjustingForParts: countRoleAdjustingForParts,
		runSpawnManager: runSpawnManager,
		incrementCreepCount: incrementCreepCount
	});

	function waypoints(creep, ret, SK){
				Game.spawns[creep.name.split(' ')[2]];
				var spawnnum = creep.name.split(' ')[2];
				if (!creep.memory.WP || (creep.memory.WP && creep.memory.WP != 'fin')){
					var flags = [];
					for (var f in Game.flags){
						var flag = Game.flags[f];
						var array = flag.name.split('-');
						if (array[0] === 'WP' && spawnnum && array[1] == spawnnum){
							flags.push(flag.name);
						}
					}

					if (flags.length > 0){
						var flags = flags.sort();
						if (!creep.memory.WP){
							creep.memory.WP = flags[0];
						}
						for (let i = 0; i < flags.length; i++){
							let flag = Game.flags[flags[i]];
							if (flag && creep.pos.isEqualTo(flag.pos)){
								if (i < flags.length - 1){
									creep.memory.WP = flags[i + 1];
								} else {
									creep.memory.WP = 'fin';
								}
							}
						}
					} else {
						creep.memory.WP = 'fin';
					}
					if (creep.memory.WP && Game.flags[creep.memory.WP] && !ret){
						//console.log(creep.memory.WP)
						if (Game.flags[creep.memory.WP] && Game.flags[creep.memory.WP].pos &&
							creep.room.name === Game.flags[creep.memory.WP].pos.roomName &&
							Game.map.getRoomType(creep.room.name) == 'highway'){
							creep.moveTo(Game.flags[creep.memory.WP], {range: 0, maxRooms: 1});
						} else {
							creep.goTo(Game.flags[creep.memory.WP].pos, {SK: SK});
						}
					} else if (creep.memory.WP){
						return Game.flags[creep.memory.WP]
					}
				}
			}

	let activeCreepsAll = {

	};
	function run$1g(creep){
			let homeRoom = creep.home;
			let targetRoom = creep.num;
			var homeRoomName = creep.name.split(' ')[2];
			//console.log('rca',targetRoom)
			let pFlag = Game.flags['portal' + homeRoomName];
			Game.flags['pExit' + homeRoomName];
			if (!activeCreepsAll[targetRoom]){
					activeCreepsAll[targetRoom] = [];
			} else {
					if (!activeCreepsAll[targetRoom].includes(creep.id)){
							activeCreepsAll[targetRoom].push(creep.id);
					}
			}
			if (creep.hits < creep.hitsMax && homeRoom){
					homeRoom.memory.RCblock = Game.time + 1000;
			}
			if (targetRoom){
					if (!creep.memory.WP || creep.memory.WP != 'fin'){
							waypoints(creep);
					} else if (!creep.memory.portal && pFlag){
							creep._moveTo(pFlag,{range:0});
					} else if (targetRoom && targetRoom === creep.room.name){
							if (!creep.room.controller.owner){
									if (!creep.pos.isNearTo(creep.room.controller)){
											creep.moveTo(creep.room.controller,{range:1,maxRooms:1});
									} else {
											creep.reserveController(creep.room.controller);
									}
									if (creep.room.controller.reservation && creep.room.controller.reservation.user === Game.username &&
											creep.room.controller.reservation.ticksToEnd ===  CONTROLLER_RESERVE_MAX){
											creep.memory.role = 'recycle';
									}
									return
							}
							if (creep.room.controller.upgradeBlocked && creep.room.controller.upgradeBlocked > creep.ticksToLive && homeRoom){
									homeRoom.memory.RCblock = Game.time + creep.room.controller.upgradeBlocked - (Game.map.getRoomLinearDistance(creep.home.name,targetRoom)*100)-100;
									creep.suicide();
									return
							}
							if (!creep.pos.isNearTo(creep.room.controller)){
									creep.moveTo(creep.room.controller,{range:1,maxRooms:1});
							} else if (!creep.shard !== Game.shard.name && creep.room.controller && !creep.room.controller.my){
									creep.attackController(creep.room.controller);
							}
							//attack controller will be performed by a different function so we can loop through the active creeps and only attack when they are all ready
					} else {
							creep.goTo(targetRoom, {range: 1});
					}
			}
	}

	function attackRoomController(targetRoomName,number){
			let targetRoom = Game.rooms[targetRoomName];
			let activeCreepList = activeCreepsAll[targetRoomName];
			if (!activeCreepList || !targetRoom || !targetRoom.controller){
					return
			}
			let activeCreeps = [];
			for (let i = activeCreepList.length; i > -1; i--){
					let creep = Game.getObjectById(activeCreepList[i]);
					if (creep && !creep.memory.role){
							activeCreeps.push(creep);
					} else {
							activeCreepList.splice(i,1);
					}
			}
			let attack = false;
			if (targetRoom && targetRoom.memory.armedHostiles){
					attack = true;
			} else {
					let nearTo = 0;
					for (let i in activeCreeps){
							let creep = activeCreeps[i];
							if (creep.pos.isNearTo(targetRoom.controller)){
									nearTo ++;
									if (creep.hits < creep.hitsMax){
											attack = true;
											break
									}
									if (creep.ticksToLive === 1){
											attack = true;
											break
									}
							}
					}
					if (number && nearTo >= number){
							attack = true;
					}
			}
			if (attack){
					for (let i in activeCreeps){
							let creep = activeCreeps[i];
							if (creep.pos.isNearTo(targetRoom.controller) && !targetRoom.controller.my && targetRoom.controller.owner){
									creep.attackController(targetRoom.controller);
							} else if (creep.pos.isNearTo(targetRoom.controller) && !targetRoom.controller.owner){
									creep.claimController(targetRoom.controller);
							}
					}
			}
	}




	let spawnCode$H = {
			priority: (room, countFunction) => {
					let priority = 30;
					return priority
			},
			isRequired: (room, countFunction) => {
					if (config.crossShardSupport){
							let target;
							crossShardLoop:
									for (let i in config.crossShardSupport){
											let obj = config.crossShardSupport[i];
											if (obj.RCARooms && obj.RCARooms[Game.shard.name]){
													for (let r in obj.RCARooms[Game.shard.name]){
															if (obj.RCARooms[Game.shard.name][r] === room.name){
																	target = i.split('-')[1];
																	break crossShardLoop
															}
													}
											}
									}
							if (target && room.creepList && room.creepList.filter((c) => c.name.split(' ')[0] == 'RCattack' && c.name.split(' ')[1] == target).length < 2){
									return target
							}
					}
					return false
			},
			spawn: (room, role, body) => {
					//decide if we need any other options
					if (body){
							//options -> TTL, creepnumber
							room.spawnCreep(role, body, {creepnumber: spawnCode$H.isRequired(room)});
					}
			},
			body: (room, countFunction) => {
					if (room.memory.roadsDown === undefined){
							room.memory.roadsDown = false;
					}
					let key = room.energyCapacityAvailable + ':' + room.memory.roadsDown;
					if (getCachedBody('RCattack',key)){
							return getCachedBody('RCattack',key)
					}
					let bodyObject = {
							body: [],
							cost: 0
					};
					//decide on what body to have
					bodyObject.body = room.makeBody([CLAIM], false);

					if (bodyObject.body && bodyObject.body.length > 0){
							bodyObject.cost += Game.getBodyCost(bodyObject.body);
					}
					cacheBody('RCattack',key,bodyObject);
					return bodyObject
			}
	};

	var RCattack = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$1g,
		attackRoomController: attackRoomController,
		spawnCode: spawnCode$H
	});

	let cachedScores = {};
	let cachedTerrain = {};
	let cacheReset;
	class QuadPosition {
			constructor(corner, oppositeCorner){
					let arr = Array.from(arguments);
					if (arr.length === 1){
							//arr[0] is either array of positions or a centre (arr of 2 numbers, and a roomName)
							if (arr[0] && Array.isArray(arr[0])){
									let xs = [];
									let ys = [];
									for (let i in arr[0]){
											if (arr[0][i] && arr[0][i].x !== undefined && !xs.includes(arr[0][i].x)){
													xs.push(arr[0][i].x);
											}
											if (arr[0][i] && arr[0][i].y !== undefined && !ys.includes(arr[0][i].y)){
													ys.push(arr[0][i].y);
											}
									}
									if (ys.length == 2 && xs.length == 2 && Math.abs(xs[0] - xs[1]) === 1 && Math.abs(ys[0] - ys[1]) === 1){
											//this is to check the coordinates supplied are adjacent and the positions form a quad, and ensures centre is in correct pos
											this.positions = arr[0];
											this.centre = new CentrePosition((xs[0] + xs[1]) / 2, (ys[0] + ys[1]) / 2, arr[0][0].roomName);
									}
							} else if (arr[0] && arr[0].roomName){
									let x = arr[0][0];
									let y = arr[0][1];
									if (!Number.isInteger(x) && !Number.isInteger(y)){
											//centre positions will always be 0.5 as between 4 coordinates
											this.centre = new CentrePosition(x, y, arr[0].roomName);
											this.positions = [
													new RoomPosition(x + 0.5, y + 0.5, roomName),
													new RoomPosition(x - 0.5, y - 0.5, roomName),
													new RoomPosition(x + 0.5, y - 0.5, roomName),
													new RoomPosition(x - 0.5, y + 0.5, roomName)
											];
									}
							}
					} else {
							if (corner && oppositeCorner && corner.roomName != undefined && oppositeCorner.roomName != undefined){
									let isNearTo = false;
									let dir;
									if (Math.abs(corner.x - oppositeCorner.x) <= 1 && Math.abs(corner.y - oppositeCorner.y) <= 1 &&
											corner.roomName === oppositeCorner.roomName){
											isNearTo = true;
									}
									if (isNearTo){
											dir = corner.getDirectionTo(oppositeCorner);
									}
									if (dir){
											this.positions = [corner, oppositeCorner, corner.movePos(dir.map8(1)), corner.movePos(dir.map8(-1))];
											this.centre = new CentrePosition((corner.x + oppositeCorner.x) / 2, (corner.y + oppositeCorner.y) / 2, corner.roomName);
									}
							}
					}
					if (!this.centre || !this.positions){
							return false
					}
			}
			isEqualTo(otherQuad){
					if (this.centre && otherQuad.centre && checkIfCentresEqual(this.centre, otherQuad.centre)){
							return true
					}
					return false
			}

			get terrain(){
					if (cachedTerrain && cachedTerrain[this.centre.id]){
							return cachedTerrain[this.centre.id]
					}
					let terrain = 'plain';
					if (this.positions){
							for (let i in this.positions){
									let ter = this.positions[i].getTerrain();
									if (ter && ter === 'swamp'){
											terrain = 'swamp';
									} else if (ter === 'wall'){
											return 'wall'
									}
							}
					}
					cachedTerrain[this.centre.id] = terrain;
					return terrain
			}

			get room(){
					if (this.positions && this.positions[0] && this.positions[0].roomName && Game.rooms[this.positions[0].roomName]){
							return Game.rooms[this.positions[0].roomName]
					} else {
							return false
					}
			}

			move(dir, newQP, matrix,newCentreId){
					let newPositions = [];
					let canMove = true;
					if (!matrix){
							matrix = this.room.structureMatrix;
					}
					let canMoveConfirmed = false;
					if (cachedScores && newCentreId && cachedScores[newCentreId] !== undefined){
							canMoveConfirmed = true;
							if (cachedScores[newCentreId] === 255 || cachedScores[newCentreId] === false){
									return
							}
					}
					for (let i = 0; i < 4; i++){
							let newPos = this.positions[i].movePos(dir, false, true);
							if (newPos){
									if (!canMoveConfirmed && ((matrix && matrix.get(newPos.x, newPos.y) >= 255) || newPos.getTerrain() == 'wall')){
											canMove = false;
											break
									}
									newPositions.push(newPos);
							} else {
									canMove = false;
									break
							}
					}
					if (canMove && newPositions.length === 4){
							if (newQP){
									return new QuadPosition(newPositions)
							} else {
									this.positions = newPositions;
									this.centre.setXY((this.positions[0].x + this.positions[1].x) / 2, (this.positions[0].y + this.positions[1].y) / 2);
							}
					} else if (canMove){
							console.log('quad error', newPositions);
					} else if (newCentreId) {
							cachedScores[newCentreId] = false;
					}
			}

			neighbours(matrix, visited){
					let neighbourList = [];
					for (let i = 1; i < 9; i++){
							let newQ = this.moveQuadCheckingVisited(i, visited, matrix);
							if (newQ){
									neighbourList.push(newQ);
							}
					}
					return neighbourList
			}
			getPositionScore(matrix){
					let score = 0;
					if (!cacheReset || cacheReset < Game.time){
							cacheReset = Game.time+200;
							cachedScores = {};
							cachedTerrain = {};
					}
					if (this.centre && this.centre.id && cachedScores && cachedScores[this.centre.id] !== undefined){
							return cachedScores[this.centre.id]
					}
					for (let i in this.positions){
							score += matrix.get(this.positions[i].x,this.positions[i].y);
							if (this.positions[i].onEdge() || this.positions[i].getTerrain() === 'wall'){
									cachedScores[this.centre.id] = false;
									return false
							}
					}
					score = Math.round(score/4);
					cachedScores[this.centre.id] = score;
					return score
			}
			moveQuadCheckingVisited(dir, visited, matrix){
					let newC = checkCentre(this.centre, dir);
					if (visited[newC.id]){
							return
					}
					let newQ = this.move(dir, true, matrix,newC.id);
					if (newQ && newQ.centre && newQ.centre.id){
							visited[newQ.centre.id] = true;
							return newQ
					}
			}
			getQuadRangeTo(otherPos){
					let centre = this.centre;
					let centreX = centre.x;
					let centreY = centre.y;
					if (otherPos.pos){
							otherPos = otherPos.pos;
					}
					if (otherPos.x > centreX){
							centreX += 0.5;
					} else {
							centreX -= 0.5;
					}
					if (otherPos.y > centreY){
							centreY += 0.5;
					} else {
							centreY -= 0.5;
					}
					if (this.room && otherPos.roomName === this.room.name){
							return dist(centreX,centreY,otherPos.x,otherPos.y)
					}
					return false
			}
			highlight(colour, opt){
					//10 cpu overall - 0.001 per call
					for (let i in this.positions){
							this.positions[i].highlight(colour, opt);
					}
			}
	}

	class CentrePosition {
			constructor(x, y, roomName){
					if (x > -1 && x < 50 && y > -1 && y < 50){
							this.x = x;
							this.y = y;
							this.roomName = roomName;
							this.id = x + '-' + y + '-' + roomName;
					}
			}
			get positions(){
					let positions = [
							new RoomPosition(this.x + 0.5, this.y + 0.5, this.roomName),
							new RoomPosition(this.x - 0.5, this.y - 0.5, this.roomName),
							new RoomPosition(this.x + 0.5, this.y - 0.5, this.roomName),
							new RoomPosition(this.x - 0.5, this.y + 0.5, this.roomName)
					];
					return positions
			}

			highlight(col, options){
					let positions = this.positions;
					for (let i in positions){
							positions[i].highlight(col, options);
					}
			}

			setXY(x, y){
					this.x = x;
					this.y = y;
					this.id = x + '-' + y + '-' + this.roomName;
			}

			isEqualTo(otherCentre){
					checkIfCentresEqual(this, otherCentre);
			}
	}

	function checkCentre(current, dir){
			let obj = {1: [0, -1], 2: [1, -1], 3: [1, 0], 4: [1, 1], 5: [0, 1], 6: [-1, 1], 7: [-1, 0], 8: [-1, -1]};
			let newCentre = new CentrePosition(current.x + obj[dir][0], current.y + obj[dir][1], current.roomName);
			return newCentre
	}

	function checkIfCentresEqual(a, b){
			if (a.id && b.id && a.id == b.id){
					return true
			}
			return false
	}

	function dist(ax, ay, bx, by){
			return Math.max(Math.abs(ax - bx), Math.abs(ay - by));
	}

	function getReachableExits(startQuadPos,room){
			if (!startQuadPos || !startQuadPos.centre || !startQuadPos.centre.id){
					console.log('bad reachable exits',JSON.stringify(startQuadPos));
					return
			}
			let visited = {};
			visited[startQuadPos.centre.id] = true;
			let toVisitList = [startQuadPos];
			let count = 0;
			let allowedExits = {};
			let matrix = new PathFinder.CostMatrix;
			if (room){
					let ramps = room.findStructures(['rampart','constructedWall']);
					for (let r in ramps){
							let ramp = ramps[r];
							let dir;
							if (ramp.pos.x === 47){
									dir = 3;
							} else if (ramp.pos.y === 47){
									dir =5;
							} else if (ramp.pos.x === 2){
									dir = 7;
							} else if (ramp.pos.y === 2){
									dir = 1;
							}
							if (dir){
									let exit = ramp.pos.movePos(dir).movePos(dir);
									if (exit.getTerrain() !== 'wall'){
											matrix.set(ramp.pos.x,ramp.pos.y,255);
									}
							}
					}
			}
			startQuadPos.highlight('blue');
			while (toVisitList.length > 0 && count < 3000){
					count++;
					let current = toVisitList.shift();
					if (current && current.centre){
							let neighbours = current.neighbours(matrix,visited);
							for (let n in neighbours){
									let neighbour = neighbours[n];
									let centre = neighbour.centre;
									if (centre.x === 0.5 || centre.x === 48.5 || centre.y === 0.5 || centre.y === 48.5){
											neighbour.highlight('green');
											let edge;
											if (centre.x === 0.5){
													edge = 7;
											} else if (centre.x === 48.5){
													edge = 3;
											} else if (centre.y === 0.5){
													edge = 1;
											} else {
													edge = 5;
											}
											if (!allowedExits[edge]){
													for (let p in neighbour.positions){
															let pos = neighbour.positions[p];
															if (pos.onEdge() && pos.oppositeEdge()){
																	allowedExits[edge] = pos.oppositeEdge().toString();
															}
													}
											}
									} else {
											//neighbour.highlight()
											toVisitList.push(neighbour);
									}
							}
					}
			}
			if (Object.keys(allowedExits).length > 0){
					return allowedExits
			} else {
					return false
			}
	}

	const top = 0;
	const parent = i => ((i + 1) >>> 1) - 1;
	const left = i => (i << 1) + 1;
	const right = i => (i + 1) << 1;
	class BinaryTree {
			constructor(comparator = (a, b) => a > b) {
					this._heap = [];
					this._comparator = comparator;
			}
			size() {
					return this._heap.length;
			}
			isEmpty() {
					return this.size() == 0;
			}
			peek() {
					return this._heap[top];
			}
			push(...values) {
					values.forEach(value => {
							this._heap.push(value);
							this._siftUp();
					});
					return this.size();
			}
			pop() {
					const poppedValue = this.peek();
					const bottom = this.size() - 1;
					if (bottom > top) {
							this._swap(top, bottom);
					}
					this._heap.pop();
					this._siftDown();
					return poppedValue;
			}
			popPush(value) {
					const replacedValue = this.peek();
					this._heap[top] = value;
					this._siftDown();
					return replacedValue;
			}
			reScoreElement(value){
					let node = this._heap.indexOf(value);
					if (node && node > -1){
							//bubble element to the top and then sift down
							while (node > top){
									this._swap(node, parent(node));
									node = parent(node);
							}
							this._siftDown();
					}
			}
			_greater(i, j) {
					return this._comparator(this._heap[i], this._heap[j]);
			}
			_swap(i, j) {
					[this._heap[i], this._heap[j]] = [this._heap[j], this._heap[i]];
			}
			_siftUp() {
					let node = this.size() - 1;
					while (node > top && this._greater(node, parent(node))) {
							this._swap(node, parent(node));
							node = parent(node);
					}
			}
			_siftDown() {
					let node = top;
					while (
							(left(node) < this.size() && this._greater(left(node), node)) ||
							(right(node) < this.size() && this._greater(right(node), node))
							) {
							let maxChild = (right(node) < this.size() && this._greater(right(node), left(node))) ? right(node) : left(node);
							this._swap(node, maxChild);
							node = maxChild;
					}
			}
	}

	playerHeap.aStar = {};
	playerHeap.aStar.rampartAvoidPositions = {};
	function findPath(startingQuadPos, targets,cornerNibbling,squad){
			let room;
			let cpuStart = Game.cpu.getUsed();
			let positionsChecked = 0;
			if (startingQuadPos){
					room = startingQuadPos.room;
			}
			if (!startingQuadPos || !targets || !Array.isArray(targets) || !targets[0] || !targets[0].roomName || !room || !room.name){
					console.log('astar invalid params', targets, room);
			}
			let matrix = room.structureMatrix;
			let canDestroyBuildings = false;
			let coreRoom = false;
			console.log('a star in room',room.name);
			if (room && room.controller && room.controller.owner && !room.controller.my && !config$1.whiteList.includes(room.controller.owner.username) &&
			!config$1.allies.includes(room.controller.owner.username)){
					console.log('using hostile structure matrix');
				matrix = room.hostileStructureMatrix;
					canDestroyBuildings = true;
			}
			if (Memory.coreRooms && Memory.coreRooms[room.name] && !room.controller){
					console.log('using hostile structure matrix');
					matrix = room.hostileStructureMatrix;
					canDestroyBuildings = true;
					coreRoom = true;
			}
			let nearRampartPositions;
			let visitedRampartNeighbours = {};
			if (playerHeap.aStar.rampartAvoidPositions && playerHeap.aStar.rampartAvoidPositions[room.name] && playerHeap.aStar.rampartAvoidPositions[room.name].expiry > Game.time){
					nearRampartPositions = playerHeap.aStar.rampartAvoidPositions[room.name].positions;
			} else {
					let ramparts = room.find(FIND_STRUCTURES,{filter:(s)=>s.structureType === STRUCTURE_RAMPART && !s.my});
					let positions = [];
					if (ramparts.length > 0){
							for (let r in ramparts){
									let structures =  ramparts[r].pos.lookAround(LOOK_STRUCTURES,0,
											{filter:(s)=>s.structureType !== 'road' && s.structureType !== 'container'&& s.structureType !== 'rampart'});
									if (structures && structures.length > 0){
											continue
									}
									let neighbours = ramparts[r].pos.neighbours();
									for (let n in neighbours){
											let neighbour = neighbours[n];
											let str = neighbour.toString();
											if (!visitedRampartNeighbours[str] && neighbour.getTerrain() !== 'wall'){
													positions.push(str);
											}
											if (!visitedRampartNeighbours[str]){
													visitedRampartNeighbours[str] = 1;
											} else {
													visitedRampartNeighbours[str]++;
											}
									}
							}
					}
					playerHeap.aStar.rampartAvoidPositions[room.name] = {
							expiry:Game.time + 25,
							positions:positions
					};
					nearRampartPositions = positions;
			}
			let corners = [];
			if (nearRampartPositions){
					for (let i in nearRampartPositions){
							let pos = nearRampartPositions[i].toPos();
							let score = matrix.get(pos.x,pos.y);
							let target = score;
							let possibleAttackerDamage = 50;
							let visitedRamps = visitedRampartNeighbours[nearRampartPositions[i]];
							if (visitedRamps > 1){
									target += visitedRamps*possibleAttackerDamage;
									if (target > 255){
											target = 254;
									}
							} else if (visitedRamps === 1 && cornerNibbling){
									corners.push(pos);
							}
							matrix.set(pos.x,pos.y,target);
					}
			}
			for (let i in corners){
					let corner = corners[i];
					let ramp = corner.lookAround(LOOK_STRUCTURES,1,{filter:(s)=>s.structureType === 'rampart'})[0];
					if (ramp){
							let cost = matrix.get(ramp.pos.x,ramp.pos.y);
							if (cost !== 255 && ramp.pos.getTerrain() !== 'wall'){
									cost -= 10;
									if (cost < 1){
											cost = 1;
									}
									matrix.set(ramp.pos.x,ramp.pos.y,cost);
							}
							let dir = ramp.pos.getDirectionTo(corner);
							let preferredPositions = [];
							if (dir){
									preferredPositions = [corner.movePos(dir),corner.movePos(dir.map8(1)),corner.movePos(dir.map8(1))];
							}
							for (let p in preferredPositions){
									preferredPositions[p].highlight('blue');
									let cost = matrix.get(preferredPositions[p].x,preferredPositions[p].y);
									if (cost !== 255 && preferredPositions[p].getTerrain() !== 'wall'){
											cost -= 10;
											if (cost < 1){
													cost = 1;
											}
											matrix.set(preferredPositions[p].x,preferredPositions[p].y,cost);
									}
							}
					}
			}
			if (!startingQuadPos.room || startingQuadPos.room.name !== targets[0].roomName){
					console.log('astar multi room');
					return false
			}
			room.find(FIND_CREEPS).forEach((c) => {
					if (c.my || c.isWhiteListed){
							if (!squad || !squad.members || !squad.members.includes(c.id)){
									matrix.set(c.pos.x, c.pos.y, 255);
							}
					}
			});
			for (let i in startingQuadPos.positions){
					//ensure we can still path through our own squad
					if (matrix.get(startingQuadPos.positions[i].x, startingQuadPos.positions[i].y)===255){
							matrix.set(startingQuadPos.positions[i].x, startingQuadPos.positions[i].y, 1);
					}
			}
			if ((room.controller && room.controller.owner && !room.controller.my)|| coreRoom){
					let tp = room.getTowerPowerMatrix();
					if (tp){
							matrix = PathFinder.mergeMatrix(matrix, tp);
					}
			}
			for (let i in startingQuadPos.positions){
					matrix.set(startingQuadPos.positions[i].x, startingQuadPos.positions[i].y, 0);
			}
			//[pos,fScore - how far to dest]
			let startC = startingQuadPos.centre.id;
			//startingQuadPos.highlight('green')
			let fScore = {};
			let openSet = new BinaryTree((a,b) => fScore[a.centre.id] < fScore[b.centre.id]);
			openSet.push(startingQuadPos);
			let cameFrom = {};
			//gScore - how far from start
			let gScore = {};
			gScore[startC] = 0;
			let visited = {};
			visited[startC] = true;
			fScore[startC] = closestTargetRange(startingQuadPos.centre, targets);
			while (!openSet.isEmpty()){
					let current = openSet.pop();
					let currentC = current.centre;
					//current.highlight()
					let nearestRange = closestTargetRange(currentC, targets);
					if (nearestRange < 2){
							//current.highlight('gold')
							console.log('a* path found,',Game.cpu.getUsed()-cpuStart,'positions visited:',positionsChecked);
							if (canDestroyBuildings){
									return reconstructPath(cameFrom, startC, currentC,room.hostileStructureMatrix)
							}
							return reconstructPath(cameFrom, startC, currentC)
					}
					for (let i = 1; i < 9; i++){
							let nextQuadPos = current.moveQuadCheckingVisited(i, visited, matrix);
							if (nextQuadPos){
									positionsChecked++;
									let nextCID = nextQuadPos.centre.id;
									let terrain = nextQuadPos.terrain;
									let score = 1;
									if (cameFrom[nextCID] && cameFrom[nextCID].direction == i){
											//prioritise straight lines as turning decreases speed
											score = 0.5;
									}
									if (terrain === 'swamp'){
											score += 5;
									}
									let matrixScore;
									if (matrix){
											matrixScore = nextQuadPos.getPositionScore(matrix);
											if (matrixScore !== undefined && matrixScore !== false){
													score += matrixScore;
											} else {
													continue
											}
									}
									//can move this way so process as normal a*
									let tentativeGScore = gScore[currentC.id] + score;
									if (!gScore[nextCID] || tentativeGScore < gScore[nextCID]){
											let range = closestTargetRange(nextQuadPos.centre, targets);
											//nextQuadPos.highlight('orange',{opacity:0.05+0.01*tentativeGScore})
											cameFrom[nextCID] = {centre: currentC, direction: i};
											fScore[nextCID] = tentativeGScore + (range * 2);
											if (!gScore[nextCID]){
													openSet.push(nextQuadPos);
											} else {
													openSet.reScoreElement(nextQuadPos);
											}
											gScore[nextCID] = tentativeGScore;
									}
							}
					}
			}
			console.log('a* no path',targets);
			return false
	}

	function closestTargetRange(centre, targets){
			let bestRange;
			if (!centre || !targets || targets.length === 0){
					return
			}
			for (let i in targets){
					let target = targets[i];
					if (target && target.pos) target = target.pos;
					if (target && target.x != undefined){
							let range = dist(centre.x, centre.y, target.x, target.y);
							if (range !== undefined && (bestRange === undefined || range < bestRange)){
									bestRange = range;
							}
					}
			}
			if (bestRange !== undefined){
					return bestRange
			}
	}

	function reconstructPath(cameFromAll, start, end,hostileMatrix){
			//looks through quad positions and works out a path
			let path = [];
			let current = end;
			let count = 0;
			let dir = 0;
			let possibleHostileStructures = [];
			while (current.id != start.id && count < 2000){
					count++;
					current.highlight('blue');
					let cameFrom = cameFromAll[current.id];
					if (cameFrom){
							let newdir = cameFrom.direction;
							if (dir != newdir){
									path.splice(0, 0, [current.id, newdir]);
									dir = newdir;
							}
							current = cameFrom.centre;
							if (hostileMatrix){
									//we want to figure out where the next closest hostile structure is
									let positions = current.positions;
									for (let p in positions){
											let pos = positions[p];
											let cost = hostileMatrix.get(pos.x,pos.y);
											if (cost > 1){
													//likely hostile structure here
													possibleHostileStructures.push(pos.toString());
													pos.highlight('red');
											}
									}
							}
					} else {
							break
					}
			}
			let pathObj = {
					path:path,
			};
			if (possibleHostileStructures){
					pathObj.hostileStructurePositions = possibleHostileStructures;
			}
			return pathObj
	}

	//formation proto -> new Formation(members)
	playerHeap.formationManager = {};
	playerHeap.formationManager.allFormations = {};
	playerHeap.formationManager.sharedTargetsAllRooms = {};
	class Formation {
			constructor(members, id, options){
					this.members = [];
					this.roleOrder = {};
					members.sort((a, b) => {
							let aScore = 1, bScore = 1;
							if (a.role === 'medic'){
									aScore = 2;
							}
							if (b.role === 'medic'){
									bScore = 2;
							}
							return aScore - bScore
					});
					if (options && options.extraMembers){
							this.extraMembers = [];
							for (let i in options.extraMembers){
									this.extraMembers.push(options.extraMembers[i].id);
							}
					}
					let isHybridSquad = true;
					for (let i in members){
							if (members[i].role !== 'hybrid'){
									isHybridSquad = false;
							}
							this.members.push(members[i].id);
							if (!this.leader){
									this.leader = members[i].id;
									this.roleOrder['a'] = members[i].id;
							} else if (!this.deputy){
									this.deputy = members[i].id;
									this.roleOrder['b'] = members[i].id;
							} else if (!this.roleOrder['c']){
									this.roleOrder['c'] = members[i].id;
							} else if (!this.roleOrder['d']){
									this.roleOrder['d'] = members[i].id;
							}
					}
					for (let i in members){
							let isSaved = false;
							let arr = ['a', 'b', 'c', 'd'];
							for (let a in arr){
									if (this.roleOrder[arr[a]] && this.roleOrder[arr[a]] == members[i].id){
											isSaved = true;
											break
									}
							}
							if (!isSaved){
									if (!this.leader){
											this.leader = members[i].id;
											this.roleOrder['a'] = members[i].id;
									} else if (!this.deputy){
											this.deputy = members[i].id;
											this.roleOrder['b'] = members[i].id;
									} else if (!this.roleOrder['c']){
											this.roleOrder['c'] = members[i].id;
									} else {
											this.roleOrder['d'] = members[i].id;
									}
							}
					}
					if (isHybridSquad){
							this.hybridSquad = true;
					}
					this.attackDir;
					this.id = id;
					let width = Math.ceil(members.length / 2);
					if (width > 3){
							width = 3;
					}
					this.width = width;
					this.leader = members[0].id;
					options && options.dir ? this.attackDir = options.dir : this.attackDir = 1;
					this.leaderPos = null;
					if (this.leader){
							this.room = this.leader.room;
					}
			}

			get quadPosition(){
					if (this.QP && this.QPtime === Game.time){
							return this.QP
					}
					let positions = [];
					for (let i in this.members){
							let member;
							if (this.members[i]){
									member = Game.getObjectById(this.members[i]);
							}
							if (member){
									positions.push(member.pos);
							}
					}
					let QP = new QuadPosition(positions);
					if (QP && QP.positions){
							this.QP = QP;
							this.QPtime = Game.time;
							return QP
					}
					return false
			}
			checkForHostileDir(){
					let minX,minY,maxX,maxY,roomName;
					if (!this.isAQuad()){
							return undefined
					}
					for (let i in this.members){
							let member = Game.getObjectById(this.members[i]);
							if (!roomName && member){
									roomName = member.room.name;
							}
							if (!minX || minX > member.pos.x){
									minX = member.pos.x;
							}
							if (!minY || minY > member.pos.y){
									minY = member.pos.y;
							}
							if (!maxX || maxX < member.pos.x){
									maxX = member.pos.x;
							}
							if (!maxY || maxY < member.pos.y){
									maxY = member.pos.y;
							}
					}
					if (minX > 0){minX--;}
					if (minY > 0){minY--;}
					if (maxX < 49){maxX++;}
					if (maxY < 49){maxY++;}
					//loop through each position next to a quad
					let sideScore = {
							1:0,
							3:0,
							5:0,
							7:0
					};
					for (let i = minX; i <= maxX; i++){
							let check1 = new RoomPosition(i,minY,roomName);
							let check5 = new RoomPosition(i,maxY,roomName);
							checkSide(check1,1);
							checkSide(check5,5);
					}
					for (let i = minY; i <= maxY; i++){
							let check7 = new RoomPosition(minX,i,roomName);
							let check3 = new RoomPosition(maxX,i,roomName);
							checkSide(check7,7);
							checkSide(check3,3);
					}
					let bestSide,bestScore;
					for (let i in sideScore){
							if (sideScore[i]>0 && (!bestSide || bestScore<sideScore[i])){
									bestSide = i;
									bestScore = sideScore[i];
							}
					}
					if (bestSide){
							return bestSide
					}
					function checkSide(position,side){
							if (position && !position.onEdge() && side){
									let hostile = position.lookAround(LOOK_CREEPS,0,{filter:(h)=>!h.my && !h.isWhiteListed && (h.stats().attack > 0 || h.stats().ranged_attack > 0)})[0];
									let structure = position.lookAround(LOOK_STRUCTURES,0,{filter:(s)=>!s.my && !s.isWhiteListed})[0];
									if (hostile){
											sideScore[side]+=3;
									}
									if (structure){
											sideScore[side]++;
									}
							}
					}
			}
			qMove(pos,options,squad){
					//move the lead and plan optimum positions for rest of squad -> only move if all members can move
					//dir is one of the dir constants
					//todo implement pos as an array
					if (Array.isArray(pos)){
							for (let i in pos){
									if (pos[i] && pos[i].pos){
											pos[i] = pos[i].pos;
									}
							}
					} else if (pos.pos){
							pos = pos.pos;
					}
					let rangedSquad,noTurn,hostileRoom,fixTurn,freeze,avoidRamps;
					if (options && options.rangedSquad){
							rangedSquad = true;
					}
					if (options && options.avoidRamps){
							avoidRamps = true;
					}
					if (options && options.freeze){
							freeze = true;
					}
					if ((options && options.noTurn) || this.hybridSquad){
							noTurn = true;
					}
					if (options && options.fixTurn){
							fixTurn = options.fixTurn;
					}
					if (!fixTurn && !this.hybridSquad){
							let hosSide = this.checkForHostileDir();
							if (hosSide){
									fixTurn = hosSide;
									console.log('hostile side:',fixTurn);
							}
					}
					let path = this.path;
					let leader = Game.getObjectById(this.leader);
					let members = [];
					let medics = 0;
					for (let i in this.members){
							let member = Game.getObjectById(this.members[i]);
							if (member){
									members.push(member);
									if (member.role === 'medic'){
											medics++;
									}
							} else {
									return false
							}
					}
					if (!leader){
							leader = members[0];
					}
					if (this.noPath && this.noPath > Game.time){
							leader.say('no path');
							return -2
					}
					let isAssembled;
					if (fixTurn){
							isAssembled = this.assemble(leader.pos, fixTurn);
					} else if (noTurn && this.attackDir){
							isAssembled = this.assemble(leader.pos, this.attackDir);
					} else if (path && path[0] && path[0][1]){
							isAssembled = this.assemble(leader.pos, path[0][1]);
					} else {
							isAssembled = this.assemble(leader.pos);
					}
					if (isAssembled === -2){
							return -2
					} else if (isAssembled === false){
							//leader.say('assemble')
							return
					} else {
							console.log('assembled',isAssembled);
					}
					if (leader && leader.room && ((leader.room.controller && leader.room.controller.owner && !leader.room.controller.my) || (Memory.coreRooms && Memory.coreRooms[leader.room.name]))){
						hostileRoom = true;
					}
					let hostileTarget;
					if ((!path || !this.pathDest || this.pathDest != pos.toString()) && leader && leader.pos && pos && leader.pos.roomName == pos.roomName && !leader.pos.onEdge()){
							console.log('qMove saving path', isAssembled);
							let quadPos = this.quadPosition;
							if (!quadPos && isAssembled && isAssembled['a']){
									quadPos = new QuadPosition(isAssembled['a'],isAssembled['c']);
							}
							if (quadPos){
									let cornerNibbling = false;
									if (medics > 2){
											cornerNibbling = true;
									}
									Game.cpu.getUsed();
									let pathObj = savePath$1(quadPos, pos,cornerNibbling,squad);
									if (pathObj && pathObj.path){
											path = pathObj.path;
									}
									if (path){
											this.path = path;
											this.pathDest = pos.toString();
											this.destination = pos;
											if (pathObj && pathObj.hostileStructurePositions){
													this.hostileStructurePositions = pathObj.hostileStructurePositions;
											}
									} else {
											this.noPath = Game.time + 5;
											return -2
									}
							} else {
									return -3
							}
					}
					let extraMembers = [];
					if (this.extraMembers){
							for (let i in this.extraMembers){
									extraMembers.push(Game.getObjectById(this.extraMembers[i]));
							}
					}
					if (extraMembers && isAssembled){
							for (let i in extraMembers){
									let rangeToQuad;
									if (this.quadPosition){
											rangeToQuad = this.quadPosition.getQuadRangeTo(extraMembers[i].pos);
									}
									if (rangeToQuad > 4 && Game.time%2===0){
											extraMembers[i].say(`q${rangeToQuad}`);
											isAssembled = false;
									}
							}
					}
					let moveDir,moved;
					if (isAssembled){
							if (!this.destination || this.destination.x === undefined || !this.destination.isNearTo(pos)){
									this.destination = pos;
									this.path = undefined;
									this.pathDest = undefined;
							}
							//fatigue check -> prevent seperation
							let fatigue = false;
							let roomName;
							for (let i in members){
									let member = members[i];
									roomName = member.room.name;
									if (member.fatigue && member.fatigue > 0){
											fatigue = true;
									}
									if (member.pos.isNearTo(pos)){
											path = [];
											//so we don't path around a target and just turn if squad next to it
									}
							}
							let assignedSharedTarget = false;
							let sharedTargets;
							if (roomName && playerHeap.formationManager.sharedTargetsAllRooms[roomName]){
									sharedTargets = playerHeap.formationManager.sharedTargetsAllRooms[roomName];
							} else {
									playerHeap.formationManager.sharedTargetsAllRooms[roomName] = [];
									sharedTargets = playerHeap.formationManager.sharedTargetsAllRooms[roomName];
							}
							if (sharedTargets && sharedTargets.length > 0){
									//encourages squads to share targets if possible
									for (let i in sharedTargets){
											let target = Game.getObjectById(sharedTargets[i]);
											if (target && (target.pos.isNearTo(leader) || (this.quadPosition && this.quadPosition.getQuadRangeTo(target.pos) < 4) || (rangedSquad && target.pos.inRangeTo(leader,2)))){
													hostileTarget = target;
													assignedSharedTarget = true;
													break;
											}
									}
							}
							if (!assignedSharedTarget && this.hostileStructurePositions){
									for (let h = this.hostileStructurePositions.length-1;h> -1;h--){
											let pos = this.hostileStructurePositions[h].toPos();
											if (pos){
													pos.highlight('purple');
													console.log(pos);
													let struct = pos.lookAround(LOOK_STRUCTURES,0,{filter:(s)=>!s.my && s.structureType !== 'road' && s.structureType !== STRUCTURE_CONTAINER
													&& (s.owner || s.structureType === 'constructedWall')})[0];
													if (struct){
															let tempHostileTarget = struct;
															let hostileTargetRange;
															if (rangedSquad){
																	if (this.quadPosition){
																			hostileTargetRange = this.quadPosition.getQuadRangeTo(tempHostileTarget.pos);
																	} else {
																			hostileTargetRange = leader.pos.getRangeTo(tempHostileTarget.pos);
																	}
															}
															if (rangedSquad && hostileTargetRange < 4 || (leader && leader.pos.isNearTo(pos))){
																	hostileTarget = tempHostileTarget;
															}
															if ((leader && leader.pos.isNearTo(tempHostileTarget)) || (rangedSquad && avoidRamps && hostileTargetRange < 2)|| (rangedSquad && avoidRamps && freeze && hostileTargetRange < 3)){
																	path = [];
																	if (freeze){
																			leader.say('fr');
																	}
																	break
															}
													}
											}
									}
							}
							if (sharedTargets && !assignedSharedTarget && hostileTarget){
									sharedTargets.push(hostileTarget.id);
							}
							console.log('hostile target',hostileTarget);
							if (!rangedSquad && hostileTarget){
									let dir = leader.pos.getDirectionTo(hostileTarget);
									if (dir % 2 !== 0){
											if (this.attackDir != dir){
													this.turn(dir);
													moveDir = dir;
													this.attackDir = dir;
											}
									} else if (this.deputy && Game.getObjectById(this.deputy) && !Game.getObjectById(this.deputy).pos.isNearTo(hostileTarget)){
											let tryMove = checkAndMove(members, map8$2(dir, 1));
											if (!tryMove){
													checkAndMove(members, map8$2(dir, -1));
											}
									}
							} else if (path && path.length > 0 && !fatigue){
									let targetCentreId = path[0][0];
									let dir = path[0][1];
									moveDir = dir;
									//fix the axis that does not need to change
									let quadPos = this.quadPosition;
									if (quadPos && quadPos.centre && quadPos.centre.id){
											if (quadPos.centre.id != targetCentreId){
													checkAndMove(members, dir);
											} else {
													path.splice(path, 1);
											}
									}
							} else if (path && path.length === 0 && !fatigue && !fixTurn && rangedSquad && leader.pos.inRangeTo(pos,3)){
									let dir = leader.pos.getDirectionTo(pos);
									if (dir % 2 !== 0){
											dir.map8(1);
									}
									moveDir = dir;
									if (dir){
											if (this.attackDir != dir){
													this.turn(dir);
													this.attackDir = dir;
											}
									}
							} else if (path && path.length === 0 && !fatigue && leader.pos.isNearTo(pos)){
									let dir = leader.pos.getDirectionTo(pos);
									moveDir = dir;
									if (dir % 2 !== 0){
											if (this.attackDir != dir){
													this.turn(dir);
													this.attackDir = dir;
											}
									} else if (this.deputy && Game.getObjectById(this.deputy) && !Game.getObjectById(this.deputy).pos.isNearTo(pos)){
											let tryMove = checkAndMove(members, map8$2(dir, 1));
											if (!tryMove){
													checkAndMove(members, map8$2(dir, -1));
											}
									}
							} else if (path && path.length === 0 && !fixTurn && !fatigue && !leader.pos.isNearTo(pos)){
									//if squad is near but leader isn't turn to be near it
									let dir = leader.pos.getDirectionTo(pos);
									moveDir = dir;
									if (dir % 2 !== 0){
											if (this.attackDir != dir){
													this.turn(dir);
													this.attackDir = dir;
											}
									} else {
											dir = map8$2(dir, 1);
											this.turn(dir);
											this.attackDir = dir;
									}
							}
							if (!moveDir){
									moveDir = this.attackDir;
							}

							function checkAndMove(members, dir){
									let check = true;
									for (let i in members){
											let newPos = members[i].pos.movePos(dir);
											if (!newPos.isWalkable()){
													members[i].say('nw'+dir);
													newPos.highlight('red');
													check = false;
													let struct = newPos.lookAround(LOOK_STRUCTURES,0,{filter:(s)=>!s.my && s.owner})[0];
													if (struct){
															hostileTarget = struct;
													}
													break
											}
											if (rangedSquad && hostileRoom && avoidRamps){
													let possibleRamps = newPos.lookAround(LOOK_STRUCTURES,1,{filter:(s)=>s.structureType === STRUCTURE_RAMPART && !s.my});
													if (possibleRamps){
															let ramp;
															for (let r in possibleRamps){
																	let possibleRamp = possibleRamps[r];
																	//only one structure at position (excluding containers and roads) means rampart is walkable
																	let otherStructures = possibleRamp.pos.lookAround(LOOK_STRUCTURES,0,{filter:(s)=>s.structureType !== STRUCTURE_RAMPART
																	&& !s.my && s.structureType !== 'road' && s.structureType !== 'container'});
																	if (!otherStructures || otherStructures.length === 0){
																			ramp = possibleRamp;
																			//members[i].say('ramp blocked')
																			break;
																	}
															}
															if (ramp){
																	check = false;
																	if (!hostileTarget){
																			hostileTarget = ramp;
																	}
																	break
															}
													}
											}
											let hos = newPos.lookAround(LOOK_CREEPS, 0, {filter: (c) => !c.my})[0];
											if (hos){
													members[i].say('hos in way');
													check = false;
													if (Game.time % 5 === 0){
															delete this.path;
													}
													break
											}
									}
									if (check && !freeze){
											for (let i in members){
													members[i].move(dir);
											}
											moved = true;
											return true
									} else if (freeze){
											for (let i in members){
													members[i].say('fr');
											}
									}
									return false
							}
					}
					if (extraMembers && isAssembled && moveDir){
							let arr = ['a','b','c','d'];
							for (let i in extraMembers){
									if (!arr[i]){
											arr[i] = 'd';
									}
									if (!extraMembers[i] || !extraMembers[i].pos){
											continue
									}
									let newPos = isAssembled[arr[i]].movePos(moveDir.map8(4));
									if (!moved){
											newPos = newPos.movePos(moveDir.map8(4));
									}
									newPos.highlight('orange');
									if (extraMembers[i].isMoving){
											continue
									}
									if (extraMembers[i].pos.inRangeTo(newPos,2)){
											extraMembers[i].move(extraMembers[i].pos.getDirectionTo(newPos));
									} else {
											extraMembers[i].moveTo(newPos,{range:1});
									}
							}
					} else if (extraMembers){
							for (let i in extraMembers){
									extraMembers[i].moveTo(members[1],{range:2});
							}
					}
					this.leaderPos = leader.pos.toString();
					if (hostileTarget){
							new RoomVisual(leader.pos.roomName).circle(leader.pos, {fill: 'red', radius: 0.7});
							return hostileTarget
					}
					new RoomVisual(leader.pos.roomName).circle(leader.pos, {fill: '#6d0a0a', radius: 0.7});
					return 0
			};
			setHybridDir(dir,members){
					if (!dir){
							return
					}
					let leaderDirections = [dir.map8(4),dir.map8(3),dir.map8(2)];
					for (let i in members){
							let isLeader = true;
							for (let j in members){
									if (j !== i){
											if (!leaderDirections.includes(members[i].getDirectionTo(members[j]))){
													isLeader = false;
													break
											}
									}
							}
							if (isLeader){
									//this creep should be the leader
									members[i].highlight('blue');
							}
					}
			};
			turn(dir){
					let letters = ['a', 'b', 'c', 'd'];
					let members = {};
					for (let i in letters){
							members[letters[i]] = Game.getObjectById(this.roleOrder[letters[i]]);
					}
					let currentDir = this.attackDir;
					if (members['a'] && members['d']){
							currentDir = members['d'].pos.getDirectionTo(members['a']);
					}
					//console.log(members['a'],members['d'])
					if (dir == currentDir){
							//console.log('turning in current dir', dir)
							this.attackDir = currentDir;
							return
					}


					if (Math.abs(dir - currentDir) == 2 || Math.abs(dir - currentDir) == 6){
							if (map8$2(dir, -2) == currentDir){
									moveMembers([members['a'], members['b'], members['c'], members['d']]);
							} else {
									moveMembers([members['d'], members['c'], members['b'], members['a']]);
							}
							//spin
					} else if (Math.abs(dir - currentDir) == 4){
							//flip - move corners toward each other
							swap(members['a'], members['c']);
							swap(members['b'], members['d']);
					}

					function moveMembers(arr){
							for (let i = 0; i < arr.length; i++){

									let member1 = arr[i];
									let member2 = arr[i + 1];
									if (!member2){
											member2 = arr[0];
									}
									//console.log(member1, member2)
									member1.move(member1.pos.getDirectionTo(member2));
							}
					}

					function swap(member1, member2){
							member1.move(member1.pos.getDirectionTo(member2));
							member2.move(member2.pos.getDirectionTo(member1));
					}

					this.attackDir = dir;
			}

			assemble(pos, dir){
					let attackDir = this.attackDir;
					if (dir){
							if (dir % 2 === 0){
									dir++;
									if (dir === 9){
											dir = 1;
									}
							}
							attackDir = dir;
					}
					if (this.width == 2){
							let assembled = this.assembleQuad(pos, attackDir);
							return assembled
					}
			};
			isAQuad(){
					let members = {};
					if (!this.roleOrder){
							return false;
					}
					for (let i in this.roleOrder){
							members[i] = Game.getObjectById(this.roleOrder[i]);
					}
					if (members['a'] && members['b'] && members['c'] && members['d']){
							let adjDir = members['d'].pos.getDirectionTo(members['a']);
							let bPos = members['a'].pos.movePos(map8$2(adjDir, 2));
							let cPos = members['a'].pos.movePos(map8$2(adjDir, 3));
							let dPos = members['a'].pos.movePos(map8$2(adjDir, 4));
							if (members['b'].pos.isEqualTo(bPos) && members['c'].pos.isEqualTo(cPos) && members['d'].pos.isEqualTo(dPos) && (adjDir % 2 != 0)){
									return true
							}
					}
					return false
			}
			assembleQuad(pos, dir){
					let members = {};
					let arr = ['a', 'b', 'c', 'd'];
					let positions = {
							'a': pos,
							'b': pos.movePos(map8$2(dir, 2)),
							'c': pos.movePos(map8$2(dir, 3)),
							'd': pos.movePos(map8$2(dir, 4))
					};
					for (let i in arr){
							if (this.roleOrder[arr[i]]){
									members[arr[i]] = Game.getObjectById(this.roleOrder[arr[i]]);
							}
					}
					if (members['a'] && members['b'] && members['c'] && members['d']){
							let adjDir = members['d'].pos.getDirectionTo(members['a']);
							let checkQuad = this.isAQuad();
							if (checkQuad){
									if (adjDir == dir){
											return positions
									}
									//squad is assembled, just needs turning
									if (this.hybridSquad){
											this.turn(dir);
											//all the creeps are the same, don't waste time and cpu turning, just change the leader ect
											//this.setHybridDir(dir,members)
									} else {
											this.turn(dir);
									}
									return false
							}
					}
					delete this.path;
					if (dir){
							this.attackDir = dir;
					}
					let foundAssemblePos = findAssemblePos(members,positions);
					if (!foundAssemblePos){
							return -2
					} else {
							positions = foundAssemblePos;
					}
					let dir2centre,dir4centre;
					let orderedPositions = {
							//order creeps based on position in quad
							// 1  2
							// 4  3
					};
					for (let i in members){
							let thisMember = members[i];
							for (let j in members){
									if (j === i){
											continue
									}
									let thatMember = members[j];
									let dir = thisMember.pos.getDirectionTo(thatMember);
									if (dir && dir === 2){
											if (thisMember.pos.isNearTo(thatMember)){
													dir2centre = `${((thisMember.pos.x+thatMember.pos.x)/2)},${((thisMember.pos.y+thatMember.pos.y)/2)}`;
											}
											orderedPositions[2] = thatMember.pos;
											orderedPositions[4] = thisMember.pos;
											break
									} else if (dir && dir === 4){
											if (thisMember.pos.isNearTo(thatMember)){
													dir4centre = `${((thisMember.pos.x+thatMember.pos.x)/2)},${((thisMember.pos.y+thatMember.pos.y)/2)}`;
											}
											orderedPositions[1] = thisMember.pos;
											orderedPositions[3] = thatMember.pos;
											break
									}
							}
					}
					if (dir2centre && dir4centre && dir4centre === dir2centre){
							console.log(pos,'quad shuffle',Game.time,dir2centre,dir4centre);
							//squad is in quad formation - just need some shuffling
							switch (dir){
									case 1:
											pos = orderedPositions[1];
											break;
									case 3:
											pos = orderedPositions[2];
											break;
									case 5:
											pos = orderedPositions[3];
											break;
									case 7:
											pos = orderedPositions[4];
							}
							positions = {
									'a': pos,
									'b': pos.movePos(map8$2(dir, 2)),
									'c': pos.movePos(map8$2(dir, 3)),
									'd': pos.movePos(map8$2(dir, 4))
							};
					}
					for (let i in members){
							if (members[i]){
									getInPosition(members[i], positions[i],positions);
							}
					}

					function findAssemblePos(members,positions){
							//check starting positions and if okay just return
							let originalPosOkay = true;
							for (let p in positions){
									if (positions[p] && (!positions[p] || !positions[p].isWalkable() || positions[p].onEdge() || creepBlock(positions[p]))){
											originalPosOkay = false;
									}
							}
							if (originalPosOkay){
									return positions
							}
							for (let i = 1; i < 9; i++){
									let newPos = pos.movePos(i);
									let newPosOkay = true;
									positions = {
											'a': newPos,
											'b': newPos.movePos(map8$2(dir, 2)),
											'c': newPos.movePos(map8$2(dir, 3)),
											'd': newPos.movePos(map8$2(dir, 4))
									};
									for (let p in positions){
											if (positions[p] && (!positions[p].isWalkable() || positions[p].onEdge() || creepBlock(positions[p]))){
													newPosOkay = false;
													break
											}
									}
									if (newPosOkay){
											newPos.highlight('green');
											return positions
									}
							}
							function creepBlock(pos){
									let creeps = pos.creepAtPosition;
									if (creeps && creeps.length > 0){
											let creep = creeps[0];
											for (let m in members){
													let member = members[m];
													if (member.id === creep.id){
															return false
													}
											}
											if (creep.my){
													return true
											}
									}
							}
					}

					function getInPosition(creep, temppos,allPositions){
							if (!temppos || !creep){
									console.log('no temppos get in pos formation manager', creep);
									return false
							}
							if (!temppos.isWalkable() && !temppos.onEdge()){
									pos.movePos(temppos.getDirectionTo(pos));
							}
							if (temppos && !creep.pos.isEqualTo(temppos)){
									temppos.highlight('brown');
									if (creep.pos.getRangeTo(temppos) > 2){
											if (creep.room.name === temppos.roomName){
													creep._moveTo(temppos, {range: 2, maxRooms: 1});
											} else {
													creep.moveTo(temppos,{range:2});
											}
									} else if (creep.pos.getRangeTo(temppos)===2){
											//to prevent the quad blocking its own members we allow forming 'through' the quad
											//this also increases grouping and prevents members being far from healing
											let nearToQuad = undefined;
											let nearPositionKey;
											for (let i in allPositions){
													if (creep.pos.isNearTo(allPositions[i])){
															if (allPositions[i].isWalkable(true)){
																	nearToQuad = allPositions[i];
																	nearPositionKey = i;
																	break
															} else if (!nearToQuad || (nearPositionKey && nearPositionKey === 'a')){
																	nearToQuad = allPositions[i];
																	nearPositionKey = i;
															}
													}
											}
											if (!nearToQuad){
													creep._moveTo(temppos,{range:1,maxRooms:1});
											} else {
													let tryMoveToFreePos = moveToFreePosition(creep,positions);
													if (!tryMoveToFreePos){
															creep.move(creep.pos.getDirectionTo(nearToQuad));
															let otherCreep = nearToQuad.lookAround(LOOK_CREEPS,0,{filter:(c)=>c.my})[0];
															if (otherCreep){
																	moveToFreePosition(otherCreep,positions,true);
															}
													}
											}
									} else {
											creep.move(creep.pos.getDirectionTo(temppos));
									}
							} else if (temppos){
									temppos.highlight('green');
							}
							if (creep.fatigue > 0);
					}
					function moveToFreePosition(creep,allPositions,force){
							//returns true if can move to a free pos or already in a free pos
							if (!force){
									for (let i in allPositions){
											if (creep.pos.isEqualTo(allPositions[i])){
													return true
											}
									}
							}
							for (let i in allPositions){
									if (creep.pos.isNearTo(allPositions[i]) && allPositions[i].isWalkable(true)){
											creep.move(creep.pos.getDirectionTo(allPositions[i]));
											return true
									}
							}
					}

					return positions
			}
	}

	function getFormation(squad, members,extraMembers){
			let f;
			if (!squad.id || !playerHeap.formationManager.allFormations[squad.id]){
					let guid;
					if (squad.id){
							guid = squad.id;
					} else {
							let guid = Game.generateId();
							squad.id = guid;
					}
					f = new Formation(members, guid,{extraMembers:extraMembers});
					playerHeap.formationManager.allFormations[guid] = f;
			} else {
					f = playerHeap.formationManager.allFormations[squad.id];
			}
			return f
	}

	function savePath$1(quadStart, dest,cornerNibbling,squad){
			//find path if loadPath return null and creep is near container (as this means the path will no be on the unwalkable mining spot)
			if (dest.pos){
					dest = dest.pos;
			}
			let pathObj;
			let room = Game.rooms[dest.roomName];
			if (dest[0] && dest[0].roomName){
					room == dest[0].roomName;
			}
			if (!room){
					console.log('astar error no room');
					return false
			}
			let arr = [];
			if (dest[0] && Array.isArray(dest)){
					arr = dest;
			} else {
					arr = [dest];
			}
			try {
					let cpu = Game.cpu.getUsed();
					//TODO actually use the quad position of the quad if

					pathObj = findPath(quadStart, arr,cornerNibbling,squad);
					//console.log('astar cpu',Game.cpu.getUsed()-cpu)
			} catch (err){
					console.log('astar' + err.stack.split("at"));
			}

			if (pathObj && pathObj.path){
					console.log('astar path', pathObj.path, quadStart.centre.id, dest[0]);
					return pathObj
			}
	}

	function map8$2(val, jump){
			let count = jump;
			let ret = Number.parseInt(val);
			while (count != 0){
					if (count < 0){
							ret = ret - 1;
							count = count + 1;
					} else {
							ret = ret + 1;
							count = count - 1;
					}
					if (ret === 9){
							ret = 1;
					}
					if (ret === 0){
							ret = 8;
					}
			}
			return ret
	}

	let squadDict = {
			'Bow':{
					//unique squad for destroying ramparts/walls at rooms edges
					structures: true,
					sFilter: [{filter: (s) => s.structureType == STRUCTURE_TOWER}, {filter: (s) => s.structureType == STRUCTURE_SPAWN}, {filter: (s) => s.structureType != STRUCTURE_KEEPER_LAIR && s.structureType != STRUCTURE_CONTROLLER && s.structureType != STRUCTURE_RAMPART}],
					hostiles: true,
					cons: true,
					hFilter: {filter: (c) => !c.isWhiteListed},
					cFilter: {filter: (s) => (s.structureType == STRUCTURE_SPAWN || s.structureType == STRUCTURE_TOWER)&& !s.isWhiteListed && s.progress > s.progressTotal * 0.25}
			},
			'C': {//core
					structures: true,
					sFilter: [{filter: (s) => !s.isWhiteListed && (s.structureType === STRUCTURE_INVADER_CORE || s.structureType === STRUCTURE_TOWER)},{filter: (s) => !s.isWhiteListed && (s.structureType != STRUCTURE_KEEPER_LAIR && s.structureType != STRUCTURE_CONTROLLER && s.structureType != STRUCTURE_RAMPART)}],
					hostiles: true,
					hFilter: {filter: (c) => c.owner.username == 'Invader' || c.owner.username === 'Source Keeper'}
			},
			'Ca': {//capture
					structures: true,
					sFilter: [{filter: (s) => s.structureType === STRUCTURE_TOWER || s.structureType === STRUCTURE_SPAWN},{filter: (s) => s.structureType != STRUCTURE_KEEPER_LAIR
									&& s.structureType != STRUCTURE_CONTROLLER && s.structureType != STRUCTURE_RAMPART}],
					hostiles: true,
					hFilter: {filter: (c) => c.owner.username != 'Source Keeper' && !c.isWhiteListed},
					cons: true,
					cFilter: {filter: (s) => (s.structureType == STRUCTURE_SPAWN || s.structureType == STRUCTURE_TOWER || s.structureType === STRUCTURE_TERMINAL || s.structureType === STRUCTURE_STORAGE) && !s.isWhiteListed && s.progress > s.progressTotal * 0.25}
			},
			'Cl': {
					//claim attack controller
					structures: true,
					sFilter: [{filter: (s) => s.structureType === STRUCTURE_TOWER || s.structureType === STRUCTURE_SPAWN},{filter: (s) => s.structureType != STRUCTURE_KEEPER_LAIR
									&& s.structureType != STRUCTURE_CONTROLLER && s.structureType != STRUCTURE_RAMPART}],
					energyThreshold:0.7
			},
			'Co': {
					//controller
					structures: true,
					sFilter: [{filter: (s) => s.structureType == STRUCTURE_RAMPART && s.room.controller && s.pos.isNearTo(s.room.controller)}],
					energyThreshold:0.7
			},
			'D': {//defend -> for holding a room, will not idle
					structures: true,
					sFilter: [{filter: (s) => !s.isWhiteListed && (s.structureType === "invaderCore" || s.structureType === 'tower' || s.structureType === 'spawn'
							|| s.structureType === 'extension' || s.structureType === 'storage')}],
					hostiles: true,
					hFilter: {filter: (c) => !c.isWhiteListed && c.owner.username !== 'Source Keeper'},
					cons: true,
					cFilter: {filter: (s) => (s.structureType == STRUCTURE_SPAWN || s.structureType == STRUCTURE_TOWER) && !s.isWhiteListed && s.progress > s.progressTotal * 0.25}
			},
			'chase': {//defend -> for holding a room, will not idle
					structures: true,
					sFilter: [{filter: (s) => !s.isWhiteListed && (s.structureType === "invaderCore" || s.structureType === 'tower' || s.structureType === 'spawn'
									|| s.structureType === 'extension' || s.structureType === 'storage')}],
					hostiles: true,
					hFilter: {filter: (c) => !c.isWhiteListed && (c.owner.username !== 'Source Keeper' ||
									!Game.flags['defendPoint'+c.room.name] || !Game.flags['defendPoint'+c.room.name].pos || Game.flags['defendPoint'+c.room.name].pos.getRangeTo(c) < 10)},
					cons: true,
					cFilter: {filter: (s) => (s.structureType == STRUCTURE_SPAWN || s.structureType == STRUCTURE_TOWER) && !s.isWhiteListed && s.progress > s.progressTotal * 0.25}
			},
			'DC': {//defend core room -> for holding a room, will not idle
					structures: true,
					sFilter: [{filter: (s) => s.structureType == STRUCTURE_RAMPART && s.pos.lookAround(LOOK_STRUCTURES, 0, {filter: (s1) => s1.structureType == 'container'})[0]}],
					hostiles: true,
					hFilter: {filter: (c) => !c.isWhiteListed},
					energyThreshold:0.7,
			},
			'EdgeDrain':{
					structures: true,
					sFilter: [{filter: (s) => s.structureType == STRUCTURE_TOWER}, {filter: (s) => s.structureType == STRUCTURE_SPAWN}, {filter: (s) => s.structureType != STRUCTURE_KEEPER_LAIR && s.structureType != STRUCTURE_CONTROLLER && s.structureType != STRUCTURE_STORAGE && s.structureType != STRUCTURE_TERMINAL && s.structureType != STRUCTURE_RAMPART}],
					hostiles: true,
					cons: true,
					hFilter: {filter: (c) => !c.isWhiteListed},
					cFilter: {filter: (s) => (s.structureType == STRUCTURE_SPAWN || s.structureType == STRUCTURE_TOWER) && !s.isWhiteListed && s.progress > s.progressTotal * 0.25}
			},

			'G': {//guard for defending remotes and home base
					structures: false,
					sFilter: [],
					hostiles: true,
					hFilter: {filter: (c) => c.owner.username != 'Source Keeper' && !c.isWhiteListed}
			},
			'E' : {
					//escort - only used to escort a creep to a room
					hostiles: true,
					hFilter: {filter: (c) => c.owner.username != 'Source Keeper' && !c.isWhiteListed}
			},
			'H':{//harass
					structures:true,
					sFilter:[{filter:(s)=> s.structureType === STRUCTURE_ROAD || s.structureType === STRUCTURE_CONTAINER}],
					hostiles:true,
					hFilter: {filter: (c) => c.owner.username != 'Source Keeper' && !c.isWhiteListed && (c.stats().attack ||c.stats().ranged_attack || c.stats().heal)},
					energyThreshold:0.95
			},
			'L': {//loot
					structures: true,
					sFilter: [{filter: (s) => s.structureType == STRUCTURE_TOWER}, {filter: (s) => s.structureType == STRUCTURE_SPAWN}, {filter: (s) => s.structureType != STRUCTURE_KEEPER_LAIR && s.structureType != STRUCTURE_CONTROLLER && s.structureType != STRUCTURE_STORAGE && s.structureType != STRUCTURE_TERMINAL && s.structureType != STRUCTURE_RAMPART}],
					hostiles: false,
					cons: true,
					hFilter: {filter: (c) => !c.isWhiteListed},
					cFilter: {filter: (s) => (s.structureType == STRUCTURE_SPAWN || s.structureType == STRUCTURE_TOWER)&& !s.isWhiteListed && s.progress > s.progressTotal * 0.25}
			},
			'P': {//power
					structures: false,
					sFilter: [],
					hostiles: true,
					hFilter: {filter: (c) => c.owner.username != 'Screeps' && c.body !== ['move'] && !c.isWhiteListed && (c.owner.username.isEnemy || c.stats().attack || c.stats().ranged_attack || c.stats().heal)}
			},
			'R': {//raze
					structures: true,
					sFilter: [{filter: (s) => s.structureType == STRUCTURE_TOWER}, {filter: (s) => s.structureType == STRUCTURE_SPAWN},{filter: (s) => s.structureType == STRUCTURE_TERMINAL}, {filter: (s) => s.structureType == STRUCTURE_STORAGE}, {filter: (s) => s.structureType == STRUCTURE_LAB}, {filter: (s) => s.structureType != STRUCTURE_KEEPER_LAIR && s.structureType != STRUCTURE_CONTROLLER && s.structureType != STRUCTURE_RAMPART}],
					hostiles: true,
					cons: true,
					hFilter: {filter: (c) => !c.isWhiteListed},
					cFilter: {filter: (s) => (s.structureType == STRUCTURE_SPAWN || s.structureType == STRUCTURE_TOWER)&& !s.isWhiteListed && s.progress > s.progressTotal * 0.25}
			},
			'W': {//wall remover
					structures: true,
					sFilter: [{filter: (s) => s.room.controller && !s.room.controller.owner && s.structureType == STRUCTURE_RAMPART && ((s.room.storage && s.pos.isEqualTo(s.room.storage)) || (s.room.terminal&& s.pos.isEqualTo(s.room.terminal)))}
							,{filter: (s) => s.structureType == STRUCTURE_TOWER}, {filter: (s) => s.structureType == STRUCTURE_SPAWN}, {filter: (s) => s.structureType != STRUCTURE_KEEPER_LAIR && s.structureType != STRUCTURE_CONTROLLER && s.structureType != STRUCTURE_TERMINAL && s.structureType != STRUCTURE_STORAGE && s.structureType != STRUCTURE_FACTORY}],
					hostiles: false,
					cons: true,
					energyThreshold:0.95,
					hFilter: {filter: (c) => !c.isWhiteListed},
					cFilter: {filter: (s) => (s.structureType == STRUCTURE_SPAWN || s.structureType == STRUCTURE_TOWER) && s.progress > s.progressTotal * 0.25}
			},

			'SKM': {//for sitting on the sk mineral lair
					structures: false,
					sFilter: [],
					hostiles: true,
					hFilter: {filter: (c) => !c.isWhiteListed && c.owner.username != 'Source Keeper'}
			},
			'SKE': {//for sitting on the sk mineral lair
					structures: false,
					sFilter: [],
					hostiles: true,
					hFilter: {filter: (c) => !c.isWhiteListed && c.body.length > 1 && c.pos.lookAround(LOOK_MINERALS,3).length === 0}
			},
			'T': {},
			'blank': {
					structures: null,
					sFilter: [],
					hostiles: null,
					hFilter: {}
			}
	};

	function saveConflictStatus(room){
		if (Memory.contestedRooms){
			console.log('saving conflict in ', room);
			if (!Memory.contestedRooms[room.name] && room.hostileList){
				Memory.contestedRooms[room.name] = {
					hostilePresence: room.hostileList.length,
					expiry: Game.time + 30000
				};
			} else if (room.hostileList){
				Memory.contestedRooms[room.name].expiry = Game.time + 30000;
				if (!Memory.contestedRooms[room.name].hostilePresence || Memory.contestedRooms[room.name].hostilePresence < room.hostileList.length){
					Memory.contestedRooms[room.name].hostilePresence = room.hostileList.length;
				}
			}
		}
	}

	playerHeap.hasSpawned = {};
	playerHeap.allExtensionArray = [];
	function spawnCreep(role, roomName, body, options){
			let room = Game.rooms[roomName];
			let TTL, creepnumber,memory,assignedHomeName;
			if (room && room.memory.highPrioritySpawnBlock && Game.time < room.memory.highPrioritySpawnBlock){
					return -4
			}
			if (options){
					if (options.TTL){
							TTL = options.TTL;
					}
					if (options.creepnumber){
							creepnumber = options.creepnumber;
					}
					if (options.memory){
							memory = options.memory;
					}
					if (options.assignedHomeName){
							assignedHomeName = options.assignedHomeName;
					}
			}
			if (room && room.squadSpawningBlockCivs && role !== 'fixer' && role !== 'harvester' && role !== 'guard' && role !== 'vision'){
					return
			}
			if (role === 'depositBlocker' && !memory){
					console.log(role,roomName,'no mem');
					return -10
			}
			new RoomVisual(roomName).text('trying to spawn' + role + ' energy avail:' + room.energyAvailable + ', cost:' + Game.getBodyCost(body), 40, 48);
			let spawns = room.find(FIND_STRUCTURES, {filter: (s) => s.structureType == STRUCTURE_SPAWN});
			//working out creepnumber
			if (creepnumber == undefined){
					let numberRoom = room;
					if (assignedHomeName){
							numberRoom = Game.rooms[assignedHomeName];
					}
					creepnumber = getRequiredCreepNum(numberRoom,role,TTL);
			}
			if (!creepnumber){
					creepnumber = 1;
			}
			let extList;
			if (room.class === 'thoriumMine' && (!playerHeap.allExtensionArray[room.name] || Game.time % 100 === 0)) {
					extList = playerHeap.allExtensionArray[room.name] = room.findStructures('extension');
					if (spawns){
							for (let s in spawns){
									extList.push(spawns[s]);
							}
					}
					if (extList){
							playerHeap.allExtensionArray[room.name] = extList;
					}
			} else if (room && access(room.name) && access(room.name).structures && access(room.name).structures['extension'] && !playerHeap.allExtensionArray[room.name]){
					playerHeap.allExtensionArray[room.name] = [];
					for (let i in access(room.name).structures['extension']){
							let pos = access(room.name).structures['extension'][i].toPos();
							if (pos){
									let ext = pos.lookAround(LOOK_STRUCTURES, 0, {filter: (s) => s.structureType == STRUCTURE_EXTENSION});
									if (ext){
											if (!extList){
													extList = [];
											}
											extList.push(ext[0]);
									}
							}
					}
					if (room.memory.sourcePositions && extList){
							for (let i in room.memory.sourcePositions){
									let mem = room.memory.sourcePositions[i];
									if (mem && mem.e1){
											let pos = mem.e1.toPos();
											if (pos){
													let ext = pos.lookAround(LOOK_STRUCTURES, 0, {filter: (s) => s.structureType == STRUCTURE_EXTENSION});
													if (ext){
															extList.splice(0, 0, ext[0]);
													}
											}
									}
									if (mem && mem.e2){
											let pos = mem.e2.toPos();
											if (pos){
													let ext = pos.lookAround(LOOK_STRUCTURES, 0, {filter: (s) => s.structureType == STRUCTURE_EXTENSION});
													if (ext){
															extList.splice(0, 0, ext[0]);
													}
											}
									}
							}
					}
					if (spawns){
							for (let s in spawns){
									extList.splice(0, 0, spawns[s]);
							}
					}
					if (extList){
							playerHeap.allExtensionArray[room.name] = extList;
					}
			} else if (playerHeap.allExtensionArray[room.name]){
					extList = playerHeap.allExtensionArray[room.name];
			}
			//spawning
			let spawn = spawns.filter((s) => !s.spawning && !s.isRenewing && (!playerHeap.hasSpawned[s.id] || playerHeap.hasSpawned[s.id] !== Game.time) && (room.controller.level == 8 || s.isActive()))[0];
			if (spawn && creepnumber != undefined){
					let roomName = room.name;
					if (assignedHomeName){
							roomName = assignedHomeName;
					}
					let name = role + ' ' + creepnumber + ' ' + roomName + ' ' + Game.shard.name + ' ' + Game.time % 4000;
					if (spawn.spawnCreep(body, name, {energyStructures: extList,memory:memory}) == 0){
							playerHeap.hasSpawned[spawn.id] = Game.time;
							incrementCreepCount(room.name,role);
							{
									console.log('Spawning: ' + name);
							}
							if (config.logEnergy){
									room.logEnergyStats('spawning', findCost(body));
							}
							if (role == 'ambusher'){
									if (room.memory.ambush && room.memory.ambush.room){
											if (Memory.convoys[room.memory.ambush.room]){
													if (Memory.convoys[room.memory.ambush.room][1]){
															Memory.convoys[room.memory.ambush.room][1] += 1;
													} else {
															Memory.convoys[room.memory.ambush.room][1] = 1;
													}
											}
									}
							}
							if (role == 'ambushCollector'){
									if (room.memory.ambush && room.memory.ambush.room){
											if (Memory.convoys[room.memory.ambush.room]){
													if (Memory.convoys[room.memory.ambush.room][2]){
															Memory.convoys[room.memory.ambush.room][2] += 1;
													} else {
															Memory.convoys[room.memory.ambush.room][2] = 1;
													}
											}
									}
							}
							if (!room.memory.energyIn){
									room.memory.energyIn = -findCost(body);
							} else {
									room.memory.energyIn = room.memory.energyIn - findCost(body);
							}
							return 0
					} else {
							let ret = spawn.spawnCreep(body, name,{memory:memory});
							console.log(spawn.room.name + ' cannot spawn ' + role, body, ret);
							return ret
					}
			} else if (spawn && role == 'reserve'){
					let roomName = room.name;
					if (assignedHomeName){
							roomName = assignedHomeName;
					}
					let name = role + ' ' + creepnumber + ' ' + roomName + ' ' + Game.shard.name + ' ' + Game.time % 4000;
					if (spawn.spawnCreep(body, name, {energyStructures: extList}) == 0){
							room.memory.lastReserveSpawn = Game.time;
							{
									console.log('Spawning: ' + name);
							}
							incrementCreepCount(room.name,role);
							playerHeap.hasSpawned[spawn.id] = Game.time;
							if (config.logEnergy){
									room.logEnergyStats('spawning', findCost(body));
							}
							if (!room.memory.energyIn){
									room.memory.energyIn = -findCost(body);
							} else {
									room.memory.energyIn = room.memory.energyIn - findCost(body);
							}
							return 0
					} else if (spawn.spawnCreep(body, name, {energyStructures: extList,memory:memory}) == -6){
							if (Game.cpu.bucket < 3000){
									room.memory.spawnEnergyBlock = findCost(body);
									room.memory.spawnBlockTime = Game.time + 20;
							}
							return -6
					}
			} else {
					return -4
			}

			function findCost(body){
					let cost = 0;
					for (let bp in body){
							cost = cost + BODYPART_COST[body[bp]];
					}
					return cost
			}
	}
	function getRequiredCreepNum(room,role,TTL){
			if (room && role && room.roleList && room.roleList[role]){
					let creepsAlive = room.roleList[role].filter((c)=> (!c.ticksToLive || (TTL && c.ticksToLive > TTL) || (!TTL && c.ticksToLive > c.TTLRespawnDue)));
					if (creepsAlive.length > 0){
							for (let i = 1; i <= creepsAlive.length + 1; i++){
									let checkCreep = creepsAlive.filter((c)=>c.num === i)[0];
									if (!checkCreep){
											return i
									}
							}
					} else {
							return 1
					}
			} else if (room && role && room.roleList){
					return 1
			}
	}
	function spawnSquadMembers(room, role, body, squadName){
			if (!body){
					return -10
			}
			if (!room.spawnFree){
					return -4
			}
			if (!squadName){
					console.log('spawning',role,'no squad name');
					return
			}
			let extList;
			if (playerHeap.allExtensionArray[room.name]){
					extList = playerHeap.allExtensionArray[room.name];
			}
			let spawns = room.find(FIND_STRUCTURES, {filter: (s) => s.structureType == STRUCTURE_SPAWN});
			let spawn = spawns.filter((s)=> s.my && !s.spawning && !s.isRenewing && (!playerHeap.hasSpawned[s.id] || playerHeap.hasSpawned[s.id] !== Game.time)&& (room.controller.level === 8 ||
					CONTROLLER_STRUCTURES['spawn'][room.controller.level] >= spawns.length || s.isActive()))[0];
			if (spawn){
					let name = role + ' ' + spawn.name.slice(5) + ' ' + room.name + ' ' + Game.shard.name + ' ' + Game.time % 4000;
					let trySpawn = spawn.spawnCreep(body, name, {energyStructures: extList,memory:{squad:squadName}});
					console.log('try squad',trySpawn);
					if (trySpawn === 0){
							incrementCreepCount(room.name,role);
							if (config.logEnergy){
									room.logEnergyStats('spawning', findCost(body));
							}
							playerHeap.hasSpawned[spawn.id] = Game.time;
							Memory.squads[squadName].members.push(name);
							return 0
					} else if (trySpawn !== 0){
							if (Game.cpu.bucket < 3000){
									room.memory.spawnEnergyBlock = findCost(body);
									room.memory.spawnBlockTime = Game.time + 20;
							}
							let try2 = spawn.spawnCreep(body, name,{memory:{squad:squadName}});
							console.log('squad spawn error', try2, role, 'body:', body, 'body length:', body.length, name, squadName);
							if (try2 === 0){
									incrementCreepCount(room.name,role);
									Memory.squads[squadName].members.push(name);
									if (config.logEnergy){
											room.logEnergyStats('spawning', findCost(body));
									}
									playerHeap.hasSpawned[spawn.id] = Game.time;
									return 0
							} else {
									return try2
							}
					}
			}

			function findCost(body){
					if (!body || body.length == 0){
							return
					}
					let cost = 0;
					for (let bp = 0; bp < body.length; bp++){
							cost = cost + BODYPART_COST[body[bp]];
					}
					return cost
			}
	}

	function run$1f (creep){
		if (!creep.home){
			return
		}
		if (!creep.memory.squad){
			let rally = Game.flags['rally' + creep.home.name];
			if (rally && !creep.pos.inRangeTo(rally, 3)){
				creep.moveTo(rally.pos, {range: 3});
			} else {
				creep.startNap(3);
			}
		}
	}
	function getBody$4(room,level,type){
		let body;
		let energyCap = room.energyCapacityAvailable;
			let fixedSection = [MOVE,HEAL];
			if (level && config.boostLevels[level] && (config.boostLevels[level].includes('GO') || config.boostLevels[level].includes('GHO2')||
					config.boostLevels[level].includes('XGHO2'))){
					fixedSection = [TOUGH,TOUGH,TOUGH,TOUGH,TOUGH,MOVE,MOVE,MOVE,MOVE,MOVE,TOUGH,TOUGH,TOUGH,MOVE,MOVE,MOVE];
			}
		if (type === 'T'){
			body = ['ranged_attack', 'move'];
		} else if (level > 0){
			body = bodies$3[level];
		} else if (type === 'G'){
			body = (_.repeat('move ', 24) + _.repeat('attack ', 20) + +_.repeat('ranged_attack ', 5) + 'move').split(' ');
			if (Game.getBodyCost(body)>energyCap){
				body = room.makeBody([ATTACK, ATTACK, ATTACK, RANGED_ATTACK], false, {sort: true,level:level,fixedSection:fixedSection});
			}
		}
		if ((!body || Game.getBodyCost(body) > energyCap)){
			body = room.makeBody([RANGED_ATTACK], false, {sort: true,level:level,fixedSection:fixedSection});
		}
			if ((!body || body.length === 1|| Game.getBodyCost(body) > energyCap)){
					body = room.makeBody([RANGED_ATTACK], false, {sort: true,level:level,fixedSection:fixedSection});
			}
		if (Game.getBodyCost(body) > energyCap){
			return false
		}
		return body
	}
	const bodies$3 = {
		1:(_.repeat('move ', 16) + _.repeat('ranged_attack ', 26)+ _.repeat('heal ', 7) + 'move').split(' '),
		2:(_.repeat('move ', 12) + _.repeat('ranged_attack ', 30) + _.repeat('heal ', 7) + 'move').split(' '),
		3:(_.repeat('tough ', 10) + _.repeat('move ', 12) + _.repeat('ranged_attack ', 20)+ _.repeat('heal ', 7) + 'move').split(' '),
		4:(_.repeat('tough ', 8) + _.repeat('move ', 9) + _.repeat('ranged_attack ', 22) + _.repeat('heal ', 10) + 'move').split(' '),
			5:(_.repeat('tough ', 10) + _.repeat('move ', 9) + _.repeat('tough ', 2) + _.repeat('ranged_attack ', 15) + _.repeat('heal ', 13) + 'move').split(' ')
	};

	var sniper = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$1f,
		getBody: getBody$4
	});

	function run$1e(creep){
		if (!creep.home){
			return
		}
		if (!creep.memory.squad){
			let rally = Game.flags['rally' + creep.home.name];
			if (rally && !creep.pos.inRangeTo(rally, 3)){
				creep.moveTo(rally.pos, {range: 3});
			} else {
				creep.startNap(3);
			}
		}
	}





	function getBody$3(room,level,type){
		let body;
		let energyCap = room.energyCapacityAvailable;
		if (type === 'T'){
			body = ['work', 'move'];
		} else if (level > 0){
			body = bodies$2[level];
		}
		let fixedSection = ['ranged_attack','move','ranged_attack','move','ranged_attack','move'];
			if (level && config.boostLevels[level] && (config.boostLevels[level].includes('GO') || config.boostLevels[level].includes('GHO2')||
					config.boostLevels[level].includes('XGHO2'))){
					fixedSection = [RANGED_ATTACK, MOVE, RANGED_ATTACK, MOVE, RANGED_ATTACK, MOVE,TOUGH,TOUGH,TOUGH,TOUGH,TOUGH,TOUGH,TOUGH,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE];
			}
		if ( (!body || Game.getBodyCost(body) > energyCap)){
			body = room.makeBody([WORK], false, {sort: true,level:level,fixedSection:fixedSection});
		}
		if (Game.getBodyCost(body) > energyCap){
			return false
		}
		return body
	}
	const bodies$2 = {
		1:(_.repeat('move ', 16) + _.repeat('work ', 28) + _.repeat('ranged_attack ', 5) + 'move').split(' '),
		2:(_.repeat('move ', 12) + _.repeat('work ', 30) + _.repeat('ranged_attack ', 7) + 'move').split(' '),
		3:(_.repeat('tough ', 7) + _.repeat('work ', 25) + _.repeat('ranged_attack ', 5) + _.repeat('move ', 12) + 'move').split(' '),
		4:(_.repeat('tough ', 12) + _.repeat('move ', 9) + _.repeat('tough ', 3) + _.repeat('work ', 20) + _.repeat('ranged_attack ', 5) + 'move').split(' '),
		5:(_.repeat('tough ', 12) + _.repeat('move ', 9) + _.repeat('tough ', 3) + _.repeat('work ', 20) + _.repeat('ranged_attack ', 5)  + 'move').split(' ')
	};

	var dozer = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$1e,
		getBody: getBody$3
	});

	function run$1d(creep){
			if (!creep.home){
					return
			}
			if (!creep.memory.squad){
					creep.say('no sq',true);
					let rally = Game.flags['rally' + creep.home.name];
					if (rally && !creep.pos.inRangeTo(rally, 3)){
							creep.moveTo(rally.pos, {range: 3});
					} else {
							creep.startNap(3);
					}
			}
	}



	function getBody$2(room,level,type){
			let body;
			let energyCap = room.energyCapacityAvailable;
			let fixedSection = [RANGED_ATTACK, MOVE, RANGED_ATTACK, MOVE, RANGED_ATTACK, MOVE];
			if (level && config.boostLevels[level] && (config.boostLevels[level].includes('GO') || config.boostLevels[level].includes('GHO2')||
					config.boostLevels[level].includes('XGHO2'))){
					fixedSection = [RANGED_ATTACK, MOVE, RANGED_ATTACK, MOVE, RANGED_ATTACK, MOVE,TOUGH,TOUGH,TOUGH,TOUGH,TOUGH,MOVE,MOVE,MOVE,MOVE,MOVE];
					if (type === 'C'){
							fixedSection = [TOUGH,TOUGH,TOUGH,MOVE,MOVE,MOVE];
					}
			}
			if (type === 'SKM' || type === 'SKE'){
					body = room.makeBody([HEAL, TOUGH], false, {sort: true, maxParts: 20,level:level});
			} else if (type === 'T'){
					body = ['heal', 'move'];
			} else if (level > 0){
					body = bodies$1[level];
			} else if (energyCap > 2000){

					body = room.makeBody([HEAL], false, {
							maxParts: 44,
							sort: true,
							level:level,
							fixedSection: fixedSection
					});
			}
			if ((!body || Game.getBodyCost(body) > energyCap)){
					body = room.makeBody([HEAL], false, {sort: true,level:level,fixedSection: fixedSection});
			}
			if (!body||(!level && (type === 'P' || type === 'C')) || Game.getBodyCost(body) > energyCap || room.controller.level < 5){
					body = room.makeBody([HEAL], false,{sort:true});
			}

			if (Game.getBodyCost(body) > energyCap){
					return false
			}
			return body
	}
	const bodies$1 = {
			1:(_.repeat('move ', 16) + _.repeat('heal ', 30) + _.repeat('ranged_attack ', 3) + 'move').split(' '),
			2:(_.repeat('move ', 12) + _.repeat('heal ', 32) + _.repeat('ranged_attack ', 5)  + 'move').split(' '),
			3:(_.repeat('tough ', 3) + _.repeat('move ', 12) + _.repeat('tough ', 2) + _.repeat('ranged_attack ', 2) + _.repeat('heal ', 30) + 'move').split(' '),
			4:(_.repeat('tough ', 5) + _.repeat('move ', 9) + _.repeat('ranged_attack ', 2) + _.repeat('heal ', 33) + 'move').split(' '),
			5:(_.repeat('tough ', 7) + _.repeat('move ', 9) + _.repeat('tough ', 2) + _.repeat('ranged_attack ', 2) + _.repeat('heal ', 29) + 'move').split(' ')
	};

	var medic = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$1d,
		getBody: getBody$2
	});

	function run$1c (creep){
		if (!creep.home){
			return
		}
		if (!creep.memory.squad){
			let rally = Game.flags['rally' + creep.home.name];
			if (rally && !creep.pos.inRangeTo(rally, 3)){
				creep.moveTo(rally.pos, {range: 3});
			} else {
				creep.startNap(3);
			}
		}
	}


	function getBody$1(room,level,type){
		let body;
		let energyCap = room.energyCapacityAvailable;
		if (type === 'T'){
			body = ['ranged_attack', 'move'];
		} else if (level > 0){
			body = bodies[level];
		} else if (type === 'G'){
			body = room.makeBody([HEAL, RANGED_ATTACK,RANGED_ATTACK], false, {sort: true,level:level});
			if (room.controller.level === 8){
					body = room.makeBody([HEAL,RANGED_ATTACK], false, {sort: true,level:level});
			}
		}
		if (body && Game.getBodyCost(body) > energyCap && level > 3){
				body = room.makeBody([TOUGH,RANGED_ATTACK,RANGED_ATTACK,HEAL,MOVE], false, {sort: true,noMove:true,level:level});
		}
		if ( (!body || Game.getBodyCost(body) > energyCap)){
			body = room.makeBody([RANGED_ATTACK,RANGED_ATTACK,HEAL], false, {sort: true,level:level});
		}
		if (Game.getBodyCost(body) > energyCap){
			return false
		}
		return body
	}
	const bodies = {
		1:(_.repeat('move ', 16) + _.repeat('ranged_attack ', 23) + _.repeat('heal ', 10)  + 'move').split(' '),
		2:(_.repeat('move ', 12) + _.repeat('ranged_attack ', 27) + _.repeat('heal ', 10)  + 'move').split(' '),
		3:(_.repeat('move ', 12) + _.repeat('ranged_attack ', 27) + _.repeat('heal ', 10)  + 'move').split(' '),
		4:(_.repeat('tough ', 3) + _.repeat('move ', 9) + _.repeat('ranged_attack ', 27) + _.repeat('heal ', 10) + 'move').split(' '),
		5:(_.repeat('tough ', 3) + _.repeat('move ', 9) + _.repeat('ranged_attack ', 22) + _.repeat('heal ', 15) + 'move').split(' ')
	};

	var hybrid = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$1c,
		getBody: getBody$1
	});

	function spawnSquad(room, squad, squadName){
			let squadBody = {};
			if (squad.delaySpawn && squad.delaySpawn > Game.time){
					return
			}
			if ((room.civList && room.civList.length < 3) || !room.civList){
					room.display('yield');
					console.log('yield spawning A',room.name,room.memory.prioritySpawn);
					return
			}
			let spawns = room.findStructures('spawn',(s)=>s.my && !s.spawning);
			if (spawns.length === 0){
					return
			}
			let moverAlive = false;
			let yieldList = ['harvester', 'miner1', 'fixer', 'guard', 'transfer'];
			let needYield = false;
			for (let i in yieldList){
					try {
							let role = yieldList[i];
							let module = RoleModules[role];
							if (module && module.spawnCode){
									let cpu = Game.cpu.getUsed();
									//eco stable,energy crisis?
									let isNeeded = module.spawnCode.isRequired(room, countRole);
									//console.log('isNeeded',role,Game.cpu.getUsed()-cpu)
									let cpu2 = Game.cpu.getUsed();
									let prio = module.spawnCode.priority(room, countRole);
									//console.log('prio',role,Game.cpu.getUsed()-cpu2)
									if (isNeeded && prio < 25){
											needYield = true;
											break
									}
							}
					} catch (err){
							console.log(err);
							console.log('role failed', +yieldList[i]);
					}
			}
			if (needYield){
					if (spawns.length > 1){
							needYield = false;
					}
			}
			if (needYield){
					room.display('yield');
					console.log('yield squad spawning', room.name);
					return
			}
			if (!room){
					console.log('no room in squad spawning', room, squad, squadName);
					return
			}
			if (countRole('mover',room)>0){
					moverAlive = true;
			}
			let boostLevel = squad.boosted;
			if (boostLevel === 'N'){
					boostLevel = 0;
			}
			squadBody['sniper'] = getBody$4(room,boostLevel,squad.type);
			squadBody['dozer'] = getBody$3(room,boostLevel,squad.type);
			squadBody['medic'] = getBody$2(room,boostLevel,squad.type);
			squadBody['attacker'] = getBody$6(room,boostLevel,squad.type);
			squadBody['hybrid'] = getBody$1(room,boostLevel,squad.type);
			let squadRoleNeeded;
			room.display('blabs',room.memory.blabsFull);
			if (squad.state === 'spawning' && (!squad.boosted || squad.boosted === 'N' ||
							((room.memory.blabsFull || moverAlive || squad.members.length > 0) && room.memory.boostingRequired === squad.boosted)) &&
					squad.members.length < (squad.dozers + squad.medics + squad.attackers + squad.snipers +squad.hybrids)){
					let active = {
							'attackers': 0,
							'dozers': 0,
							'medics': 0,
							'snipers': 0,
							'hybrids':0
					};
					for (let m in squad.members){
							let creep = Game.creeps[squad.members[m]];
							if (creep){
									if (!active[creep.role + 's']){
											active[creep.role + 's'] = 0;
									}
									active[creep.role + 's']++;
							}
					}
					for (let r in active){
							if (squad[r] && squad[r] > active[r]){
									squadRoleNeeded = r.slice(0, -1);
							}
					}
			}
			room.display('squad spawning 0');
			//console.log(room.name,squadRoleNeeded)
			if (squadRoleNeeded){
					room.display('squad spawning');
					//console.log(room.name, 'try to spawn:', squadRoleNeeded)
					if (squad.type !== 'SKM' && squad.type !== 'SKE'){
							room.squadSpawningBlockCivs = true;
					}
					let ret = spawnSquadMembers(room, squadRoleNeeded, squadBody[squadRoleNeeded], squadName);
					console.log('spawn squad',squadRoleNeeded,squadBody[squadRoleNeeded],ret);
					if (ret === -6){
							let num = 2;
							let cost = Game.getBodyCost(squadBody[squadRoleNeeded]);
							let dif = cost - room.energyAvailable;
							if (dif > 1000){
									num = 15;
							} else if (dif > 500){
									num = 10;
							} else if (dif > 100){
									num = 5;
							}
							squad.delaySpawn = Game.time+num;
					}
			}
	}

	playerHeap.combatUtils = {};
	playerHeap.combatUtils.shareTargets = {};
	let sharedTargetTick = 0;
	function engage(creep, target, members, type,inTargetRoom,formation){
			predictNextHits(creep.room);
			let stats = creep.stats();
			let hos;
			if (sharedTargetTick !== Game.time){
					sharedTargetTick = Game.time;
					playerHeap.combatUtils.shareTargets = {};
			}
			if (inTargetRoom === undefined){
					inTargetRoom = true;
			}
			if (creep.room.memory.hostiles){
					hos = creep.pos.lookAround(LOOK_CREEPS, 1, {filter: (c) => !c.my && !c.isWhiteListed});
					if (hos.length > 0){
							hos.sort((a,b)=>b.stats().heal - a.stats().heal);
					}
			}
			if (target && target.color){
					target = undefined;
			}
			let canRMA = true;
			if (type && (type === 'L' || type === 'W') && creep.room.storage){
					if (creep.pos.inRangeTo(creep.room.storage,3)){
							canRMA = false;
					}
			}
			if (canRMA && type && (type === 'L' || type === 'W') && creep.room.terminal){
					if (creep.pos.inRangeTo(creep.room.terminal,3)){
							canRMA = false;
					}
			}
			if (creep.room.controller && !creep.room.controller.my && creep.room.controller.isWhiteListed){
					canRMA = false;
			}
			if (creep.role === 'dozer'){
					canRMA = false;
			}
			if (stats.ranged_attack && stats.ranged_attack > 0 && (!target || !target.structureType || target.structureType !== STRUCTURE_POWER_BANK)){
					let rangeHos;
					if (creep.room.memory.hostiles && (!target || target.structureType || creep.pos.getRangeTo(target)>3)){
							if (type !== 'Ca' && type !== 'L' && type !== 'R' && type !== 'C'){
									rangeHos = creep.pos.lookAround(LOOK_CREEPS, 3, {filter: (c) => !c.my && !c.isWhiteListed});
							} else {
									rangeHos = creep.pos.lookAround(LOOK_CREEPS, 3, {filter: (c) => !c.my && !c.isWhiteListed
													&& c.pos.lookAround(LOOK_STRUCTURES,0,{filter:(s)=>s.structureType === STRUCTURE_RAMPART}).length === 0});
							}
					}
					if (rangeHos && rangeHos.length > 0){
							rangeHos = rangeHos.sort((a,b)=> {
									if (playerHeap.combatUtils.shareTargets[a.id]){
											return -1
									} else if (playerHeap.combatUtils.shareTargets[b.id]){
											return 1
									}
							});
					}
					let allies = creep.pos.lookAround(LOOK_CREEPS, 3, {filter: (c) => !c.my && c.isWhiteListed});
					let canRangedAttackStructures = stats.ranged_attack > 50 || (stats.work === 0 && stats.attack === 0);
					if (hos && hos.length > 0 && allies.length === 0 && canRMA){
							creep.rangedMassAttack();
					} else if (rangeHos && rangeHos.length > 0){
							creep.rangedAttack(rangeHos[0]);
							playerHeap.combatUtils.shareTargets[rangeHos[0].id] = 1;
					} else if (target && canRMA && allies.length === 0 && (!target.structureType || target.owner) && creep.pos.isNearTo(target)){
							creep.rangedMassAttack();
					} else if (target && (!target.structureType || canRangedAttackStructures) && creep.pos.inRangeTo(target,3)){
							creep.rangedAttack(target);
							playerHeap.combatUtils.shareTargets[target.id] = 1;
					} else if (canRangedAttackStructures) {
									let dict = squadDict[type];
									if (dict && inTargetRoom && dict.structures && dict.sFilter && creep.room &&
											(!creep.room.controller || !creep.room.controller.my)){
											let filters = Array.from(dict.sFilter);
											filters.push({filter: (s) => s.structureType == STRUCTURE_RAMPART && !s.my && !s.isWhiteListed});
											for (let f in filters){
													let hosStruct = creep.pos.lookAround(LOOK_STRUCTURES, 3, filters[f]);
													if (hosStruct && hosStruct[0] && !hosStruct[0].my){
															if ((creep.pos.isNearTo(hosStruct[0]) || hosStruct.length > 3) && allies.length === 0 && hosStruct[0].structureType !== STRUCTURE_WALL && canRMA){
																creep.rangedMassAttack();
																	break
															}
															creep.rangedAttack(hosStruct[0]);
															break
													}
											}
									}
					}
			}
			let attacked = false;
			if (stats.attack && stats.attack > 0){
					if (target && target.pos && target.pos.isNearTo(creep)){
							if (creep.home){
									let powerNum = creep.home.memory.powernum;
									if (powerNum > 5){
											powerNum = 5;
									}
									if (target && target.structureType && target.structureType == STRUCTURE_POWER_BANK && target.hits < 10000 && creep.ticksToLive > 50 && target.ticksToDecay > 50){
											let powerMovers = creep.room.find(FIND_MY_CREEPS,{filter:(c)=>c.role === 'powermover'});
											if((!powerMovers || powerMovers.length === 0 || (powerNum &&  powerMovers.length < powerNum))){
													return
											}
									}
							}
							if (target && target.structureType){
									attacked = true;
									creep.attack(target);
									playerHeap.combatUtils.shareTargets[target.id] = 1;
							} else if (hos && hos.length == 1){
									if (creep.attack(target) == -9){
											creep.attack(hos[0]);
											attacked = true;
											playerHeap.combatUtils.shareTargets[hos[0].id] = 1;
									}
							} else if (hos && hos.length > 1){
									hos.sort((a, b) => a.hits - b.hits);
									if (hos && hos.length > 0){
											hos = hos.sort((a,b)=> {
													if (playerHeap.combatUtils.shareTargets[a.id]){
															return -1
													} else if (playerHeap.combatUtils.shareTargets[b.id]){
															return 1
													}
											});
									}
									attacked = true;
									creep.attack(hos[0]);
									playerHeap.combatUtils.shareTargets[hos[0].id] = 1;
							}
					} else {
							try {
									let target;
									let dict = squadDict[type];
									if (dict && inTargetRoom && dict.structures && dict.sFilter && creep.room &&
											(!creep.room.controller || !creep.room.controller.my)){
											let filters = Array.from(dict.sFilter);
											filters.push({filter: (s) => s.structureType == STRUCTURE_RAMPART && !s.my && !s.isWhiteListed});
											for (let f in filters){
													let nearStruct = creep.pos.lookAround(LOOK_STRUCTURES, 1, filters[f]);
													if (nearStruct && nearStruct.length > 0){
															nearStruct = nearStruct.sort((a,b)=> {
																	if (playerHeap.combatUtils.shareTargets[a.id]){
																			return -1
																	} else if (playerHeap.combatUtils.shareTargets[b.id]){
																			return 1
																	}
															});
													}
													if (nearStruct && nearStruct[0] && !nearStruct[0].my){
															target = nearStruct[0];
															playerHeap.combatUtils.shareTargets[target.id] = 1;
															break
													}
											}
									}
									if (!target && dict && dict.hostiles && dict.hFilter){
											let nearCreep = creep.pos.lookAround(LOOK_CREEPS, 1, dict.hFilter);
											nearCreep = nearCreep.filter((c) => !c.my);
											if (nearCreep && nearCreep[0] && !nearCreep[0].my){
													target = nearCreep[0];
											}
									}
									if (target && creep.pos.isNearTo(target)){
											attacked = true;
											creep.attack(target);
									}
							} catch (err){
									console.log(err);
							}
					}
			}
			if (stats.heal && stats.heal > 0 && (!stats.attack || (!target && !hos) || !attacked)){
					if (!members){
							healFriends(creep);
					} else if (members.length == 4 && type === 'C' && (!formation || formation.isAQuad())){
							healQuad(members,type);
					} else {
							let i = members.indexOf(creep);
							if (creep.room.memory.hostiles || (creep.room.controller && !creep.room.controller.my && creep.room.controller.owner)
									|| creep.hits < creep.hitsMax || creep.pos.onEdge() || (members[i - 1] && (members[i - 1].pos.onEdge() || members[i - 1].hits < members[i - 1].hitsMax || members[0].hits < members[0].hitsMax))){
									healFriends(creep);
							}
					}
			}
			if (stats.work && stats.work > 0){
					if (target && target.structureType && creep.pos.isNearTo(target)){
							creep.dismantle(target);
					} else {
							let dict = squadDict[type];
							let target;
							if (dict && inTargetRoom && dict.structures && dict.sFilter && creep.room &&
									(!creep.room.controller || !creep.room.controller.my)){
									let filters = Array.from(dict.sFilter);
									filters.push({filter: (s) => s.structureType == STRUCTURE_RAMPART && !s.my && !s.isWhiteListed});
									for (let f in filters){
											let nearStruct = creep.pos.lookAround(LOOK_STRUCTURES, 1, filters[f]);
											if (nearStruct && nearStruct[0] && !nearStruct[0].my){
													target = nearStruct[0];
													break
											}
									}
							}
							if (target){
									creep.dismantle(target);
							}
					}
			}
	}
	function predictNextHits(room){
			if (room.predictedNextHits || !room.memory.armedHostiles){
					return
			}
			for (let i in room.armedHostileList){
					let hostile = room.armedHostileList[i];
					let nearCreeps = hostile.pos.lookAround(LOOK_CREEPS,1,{filter:(c)=>c.my});
					if (nearCreeps.length > 0){
							if (hostile.stats().attack && hostile.stats().attack > 0){
									let target = nearCreeps[0];
									if (nearCreeps.length > 1){
											let newList = nearCreeps.filter((c)=>c.role=== 'medic');
											if (newList[0]){
													target = newList[0];
											}
									}
									target.guessNextHits(hostile.stats().attack);
							} else {
									if (hostile.stats().ranged_attack && hostile.stats().ranged_attack>0){
											for (let n in nearCreeps){
													nearCreeps[n].guessNextHits(hostile.stats().ranged_attack);
											}
									}
							}
					}
			}
			room.predictedNextHits = true;
	}

	function healQuad(arr,type){
			let members = Array.from(arr);
			let sort = members.sort((a, b) => a.hits / a.hitsMax - b.hits / b.hitsMax);
			let core;
			if (type === 'C'){
					core = members[0].room.findStructures('invaderCore')[0];
			}
			if (sort && sort[0].hits < sort[0].hitsMax - 50){
					for (let i in members){
							members[i].heal(sort[0]);
					}
			} else if (core){
					let closest,closestRange;
					for (let i in members){
							let range = members[i].pos.getRangeTo(core);
							if (range && (!closest || range < closestRange)){
									closest = members[i];
									closestRange = range;
							}
					}
					for (let i in members){
							if (closest){
									members[i].heal(closest);
							} else {
									if (members[i - 1]){
											members[i].heal(members[i - 1]);
									} else {
											members[i].heal(members[i]);
									}
							}
					}
			} else {
					for (let i in members){
							if (members[i - 1] && (Game.time + Math.round(Math.random())) % 2 === 0){
									members[i].heal(members[i - 1]);
							} else {
									members[i].heal(members[i]);
							}
					}
			}
	}

	function healFriends(creep){
			if (creep.hits < creep.hitsMax * 0.6){
					creep.heal(creep);
			} else {
					let nearFriends = creep.pos.lookAround(LOOK_CREEPS,3,{filter:(c)=>c.my || (config.allies.includes(c.owner.username))});
					let best = creep,bestVal = (creep.hitsMax-creep.nextHits);
					for (let i in nearFriends){
							let friend = nearFriends[i];
							if (friend.id === this.id){
									continue
							}
							let val = friend.hitsMax-friend.nextHits;
							if (val > 0){
									if (!friend.pos.isNearTo(creep)){
											val /= 3;
									}
							}
							if (val > 0 && val > bestVal){
									best = friend;
									bestVal = val;
							}
					}
					if (best){
							//console.log('best heal found',creep,best,bestVal)
							creep.heal(best);
					}
			}
	}

	function runLineSquad(members, target, targetRoom, squad, towerPowerMatrix){
			//squad refers to the memory info for the squad
			let sep = false;
			let powerbank = false;
			if (target && target.structureType && target.structureType === 'powerBank' && target.room && !target.room.memory.armedHostiles){
					powerbank = true;
			}
			if (members.length > 1){
					sep = isSeparated(members);
			}
			let inBase = false;
			let homeRoom = members[0].home;
			if (members.length > 1 && homeRoom && members[0].room.name == members[0].home.name && !members[0].home.memory.hostiles && sep){
					let exts = members[0].pos.lookAround(LOOK_STRUCTURES, 3, {filter: (s) => s.structureType == STRUCTURE_EXTENSION});
					if (exts && exts.length > 0){
							members[0].say('in base');
							sep = false;
							inBase = true;
					}
			}
			if (Memory.portals && squad && squad.type !== 'P' && Memory.portals[members[0].pos.roomName]){
					if (members[0].pos.lookAround(LOOK_STRUCTURES,3,{filter:(s)=>s.structureType === 'portal'})[0]){
							sep = false;
					}
			}
			if (members.length == 0){
					return
			}
			let nearTarget = false;
			if (target){
					let range = members[0].pos.getRangeTo(target);
					if (((members[0].role == 'sniper' || members[0].role == 'hybrid') && range === 2 &&
							((target.body && target.stats.attack) || (target.structureType && target.structureType === 'rampart'))) || range === 1){
							nearTarget = true;
					}
					if (!target.body && !target.structureType){
							//target is a position - move onto it
							nearTarget = false;
					}
			}
			for (let i = 0; i < members.length; i++){
					let creep = members[i];
					if (!creep.pos){
							continue
					}
					if ((creep.room.name == targetRoom && target && !powerbank && (!target.structureType || target.structureType !== STRUCTURE_CONTROLLER)) || creep.room.memory.hostiles){
							engage(creep, target, members, squad.type);
					}
					if (nearTarget == false){
							if (i == 0 && (sep == false || creep.pos.onEdge() || creep.pos.nearEdge() ||
									(Game.map.getSector(creep.room.name) && Game.map.getSector(targetRoom) && Game.map.getSector(creep.room.name) !== Game.map.getSector(targetRoom)
											&& Game.map.getRoomType(creep.room.name) === 'centre') || (Game.map.getRoomType(creep.room.name) === 'centre' && creep.pos.lookAround(LOOK_STRUCTURES, 1, {filter: (s) => s.structureType === STRUCTURE_PORTAL}).length > 0))){
									let waypoint;
									if ((squad.targetRoom && creep.room.name == squad.targetRoom) || squad.type == 'G' || squad.type == 'SKM'){
											creep.memory.WP = 'fin';
									}
									if (!creep.memory.WP || creep.memory.WP != 'fin'){
											waypoint = waypoints(creep, true);
									}
									if (waypoint){
											creep.goTo(waypoint, {SK: true,freshRoute:true});
									} else if (targetRoom && creep.room.name != targetRoom){
											if (squad.type && squad.type === 'P'  && homeRoom && Memory.powerPaths && Memory.powerPaths[squad.homeRoom]
													&& Memory.powerPaths[squad.homeRoom][targetRoom] && Memory.powerPaths[squad.homeRoom][targetRoom].path){
													let path = Memory.powerPaths[squad.homeRoom][targetRoom].path;
													creep.moveUsingSavedPath(path.sPath,path.start.toPos(),path.end.toPos());
											} else {
													let quad = false;
													if (members.length >= 4){
															quad = true;
													}
													creep.goTo(targetRoom, {SK: true,freshRoute:true,quad:quad});
													if (creep.memory.exit){
															for (let m in members){
																	if (members[m].room.name === creep.room.name){
																			members[m].memory.lastExit = creep.memory.exit;
																	}
															}
													}
											}
									} else {
											if (!squad.nextWaveTime && squad.timeRequested){
													squad.nextWaveTime = creep.ticksToLive + squad.timeRequested - 150;
											} else if (!squad.nextWaveTime){
													squad.nextWaveTime = Game.time - 1;
											}
											if (!target && squad.type === 'D' && creep.room.controller && creep.pos.getRangeTo(creep.room.controller) > 3){
													creep.moveTo(creep.room.controller, {range: 2});
											} else if (target && !target.body && !target.pos && target.onEdge()){
													//target is an edge position to change room
													creep.moveTo(target,{range:0});
											} else if (target){
													if (creep.pos.onEdge()){
															let side = creep.pos.edgeSide();
															let dir = side.map8(4);
															creep.move(dir);
													} else {
															if (target && target.pos && (!target.pos.onEdge() || creep.pos.getRangeTo(target)>2)){
																	creep.moveTo(target, {
																			range: 1, maxRooms: 1
																	});
															} else if (target && (squad.type === 'D' || squad.type === 'chase') && !target.body && !target.structureType && creep.pos.getRangeTo(target)> 1){
																	creep.moveTo(target,{
																			range: 1, maxRooms: 1
																	});
															}
													}
											} else if (squad.type === 'D' && !creep.room.controller){
													creep.moveTo(new RoomPosition(25, 25, targetRoom), {range: 10, maxRooms: 1});
											}
									}
							} else if (i > 0){
									//new RoomVisual(creep.room.name).line(creep.pos, members[i - 1].pos)
									if (members[i - 1]){
											if (inBase){
													let rally = Game.flags['rally' + homeRoom.name];
													if (squad.rally && squad.rally.toPos()){
															rally = squad.rally.toPos();
													}
													if (rally){
															creep.moveTo(rally);
													}
											} else if (creep.pos.onEdge() && !members[i - 1].pos.onEdge() && (creep.pos.inRangeTo(members[i - 1], 2) || members[i - 1].pos.inRangeTo(creep.pos.oppositeEdge()))){
													let pos = creep.pos;
													if (pos.roomName != members[i - 1].room.name){
															pos = pos.oppositeEdge();
													}
													creep.move(pos.getDirectionTo(members[i - 1]));
											} else {
													let next = members[i - 1];
													let range;
													if (members[i].room.name == next.room.name){
															range = members[i].pos.getRangeTo(next);
													} else if (next.pos.onEdge() && next.pos.oppositeEdge().roomName == members[i].roomName){
															range = members[i].pos.getRangeTo(next);
															next = next.pos.oppositeEdge();
													} else if (creep.memory.lastExit){
															let lastExit = creep.memory.lastExit.toPos();
															if (lastExit && creep.room.name === lastExit.roomName){
																	creep.moveTo(lastExit,{range:0});
																	continue
															}
													}
													if (range && range === 1){
															if (next.isMoving){
																	let dir = creep.pos.getDirectionTo(next);
																	let nextPos = creep.pos.movePos(dir);
																	if (!nextPos){
																			creep.moveTo(next, {range: 1});
																	} else {
																			members[i].move(dir);
																	}
															}
													} else {
															creep.moveTo(members[i - 1], {range: 1});
													}
											}
									}
							}
					} else {
							if (powerbank && creep.role === 'attacker' && target && creep.pos.isNearTo(target)){
									creep.attack(target);
							}
							if (i == 0){
									if (creep.role != 'sniper'){
											if (creep.role === 'dozer'){
													creep.dismantle(target);
											}
											if (target.structureType && (target.structureType == STRUCTURE_WALL || target.structureType == STRUCTURE_RAMPART) && creep.pos.getDirectionTo(target) % 2 != 0){
													if (members[i + 1] && members[i + 1].pos.isNearTo(creep)){
															creep.move(creep.pos.getDirectionTo(members[i + 1]).map8(4));
													}
											}
									}
									if (target.structureType == STRUCTURE_CONTROLLER){
											creep.signController(target, `${Game.username} territory`);
									}
									if (target && target.progress){
											//is a construction site
											creep.moveTo(target.pos,{range:0});
									}
							} else if (target && target.pos){
									if (creep.role == 'dozer'){
											creep.dismantle(target);
									}
									if (!creep.pos.isNearTo(target) && creep.role != 'medic' && creep.role != 'sniper'){
											let neighbours = target.pos.neighbours(1);
											let newSpot;
											if (!newSpot){
													newSpot = neighbours.find((p) => p && p.lookFor(LOOK_STRUCTURES).filter((s) => s.structureType != STRUCTURE_ROAD).length == 0 &&
															p.getTerrain() != 'wall' && !p.creepAtPosition && p.onEdge() == false && p.lookAround(LOOK_CREEPS, 1, {filter: (c) => c.my}).length > 0);
											}
											if (newSpot){
													creep.goTo(newSpot, {SK: true,freshRoute:true});
											}

									} else if ((creep.role == 'sniper' || creep.role == 'medic') && members[i - 1] && creep.pos.getRangeTo(members[i - 1]) > 2){
											creep.moveTo(members[i - 1], {range: 2});
									} else if (members[i - 1]){
											let next = members[i - 1];
											if (next.role == 'medic'){
													next = members[0];
											}
											if (powerbank){
													creep.heal(next);
											}
											if (!creep.pos.isNearTo(next)){
													let neighbours = next.pos.neighbours(1);
													let closest;
													let closestRange;
													let moved = false;
													for (let i in neighbours){
															if (neighbours[i].isWalkable(true)){
																	if (neighbours[i].isNearTo(creep)){
																			creep.move(creep.pos.getDirectionTo(neighbours[i]));
																			moved = true;
																			break
																	}
															} else if (!closest || closestRange > neighbours[i].getRangeTo(creep)){
																	closest = neighbours[i];
																	closestRange = neighbours[i].getRangeTo(creep);
															}
													}
													if (closest && !moved){
															creep.moveTo(closest, {range: 1});
													}
											}
									}
							} else ;
					}
			}
	}

	function isSeparated(members){
			let sep = false;
			for (let i in members){
					let creep = members[i];
					if (creep && creep.pos){
							if (i > 0){
									//check other creeps to see if near to them
									if (creep && (!creep.pos.isNearTo(members[i - 1]) && creep.pos.onEdge() == false && members[i - 1].pos.onEdge() == false) || sep === true){
											sep = true;
											//creep.say('sep')
									}
							}
							if (creep && creep.fatigue > 0){
									sep = true;
									//creep.say('fat')
							}
					}
					//creep.say(i)
			}
			return sep
	}

	function run$1b(creep){
		console.log(creep.pos, 'trader');
		var homeRoom = Game.rooms[creep.name.split(' ')[2]];
		creep.name.split(' ')[3];
		let targetShard = creep.num;
		var flag = Game.flags['ShardTrade'];
		let portalRoomFlag = Game.flags['PortalRoom'];
		if (_.sum(creep.store) == creep.store.getCapacity() && creep.memory.target){
			creep.memory.dropping = true;
		}
		creep.heal(creep);
		if (Game.shard.name != targetShard){
			if (creep.room.terminal && !creep.memory.readyToDepart){
				if (!creep.memory.boosted){
					let currentBoost;
					for (let i in creep.body){
						let part = creep.body[i];
						if (part.boost){
							continue
						}
						if (part.type == 'heal'){
							currentBoost = 'LO';
						} else if (part.type == 'move'){
							currentBoost = 'ZO';
						} else if (part.type == 'tough'){
							currentBoost = 'GO';
						}
					}
					if (!currentBoost){
						creep.memory.boosted = true;
					} else if (homeRoom.memory.sboostlab && homeRoom.memory.sboostlab[currentBoost]){
						let sblab = Game.getObjectById(homeRoom.memory.sboostlab[currentBoost]);
						if (sblab && sblab.boostCreep(creep) == -9){
							creep.moveTo(sblab, {range: 1});
						}
					}
					return
				}
				if (Memory.market && Memory.market.exports){
					let level5s = config$1.level5Commodities;
					let withdraw;
					for (let i in level5s){
						let c = level5s[i];
						if (c && creep.room.terminal.store[c] && Memory.market.exports[c]  && Memory.market.exports[c].volume
								&& Memory.market.exports[c].volume > 0  && Memory.market.exports[c].shard == targetShard){
							withdraw = c;
							break
						}
					}
					if (withdraw && creep.store.getFreeCapacity() > 0){
							let ret = creep.withdraw(creep.room.terminal, withdraw);
						if (ret == -9){
							creep.moveTo(creep.room.terminal, {range: 1, maxRooms: 1});
						} else if (ret === 0){
								let amount = creep.store.getFreeCapacity();
								if (creep.room.terminal.store[withdraw] < amount){
										amount = creep.room.terminal.store[withdraw];
								}
								Memory.market.exports[withdraw].volume -= amount;
						}
					} else if (creep.store.getUsedCapacity() > 0){
						creep.memory.readyToDepart = true;
					}
				} else if (creep.store.getUsedCapacity() > 0){
					creep.memory.readyToDepart = true;
				}
			} else if (targetShard && Game.shard.name != targetShard){
				//goTo portalRoom
				if (portalRoomFlag && portalRoomFlag.pos && creep.room.name != portalRoomFlag.pos.roomName){
					creep.goTo(portalRoomFlag.pos);
				} else {
					let goalNum = Number.parseInt(targetShard.slice(5));
					let currentNum = Number.parseInt(Game.shard.name.slice(5));
					let targetPortalNum = Number.parseInt(Game.shard.name.slice(5));
					goalNum > currentNum ? targetPortalNum++ : targetPortalNum--;
					if (!creep.room.memory.portals){
						let portals = creep.room.find(FIND_STRUCTURES, {filter: (s) => s.structureType == STRUCTURE_PORTAL});
						creep.room.memory.portals = {};
						for (let i in portals){
							let portal = portals[i];
								if (portal.destination.shard && portal.destination.shard === 'shard0' && portal.pos.lookAround(LOOK_FLAGS,0).length === 0){
										continue
								}
							creep.room.memory.portals[portal.destination.shard] = portal.pos.toString();
						}
					}
					let portal = creep.room.memory.portals['shard' + targetPortalNum];
					if (portal){
							if (creep.pos.isNearTo(portal.toPos())){
									creep.move(creep.pos.getDirectionTo(portal.toPos()));
							} else {
									creep.moveTo(portal.toPos(),{range:1});
							}
					}
				}
			}
		} else if (flag && flag.room){
			if (flag.room.terminal){
				if (creep.store.getUsedCapacity() > 0){
						if (creep.room.name !== flag.room.name){
								creep.goTo(flag.room.terminal);
						} else if (!creep.pos.isNearTo(flag.room.terminal)){
								creep.moveTo(flag.room.terminal,{range:1});
						} else {
								for (let i in creep.store){
										creep.transfer(flag.room.terminal, i);
								}
						}
				} else if (flag.room.memory.boostflag){
					let unb = creep.unboost(flag.room);
					if (unb == -5){
						creep.suicide();
					}
				}
			}
		} else if (Game.shard.name == targetShard);
	}



	let spawnCode$G = {
		priority: (room, countFunction) => {
			let priority = 19;
			return priority
		},
		isRequired: (room, countFunction) => {
			if (!room.ecoStable || room.memory.armedHostiles || room.memory.defcon < 5 || room.energyCapacityAvailable < 10000){
				return false
			}
			let traderNum = 0;
				room.display(`trader required ${spawnCode$G.traderRequired(room)}`);
			if (spawnCode$G.traderRequired(room)){
					traderNum = 1;
				//dont spawn if no boost avail
				if (room.memory.sboostlab){
					let neededBoosts = ['LO','GO','ZO'];
						for (let b in neededBoosts){
								let boost = neededBoosts[b];
								if (!room.memory.sboostlab[boost]){
										traderNum = 0;
										break
								} else {
										let sblab = Game.getObjectById(room.memory.sboostlab[boost]);
										if (!sblab || sblab.mineralType !== boost || sblab.store[boost] < 750){
												traderNum = 0;
										}
								}
						}
				} else {
					traderNum = 0;
				}
			} else {
				traderNum = 0;
			}
			return countFunction('trader', room) < traderNum;
		},
			traderRequired: (room) => {
					if (Memory.market && Memory.market.exports && Game.flags['ShardTrade'] && Game.flags['ShardTrade'].pos.roomName && Game.flags['ShardTrade'].pos.roomName == room.name && room.terminal){
							let level5s = config$1.level5Commodities;
							let shards = {};
							//check if we have enough exports to one shard to warrant a trip
							level5s.forEach((c) => {
									console.log(c);
									if (Memory.market.exports[c] && Memory.market.exports[c].volume > 0){
											if (!shards[Memory.market.exports[c].shard]){
													shards[Memory.market.exports[c].shard] = room.terminal.store[c];
											} else {
													shards[Memory.market.exports[c].shard] += room.terminal.store[c];
											}
									}
							});
							for (let s in shards){
									if (shards[s] >= 20){
											Memory.exportShard = s;
											return true
									}
							}
					}
			},
		spawn: (room, role, body) => {
			//decide if we need any other options
			if (body){
				//options -> TTL, creepnumber
				room.spawnCreep(role, body,{creepnumber:Memory.exportShard});
			}
		},
		body: (room, countFunction) => {
			if (room.memory.roadsDown === undefined){
				room.memory.roadsDown = false;
			}
			let key = room.energyCapacityAvailable + ':' + room.memory.roadsDown;
				if (getCachedBody('trader',key)){
						return getCachedBody('trader',key)
				}
			let bodyObject = {
				body: [],
				cost: 0
			};
			//decide on what body to have
			bodyObject.body = (_.repeat('tough ', 7) + _.repeat('heal ', 25) + _.repeat('move ', 17) + 'carry').split(' ');

			if (bodyObject.body && bodyObject.body.length > 0){
				bodyObject.cost += Game.getBodyCost(bodyObject.body);
			}
				cacheBody('trader',key,bodyObject);
			return bodyObject
		}
	};

	var trader = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$1b,
		spawnCode: spawnCode$G
	});

	let compressDictionary = {
			RESOURCE_UTRIUM : RESOURCE_UTRIUM_BAR,
			RESOURCE_LEMERGIUM : RESOURCE_LEMERGIUM_BAR,
			RESOURCE_ZYNTHIUM:RESOURCE_ZYNTHIUM_BAR,
			RESOURCE_KEANIUM:RESOURCE_KEANIUM_BAR,
			RESOURCE_GHODIUM:RESOURCE_GHODIUM_MELT,
			RESOURCE_OXYGEN:RESOURCE_OXIDANT,
			RESOURCE_HYDROGEN:RESOURCE_REDUCTANT,
			RESOURCE_CATALYST:RESOURCE_PURIFIER,
			RESOURCE_ENERGY:RESOURCE_BATTERY
	};
	let decompressDictionary = {
			RESOURCE_UTRIUM_BAR:RESOURCE_UTRIUM,
			RESOURCE_LEMERGIUM_BAR:RESOURCE_LEMERGIUM,
			RESOURCE_ZYNTHIUM_BAR:RESOURCE_ZYNTHIUM,
			RESOURCE_KEANIUM_BAR:RESOURCE_KEANIUM,
			RESOURCE_GHODIUM_MELT:RESOURCE_GHODIUM,
			RESOURCE_OXIDANT:RESOURCE_OXYGEN,
			RESOURCE_REDUCTANT:RESOURCE_HYDROGEN,
			RESOURCE_PURIFIER:RESOURCE_CATALYST,
			RESOURCE_BATTERY:RESOURCE_ENERGY
	};

	const interShardTradeAdjust = 3.5;
	const level5InterShardTradeAdjust = 5;
	function runMarketManager(){
			if (Game.market.credits < config$1.minCredits*0.5 || !config$1.marketActive){
					//console.log('market code unprofitable')
					return
			}
			if (Game.time % 100 !== 0){
					return
			}
			if (!config$1.marketActive){
					return
			}
			let now = Date.now();
			let time = new Date(now);
			let hours = time.getHours();
			if (!Memory.market || !Memory.market.buy || !Memory.market.sell){
					Memory.market = {
							resources: {},
							buy: {},
							sell: {}
					};
			}
			if ( !Memory.market.lastChecked || (Memory.market.lastChecked != hours)){
					//powerbank data report once daily
					Game.notify('Power banks');
					Game.notify(JSON.stringify(Memory.powerBanks));
					let activeShardData = {};
					if (config$1.activeShards && config$1.official && InterShardMemory){
							for (let i in config$1.activeShards){
									let shardName = config$1.activeShards[i];
									let mem = InterShardMemory.getRemote(shardName);
									let parsedMem;
									if (mem){
											parsedMem = JSON.parse(mem);
									}
									if (parsedMem){
											activeShardData[shardName] = parsedMem.valuables;
									}
							}
					}
					Memory.market = {
							resources: {},
							buy: {},
							sell: {},
							valuables: {},
							exports: {}
					};
					let history = Game.market.getHistory();
					let resources = {};
					for (let i in history){
							let res = history[i].resourceType;
							if (res){
									if (!resources[res]){
											resources[res] = [history[i]];
									} else {
											resources[res].push(history[i]);
									}
							}
					}
					for (let i in resources){
							if (resources[i].length === 0){
									continue
							}
							let resObj = {
									'fn': undefined,
									'w': undefined,
									'd': undefined,
									'sd': undefined,
									'marketIsActive': undefined
							};
							let sort = resources[i].sort((a, b) => {
									if (a.date && b.date){
											let ad = Date.parse(a.date);
											let bd = Date.parse(b.date);
											if (ad && bd){
													return (bd - ad)
											}
									}
							});
							if (sort && sort.length > 0){
									//calculate day,week and fortnight avg price so we can use overlap to make market decisions
									let dArr = sort.slice(0, 1);
									let wArr = sort.slice(0, 7);
									resObj.w = findAverage(wArr);
									resObj.d = findAverage(dArr);
									resObj.fn = findAverage(sort);
									//calculate SD of the average prices over fortnight to workout volatility of the average price,
									//we want this high enough to allow profitability (base of energy price for buy and sell or 10% tax on buy and sell orders)
									resObj.sd = findSD(sort);
									resObj.marketIsActive = isActive(sort, i);
							}
							Memory.market.resources[i] = resObj;
					}
					//need to decide if worth buying and selling, only if stddev is enough, profit > transaction cost, market is active, fn is less than w and d for sell and vice versa
					for (let i in Memory.market.resources){
							let res = Memory.market.resources[i];
							//check enough volatility to make money
							let energyPrice = Memory.market.resources['energy'].w;
							if (res.marketIsActive){
									let wDif = res.d - res.w;
									//let fnDif = res.d - res.fn
									//need make over energy price per sale which is the may transfer cost
									let difReq = energyPrice;
									if (wDif > 0 && wDif > difReq){
											//day av is higher than other avs meaning price isup so sell!
											let price = res.fn + difReq;
											Memory.market.sell[i] = price;
									}
									if (wDif < 0 && wDif < (-difReq)){
											//day av is lower than other avs meaning price isup so sell!
											let price = res.fn - difReq;
											Memory.market.buy[i] = price;
									}
							}
							let importNeeded = false;
							if ((Memory.productionMandate && Memory.productionMandate[i]) ||  (Memory.mineralsNeeded && Memory.mineralsNeeded[i])
							|| (Memory.urgentBoostProductionNeeded && Memory.urgentBoostProductionNeeded[i])){
									importNeeded = true;
							}
							if (i !== 'energy' && allOrders && !INTERSHARD_RESOURCES.includes(i) && res.w && (res.w > energyPrice * 5 || importNeeded)){
									//decide if worth importing or not -> need a price of at least 5x energy to even consider as we will pay 1 energy per resource for at least two orders
									//plus any addition transfer and transport of resources, and we need at least this amount just for profit -> this will save us processing cheap unprofitable resources
									let sellTos = allOrders.filter((o) => o.resourceType == i && o.type == 'buy'
											&& (!Game.rooms[o.roomName] || !Game.rooms[o.roomName].controller || !Game.rooms[o.roomName].controller.my));
									let price = res.w;
									if (importNeeded && Game.market.credits >  config$1.maxCredits){
											let adjust = (Game.market.credits/config$1.maxCredits)/5;
											if (adjust > 0.5){
													adjust = 0.5;
											}
											price *= (1+adjust);
									}
									let volume = 0;
									if (sellTos && sellTos.length > 0){
											for (let o in sellTos){
													let order = sellTos[o];
													volume += order.remainingAmount;
											}
									}
									if (volume > 100000){
											volume = 100000;
									}
									if (importNeeded && volume < 10000){
											volume = 10000;
									}
									if (Game.flags['ShardTrade'] && Game.flags['ShardTrade'].room){
											let shardRoom = Game.flags['ShardTrade'].room;
											if (shardRoom.total(i) > 0){
													volume -= shardRoom.total(i);
											}
									}
									let amountNeeded = 3000*Memory.myRooms.length;
									let level5 = false;
									if (COMMODITIES && COMMODITIES[i] && COMMODITIES[i].level){
											switch(COMMODITIES[i].level){
													case 5:
															amountNeeded = 70;
															volume = 70;
															level5 = true;
															break;
													case 4:
															amountNeeded = 100;
															break;
													case 3:
															amountNeeded = 100;
															break;
													case 2:
															amountNeeded = 500;
															break
													case 1:
															amountNeeded = 1000;
											}
									} else if (config$1.minerals.includes(i)){
											amountNeeded = ((config$1.mineralTarget+config$1.excess)/2)*Memory.myRooms.length;
									}
									if (volume > 0){
											if (level5 || Memory.market.resources[i].marketIsActive || importNeeded){
													let amountRequiredForImport = amountNeeded-Game.getResourceTotal(i);
													if (volume > amountRequiredForImport){
															volume = amountRequiredForImport;
													}
													if (Memory.importsToSell && Memory.importsToSell[i] && (Memory.importsToSell[i]/Memory.myRooms.length) > 1000 && Memory.importsToSell[i] > 3000){
															//still trying to sell this thing - don't import
															volume = 0;
															continue
													}
													if (volume <= 0){
															continue
													}
													Memory.market.valuables[i] = {price: price, volume: volume};
											}
									}
							}
					}
					let allRoomNames = [];
					for (let i in Game.rooms){
							let room = Game.rooms[i];
							if (room.controller && room.controller.my && room.class == 'normal'){
									allRoomNames.push(room.name);
							}
					}
					//save the list of expensive resources that may be profitable to intershard trade
					//find centre,middle, average room position
					let avRoomPosition = averageRooms(allRoomNames);
					Memory.market.averageRoomName = avRoomPosition;
					Memory.market.lastChecked = hours;
			}
			if (config$1.official){
					let interMem = JSON.parse(InterShardMemory.getLocal());
					let day = Memory.market.lastChecked;
					if (!interMem){
							return
					}
					if (!interMem.date || interMem.date != day){
							interMem.date = day;
							interMem.valuables = Memory.market.valuables;
							interMem.exports = Memory.market.exports;
							InterShardMemory.setLocal(JSON.stringify(interMem));
					} else if (Game.time % 100 === 0 && interMem && config$1.activeShards){
							let ourBlockTime;
							if (Memory.blockTraders){
									ourBlockTime = Memory.blockTraders;
							}
							for (let i in config$1.activeShards){
									let shardName = config$1.activeShards[i];
									let mem = InterShardMemory.getRemote(shardName);
									let parsedMem;
									if (mem){
											parsedMem = JSON.parse(mem);
									}
									if (parsedMem){
											let otherBlockTime = parsedMem.blockTraders;
											if (otherBlockTime && otherBlockTime > ourBlockTime){
													ourBlockTime = otherBlockTime;
											}
									}
							}
							if (ourBlockTime){
									interMem.blockTraders = ourBlockTime;
									InterShardMemory.setLocal(JSON.stringify(interMem));
							}
					}
			}
			if (config$1.activeShards && config$1.official && InterShardMemory &&
					(!Memory.market.exports || !Memory.market.lastExportCheck || (Memory.market.lastExportCheck != hours))){
					Memory.market.exports = {};
					let activeShardData = {};
					for (let i in config$1.activeShards){
							let shardName = config$1.activeShards[i];
							let mem = InterShardMemory.getRemote(shardName);
							let parsedMem;
							if (mem){
									parsedMem = JSON.parse(mem);
							}
							if (parsedMem){
									activeShardData[shardName] = parsedMem.valuables;
							}
					}
					for (let i in Memory.market.resources){
							let res = Memory.market.resources[i];
							if (INTERSHARD_RESOURCES.includes(i)){
									continue
							}
							if ((Memory.productionMandate && Memory.productionMandate[i])
									|| (Memory.mineralsNeeded && Memory.mineralsNeeded[i])){
									//need to keep this item for our eco
									continue
							}
							//check enough volatility to make money
							let energyPrice = Memory.market.resources['energy'].w;
							//check if we can export the resource
							if (config$1 && config$1.activeShards){
									for (let s in config$1.activeShards){
											let shardName = config$1.activeShards[s];
											let resourceData = activeShardData[shardName];
											if (resourceData && resourceData[i] && shardName != Game.shard.name){
													//look at the other shards price for this valuable and export if difference is high enough
													let price = resourceData[i].price;
													//adjust price to factor the fact we will be buying slightly high and selling slightly low given buy/sell orders have a gap - need to make it slightly more profitable
													let adjust = 1.04;
													let volume = resourceData[i].volume;
													let energyAdjust = interShardTradeAdjust;
													let level5 = false;
													if (config$1.level5Commodities && config$1.level5Commodities.includes(i)){
															energyAdjust = level5InterShardTradeAdjust;
															level5 = true;
													}
													let priceNeeded = (adjust*(res.w + (energyPrice * energyAdjust)));
													if (level5){
															priceNeeded += 30000;
													}
													if (price && res.w && price > priceNeeded){
															if (!Memory.market.exports[i] ||
																	(price && price > Memory.market.exports[i].price)){
																	Memory.market.exports[i] = {
																			shard: shardName,
																			price: price,
																			volume: volume
																	};
															}
													}
											}
									}
							}
					}
					Memory.market.lastExportCheck = hours;
			}
			//also scan for opportunities to buy and sell simultaneously if overlap in market
			if (Game.time % 500 == 0 && allOrders){
					Memory.market.overlap = {};
					Memory.market.compress = {};
					Memory.market.decompress = {};
					allOrders = Game.market.getAllCachedOrders();
					if (Memory.market && Memory.market.resources && Memory.market.resources['energy'] && Memory.market.resources['energy'].w){
							Memory.market.resources['energy'].w;
					} else if (Memory.market && Memory.market.resources && Memory.market.resources['energy'] && Memory.market.resources['energy'].d){
							Memory.market.resources['energy'].d;
					}
					for (let i in Memory.market.resources){
							let res = i;
							let bulkAmount = 1000;
							//orders that we sell to!!
							let sellTos = allOrders.filter((o) => o.resourceType == res && o.type == 'buy' && o.remainingAmount >= bulkAmount
									&& (!Game.rooms[o.roomName] || !Game.rooms[o.roomName].controller || !Game.rooms[o.roomName].controller.my));
							//orders that we buyFrom!
							let buyFroms = allOrders.filter((o) => o.resourceType == res && o.type == 'sell' && o.remainingAmount >= bulkAmount
									&& (!Game.rooms[o.roomName] || !Game.rooms[o.roomName].controller || !Game.rooms[o.roomName].controller.my));
							for (let j in sellTos){
									let avRoom = Memory.market.averageRoomName;
									if (avRoom){
											let O = sellTos[j];
											if (O && O.roomName){
													O.adjPrice = O.price - (Game.market.calcTransactionCost(bulkAmount, avRoom, O.roomName) / bulkAmount);
											}
									}
							}
							for (let j in buyFroms){
									let avRoom = Memory.market.averageRoomName;
									if (avRoom){
											let O = buyFroms[j];
											if (O && O.roomName){
													O.adjPrice = O.price + (Game.market.calcTransactionCost(bulkAmount, avRoom, O.roomName) / bulkAmount);
											}
									}
							}
							//want to buy low sort sort descending ->lowest at end -> LOOK AT THE SELL ORDERS TO BUY FROM
							let buys = buyFroms.sort((a, b) => {
									return b.adjPrice - a.adjPrice

							});
							//want to sell high sort sort ascending-> find price of highest sale
							let highestSell = sellTos.sort((a, b) => {
									return a.adjPrice - b.adjPrice
							})[0];
							if (buys.length == 0 || !highestSell){
									continue
							}
							let lastEl;
							if (buys.length > 1){
									lastEl = buys.pop();
							} else {
									lastEl = buys[0];
							}
							let minSellPrice = lastEl.adjPrice;
							let targetOrders = [];
							while (lastEl && lastEl.adjPrice < highestSell.adjPrice){
									if (lastEl.adjPrice < highestSell.adjPrice){
											targetOrders.push(lastEl.id);
											lastEl = buys.pop();
									} else {
											break
									}
							}
							if (minSellPrice && targetOrders.length > 0){
									Memory.market.overlap[res] = {
											minSellPrice: highestSell.adjPrice,
											targetBuyOrders: targetOrders
									};
							}
					}
					//check if any compressing or decompressing is worth while
					const compressables = ['utrium_bar', 'lemergium_bar', 'zynthium_bar', 'keanium_bar', 'ghodium_melt', 'oxidant', 'reductant', 'purifier', 'battery'];
					for (let i in compressables){
							let commodity = compressables[i];
							let components = COMMODITIES[commodity].components;
							let vol = COMMODITIES[commodity].amount;
							if (!Memory.market.resources[commodity]){
									continue
							}
							let commCost = Memory.market.resources[commodity].d * COMMODITIES[commodity].amount;
							let compCost = 0;
							for (let c in components){
									if (Memory.market.resources[c]){
											compCost += components[c] * Memory.market.resources[c].d;
											vol += components[c];
									}
							}
							let dif = commCost - compCost;
							if (Math.abs(dif) > Memory.market.resources['energy'].d * vol){
									if (dif > 0){
											//commodity is more than components -> compress
											Memory.market.compress[commodity] = [Math.abs(dif), Memory.market.resources['energy'].d * vol];
									} else {
											//decompress
											Memory.market.decompress[commodity] = [Math.abs(dif), Memory.market.resources['energy'].d * vol];
									}
							}
					}

					//commodity prices
					let level5 = config$1.level5Commodities;
					let prices = {};
					for (let c in level5){
							let com = level5[c];
							setPrices$1(com, prices);
					}
					Memory.commodities.prices = prices;
					for (let c in level5){
							let com = level5[c];
							setRawPrices(com);
					}
			}
			//if overlap or compress/decompress -> create a mandate
			//compress/decompress only once market order is confirmed as complete -> only have one mandate for each thing at a time
			//overlap -> only process sell once buy has been confirmed
			//sell and buy trends -> try to limit sale except when meeting these -> use minerals for boosts and producing bars for commodities

	}

	let allOrders;
	let baseCommodities = ['H', 'O', 'Z', 'K', 'U', 'L', 'G', 'X', 'energy', 'alloy', 'mist', 'sillicon', 'biomass'];

	function setRawPrices(commodity){
			//+ Memory.market.resources['energy'].w*Math.ceil(compAmount-Math.exp(-1)) adjusts for av energy price for transfers
			let com = COMMODITIES[commodity];
			if (com){
					let rawPrice = 0;
					for (let i in com.components){
							let compAmount = com.components[i];
							if (!baseCommodities.includes(i) && Memory.commodities.prices[i]){
									//not a base commodity so recurse on down the chain
									if (Memory.commodities.prices[i].rawPrice){
											rawPrice += Memory.commodities.prices[i].rawPrice * compAmount + Memory.market.resources['energy'].d * Math.ceil(compAmount - Math.exp(-1));
									} else {
											rawPrice += setRawPrices(i) * compAmount + Memory.market.resources['energy'].d * Math.ceil(compAmount - Math.exp(-1));
									}
							} else {
									//base commodity
									let price;
									if (Memory.market.resources[i] && Memory.market.resources[i].d){
											price = Memory.market.resources[i].d;
									} else if (Memory.market.resources[i] && Memory.market.resources[i].w){
											price = Memory.market.resources[i].w;
									} else if (Memory.market.resources[i] && Memory.market.resources[i].guess){
											price = Memory.market.resources[i].guess;
									}
									rawPrice += price * compAmount + Memory.market.resources['energy'].d * Math.ceil(compAmount - Math.exp(-1));
							}
					}
					//remember to divide rawPrice by the amount produced per reaction
					rawPrice = rawPrice / com.amount;
					Memory.commodities.prices[commodity].rawPrice = rawPrice;
					Memory.commodities.prices[commodity].rawProfit = Memory.commodities.prices[commodity].avPrice - rawPrice;
					return rawPrice
			}
	}

	function setPrices$1(commodity, cache){
			let com = COMMODITIES[commodity];
			if (com && !baseCommodities.includes(commodity)){
					let amount = com.amount;
					let costBasedOnComponents = 0;
					let error = false;
					for (let i in com.components){
							let price;
							if (Memory.market.resources[i] && Memory.market.resources[i].w){
									price = Memory.market.resources[i].w;
							} else if (Memory.market.resources[i] && Memory.market.resources[i].guess){
									price = Memory.market.resources[i].guess;
							} else if (allOrders){
									//set guess as the highest buy price as this is closest to actual price (no one will sell to low price for high value commodities)
									let orders = allOrders.filter((o) => (o.type == 'buy' && o.resourceType == i));
									orders = orders.sort((a, b) => b.price - a.price);
									if (orders[0]){
											price = orders[0].price;
									}
							}
							if (price){
									let newPrice = price * com.components[i];
									//newPrice does not reflect transfer costs so we need to add on this -> use 30 room distance as margin of error
									newPrice += Memory.market.resources['energy'].w * Math.ceil(com.components[i] - Math.exp(-1));
									costBasedOnComponents += newPrice;
							} else {
									error = true;
							}
							setPrices$1(i, cache);
					}
					costBasedOnComponents = costBasedOnComponents / amount;
					if (!error && Memory.market.resources[commodity] && Memory.market.resources[commodity].w){
							cache[commodity] = {
									costBasedOnComps: costBasedOnComponents,
									avPrice: Memory.market.resources[commodity].w,
									profit: Memory.market.resources[commodity].w - costBasedOnComponents
							};
					} else if (!error && Memory.market.resources[commodity] && Memory.market.resources[commodity].guess){
							cache[commodity] = {
									costBasedOnComps: costBasedOnComponents,
									avPrice: Memory.market.resources[commodity].guess,
									profit: Memory.market.resources[commodity].guess - costBasedOnComponents
							};
					}
			}
	}

	function toCoOrds(roomName){
			let arr = roomName.match(/(\D|\d+)/g);
			let x;
			let y;
			if (arr[0] == 'W'){
					x = -Number.parseInt(arr[1]);
			} else {
					x = Number.parseInt(arr[1]);
			}
			if (arr[2] == 'S'){
					y = -Number.parseInt(arr[3]);
			} else {
					y = Number.parseInt(arr[3]);
			}
			return [x, y]
	}

	function averageRooms(arr){
			let xs = [];
			let ys = [];
			for (let i in arr){
					let cos = toCoOrds(arr[i]);
					xs.push(cos[0]);
					ys.push(cos[1]);
			}
			let x = Math.abs(Math.round(averageArr(xs)));
			let y = Math.abs(Math.round(averageArr(ys)));
			let l1 = 'E';
			let l2 = 'N';
			if (x < 0){
					l1 = 'W';
			}
			if (y < 0){
					l2 = 'S';
			}
			//console.log('average roomPos',l1+Number.parseInt(x)+l2+Number.parseInt(y))
			return (l1 + Number.parseInt(x) + l2 + Number.parseInt(y))
	}

	function averageArr(arr){
			let sum = 0;
			for (let i in arr){
					sum += arr[i];
			}
			return sum / arr.length
	}

	function isActive(objArr, resource){
			let total = 0;
			for (let i in objArr){
					let val = objArr[i].transactions;
					if (val === 0){
							return false
					}
					total += val;
			}
			if (total < 700){
					//50 transactions a day
					return false
			}
			if (!allOrders){
					allOrders = Game.market.getAllCachedOrders();
			}
			let buyOs = allOrders.filter((o) => o.resourceType == resource && o.type == 'buy').length;
			let sellOs = allOrders.filter((o) => o.resourceType == resource && o.type == 'sell').length;
			if (buyOs < 1 || sellOs < 1){
					return false
			}
			return true
	}

	function findSD(objArr){
			//http://www.talkstats.com/threads/an-average-of-standard-deviations.14523/
			let top = 0;
			let bottom = 0;
			let count = 0;
			for (let i in objArr){
					if (!objArr[i].transactions){
							continue
					}
					top += ((objArr[i].transactions - 1) * Math.pow(objArr[i].stddevPrice, 2));
					bottom += objArr[i].transactions;
			}
			return Math.sqrt(top / (bottom - count))
	}

	function findAverage(objArr){
			//by converting using vol with the avg price we take into account days with more/less vol
			let array = [];
			if (objArr){
					for (let i in objArr){
							if (!objArr[i]){
									continue
							}
							if (objArr.length > 0 && (objArr[i].stddevPrice<objArr[i].avgPrice || objArr[i].resourceType === 'energy')){
									//want to exclude days where likely manipulation or trades affecting price
									//especially imporant in global
									array.push([objArr[i].volume, objArr[i].avgPrice]);
							}
					}
			}
			if (array && array.length > 0 && array[0] && array[0].length > 0){
					let totalVol = 0;
					let totalPrice = 0;
					for (let i in array){
							totalVol += array[i][0];
							totalPrice += (array[i][0] * array[i][1]);
					}
					if (totalVol && totalPrice){
							return totalPrice / totalVol;
					} else {
							console.log('finding average error',totalPrice,totalVol);
					}
			} else {
					console.log('finding average error 2',array);
			}
	}

	function run$1a (creep){
			if (Game.time % 1500 == 0){
					delete creep.memory.hostile;
			}
			creep.room.name;
			var homeRoom = Game.rooms[creep.name.split(' ')[2]];
			var targetroom = Game.rooms[creep.name.split(' ')[1]];
			let target;
			if (targetroom){
					target = targetroom.controller;
					if (target && target.my){
							delete homeRoom.memory.remoteRooms[targetroom.name];
					}
			}
			if (target && target.reservation && target.reservation.ticksToEnd > 3000){
					if (homeRoom.memory.remoteRooms && homeRoom.memory.remoteRooms[targetroom.name]){
							homeRoom.memory.remoteRooms[targetroom.name].reserveNeeded = false;
					}
			}
			let hostile;
			if (creep.room.memory.armedHostiles){
					hostile = true;
			} else {
					hostile = null;
			}
			if (hostile){
					checkGuardNeeded(creep);
			}
			if (!hostile && creep.memory.inPos){
					let ret = creep.reserveController(target);
					if (ret !== 0){
							delete creep.memory.inPos;
					} else {
							return
					}
			}
			let path = loadPath(homeRoom, creep.name.split(' ')[1]);
			if (!path && target && Game.time % 50 == 0){
					path = savePath(homeRoom, target);
			}
			if (target && Memory.rooms[target.room.name] && Memory.rooms[target.room.name].hostiles){
					delete creep.memory.hostile;
			}
			if (creep.home.memory.remoteRooms[creep.room.name] && creep.home.memory.remoteRooms[creep.room.name].controllerClearNeeded == true){
					console.log('controller clear needed',creep.name.split(' ')[1]);
					return
			}
			if (!creep.memory.hostile){
					let range;
					if (creep.room.name === targetroom && target){
							range = creep.pos.getRangeTo(target);
					}
					if (range && range <= 3){
							creep.memory.nearTarget = true;
					}
					if (path && path.start && path.start.toPos()&& (range === undefined || range > 3) && !creep.memory.nearTarget && (!creep.memory.sPath || !creep.memory.sPath.error)){
							let test = creep.moveUsingSavedPath(path.sPath, path.start.toPos(), target);
							if (test == 'delete'){
									delete creep.home.memory.resPaths[creep.name.split(' ')[1]];
							}
					} else {
							creep.wipePath();
							if (target && creep.room.name != targetroom.name){
									creep.moveTo(target,{range:1});
							} else if (target){
									if (creep.memory.sPath && creep.memory.sPath.error){
											if (creep.home.memory.remoteRooms[creep.room.name] && !creep.memory.controllerCheck){
													let wall = creep.room.controller.pos.lookAround(LOOK_STRUCTURES, 1, {
															filter: (s) => {
																	return s.structureType == STRUCTURE_WALL
															}
													})[0];
													if (wall){
															console.log(`res controller clear + ${creep.room.name}`);
															creep.home.memory.remoteRooms[creep.room.name].controllerClearNeeded = true;
													}
													creep.memory.controllerCheck = true;
											}
									}
									if (creep.pos.isNearTo(target)){
											creep.reserveController(target);
											creep.memory.inPos = true;
									} else {
											creep.moveTo(target, {range: 1});
									}
									if (target && target.reservation && Game && Game.username && target.reservation.username != Game.username){
											if (target.reservation.username === 'Invader'){
													let corePresent = checkForCore(creep);
													if (corePresent){
															creep.memory.role = 'recycle';
													}
											}
											creep.attackController(target);
									} else if (Game.time % 200 === 0 && Memory.sectors && Memory.sectors[creep.home.sector].invaderCore){
											checkForCore(creep,true);
									}
									if (creep.room && creep.room.controller && (!creep.room.controller.sign || (creep.room.controller.sign && creep.room.controller.sign.username && creep.room.controller.sign.username !== Game.username && creep.room.controller.sign.username !== "Screeps"))){
											creep.signController(creep.room.controller, `${Game.username} territory`);
									}
							} else if (targetroom){
									let pos = new RoomPosition(25,25,creep.name.split(' ')[1]);
									creep.moveTo(pos,{range:15});
							} else {
									let pos = new RoomPosition(25,25,creep.name.split(' ')[1]);
									creep.moveTo(pos,{range:15});
							}
					}
			} else {
					creep.say('hos');
					creep.moveTo(creep.home.controller, {range: 2});
			}

			function savePath(room, controller){
					//start point needs to be walkable
					let spawn = Game.spawns[creep.home.memory.spawn];
					let start = room.getPositionAt(spawn.pos.x, spawn.pos.y - 2);
					let needSKmatrix = false;
					let path = PathFinder.search(start, {pos: controller.pos, range: 1}, {
							plainCost: 1,
							swampCost: 5,
							roomCallback: function (roomName){
									let room = Game.rooms[roomName];
									if (!room) return;
									if (Game.map.isCoreRoom(roomName)){
											return false
									}
									let costs = new PathFinder.CostMatrix;
									if (room && room.memory.upgraderPositions){
											for (let i in room.memory.upgraderPositions){
													let pos = room.memory.upgraderPositions[i].toPos();
													if (pos){
															costs.set(pos.x,pos.y,20);
													}
											}
									}
									room.find(FIND_STRUCTURES).forEach(function (struct){
											if (struct.structureType === STRUCTURE_ROAD){
													// don't favor roads over plain tiles
													costs.set(struct.pos.x, struct.pos.y, 3);
											} else if (struct.structureType !== STRUCTURE_RAMPART ||
													!struct.my){
													// Can't walk through non-walkable buildings
													costs.set(struct.pos.x, struct.pos.y, 0xff);
											}
									});
									if (Game.map.getRoomType(roomName) == 'SK'){
											costs = Game.map.getSKMatrix(roomName);
											if (!costs){
													needSKmatrix = true;
											}
									}
									room.find(FIND_EXIT).forEach((e) => {
											if (e.oppositeEdge() && Memory.ownedRooms[e.oppositeEdge().roomName]){
													costs.set(e.x, e.y, 0xff);
											}
									});
									room.find(FIND_CONSTRUCTION_SITES).forEach((s) => {
											if (s.my && s.structureType != STRUCTURE_ROAD && s.structureType != STRUCTURE_CONTAINER && s.structureType != STRUCTURE_RAMPART){
													costs.set(s.pos.x, s.pos.y, 0xff);
											}
									});
									return costs;
							},
					});
					if (path.incomplete || needSKmatrix){
							return null
					}
					//serialize
					let sPath = PathFinder.serializePath(start, path);
					//save, with an expiry in order to ensure fresh paths
					room.memory.resPaths[targetroom.name] = {
							path: {
									sPath: sPath,
									start: start.toString(),
									end: path.path[path.path.length - 1].toString()
							},
							expiry: Game.time + 10000
					};
					//path obj needs serialized path as well as a start pos and end pos
					return path
			}

			function loadPath(room, targetroomname){
					if (!room.memory.resPaths){
							room.memory.resPaths = {};
					}
					if (creep.memory.sPath && creep.memory.sPath.error){
							if (creep.memory.sPath.error == 'structure'){
									delete room.memory.resPaths[targetroomname];
									return null
							}
					}
					let mem = room.memory.resPaths[targetroomname];
					if (mem && mem.path && mem.expiry > Game.time){
							return mem.path
					} else {
							return null
					}
			}
	}

	let spawnCode$F = {
			priority: (room, countFunction) => {
					let priority = 44;
					if (countFunction('remoteminer', room) > 2 && countFunction('yak', room) > 2){
							priority -= 5;
					}
					if (room.energyAvailable < room.energyCapacityAvailable*0.7 || (room.memory.lastReserveSpawn && (Game.time - room.memory.lastReserveSpawn)>30)){
							//reduce chance of a reserve creep costing us spawn time
							priority = 60;
					}
					return priority
			},
			isRequired: (room, countFunction) => {
					if ((room.memory.armedHostiles && (!room.justInvader || !room.ecoStable))|| room.memory.underHarassment || room.memory.defcon < 4 || !canSpawnReserves(room)){
							return false
					}
					let required = false;
					loop:
							if (room.memory.remoteRooms){
									for (let r in room.memory.remoteRooms){
											if (room.memory.remoteRooms[r].reserveNeeded == true && Game.rooms[r]){
													let accessible = room.checkRemoteIsAccessible(r);
													let distance = 100;
													if (room.memory.remoteRooms[r].route){
															distance = room.memory.remoteRooms[r].route.length*50;
													}
													let numberNeeded = 1;
													if (Game.rooms[r] && Game.rooms[r].controller && room.controller.level < 7 &&
															(!Game.rooms[r].controller.reservation || Game.rooms[r].controller.reservation.ticksToEnd<100)){
															let body = spawnCode$F.body(room).body;
															if (body.length < 3){
																	let ns = Game.rooms[r].controller.pos.neighbours(1);
																	let freeSpaces = 0;
																	for (let n in ns){
																			if (ns[n].getTerrain() !== 'wall'){
																					freeSpaces++;
																			}
																			if (freeSpaces > 1){
																					numberNeeded = 2;
																					break
																			}
																	}
															}
													}
													if (accessible && room.creepList && room.creepList.filter((c) => c.name.split(' ')[0] == 'reserve' && (c.body.length > 2 || c.ticksToLive > (50+distance)) && c.name.split(' ')[1] == r).length < numberNeeded){
															required = r;
															break loop
													}
											}
									}
									required = null;
							} else {
									required = null;
							}
					return required
			},
			spawn: (room, role, body) => {
					//decide if we need any other options
					if (body && spawnCode$F.isRequired(room)){
							//options -> TTL, creepnumber
							room.spawnCreep(role, body, {creepnumber: spawnCode$F.isRequired(room)});
					}
			},
			body: (room, countFunction) => {
					if (room.memory.roadsDown === undefined){
							room.memory.roadsDown = false;
					}
					let bodyObject = {
							body: [],
							cost: 0
					};
					//decide on what body to have
					bodyObject.body = room.makeBody([CLAIM], false,{maxParts:12});
					let smallReservesNeeded = false;
					if (room.memory.remoteRooms && room.sector && Memory.sectors && Memory.sectors[room.sector] && Memory.sectors[room.sector].invaderCore){
							for (let i in room.memory.remoteRooms){
									if (room.memory.remoteRooms[i] && room.memory.remoteRooms[i].smallReserve && room.memory.remoteRooms[i].smallReserve > Game.time){
											//reduces reserve size if invader cores are close enough to our rooms
											smallReservesNeeded = true;
									}
							}
					}
					if (!config.conserveCpu || (!room.ecoStable && room.controller.level > 4) || smallReservesNeeded){
							let maxParts = 2*Math.floor((room.energyCapacityAvailable*0.6)/650);
							if (maxParts<2){
									maxParts = 2;
							}
							bodyObject.body = room.makeBody([CLAIM], false, {maxParts: maxParts});
					}
					if (config.swampyGround && room.energyCapacityAvailable >= 850){
							bodyObject.body = room.makeBody([CLAIM, MOVE, MOVE, MOVE, MOVE, MOVE], false, {noMove: true});
					}
					if (room.energyCapacityAvailable === 650){
							bodyObject.body = [CLAIM,MOVE];
					}
					if (bodyObject.body && bodyObject.body.length > 0){
							bodyObject.cost += Game.getBodyCost(bodyObject.body);
					}

					return bodyObject
			}
	};
	function canSpawnReserves(room){
			return room.energyCapacityAvailable >= 650;
	}

	var reserve = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$1a,
		spawnCode: spawnCode$F,
		canSpawnReserves: canSpawnReserves
	});

	//todo also cache room status eg closed
	//todo add quad entry points
	function findCustomRoute(startRoomName,targetRoomName,SKAvoid,quad){
			{
					let homePos = new RoomPosition(0, 0, startRoomName);
					Game.map.visual.rect(homePos, 50, 50, {fill: '#5fff33'});
			}
			let fScore = {};
			let queue = new BinaryTree((a,b) => fScore[a] < fScore[b]);
			let cameFrom = {};
			let gScore = {};
			let rangeAdjust = 5;
			gScore[startRoomName] = 0;
			let visited = {};
			fScore[startRoomName] = Game.map.getRoomLinearDistance(startRoomName,targetRoomName)*rangeAdjust;
			queue.push(startRoomName);
			while (!queue.isEmpty()){
					let current = queue.pop();
					if (current){
							if (current === targetRoomName){
									{
											let homePos = new RoomPosition (0,0,targetRoomName);
											Game.map.visual.rect(homePos,50,50,{fill:'#f09e0f'});
									}
									let route = assembleRoute(current);
									return route
							}
							let neighbours = Game.map.describeExits(current);
							if (Memory.portals && Memory.portals[current]){
									for (let i in Memory.portals[current]){
											if (i && i.slice(0,5) !== 'shard'){
													neighbours[i] = i;
											}
									}
							}
							visited[current] = true;
							let avoidRooms = [];
							if (quad && Memory.quadEntryPoints && Memory.quadEntryPoints[targetRoomName] && Memory.quadEntryPoints[targetRoomName].positions){
									let exitRooms = Game.map.describeExits(targetRoomName);
									let canEnter = {};
									for (let i in Memory.quadEntryPoints[targetRoomName].positions){
											let pos = Memory.quadEntryPoints[targetRoomName].positions[i].toPos();
											if (pos && pos.roomName && !canEnter[pos.roomName]){
													canEnter[pos.roomName] = true;
											}
									}
									for (let i in exitRooms){
											if (!canEnter[exitRooms[i]]){
													avoidRooms.push(exitRooms[i]);
											}
									}
							}
							for (let i in neighbours){
									let roomName = neighbours[i];
									if (!visited[roomName]){
											let status = Game.map.getRoomStatus(roomName).status;
											if (status !== 'normal' && (SKAvoid && Game.map.getRoomType(roomName) === 'SK')){
													visited[roomName] = true;
													continue
											}
											{
													let homePos = new RoomPosition(0, 0, roomName);
													Game.map.visual.rect(homePos, 50, 50, {fill: '#FF6633'});
											}
											let roomScore = 2;
											if (Game.map.getRoomType(roomName) === 'highway'){
													roomScore = 1;
											}
											if ((Memory.dangerRooms && Memory.dangerRooms[roomName]) || avoidRooms.includes(roomName) ){
													roomScore = 10;
											}
											if (Memory.ownedRooms && Memory.ownedRooms[roomName] && (!config.canPassThroughRooms.includes(roomName) && roomName !== targetRoomName)){
													roomScore = 20;
											}
											//add room priority here eg promote our rooms and highways
											let tentativeGScore = gScore[current]+roomScore;
											if (!gScore[roomName] || tentativeGScore < gScore[roomName]){
													let range = Game.map.getRoomLinearDistance(roomName,targetRoomName)*rangeAdjust;
													fScore[roomName] = tentativeGScore + range;
													if (!gScore[roomName]){
															queue.push(roomName);
													} else {
															//rescore value with up to date fScore
															queue.reScoreElement(roomName);
													}
													gScore[roomName] = tentativeGScore;
													cameFrom[roomName] = {lastRoom:current,direction:i};
											}
									}
							}
					} else {
							break
					}
			}
			function assembleRoute(end){
					let next = cameFrom[end];
					let name = end;
					let route = [];
					let count = 0;
					while (next && count < 50){
							count++;
							let dir = next.direction;
							if (dir.length === 1){
									dir = Number.parseInt(next.direction);
							} else {
									dir = 'portal';
							}
							route.splice(0,0,{exit:dir,room:name});
							if (next.lastRoom === targetRoomName){
									break
							}
							name = next.lastRoom;
							next = cameFrom[name];
					}
					if (count === 50){
							console.log('bad custom route',startRoomName,targetRoomName);
					}
					console.log('c',JSON.stringify(route));
					return route
			}
	}

	function goTo(destination, options){
			if (!Memory.profile){
					Memory.profile = {};
			}
			if (!Memory.profile.goTo){
					Memory.profile.goTo = {cpu: 0, count: 0};
			}
			let cpu = Game.cpu.getUsed();
			_goTo(this, destination, options);
			Memory.profile.goTo.cpu += (Game.cpu.getUsed() - cpu);
			Memory.profile.goTo.count++;
	}

	var logs = {};

	function _goTo(creep, destination, options){
			let canSaveRoutes = true;
			if (config.saveRoutes !== undefined){
					canSaveRoutes = config.saveRoutes;
			}
			// if (Game.shard.name !== creep.shard){
			// 		if (destination.pos){
			// 				destination = destination.pos
			// 		} else if (!destination.roomName){
			// 				destination = new RoomPosition(25,25,destination)
			// 		}
			// 		creep._moveTo(destination)
			// 		return;
			// }
			if (!logs.time || logs.time != Game.time){
					logs = {
							time: Game.time,
							errorCount: 0,
							routeCount: 0,
							allCount: 0
					};

			}
			let SKAvoid = false;
			if (!options || !options.SK){
					SKAvoid = true;
			}
			let pos;
			let targetRoomName;
			if (!destination){
					console.log('no dest', creep);
					return
			}
			let quad;
			if (options && options.quad){
					quad = true;
			}
			if (destination.pos){
					targetRoomName = destination.pos.roomName;
					pos = destination.pos;
			} else if (destination.name){
					targetRoomName = destination.name;
			} else if (destination.roomName){
					targetRoomName = destination.roomName;
					pos = destination;
			} else if (typeof destination === 'string'){
					targetRoomName = destination;
			} else {
					//dest is not pos so error#
					console.log('call of goTo not given pos:', arguments[0], arguments[1], arguments[2]);
					return
			}
			if (creep.room.name == targetRoomName && creep.pos.onEdge()){
					let edge = creep.pos.edgeSide();
					creep.move(edge.map8(4));
					return
			}
			if (creep.pos.onEdge() && creep.pos.oppositeEdge().roomName == targetRoomName && creep.pos.oppositeEdge().isWalkable(true)){
					let edge = creep.pos.edgeSide();
					creep.move(edge);
					return
			}
			logs.allCount++;
			let range;
			options && options.range ? range = options.range : range = 0;
			if (options){
					if (options.avoidList){
							options.avoidList;
					}
			}
			if (creep.memory.go == 'ERROR' && !pos){
					logs.errorCount++;
					//console.log(creep, 'go to error', creep.pos, targetRoomName)
					if (creep.pos.onEdge() && creep.pos.roomName != targetRoomName){
							let op = creep.pos.oppositeEdge();
							if (op && op.roomName == targetRoomName){
									if (op.x == 0){
											creep.move(3);
									} else if (op.x == 49){
											creep.move(7);
									} else if (op.y == 0){
											creep.move(5);
									} else {
											creep.move(1);
									}
							}
					}
					let pos = new RoomPosition(25, 25, targetRoomName);
					if (pos){
							creep._moveTo(pos, {range: 10});
					}
					return
			}
			//creep.memory.go is array of rooms to destination
			if (creep.home && creep.home.memory.routes && (!canSaveRoutes || (creep.hits < creep.hitsMax && creep.home && creep.home.memory.routes && creep.home.memory.routes[creep.room.name] && creep.home.memory.routes[creep.room.name].route
			) || Game.map.isCoreRoom(creep.room.name))){
					//console.log('deleting route')
					delete creep.home.memory.routes[targetRoomName];
			}

			if (creep.room.name == targetRoomName){
					if (creep.memory.go){
							creep.pos.highlight('green');
							delete creep.memory.go;
							delete creep.memory.exit;
					}
					if (!pos){
							pos = new RoomPosition(25, 25, targetRoomName);
					}
					if (pos){
							creep.moveTo(pos, {range: range,maxRooms:1});
					}

			} else if (!creep.memory.go || creep.memory.go.length == 0 || !creep.memory.go[creep.memory.go.length - 1] || creep.memory.go[creep.memory.go.length - 1].room != targetRoomName){
					delete creep.memory.exit;
					//find start and route
					//load if saved
					if (creep.home && !creep.home.memory.routes){
							creep.home.memory.routes = {};
					}
					if (canSaveRoutes && (!config.highwayWalls || Game.map.getRoomType(targetRoomName) != 'highway') && creep.home && creep.room.name == creep.home.name && creep.home.memory.routes[targetRoomName]
							&& creep.home.memory.routes[targetRoomName].expiry > Game.time && (!options || !options.freshRoute)){
							//can't used saved path for highway room in case target other side of wall
							let route = creep.home.memory.routes[targetRoomName].route;
							if (route && route.length > 0){
									creep.memory.go = route;
									return
							}
					}
					creep.pos.highlight('yellow');
					if (Game.map.getRoomType(creep.room.name) === 'centre'){
							let portal = creep.pos.lookAround(LOOK_STRUCTURES, 0, {filter: (s) => s.structureType === STRUCTURE_PORTAL && s.pos.lookAround(LOOK_CREEPS, 0).length === 0})[0];
							if (portal){
									let neighbours = creep.pos.neighbours();
									for (let i in neighbours){
											let portal = neighbours[i].lookAround(LOOK_STRUCTURES, 0, {filter: (s) => s.structureType === STRUCTURE_PORTAL})[0];
											if (!portal){
													creep.move(creep.pos.getDirectionTo(neighbours[i]));
													break
											}
									}
							}
					}
					logs.routeCount++;
					let route;
					let startSector;
					if (Game.map.getRoomType(creep.room.name) == 'highway' && config.highwayWalls){
							startSector = Game.map.getSideOfHighwayWall(creep.pos);
							if (startSector === 'open'){
									startSector = Game.map.getSector(creep.room.name);
							}
					} else {
							startSector = Game.map.getSector(creep.room.name);
					}
					let targetSector;
					if (Game.map.getRoomType(targetRoomName) !== 'highway'){
							targetSector = Game.map.getSector(targetRoomName);
					}
					if (config.highwayWalls){
							if (options && options.targetSector){
									targetSector = options.targetSector;
							}
							if (!targetSector && pos && Game.rooms[targetRoomName] && Game.map.getRoomType(targetRoomName) == 'highway'){
									targetSector = Game.map.getSideOfHighwayWall(pos);
									if (targetSector === 'open'){
											targetSector = Game.map.getSector(creep.room.name);
									}
							} else if (!targetSector && Game.map.getRoomType(targetRoomName) == 'highway'){
									let sectors = Game.map.getHighwaySectors(targetRoomName);
									if (sectors){
											for (let i in sectors){
													let current = sectors[i];
													if (Memory.reachableSectors && Memory.reachableSectors[current]){
															targetSector = current;
															break
													}
											}
									}
							}
							if (targetSector && !Memory.reachableSectors[targetSector]){
									//can't get to this sector - don't path
									console.log('eeep', pos, targetSector, 'ts', options.targetSector, creep.name);
									delete creep.memory.go;
									if (creep.role == 'observer');
							} else if (targetSector){
									//find a normal route through accessible sectors
									let queue = [startSector];
									let visited = {};
									visited[startSector] = true;
									let sectorRouteFound = false;
									let count = 50;
									whileLoop:
											while (!sectorRouteFound && queue.length > 0 && count > 0){
													count--;
													let current = queue.shift();
													if (Memory.openHighwayWalls && Memory.openHighwayWalls.sectors && Memory.openHighwayWalls.sectors[current]){
															for (let s in Memory.openHighwayWalls.sectors[current]){
																	if (s == targetSector){
																			visited[s] = current;
																			sectorRouteFound = true;
																			break whileLoop
																	}
																	if (!visited[s]){
																			visited[s] = current;
																			queue.push(s);
																	}
															}
													}
											}

									let passedSectors = [];
									if (startSector != targetSector && sectorRouteFound){
											let current = targetSector;
											let count = 10;
											while (count > 0 && current && current !== true){
													count--;
													passedSectors.splice(0, 0, current);
													current = visited[current];
											}
									}
									//use this route to determine which open walls we need to go through
									let nodeList = [creep.room.name];
									if (startSector === targetSector){
											route = getRoute(creep.room.name, targetRoomName, SKAvoid,quad);
											creep.say('route');
									} else if (passedSectors && passedSectors.length > 1){
											for (let i = 0; i < passedSectors.length - 1; i++){
													let thisS = passedSectors[i];
													let nextS = passedSectors[i + 1];
													if (Memory.openHighwayWalls && Memory.openHighwayWalls.sectors && Memory.openHighwayWalls.sectors[thisS] &&
															Memory.openHighwayWalls.sectors[thisS][nextS]){
															let openWalls = Memory.openHighwayWalls.sectors[thisS][nextS];
															let lastNode = nodeList[nodeList.length - 1];
															if (lastNode){
																	let bestRange, best;
																	for (let i in openWalls){
																			let range = Game.map.getRoomLinearDistance(openWalls[i], lastNode);
																			if (range && (!best || range < bestRange)){
																					best = openWalls[i];
																					bestRange = range;
																			}
																	}
																	if (best){
																			nodeList.push(best);
																	}
															}
													}
											}
											nodeList.push(targetRoomName);
											route = stitchRoute(nodeList, startSector, targetSector);
									}
									//find a route between each of these

									//return in normal route format
							} else {
									console.log(creep.name, targetRoomName, targetSector, 'no target sector');
							}
					} else {
							if ((Game.shard.name === 'shard0' || config.portalTravelEnabled) && Game.map.getRoomLinearDistance(creep.room.name,targetRoomName)>10){
									route = findCustomRoute(creep.room.name,targetRoomName,SKAvoid,quad);
									console.log('route',JSON.stringify(route));
							} else {
									route = getRoute(creep.room.name, targetRoomName, SKAvoid,quad);
							}
					}

					function stitchRoute(arr, startSector, targetSector){
							//pass in arr of rooms, if highway then ensure you include desired sector
							let totalRoute = [];
							let currentSector;
							for (let i = 0; i < arr.length - 1; i++){
									if (arr[i] === arr[i + 1]){
											continue
									}
									if (Game.map.getRoomType(arr[i]) === 'centre' && Game.map.getRoomType(arr[i + 1]) === 'centre'){
											//portal jump
											totalRoute = totalRoute.concat([{room: arr[i + 1], exit: 'portal'}]);
											currentSector = arr[i + 1];
											continue
									}
									let newRoute = getRoute(arr[i], arr[i + 1], SKAvoid,quad);
									if (!currentSector){
											if (arr[i + 1] === targetRoomName && targetSector){
													currentSector = targetSector;
											}
											currentSector = startSector;
									} else {
											let possibleSectors = Game.map.getHighwaySectors(arr[i]);
											for (let j in possibleSectors){
													if (possibleSectors[j] != currentSector){
															currentSector = possibleSectors[j];
															break
													}
											}
									}
									if (newRoute && newRoute != -2){
											for (let j in newRoute){
													newRoute[j].sector = currentSector;
											}
											totalRoute = totalRoute.concat(newRoute);
									} else {
											console.log('bad route');
											return false
									}
							}
							return totalRoute
					}

					if (route != -2){
							if (config.mapVisual){
									let posList = [];
									for (let r in route){
											if (route[r] && route[r].room){
													posList.push(new RoomPosition(25, 25, route[r].room));
											}
									}
									Game.map.visual.poly(posList);
							}
					}
					if (canSaveRoutes && route != -2 && creep.home && creep.room.name === creep.home.name){
							creep.home.memory.routes[targetRoomName] = {
									route: route,
									expiry: Game.time + 3000
							};
							creep.memory.go = route;
							return
					} else if (route != -2){
							if (creep.pos.onEdge() && creep.pos.oppositeEdge().roomName === targetRoomName){
									creep.say(creep.pos.edgeSide());
									let dir = creep.pos.edgeSide();
									creep.move(dir);
									return
							}
							if (route != -2){
									creep.memory.go = route;
							} else {
									creep.memory.go = 'ERROR';
							}
					} else {
							creep.memory.go = 'ERROR';
							creep.memory.goError = {start: creep.room.name, end: targetRoomName};
					}

					if (creep.home && targetRoomName === creep.home.name && canSaveRoutes){
							//load if saved
							if (!creep.home.memory.routes){
									creep.home.memory.routes = {};
							}
							if (creep.home.memory.routes[targetRoomName]){
									let route = creep.home.memory.routes[targetRoomName].route;
									let newRoute = [];
									while (route.length > 0){
											let step = route.pop();
											let newExit = map8$1(step.exit, 4);
											let newRoom;
											if (route.length > 0){
													newRoom = route[route.length - 1].room;
											} else {
													newRoom = creep.home.name;
											}
											newRoute.push({exit: newExit, room: newRoom});
									}
									creep.memory.go = newRoute;
									console.log('goTo', newRoute, creep.pos);

							}

					}

			} else {
					if (creep.memory.exit){
							let pos = creep.memory.exit.toPos();
							if (creep.room.name === pos.roomName){
									creep.moveTo(pos, { range: 0,maxRooms:1});
									return
							}
					}
					let exit = null;
					let sideOfWall = Game.map.getSideOfHighwayWall(creep.pos);
					let sectorFound = false;
					if (!sideOfWall || sideOfWall == 'open'){
							sectorFound = true;
					}
					for (let i = 0; i < creep.memory.go.length; i++){
							if (creep.room.name == creep.memory.go[i].room){
									if (creep.memory.go[i + 1]){
											creep.say('me');
											if (creep.memory.go[i + 1].exit === 'portal'){
													let portal = creep.room.find(FIND_STRUCTURES, {filter: (s) => s.structureType == STRUCTURE_PORTAL && s.pos.lookAround(LOOK_CREEPS, 0).length === 0
																	&& s.destination &&s.destination.roomName && s.destination.roomName === creep.memory.go[i + 1].room})[0];
													if (portal){
															exit = portal.pos;
													}
											} else if (config.highwayWalls && Game.map.getRoomType(creep.room.name) == 'highway'){
													if (sideOfWall != 'open' && creep.memory.go[i].sector && sideOfWall != creep.memory.go[i].sector){
															//not on the right side for this instruction
															continue
													}
													let exits;
													if (Memory.openHighwayWalls && creep.memory.go[i].sector && Memory.openHighwayWalls.rooms && Memory.openHighwayWalls.rooms.includes(creep.room.name)){
															let nextSector = creep.memory.go[i + 1].sector;
															let side;
															let sectors = Game.map.getHighwaySectors(creep.room.name);
															for (let i in sectors){
																	if (sectors[i] == nextSector){
																			side = i;
																			break
																	}
															}
															exits = creep.room.find(creep.memory.go[i + 1].exit, {filter: (e) => e.isWalkable(true)});
															let dir, sign;
															switch (side){
																	case '1':
																			dir = 0;
																			sign = 'y';
																			break;
																	case '5':
																			dir = 49;
																			sign = 'y';
																			break;
																	case '3':
																			dir = 49;
																			sign = 'x';
																			break;
																	case '7':
																			dir = 0;
																			sign = 'x';
																			break;
															}
															exits.sort((a, b) => Math.abs(dir - a[sign]) - Math.abs(dir - b[sign]));
															exit = exits[0];
													} else {
															exits = creep.room.find(creep.memory.go[i + 1].exit, {filter: (e) => e.isWalkable(true)});
															exit = creep.pos.findClosestByPath(exits);
															if (!exit){
																	creep.say('no exit');
															}
													}
											} else {
													let exits = creep.room.find(creep.memory.go[i + 1].exit);
													let nextRoom = creep.memory.go[i + 1].room;
													if (nextRoom && Game.map.getRoomType(nextRoom) == 'SK'){
															let SKMat = Game.map.getSKMatrix(nextRoom);
															if (SKMat){
																	for (let i = exits.length - 1; i > -1; i--){
																			let oppExit = exits[i].oppositeEdge();
																			if (SKMat.get(oppExit.x, oppExit.y) > 10){
																					exits.splice(i, 1);
																			}
																	}
															}
													}
													if (Game.map.getRoomType(creep.room.name) == 'SK'){
															let SKMat = Game.map.getSKMatrix(creep.room.name);
															if (SKMat){
																	for (let i = exits.length - 1; i > -1; i--){
																			let thisExit = exits[i];
																			if (SKMat.get(thisExit.x, thisExit.y) > 10){
																					exits.splice(i, 1);
																			}
																	}
															}
													}
													if (quad && Memory.quadEntryPoints && Memory.quadEntryPoints[nextRoom] && Memory.quadEntryPoints[nextRoom].positions
															&& Memory.quadEntryPoints[nextRoom].positions[creep.memory.go[i + 1].exit.map8(4)]){
															exit = Memory.quadEntryPoints[nextRoom].positions[creep.memory.go[i + 1].exit.map8(4)].toPos();
													}
													if (!exit){
															if (creep.role == 'symbolDecoder' || creep.role === 'caravanHauler' || Game.cpu.bucket > 9000 || creep.role == 'claimer' ||
																	creep.role === 'hybrid' || creep.role === 'sniper' || (creep.room.controller && creep.room.controller.owner)){
																	exit = creep.pos.findClosestByPath(exits);
															} else {
																	exit = creep.pos.findClosestByRange(exits);
															}
													}
											}
											break
									}
							}
					}
					for (let i in creep.memory.go){
							if (!creep.memory.go[i].sector || (sideOfWall && creep.memory.go[i].sector && sideOfWall == creep.memory.go[i].sector)){
									//local path won't have a sector
									sectorFound = true;
							}
					}
					if (config.highwayWalls && Game.map.getRoomType(creep.room.name) == 'highway' && !sectorFound){
							creep.say('delete');
							delete creep.memory.go;
							return
					}
					if (exit){
							creep.moveTo(exit, {range: 0,maxRooms:1});
							creep.memory.exit = exit.toString();
					} else if (creep.memory.go[0].room){
							let exits = Game.map.describeExits(creep.room.name);
							if (creep.memory.go[0].exit === 'portal'){
									let portal = creep.room.find(FIND_STRUCTURES, {filter: (s) => s.structureType == STRUCTURE_PORTAL && s.pos.lookAround(LOOK_CREEPS, 0).length === 0
													&& s.destination &&s.destination.roomName && s.destination.roomName === creep.memory.go[0].room})[0];
									if (portal){
											exit = portal.pos;
									}
									if (exit){
											creep.moveTo(exit, { range: 0,maxRooms:1});
											creep.memory.exit = exit.toString();
											return
									}
							}
							for (let i in exits){
									if (exits[i] == creep.memory.go[0].room){
											if (config.highwayWalls && Game.map.getRoomType(creep.room.name) == 'highway'){
													let exitPos = creep.room.find(Number.parseInt(i), {filter: (e) => e.lookAround(LOOK_CREEPS, 0).length < 1});
													exit = creep.pos.findClosestByPath(exitPos);
											} else {
													let exitPos = creep.room.find(Number.parseInt(i));
													let nextRoom = creep.memory.go[0].room;
													if (nextRoom && Game.map.getRoomType(nextRoom) == 'SK'){
															let SKMat = Game.map.getSKMatrix(nextRoom);
															if (SKMat){
																	for (let i = exits.length - 1; i > -1; i--){
																			let oppExit = exits[i].oppositeEdge();
																			if (SKMat.get(oppExit.x, oppExit.y) > 10){
																					exitPos.splice(i, 1);
																			}
																	}
															}
													}
													if (Game.map.getRoomType(creep.room.name) == 'SK'){
															let SKMat = Game.map.getSKMatrix(creep.room.name);
															if (SKMat){
																	for (let i = exits.length - 1; i > -1; i--){
																			let thisExit = exits[i];
																			if (SKMat.get(thisExit.x, thisExit.y) > 10){
																					exitPos.splice(i, 1);
																			}
																	}
															}
													}
													if (quad && Memory.quadEntryPoints && Memory.quadEntryPoints[nextRoom] && Memory.quadEntryPoints[nextRoom].positions
													&& Memory.quadEntryPoints[nextRoom].positions[Number.parseInt(i).map8(4)]){
															exit = Memory.quadEntryPoints[nextRoom].positions[Number.parseInt(i).map8(4)].toPos();
													}
													if (!exit){
															if (creep.role == 'symbolDecoder' || creep.role == 'claimer' || Game.cpu.bucket > 9000){
																	exit = creep.pos.findClosestByPath(exitPos);
															} else {
																	exit = creep.pos.findClosestByRange(exitPos);
															}
													}
											}
											if (exit){
													creep.moveTo(exit, { range: 0,maxRooms:1});
													creep.memory.exit = exit.toString();
													return
											} else {
													console.log(creep.name, 'should be an exit???', creep.room.name, 'to', creep.memory.go[0].room);
											}
									} else if (Game.map.getRoomType(creep.room.name) === 'centre' && Game.map.getRoomType(creep.memory.go[0].room) === 'centre'){
											exit = creep.room.find(FIND_STRUCTURES, {filter: (s) => s.structureType == STRUCTURE_PORTAL && s.pos.lookAround(LOOK_CREEPS, 0).length === 0})[0];
											if (exit){
													creep.moveTo(exit.pos, { range: 0,maxRooms:1});
													creep.memory.exit = exit.pos.toString();
													return
											} else {
													console.log(creep.name, 'should be an portal???', creep.room.name, 'to', creep.memory.go[0].room);
											}
									}
							}
							if (creep.pos.onEdge()){
									let rand = Math.ceil(Math.random() * 8);
									creep.move(rand);
							} else if (creep.home){
									delete creep.home.memory.routes[targetRoomName];
							}
							creep.pos.highlight('red');
							delete creep.memory.go;
					}
			}
	}

	function map8$1(val, jump){
			let count = jump;
			let ret = Number.parseInt(val);
			while (count != 0){
					if (count < 0){
							ret = ret - 1;
							count = count + 1;
					} else {
							ret = ret + 1;
							count = count - 1;
					}
					if (ret === 9){
							ret = 1;
					}
					if (ret === 0){
							ret = 8;
					}
			}
			return ret
	}

	function getRoute(a, b, SKAvoid,quad){
			let avoidRooms = [];
			if (quad && Memory.quadEntryPoints && Memory.quadEntryPoints[b] && Memory.quadEntryPoints[b].positions){
					let exitRooms = Game.map.describeExits(b);
					let canEnter = {};
					for (let i in Memory.quadEntryPoints[b].positions){
							let pos = Memory.quadEntryPoints[b].positions[i].toPos();
							if (pos && pos.roomName && !canEnter[pos.roomName]){
									canEnter[pos.roomName] = true;
							}
					}
					for (let i in exitRooms){
							if (!canEnter[exitRooms[i]]){
									avoidRooms.push(exitRooms[i]);
							}
					}
			}
			return Game.map.findRoute(a, b, {
					routeCallback(roomName){
							if (!Memory.ownedRooms){
									Memory.ownedRooms = {};
							}
							let sector = Game.map.getSector(roomName);
							if (config.canPassThroughRooms && config.canPassThroughRooms.includes(roomName)){
									return 2
							}
							if (config.highwayWalls && Memory.reachableSectors && !Memory.reachableSectors[sector]){
									return Infinity
							}
							if (Memory.ownedRooms[roomName] && roomName != b && (!config.symbolCollection ||
											!Memory.symbolDecoders || !Memory.symbolDecoders[roomName] || !Memory.symbolDecoders[roomName].canDecode) &&
									(!config.canAccessRooms || !Memory.ownedRooms[roomName].owner || !config.canAccessRooms.includes(Memory.ownedRooms[roomName].owner))){
									return Infinity
							}
							if (Game.map.isCoreRoom(roomName) && roomName != b){
									return Infinity
							}
							if ((Memory.dangerRooms && Memory.dangerRooms[roomName]) || avoidRooms.includes(roomName) ){
									return 20
							}
							if (Game.map.getRoomType(roomName) == 'SK' && SKAvoid && roomName != b){
									return Infinity
							} else if (Game.map.getRoomType(roomName) == 'SK'){
									return 5
							}
							if (Memory.ownedRooms[roomName] && roomName != b){
									//owned room that we can path through
									return 4
							}
							if (Game.map.getRoomType(roomName) == 'highway'){
									if (config.swampyGround){
											return 1
									}
									return 2
							}
							if (config.swampyGround){
									return 5
							}
							return 3
					}
			})
	}

	/* CALLED FROM BUILDING
	 Flag layout:
	 spawn needs to be either horizontal or vertical in line
	 'prayer+supportroomnumber' 
	auto building?
	find array for path possible near controller
	build needed building if they dont exist
	tailor to level
	 */

	function checkIfNeedToPauseInfrastructureDueToHarassment(room){
			if (config$1.pauseRemoteRoads && config$1.pauseRemoteRoads.includes(room.name)){
					return true
			}
			if (room && room.memory.remoteRoadsNeedBuilding && room.memory.remoteRoadsNeedBuilding > Game.time && room.memory.dangerousHostileInRemotes
					&& (Game.time-room.memory.dangerousHostileInRemotes) < 5000){
					return true
			}
			return false
	}
	function sortSources(sources,assignedRoomDistance){
			sources.sort((a, b) => {
					let aDist = a.distance;
					let bDist = b.distance;
					if (assignedRoomDistance && a.assignedRoomDistance){
							aDist = a.assignedRoomDistance;
					}
					if (assignedRoomDistance && b.assignedRoomDistance){
							bDist = b.assignedRoomDistance;
					}
					if (Memory.bigBoiSources && Memory.bigBoiSources[a.pos.toString()]){
							aDist = a.distance * 0.75;
					}
					if (Memory.bigBoiSources && Memory.bigBoiSources[b.pos.toString()]){
							bDist = b.distance * 0.75;
					}
					if (a.SK || a.centre){
							aDist = Math.floor(aDist*0.6);
					}
					if (b.SK || b.centre){
							bDist = Math.floor(bDist*0.6);
					}
					return aDist - bDist
			});
	}
	function cpuBlock$3(){
			if (Game.cpu.bucket < 100 || Game.cpu.getUsed() > 300){
					return true
			}
	}
	let gen;
	let genTick;
	function pushRemotesGenerator(){
					if (gen){
							assignSources();
					}
	}
	function assignSources (){
			if (genTick && genTick === Game.time){
					return
			}
			//allow pausing halfway to avoid crashing due to low cpu
			console.log('assigning sources gen');
			if (Game.cpu.bucket < 100){
					return
			}
			if (!gen){
					gen = _assignSources();
			}
			try {
					let ret = gen.next();
					genTick = Game.time;
					// console.log('extension gen ->',ret.value)
					if (ret.done === true){
							gen = undefined;
					}
			} catch (err){
					console.log(err.stack.split("at"), 'source gen');
					gen = undefined;
			}
	}
	function* _assignSources (){
			console.log('assigning');
			let rooms = _.filter(Game.rooms, (r) => r.controller && r.controller.my === true && (r.class === 'normal' || r.class === 'bunker'));
			let roomObj = {};
			let finalSourceObj = {};
			if (rooms){
					for (let i in rooms){
							if (cpuBlock$3()){
									yield;
							}
							let room = rooms[i];
							let allowedParts = 500;
							let spawns = room.find(FIND_STRUCTURES, {filter: (s) => s.structureType == STRUCTURE_SPAWN && s.my});
							if (spawns){
									allowedParts = spawns.length*500;
							}
							let minus = 90;
							if (room.controller.level === 6){
									minus = 110;
							} else if (room.controller.level === 7){
									minus = 200;
							} else if (room.controller.level === 8){
									minus = 350;
							}
							if (room.class === 'bunker'){
									minus += 100;
							}
							if (config$1.conserveCpu && Game.cpu.bucket < 9000 && Game.myRooms.length > 6 && room.controller.level < 5){
									//reaching point where low level rooms are cpu inefficient, don't activate many sources until bigger
									minus = 350;
							} else if (config$1.conserveCpu && Game.cpu.bucket < 9000 && Game.myRooms.length > 3 && room.controller.level < 5){
									//reaching point where low level rooms are cpu inefficient, don't activate many sources until bigger
									minus = 200;
							}
							allowedParts-=minus;
							if (room.memory.sparePartsAdjustment){
									allowedParts += room.memory.sparePartsAdjustment;
							}
							if (config$1.singleSpawn && room.memory.seasonOperator && Game.powerCreeps[room.memory.seasonOperator]){
									let pc = Game.powerCreeps[room.memory.seasonOperator];
									if (pc.room){
											let opLevel = pc.powers[1].level;
											let spawnLevel = pc.powers[2].level;
											if (opLevel && spawnLevel){
													//calculate the effect a pc will have on spawning based on how many ops it makes and therefore how often it can activate op spawn
													let adjust = POWER_INFO[2].effect[spawnLevel - 1];
													let cost = POWER_INFO[2].ops;
													let opsPerTick = POWER_INFO[1].effect[opLevel - 1] / POWER_INFO[1].cooldown;
													let ticksToAfford = cost / opsPerTick;
													let upTime = POWER_INFO[2].duration / ticksToAfford;
													let mod = 0.8;
													if (upTime > 1){
															upTime = 1;
													}
													let finalAdjust = adjust * upTime * mod;
													let addOnParts = Math.round(allowedParts * finalAdjust);
													//increase our allowed parts as we will be spawning quicker
													allowedParts += addOnParts;
											}
									}
							}
							roomObj[room.name] = {
									allowedParts: allowedParts,
									startingAllowedParts: allowedParts,
									currentLength: 0,
									currentDistance: 0,
									currentWorkerParts: 0
							};
							finalSourceObj[room.name] = [];
					}
			}
			if (!Memory.sourceLimit){
					Memory.sourceLimit = Object.keys(roomObj).length * 5;
			}
			if (!Memory.lastChangedSL || (Game.time - 500) > Memory.lastChangedSL){
					let lastBucket = Memory.lastBucketSL;
					let dif = 0;
					if (lastBucket){
							dif = Game.cpu.bucket - lastBucket;
					}
					if (dif && dif < -500){
							//bucket depleting, revert course
							Memory.sourceLimit--;
					} else if (Game.cpu.bucket < 50 || (Memory.redLining && Memory.redLining > Game.time - 500)){
							Memory.sourceLimit -= 3;
					} else if (Game.cpu.bucket < 2000){
							Memory.sourceLimit--;
					} else if (Game.cpu.bucket < 4000); else if (Game.cpu.bucket < 8000){
							Memory.sourceLimit ++;
					} else {
							Memory.sourceLimit += 2;
					}
					Memory.lastBucketSL = Game.cpu.bucket;
					Memory.lastChangedSL = Game.time;
			}
			let max = Object.keys(roomObj).length * 15;
			if (Memory.sourceLimit > max){
					Memory.sourceLimit = max;
			}
			let minMod = 3;
			if (Game.energyCrisis){
					minMod = 4;
			}
			if (Memory.priority === 'swc' || !config$1.official){
					minMod = 8;
			}
			let min = Math.ceil(Memory.myRooms.length*minMod);
			if (config$1.season){
					min = 60;
			}
			if (min > 200){
					min = 200;
			}
			if (Memory.sourceLimit < min){
					Memory.sourceLimit = min;
			}
			let sourcesPerRoom = {};
			if (!Memory.sources){
					return
			} else {
					for (let i in Memory.sources){
							if (cpuBlock$3()){
									yield;
							}
							if (Memory.sources[i].sourceRoom && Memory.sources[i].pos){
									if (!sourcesPerRoom[Memory.sources[i].sourceRoom]){
											sourcesPerRoom[Memory.sources[i].sourceRoom] = 1;
									} else {
											sourcesPerRoom[Memory.sources[i].sourceRoom]++;
									}
									continue
							}
							let sourcePosStr = i;
							let sourcePos;
							if (sourcePosStr && typeof sourcePosStr === 'string'){
									try {
											sourcePos = sourcePosStr.toPos();
									} catch (e){
											console.log(e, sourcePosStr);
									}
							}
							if (sourcePos && sourcePos.roomName){
									Memory.sources[i].sourceRoom = sourcePos.roomName;
									Memory.sources[i].pos = sourcePosStr;
									if (!sourcesPerRoom[Memory.sources[i].sourceRoom]){
											sourcesPerRoom[Memory.sources[i].sourceRoom] = 1;
									} else {
											sourcesPerRoom[Memory.sources[i].sourceRoom]++;
									}
							}
					}
			}
			if (config$1.weirdSources){
					Memory.bigBoiSources = {};
			}
			if (config$1.weirdSources){
					for (let i in Memory.sources){
							let pos = i.toPos();
							if (!pos){
									continue
							}
							if (pos.roomName && sourcesPerRoom[pos.roomName] === 1){
									Memory.bigBoiSources[pos.toString()] = true;
							}
					}
			}
			let assignedCache = {};
			let counter = 0;
			let assigned = 0;
			let sourceList = [];
			let yakParts = {};
			for (let i in Memory.sources){
					sourceList.push(Memory.sources[i]);
			}
			sortSources(sourceList);
			assignSourcesToRooms(sourceList);
			sourceList = sourceList.filter((s) => {
					let room = s.room;
					let pos = s.pos.toPos();
					let roomType = Game.map.getRoomType(pos.roomName);
					if (!config$1.SKMine && pos){
							if (roomType === 'centre'){
									return false
							}
					} else if (config$1.reactors && config$1.reactors[pos.roomName]){
							return false
					}
					if (room && pos){
							return checkRemote(room, pos)
					}
			});
			let furthestSource = 0;
			//skmining
			if (config$1.SKMine){
					for ( let i in Memory.rooms){
							let SKRoomMem = Memory.rooms[i];
							if (SKRoomMem && SKRoomMem.assignedEnergyHomeRoom && SKRoomMem.assignedEnergyHomeRoomRoute){
									let type = Game.map.getRoomType(i);
									let home = Game.rooms[SKRoomMem.assignedEnergyHomeRoom];
									if (home && home.memory.reactor){
											//don't want to risk invaders disrupting our route
											continue
									}
									if (home && (type === 'SK' && home.controller.level > 6) && !Game.map.isCoreRoom(i)){
											let routeOK = true;
											for (let j in SKRoomMem.assignedEnergyHomeRoomRoute){
													if (Game.map.isCoreRoom(SKRoomMem.assignedEnergyHomeRoomRoute[j])){
															routeOK = false;
															break
													}
											}
											if (routeOK){
													//divide by 3 as 3 sources in each SK room
													//check route in order to avoid core rooms
													sourceList.push({
															'SK':true,
															'sourceRoom':i,
															'distance':Math.round(SKRoomMem.assignedEnergyHomeRoomDistance/3),
															'room':SKRoomMem.assignedEnergyHomeRoom
													});
											}
									}
							}
					}
			}
			sortSources(sourceList,true);
			while (assigned < Memory.sourceLimit && sourceList[counter]){
					if (cpuBlock$3()){
							yield;
					}
					let source = sourceList[counter];
					if (source.distance > 180 && !source.SK && !source.centre){
							console.log('source distance limit');
							break
					} else if (source.distance > 250){
							continue
					}
					if (assignedCache[source.pos]){
							counter++;
							continue
					}
					let homeRoomName = source.room;
					let homeRoom = Game.rooms[homeRoomName];
					if (config$1.fixRemotes && config$1.fixRemotes[homeRoomName] && source.sourceRoom && !config$1.fixRemotes[homeRoomName].includes(source.sourceRoom)){
							console.log('cant used non fixed remote',source.pos,homeRoomName);
							counter++;
							continue
					}
					if (homeRoom.memory.centreSourceRoutes && homeRoom.memory.centreSourceRoutes[source.pos]){
							let cannotPath = false;
							for (let i in homeRoom.memory.centreSourceRoutes[source.pos]){
									if (Game.map.isCoreRoom(homeRoom.memory.centreSourceRoutes[source.pos][i])){
											console.log('centre room route blocked',source.pos,homeRoomName);
											cannotPath = true;
											break
									}
							}
							if (cannotPath){
									counter++;
									continue
							}
					} else if (Game.map.getRoomType(source.sourceRoom) === 'centre'){
							console.log('centre room no route',source.pos,homeRoomName);
							counter++;
							continue
					}
					//hibernating rooms should not be assigned many remotes to save cpu
					let blockSourcesForHibernatingRoom = false;
					if (homeRoom && homeRoom.memory.hibernate && homeRoom.memory.adjustedLowWallHits &&
							homeRoom.memory.adjustedLowWallHits > config$1.minWalls[8]){
							blockSourcesForHibernatingRoom = true;
					}
					if (roomObj[homeRoomName] && Game.rooms[homeRoomName] && (!blockSourcesForHibernatingRoom || !roomObj[homeRoomName].currentLength) && Memory.myRooms && (!Memory.myRooms.includes(source.sourceRoom)
							|| source.sourceRoom === homeRoomName || (Game.rooms[source.sourceRoom] && Game.rooms[source.sourceRoom].class !== 'normal' && Game.rooms[source.sourceRoom].class !== 'bunker' &&
									Game.rooms[source.sourceRoom].controller && Game.rooms[source.sourceRoom].controller.level > 2))){
							let room = roomObj[homeRoomName];
							let getParts;
							if (source.SK){
									getParts = getSKPartsNeeded(source.distance, Game.rooms[homeRoomName]);
							} else {
									getParts = getPartsNeeded(source.distance, Game.rooms[homeRoomName], source.sourceRoom,source);
							}
							if (!getParts || !getParts[0]){
									continue
							}
							let partsNeeded = Number.parseInt(getParts[0]);
							if (room.allowedParts > partsNeeded){
									if (source.sourceRoom !== homeRoomName){
											//only add remote miners if its not our owned room
											room.currentLength++;
											if (source.pos){
													finalSourceObj[homeRoomName].push(source.pos);
											} else if (source.SK) {
													if (Memory.rooms[source.sourceRoom] && Memory.rooms[source.sourceRoom].SKsources){
															finalSourceObj[homeRoomName] = finalSourceObj[homeRoomName].concat(Memory.rooms[source.sourceRoom].SKsources);
													} else {
															counter++;
															continue
													}
											}
									}
									setAssignedSourceData();
									if (config$1.weirdSources && Memory.bigBoiSources && Memory.bigBoiSources[source.pos]){
											//set up so that we treat one sources that is worth two sources as two, except for currentLength which affects amount of remoteMiners
											setAssignedSourceData();
									}

									function setAssignedSourceData(){
											if (source.sourceRoom !== homeRoomName){
													assigned++;
											}
											room.allowedParts -= partsNeeded;
											room.currentWorkerParts += Number.parseInt(getParts[1]);
											if (!yakParts[homeRoomName]){
													yakParts[homeRoomName] = 0;
											}
											yakParts[homeRoomName]  += Number.parseInt(getParts[2]);
											if (source.sourceRoom !== homeRoomName || !Game.rooms[homeRoomName] || !Game.rooms[homeRoomName].memory.linksource1 || !Game.getObjectById(Game.rooms[homeRoomName].memory.linksource1)){
													//only add distance for home room if links not up
													room.currentDistance += source.distance;
											}
									}

									furthestSource = source.distance;
									assignedCache[source.pos] = true;
							}
					}
					counter++;
			}


			function getPartsNeeded(distance, room, sourceRoom,source){
					let roadConst = 2;
					let pause = checkIfNeedToPauseInfrastructureDueToHarassment(room);
					if (remoteRoadsPresent(room) && !pause){
							roadConst = 1.5;
					} else if (room.memory.sourceDistanceWithoutRoads && source&& source.pos
							&& room.memory.sourceDistanceWithoutRoads[source.pos]) {
							distance = room.memory.sourceDistanceWithoutRoads[source.pos];
					}
					let mod = 1.2;
					let yakBody = Math.ceil(((distance * 2 * 10) / 50) * roadConst*mod);
					//15000 -> energy over 1500 ticks,- cost of miner,-cost of yaks,reserver,container (150),roads (2.37d)
					let minerBodyCost = (800 / (1500 - distance)) * 1500;
					let reserveCost = (650 / (600 - distance)) * 1500;
					let income = 15000;
					//minerbody slightly high to account for travel time
					let minerBody = 15;
					if (!canSpawnReserves(room)){
							income = 7500;
							minerBody = 6;
							minerBodyCost = minerBodyCost/2;
							reserveCost = 0;
							yakBody = Math.round(yakBody/2);
					}
					if (config$1.official && config$1.conserveCpu && room.energyCapacityAvailable > 3000){
							minerBodyCost = 2100;
							minerBody = 30;
					}
					if (sourceRoom && sourceRoom === room.name){
							minerBody = 0;
					}
					if (Game.map.getRoomType(sourceRoom) === 'centre'){
							income = 20000;
							reserveCost = 0;
							yakBody = Math.ceil(((distance * 2 * 13.3) / 50) * roadConst);
							minerBodyCost = (1500 / (1500 - distance)) * 1500;
							minerBody = 15;
					}
					let yakBodyCost = 50 * yakBody;
					let sourceProfit = Math.round(income - ( minerBodyCost + yakBodyCost + reserveCost + 150 + 2.37 * distance));
					if (sourceProfit && sourceProfit < 1000){
							return
					}
					if (sourceRoom && sourceRoom === room.name && room.memory.sourcePositions && source && source.pos){
							//don't add yakparts if link
							let sourcePos = source.pos.toPos();
							if (sourcePos){
									source = sourcePos.lookAround(LOOK_SOURCES,0)[0];
									if (source && source.id && room.memory.sourcePositions[source.id] && room.memory.sourcePositions[source.id].link){
											let linkPos =  room.memory.sourcePositions[source.id].link.toPos();
											if (linkPos){
													let link = linkPos.lookAround(LOOK_STRUCTURES,0,{filter:(s)=>s.structureType === 'link' && s.my})[0];
													if (link){
															yakBody = 0;
													}
											}
									}
							}
					}
					//need to adjust this as it does not include other energy costs -> resulting in overspawning, we have capacity to overspawn upgraders anyway if needed
					let adjust = 0.5;
					if (room.controller.level > 6 && room.isEnergyDonor){
							adjust = 0.2;
					}
					let workerParts = ((sourceProfit) / 1500) * adjust;
					if (room.memory.brigade){
							yakBody = Math.round(distance / 2);
					}
					//console.log('parts needed for distance',distance,':',yakBody+minerBody+workerParts)
					//adjust workerparts as we need more than just the WORK part, although if upgrader this isn't masses more than just a work part
					return [yakBody + minerBody + (workerParts * 1.2), workerParts,yakBody]
			}
			function getSKPartsNeeded(distance, room){
					let roadConst = 2;
					let pause = checkIfNeedToPauseInfrastructureDueToHarassment(room);
					if (remoteRoadsPresent(room) && !pause){
							roadConst = 1.5;
					}
					let mod = 1.2;
					let yakBody = Math.round(((distance * 2 * 15) / 50) * roadConst*mod);
					//15000 -> energy over 1500 ticks,- cost of miner,-cost of yaks,reserver,container (150),roads (2.37d)
					let minerBodyCost = (1200 / (1500 - distance)) * 1500;
					let yakBodyCost = 50 * yakBody;
					let soldierBody = getBody$6(room,0,'SKE');
					let soldierCost = 0,soldierParts = 0;
					if(soldierBody){
							soldierParts = soldierBody.length;
							soldierCost = Game.getBodyCost(soldierBody);
					}
					//source profit is higher from 4000 energy over 300 ticks and dropped energy from guard
					let sourceProfit = Math.round(23000 - ( minerBodyCost + soldierCost + yakBodyCost + 150 + 2.37 * distance));
					let minerBody = 15;
					//need to adjust this as it does not include other energy costs -> resulting in overspawning, we have capacity to overspawn upgraders anyway if needed
					let adjust = 0.7;
					let workerParts = ((sourceProfit) / 1500) * adjust;
					//times by 3 as we are working out for 3 sources in for each SK room
					return [(yakBody + minerBody + soldierParts + (workerParts * 1.2))*3, workerParts*3,yakBody*3]
			}
			console.log(assigned, 'assigned', 'furthest source:', furthestSource);
			for (let i in rooms){
					let room = rooms[i];
					let obj = roomObj[room.name];
					let sourceList = finalSourceObj[room.name];
					if (obj){
							room.memory.assignedSourceData = obj;
							if (remoteRoadsPresent(room) && !checkIfNeedToPauseInfrastructureDueToHarassment(room) && room.storage && room.storage.my);
							//bodysize of all needed yaks
							let size = yakParts[room.name];
							console.log(room.name,'yak size:', size);
							room.memory.totalYakParts = size;
							room.memory.finalSources = sourceList;
							room.memory.remoteminer = obj.currentLength;
					}
			}
	}
	function assignSourcesToRooms(sources){
			let nearSourcesPerRoom = {};
			for (let i in sources){
					let source = sources[i];
					let bidders = sources[i].rooms;
					let winner,currentDist;
					for (let j in bidders){
							let room = Game.rooms[bidders[j]];
							if (!room || !room.memory.sourcelist){
									continue
							}
							let score = 0;
							let min = 4;
							if (room.controller.level > 6){
									min = 6;
							} else if (room.controller.level > 7){
									min = 9;
							}
							if (nearSourcesPerRoom[room.name]){
									if (nearSourcesPerRoom[room.name] > min){
											score = nearSourcesPerRoom[room.name]+(nearSourcesPerRoom[room.name]-min)*2;
									} else {
											score = nearSourcesPerRoom[room.name];
									}
							}
							let dist = room.memory.sourcelist[sources[i].pos]+(score*5);
							if (!winner || dist < currentDist){
									winner = bidders[j];
									currentDist = dist;
							}
					}
					if (winner){
							source.room = winner;
							source.assignedRoomDistance = Game.rooms[winner].memory.sourcelist[sources[i].pos];
							if (!nearSourcesPerRoom[winner]){
									nearSourcesPerRoom[winner] = 0;
							}
							nearSourcesPerRoom[winner]++;
					}
			}
	}
	function adjustRemotesBasedOnSpawnUsage(room){
			if (room.memory.spawnPartsWasted && room.memory.spawnPartsWasted.logStart && (Game.time - room.memory.spawnPartsWasted.logStart) >= 500){
					let maxAdjust = 50;
					if (room.controller.level === 7){
							maxAdjust = 150;
					} else if (room.controller.level === 8){
							maxAdjust = 300;
					}
					let minAdjust =  0-maxAdjust;
					if (!room.memory.sparePartsAdjustment){
							room.memory.sparePartsAdjustment = 0;
					}
					if (room.memory.spawnPartsWasted.partsWasted > 50){
							if (!room.memory.sparePartsAdjustment){
									let adjust = 10;
									if (adjust > maxAdjust){
											adjust = maxAdjust;
									}
									room.memory.sparePartsAdjustment = adjust;
							} else if (room.memory.sparePartsAdjustment){
									room.memory.sparePartsAdjustment += 10;
									if (room.memory.spawnPartsWasted.partsWasted > 100){
											room.memory.sparePartsAdjustment += 10;
									}
									if (room.memory.sparePartsAdjustment  > maxAdjust){
											room.memory.sparePartsAdjustment = maxAdjust;
									}
							}

					} else if (room.memory.spawnPartsWasted.partsWasted < 15){
							room.memory.sparePartsAdjustment -= 5;
					} else if (room.memory.sparePartsAdjustment && !room.memory.spawnPartsWasted.partsWasted){
							//negative feedback
							room.memory.sparePartsAdjustment -= 10;
					}
					if (room.memory.cumalativeHarvest){
							let predictedHarvestPerTick = 6000/300;
							let remoteHarvest = room.memory.finalSources.length*5;
							if (canSpawnReserves(room)){
									remoteHarvest *= 2;
							}
							predictedHarvestPerTick += remoteHarvest;
							let predictedHarvest = predictedHarvestPerTick*(Game.time-room.memory.cumalativeHarvest.start);
							let ratio = room.memory.cumalativeHarvest.amount/predictedHarvest;
							if (ratio < 0.9 && room.memory.sparePartsAdjustment){
									//not utilising remotes properly - shouldn't be using more remotes
									room.memory.sparePartsAdjustment -= 5;
							}
							if (config$1.private){
									if (!room.memory.harvestEfficiencyLog){
											room.memory.harvestEfficiencyLog = {};
									}
									if (!room.memory.harvestEfficiencyLog[room.controller.level]){
											room.memory.harvestEfficiencyLog[room.controller.level] = [];
									}
									if (room.memory.harvestEfficiencyLog[room.controller.level].length > 20){
											room.memory.harvestEfficiencyLog[room.controller.level].shift();
									}
									room.memory.harvestEfficiencyLog[room.controller.level].push([ratio,predictedHarvest]);
							}
							delete room.memory.cumalativeHarvest;
					}
					if (room.memory.sparePartsAdjustment && room.memory.sparePartsAdjustment < minAdjust){
							room.memory.sparePartsAdjustment = minAdjust;
					}
					room.memory.spawnPartsWasted = {
							logStart:Game.time,
							partsWasted:0
					};
			}
	}
	function checkForCore(creep,force){
			let homeRoom = creep.home;
			if (homeRoom.memory.remoteRooms && creep.room.name != homeRoom.name &&
					homeRoom.memory.remoteRooms[creep.room.name] && !homeRoom.memory.remoteRooms[creep.room.name].coreDetected){
					if (force || (creep.room.controller && creep.room.controller.reservation && creep.room.controller.reservation.username === 'Invader')){
							let core = creep.room.findStructures('invaderCore')[0];
							if (core){
									let addOn = 500;
									if (homeRoom.controller.level < 5 || (core.level && core.level > 0)){
											addOn = 5000;
									}
									homeRoom.memory.remoteRooms[creep.room.name].coreDetected = Game.time+addOn;
									if (homeRoom.controller.level > 4);
									return true
							} else if (core){
									if (!Memory.coreRooms[creep.room.name]){
											Memory.coreRooms[creep.room.name] = homeRoom.name;
									}
							}
					}
			} else if (homeRoom.memory.remoteRooms && creep.room.name != homeRoom.name &&
					homeRoom.memory.remoteRooms[creep.room.name] && homeRoom.memory.remoteRooms[creep.room.name].coreDetected){
					return true
			}
	}
	function checkGuardNeeded(creep){
			let homeRoom = creep.home;
			if (homeRoom.memory.remoteRooms && creep.room.name != homeRoom.name){
					if (homeRoom.memory.remoteRooms[creep.room.name] && !homeRoom.memory.remoteRooms[creep.room.name].guardNeeded){
							let hostiles = creep.room.hostileList;
							let nonScout = false;
							for (let i in hostiles){
									for (let b in hostiles[i].body){
											if (hostiles[i].body[b].type !== 'move'){
													nonScout = true;
													break
											}
									}
							}
							if (nonScout){
									homeRoom.memory.remoteRooms[creep.room.name].guardNeeded = true;
							}
					}
			}
			if (creep.room.memory.armedHostiles){
					creep.memory.hostile = true;
					if (creep.room.name && homeRoom.memory.remoteRooms[creep.room.name]){
							homeRoom.memory.remoteRooms[creep.room.name].retreat = true;
					}
			}
	}
	function checkRemote(homeRoom, pos){
			if (pos && Game.rooms[pos.roomName] && Game.rooms[pos.roomName].controller &&
					(Game.rooms[pos.roomName].controller.my && (Game.rooms[pos.roomName].class == 'normal' || Game.rooms[pos.roomName].class == 'bunker'))); else if (pos && pos.roomName && Memory.ownedRooms[pos.roomName]); else if (config$1.highwayWalls && Game.map.getSector(pos.roomName) !== Game.map.getSector(homeRoom.name)); else if (config$1.fixRemotes && config$1.fixRemotes[homeRoom.name] && !config$1.fixRemotes[homeRoom.name].includes(pos.roomName)); else if (config$1.ignoreRemotes && config$1.ignoreRemotes.includes(pos.roomName)); else {
					return true
			}
			return false
	}
	function avoidSKGuards (creep,pos){
			if (creep.memory.goToPanicPos && creep.memory.panicPos){
					let panicPos = creep.memory.panicPos.toPos();
					creep.say(panicPos.x+' '+panicPos.y);
					if (panicPos && creep.memory.goToPanicPos > Game.time && !creep.pos.isNearTo(panicPos)){
							creep.moveTo(panicPos);
							return true
					} else {
							delete creep.memory.goToPanicPos;
					}
			}
			if (creep.room.name !== pos.roomName || Game.map.getRoomType(pos.roomName) !== 'SK'){
					return
			}
			let rally = Game.flags['rally'+creep.home.name];
			if (!rally){
					return
			}
			let room = creep.room;
			if (room.name === pos.roomName){
					if (config$1.mapVisual){
							Game.map.visual.text('\u{26CF}', creep.pos);
					}
					if (!creep.memory.panicPos){
							let panicPos = findPanicPos(pos);
							if (panicPos){
									creep.memory.panicPos = panicPos.toString();
							}
					}
					let panic = false;
					let cautious = false;
					let SKs = room.memory.sk;
					if (pos && creep.pos.inRangeTo(pos,7)){
							if (SKs){
									for (let i in SKs){
											let SK = Game.getObjectById(SKs[i]);
											if (SK.pos.getRangeTo(creep) < 6){
													panic = true;
											} else if (SK.pos.getRangeTo(creep) < 7){
													cautious = true;
											}
									}
							}
							if (room.memory.lairs){
									for (let i in room.memory.lairs){
											let lair = Game.getObjectById(room.memory.lairs[i]);
											if (lair && lair.ticksToSpawn && lair.ticksToSpawn < 25){
													if (lair.pos.getRangeTo(creep) < 6){
															panic = true;
													} else if (lair.pos.getRangeTo(creep) < 7){
															cautious = true;
													}
											}
									}
							}
					}

					if (panic){
							creep.say('panic');
							let panicPos;
							if (creep.memory.panicPos && creep.memory.panicPos.toPos()){
									panicPos = creep.memory.panicPos.toPos();
							} else {
									creep.rally(1);
							}
							if (panicPos && !creep.pos.isEqualTo(panicPos)){
									creep.moveTo(panicPos,{range:0});
									creep.memory.goToPanicPos = Game.time+50;
							}
							creep.wipePath();
							return true
					} else if (cautious){
							creep.say('cautious');
							return true
					}
			}
	}
	function findPanicPos(start){
			let room = Game.rooms[start.roomName];
			if (!room){
					return
			}
			let lairs = [];
			if (room.memory.lairs){
					for (let i in room.memory.lairs){
							lairs.push(Game.getObjectById(room.memory.lairs[i]));
					}
			}
			let matrix;
			let SKmatrix = Game.map.getSKMatrix(start.roomName);
			let SM = room.structureMatrix;
			if (SM && SKmatrix){
					matrix = PathFinder.applySKMatrix(room.name,SM);
			} else if (SKmatrix){
					matrix = SKmatrix;
			} else {
					return
			}
			let visited = {};
			let step = 0;
			let currentLairInfo = closestLairInfo(start);
			return lookDownPath(start,step)
			function lookDownPath(current,step){
					let nextStep = step + 1;
					if (nextStep === 1 || nextStep % 5 === 0){
							currentLairInfo = closestLairInfo(current);
					}
					let score = matrix.get(current.x,current.y);
					if (score < 5){
							currentLairInfo = closestLairInfo(current);
							if (currentLairInfo.range>7){
									return current
							}
					}
					let neighbours = current.neighbours();
					for (let i in neighbours){
							neighbours[i].direction = i;
					}
					visited[current.toString()] = true;
					let filtered = neighbours.filter((n)=>!n.onEdge() && n.getTerrain() !== 'wall' && !visited[n.toString()] && matrix.get(n.x,n.y) !== 255);
					if (filtered.length > 0){
							let sorted = filtered.sort((a,b)=>{
									return getScore(a)-getScore(b)
							});
							for (let i in sorted){
									let found = lookDownPath(sorted[i],nextStep);
									if (found){
											return found
									}
							}
					}
			}
			function getScore(pos){
					let score = matrix.get(pos.x,pos.y);
					if (score === 0){
							let terrain = pos.getTerrain();
							if (terrain === 'swamp'){
									score = 5;
							} else {
									score = 2;
							}
					}
					if (pos.direction && currentLairInfo){
							if (pos.direction === currentLairInfo.dir || pos.direction === currentLairInfo.dir.map8(1)
							|| pos.direction === currentLairInfo.dir.map8(-1)  || pos.direction === currentLairInfo.dir.map8(-2)
									|| pos.direction === currentLairInfo.dir.map8(+2)); else {
									score += 3;
							}
					}
					if (pos.onEdge()){
							score += 500;
					}
					return score
			}
			function closestLairInfo(pos){
					let closest,closestRange;
					for (let i in lairs){
							let range = lairs[i].pos.getRangeTo(pos);
							if (!closest || closestRange>range){
									closest = lairs[i];
									closestRange = range;
							}
					}
					if (closest){
							return {
									range:closestRange,
									dir:closest.pos.getDirectionTo(pos)
							}
					}
			}
	}
	function remoteRoadsPresent(room){
			if (room && room.memory.roadsDown && room.memory.remoteContainers && (!room.memory.remoteRoadsNeedBuilding
					|| room.memory.remoteRoadsNeedBuilding < Game.time|| room.storage)){
					return true
			}
	}
	function pauseRemotes(room){
			if (room.controller.level === 8 && room.total('energy')>room.memory.reserve && room.storeFillRatio > 0.9){
					return true
			}
	}

	playerHeap.wallShell = {};
	playerHeap.wallShell.wallGenerators = {};
	const origins = {};
	let planTick = {};
	playerHeap.wallShell.finalSites = {};
	function pushWallGenerators(){
			for (let i in playerHeap.wallShell.wallGenerators){
					if (Game.cpu.bucket < 200){
							break
					}
					if (planTick && planTick[i] === Game.time){
							continue
					}
					planTick[i] = Game.time;
					if (playerHeap.wallShell.wallGenerators[i] && Game.rooms[i] && origins[i]){
							console.log(`pushing room designer generation for ${i}`);
							designShell(Game.rooms[i]);
					}
			}
	}
	function designShell(room, force){
			//allow pausing halfway to avoid crashing due to low cpu
			if (!room || cpuBlock$2()){
					return
			}
			if (planTick && planTick[room.name] === Game.time){
					return
			}
			planTick[room.name] = Game.time;
			console.log('designing room', room.hyperlink);
			if (!playerHeap.wallShell.wallGenerators[room.name]){
					playerHeap.wallShell.wallGenerators[room.name] = _designShell(room);
			}
			try {
					let ret = playerHeap.wallShell.wallGenerators[room.name].next();
					if (ret.done === true){
							delete playerHeap.wallShell.wallGenerators[room.name];
							return playerHeap.wallShell.finalSites[room.name]
					}
			} catch (err){
					console.log(err.stack.split("at"), 'wall gen');
					delete playerHeap.wallShell.wallGenerators[room.name];
			}
	}
	function cpuBlock$2(){
			if (Game.cpu.bucket < 200 || Game.cpu.getUsed() > 300){
					return true
			}
	}
	function* _designShell(room){
			if (!ready() || Game.cpu.bucket < 500){
					return
			}
			//origin is where the first spawn goes, need to find this to design the room
			if (!room || !access(room.name).structures || !room.memory.spawn || !Game.spawns[room.memory.spawn]){
					console.log('no structures, cant form shell');
					return
			}
			if (!access(room.name).structures['sections']){
					console.log('no sections, cant form shell');
					return
			}
			if (!room.memory.sectionExits){
					console.log('no section exits, cant form shell');
					return
			}
			let spawn = Game.spawns[room.memory.spawn];
			let sections = access(room.name).structures['sections'];
			let roadMatrix = room.roadMatrix;
			//set ramps in sections as unwalkable
			let matrix = new PathFinder.CostMatrix;
			for (let s in sections){
					for (let r in sections[s].members){
							let posObj = sections[s].members[r];
							matrix.set(posObj.x,posObj.y,255);
					}
			}
			if (cpuBlock$2()){
					yield 'a';
			}
			let walls = [];
			let ramps = [];
			let sources = room.find(FIND_SOURCES);
			let processedPositions = {};
			let exitsAll = {};
			let normalRamps = {};
			for (let s in sections){
					if (cpuBlock$2()){
							yield 'sections';
					}
					let exits = [];
					for (let exit in room.memory.sectionExits){
							if (room.memory.sectionExits[exit][s]){
									exits.push(exit.toPos());
									exitsAll[exit] = true;
							}
					}
					for (let p in sections[s].roadIntersections){
							let pos = new RoomPosition(sections[s].members[p].x,sections[s].members[p].y,room.name);
							if (pos){
									processedPositions[pos.toString()] = true;
									processPos(pos,true);
							}
							if (cpuBlock$2()){
									yield 'intersections';
							}
					}
					for (let p in sections[s].members){
							let pos = new RoomPosition(sections[s].members[p].x,sections[s].members[p].y,room.name);
							if (pos && !processedPositions[pos.toString()]){
									processPos(pos);
							}
							if (cpuBlock$2()){
									yield 'members';
							}
					}
					function processPos(pos,intersection){
							for (let e in exits){
									let noPaths = false;
									let count = 0;
									while (count < 7 && !noPaths){
											count++;
											let pathObj = PathFinder.search(pos,{pos:exits[e],range:0},
													{
															maxRooms: 1, roomCallback: (roomName) => {
																	return matrix
															}
													});
											if (pathObj && !pathObj.incomplete){
													let firstPos = pathObj.path[0];
													let isRampart = false;
													if (intersection && count === 1){
															isRampart = true;
													}
													if (!isRampart && roadMatrix && roadMatrix.get(firstPos.x,firstPos.y) === 1){
															isRampart = true;
													}
													if (firstPos && firstPos.nearEdge()){
															let dir;
															if (firstPos.x === 1){
																	dir = 7;
															} else if (firstPos.x === 48){
																	dir = 3;
															} else if (firstPos.y === 1){
																	dir = 1;
															} else if (firstPos.y === 48){
																	dir = 5;
															}
															let neighbours;
															if (dir){
																	neighbours = [firstPos.movePos(dir),firstPos.movePos(dir.map8(1)),firstPos.movePos(dir.map8(-1))];
															} else {
																	console.log('no dir shell',firstPos);
																	neighbours = firstPos.neighbours();
															}
															for (let i in neighbours){
																	let neighbour = neighbours[i];
																	if (neighbour.getTerrain() !== 'wall'){
																			//is an exit
																			isRampart = true;
																			firstPos = pos;
																			normalRamps[pos.toString()] = true;
																			noPaths = true;
																	}
															}
													}
													if (!isRampart){
															let range = 50;
															for (let i in sources){
																	checkRange(sources[i].pos);
															}
															checkRange(room.controller.pos);
															if (room.memory.upContPos){
																	checkRange(room.memory.upContPos.toPos());
															}
															function checkRange(checkPos){
																	if (!checkPos){
																			return
																	}
																	let checkRange = checkPos.getRangeTo(firstPos);
																	if (checkRange < range){
																			range = checkRange;
																	}
															}
															if (range < 2){
																	isRampart = true;
															}
													}
													matrix.set(firstPos.x,firstPos.y,255);
													if (!ramps.includes(firstPos.toString()) && isRampart){
															ramps.push(firstPos.toString());
															firstPos.highlight('green');
													} else {
															walls.push(firstPos.toString());
															firstPos.highlight('red');
													}
											} else {
													noPaths = true;
											}
									}
							}
					}
			}
			if (cpuBlock$2()){
					yield 'validate';
			}
			//validate by setting wallMatrix for normal ramps to 1 and trying to path out -
			// while still able to path out you need to block gaps by building the real wall
			for (let s in sections){
					for (let r in sections[s].members){
							let posObj = sections[s].members[r];
							let pos = new RoomPosition(posObj.x,posObj.y,room.name);
							if (normalRamps[pos.toString()]){
									continue
									//exclude ramps that we have already marked as shell
							}
							normalRamps[pos.toString()] = true;
							matrix.set(posObj.x,posObj.y,1);
					}
			}
			for (let exitStr in exitsAll){
					if (cpuBlock$2()){
							yield 'validate exits';
					}
					let exit = exitStr.toPos();
					let noPaths = false;
					while (!noPaths){
							let pathObj = PathFinder.search(spawn.pos,{pos:exit,range:0},
									{
											maxRooms: 1, roomCallback: (roomName) => {
													return matrix
											}
									});
							if (pathObj && !pathObj.incomplete){
									for (let i in pathObj.path){
											let pos = pathObj.path[i];
											if (normalRamps[pos.toString()]){
													matrix.set(pos.x,pos.y,255);
													ramps.push(pos.toString());
													pos.highlight('blue');
											}
									}
							} else {
									noPaths = true;
							}
					}
			}

			playerHeap.wallShell.finalSites[room.name] = {
					walls:walls,
					ramparts:ramps
			};
	}

	function buildRoom(priority){
			if (ready() === false){
					return
			}
			var rooms = Game.rooms;
			let roomlist = [];
			for (let roomKey in rooms){
					let room = Game.rooms[roomKey];
					var isMyRoom = (room.controller ? room.controller.my : 0);
					if (isMyRoom && (room.class === 'normal'|| room.class === 'bunker')){
							roomlist.push(room.name);
					}
			}
			if (Memory.buildcounter === undefined || Memory.buildcounter === null){
					Memory.buildcounter = 0;
			} else if (roomlist.length > 0){
					let roomName = roomlist[Memory.buildcounter];

					let room = Game.rooms[roomName];
					if (priority){
							room = priority;
							roomName = room.name;
					}
					console.log('building',roomName,Game.cpu.bucket);
					if (!room){
							delete Memory.buildcounter;
							return
					}
					room.display('building');
					if (Game.shard.name == 'shard5');
					if (!access(roomName)){
							console.log(`${roomName} has no segment`);
							return
					} else if (!access(roomName).spaceMatrix){
							if (Game.cpu.bucket < 300){
									console.log(roomName,'space matrix await bucket');
									return
							}
							let matrix = findSpace(room, true);
							console.log(roomName,'space matrix found');
							save(roomName, 'spaceMatrix', matrix);
							return
					} else if (!access(roomName).spaceMatrix2){
							if (Game.cpu.bucket < 300){
									console.log(roomName,'space matrix 2 await bucket');
									return
							}
							let matrix = findSpace(room);
							save(roomName, 'spaceMatrix2', matrix);
							return
					} else if (!access(roomName).baseLocation){
							if (Game.cpu.bucket < 500){
									console.log(roomName,'baseLocation await bucket');
									return
							}
							let baseLocation = findBaseLocation(room, access(roomName).spaceMatrix);
							if (!baseLocation){
									baseLocation = 'checkSmall';
							}
							console.log(roomName, baseLocation);
							save(roomName, 'baseLocation', baseLocation);
							return
					} else if (access(roomName).baseLocation === 'checkSmall'){
							let baseLocation = findSmallBaseLocation(room, access(roomName).spaceMatrix);
							console.log('small base location',roomName, baseLocation);
							if (!baseLocation){
									baseLocation = 'findSpace2';
							}
							save(roomName, 'baseLocation', baseLocation);
							return
					} else if (access(roomName).baseLocation === 'findSpace2'){
							if (Game.cpu.bucket < 300){
									console.log(roomName,'findspace2 await bucket');
									return
							}
							console.log(roomName,'last try space matrix found');
							let matrix = findSpace(room, true,true);
							save(roomName, 'spaceMatrix', matrix);
							if (matrix){
									save(roomName, 'baseLocation', 'checkSmall2');
							}
							return
					} else if (access(roomName).baseLocation === 'checkSmall2'){
							let baseLocation = findSmallBaseLocation(room, access(roomName).spaceMatrix);
							console.log('small base location',roomName, baseLocation);
							if (!baseLocation){
									baseLocation = 'none';
							}
							save(roomName, 'baseLocation', baseLocation);
							return
					} else if (!access(roomName).structures){
							console.log(`building: ${roomName} has no segment structures`);
							console.log(`baselocation: ${access(room.name).baseLocation}`);
							delete room.memory.build;
					}
					room.display(`baselocation: ${access(room.name).baseLocation}`);
					if (!Memory.toRestructure){
							Memory.toRestructure = [];
					}
					if (access(roomName).roadPositions){
							let rooms = access(roomName).roadPositions;
							for (let i in rooms){
									let positions = getRoadPositions(roomName,i);
									for (let i in positions){
											let pos = positions[i];
											if (pos){
													pos.highlight('red');
											}
									}
							}
					}
					let baseLocation = access(room.name).baseLocation;
					if (baseLocation === 'none'){
							room.memory.noBase = true;
					}
					if (Game.cpu.bucket > 500 && room && (!room.memory.build || room.memory.build !== config$1.buildVer
							|| !access(roomName).structures) && ((room.memory.spawnPos && room.memory.spawnPos.toPos())
							|| (access(room.name) && baseLocation && baseLocation != 'none'))){
							if (Game.cpu.bucket < 500){
									return
							}
							delete room.memory.blockExtPos;
							console.log(roomName, 'finding sites', access(room.name).baseLocation);
							let origin;
							if (room.memory.spawnPos){
									origin = room.memory.spawnPos.toPos();
							}
							if (baseLocation && baseLocation != 'none'){
									origin = baseLocation;
							}
							let sites = designRoom(origin, room);
							console.log('sites',sites);
							if (sites){
									save(room.name, 'structures', sites);
									let positions = [];
									if (sites['road']){
											for (let i in sites['road']){
													let pos = sites['road'][i].toPos();
													if (pos){
															positions.push(pos);
													}
											}
									}
									setRoadPositions(room.name,room.name,positions);
									room.memory.build = config$1.buildVer;
									return
							}
					} else if (!room.memory.build){
							return
					} else {
							placeSites(room);
					}
					if (Game.cpu.bucket > 200 && room && room.controller.level < 8 && room.controller.level > 2 && (Game.gcl.level > 1 || room.controller.safeModeCooldown) && access(roomName).structures && !access(roomName).shell){
							let shell = designShell(room);
							if (shell && shell.ramparts){
									save(room.name, 'shell', shell);
							}
					} else if (access(roomName).shell &&room.controller.level > 3 && room.storage &&
							(Memory.myRooms.length > 1 || !room.controller.safeMode)){
							let shell = access(roomName).shell;
							if (shell && shell.ramparts){
									//Segments.save(room.name, 'shell', shell)
									for (let i in shell.ramparts){
											let pos = shell.ramparts[i].toPos();
											pos.createConstructionSite('rampart');
									}
									for (let i in shell.walls){
											let pos = shell.walls[i].toPos();
											pos.createConstructionSite('constructedWall');
											let road = pos.lookAround(LOOK_STRUCTURES,0,{filter:(s)=>s.structureType === 'road'})[0];
											if (road){
													road.destroy();
											}
									}
							}
					}
					if (!priority){
							if (Memory.buildcounter < (roomlist.length - 1)){
									Memory.buildcounter = Memory.buildcounter + 1;
							} else {
									Memory.buildcounter = 0;
							}
					}
			}
	}

	function placeSites(room){
			if (!room || !access(room.name)){
					console.log(`place sites can not find room ${room}`);
					return
			}
			if (!room.siteNumber){
					let sites = room.find(FIND_MY_CONSTRUCTION_SITES);
					if (sites.length > 0){
							room.siteNumber = sites.length;
					}
			}
			if ((!room.memory.spawnPos || !room.memory.spawnPos.toPos()) && room.controller.level < 3 &&
					(!ready() || !access(room.name).baseLocation || access(room.name).baseLocation === 'none')){
					console.log('no spawn pos');
					return
			}
			console.log('placing sites',room.hyperlink);
			if (room.name && Memory.toRestructure && Memory.toRestructure.includes(room.name)){
					return
			} else {
					if (Game.flags['moveStore' + room.name]){
							Game.flags['moveStore' + room.name].remove();
					}
			}
			let structureCache = access(room.name).structures;
			if (!structureCache){
					console.log('placing: no s cache',room.name);
					return
			}
			if (structureCache['road']){
					//regen road cache if needed
					let positions = [];
					if (structureCache['road']){
							for (let i in structureCache['road']){
									let pos = structureCache['road'][i].toPos();
									if (pos){
											positions.push(pos);
									}
							}
					}
					setRoadPositions(room.name,room.name,positions);
			}
			if (structureCache.upCont){
					room.memory.upContPos = structureCache.upCont;
					console.log(room.name,'upcontpos',structureCache.upCont);
			}
			let canSafeMode = (room.controller.safeModeAvailable && !room.controller.safeModeCooldown) || room.controller.safeMode;
			if ((room.memory.bunker || (Game.flags['bunker'+room.name] && room.controller.level < 8)) && structureCache && room.memory.fixedBaseOrigin){
					room.memory.bunker = true;
					buildBunker(room,structureCache,canSafeMode);
					for (let i in structureCache['extension']){
							let pos = structureCache['extension'][i].toPos();
							new RoomVisual(pos.roomName).text(i,pos);
					}
					if (room.controller.level > 4 && room.storage && room.total('energy') > (room.memory.reserve*0.9) && (!room.memory.lastAttacked || canSafeMode  || Game.time-room.memory.lastAttacked>5000)){
							sourceStructures(room);
							if (!room.memory.lastAttacked || canSafeMode || Game.time-room.memory.lastAttacked>20000){
									buildStructure(room,'extension',structureCache['extension'].slice(0,8));
									buildStructure(room,'extension',structureCache['extension'].slice(10,16));
							}
							if (!room.memory.lastAttacked || Game.time-room.memory.lastAttacked>40000){
									buildStructure(room,'extension',structureCache['extension'].slice(18,24));
									buildStructure(room,'extension',structureCache['extension'].slice(26,40));
									buildStructure(room, 'road', structureCache['startRoads']);
							}
					}
					return
			} else {
					delete room.memory.bunkerRampartPositions;
			}
			if (Game.flags['delay' + room.name] && room.controller.level < 7){
					let block = false;
					if (Game.flags['block'+room.name]){
							block = true;
					}
					if (room.controller.level > 2 && !room.memory.hostiles && structureCache){
							buildStructure(room, 'rampart', structureCache['tower'].slice(0,1));
							buildStructure(room, 'tower', structureCache['tower'].slice(0,1));
							if (!block && (!room.memory.lastAttacked || Game.time-room.memory.lastAttacked>3000 || canSafeMode)){
									buildStructure(room, 'rampart', structureCache['spawn'].slice(0,1));
									let pos = structureCache['spawn'][0].toPos();
									if (pos.lookAround(LOOK_STRUCTURES,0,{filter:(s)=>s.structureType === STRUCTURE_RAMPART && s.hits > 5000}).length === 0){
											return
									}
									buildStructure(room,'spawn',structureCache['spawn'].slice(2,3));
									buildStructure(room,'extension',structureCache['extension'].slice(0,8));
							}
							if (room.controller.level > 4){
									buildStructure(room, 'rampart', structureCache['tower'].slice(1,2));
									buildStructure(room, 'tower', structureCache['tower'].slice(1,2));
							}
					}
					if ((!room.memory.lastAttacked || canSafeMode  || Game.time-room.memory.lastAttacked>5000) && !room.memory.hostiles);
					return
			}
			sourceStructures(room);
			if (room && structureCache){
					for (var s in structureCache){
							testStructures(s, structureCache[s], room);
					}
			}
			if (!structureCache){
					console.log("no structure cache", room);
					delete room.memory.build;
					return
			}
			if (structureCache.staticFillerSpots){
					room.memory.staticFillerSpots = structureCache.staticFillerSpots;
			}
			if (structureCache.fillerTower && structureCache.fillerTower[0]){
					room.memory.staticFillerTowerPosition = structureCache.fillerTower[0];
			}
			var structurelist = room.find(FIND_STRUCTURES);
			let spawn = Game.spawns[room.memory.spawn];
			if (!spawn){
					spawn = room.find(FIND_STRUCTURES,{filter:(s)=>s.structureType === STRUCTURE_SPAWN})[0];
			}
			if (!spawn && (!room.controller.safeMode || (!room.controller.safeModeAvailable && !room.memory.safeModeCooldown))){
					if (Memory.myRooms.length === 1){
							buildStructure(room, 'spawn', structureCache['spawn']);
					}
					buildStructure(room, 'rampart', structureCache['spawn'].slice(0,1));
					let pos = structureCache['spawn'][0].toPos();
					if (pos.lookAround(LOOK_STRUCTURES,0,{filter:(s)=>s.structureType === STRUCTURE_RAMPART && s.hits > 5000}).length === 0){
							return
					}
			}
			var extractor = room.mineral.pos.lookFor(LOOK_STRUCTURES)[0];
			if (!extractor && room.controller.level > 5){
					room.mineral.pos.createConstructionSite(STRUCTURE_EXTRACTOR);
			}
			if (!room.memory.roadsDown){
					let roads = structurelist.filter((s) => s.structureType == STRUCTURE_ROAD);
					if (roads.length > 30 || room.controller.level > 3){
							room.memory.roadsDown = true;
					}
			}
			let extensions = structurelist.filter((s) => s.structureType == STRUCTURE_EXTENSION);
			let towers = structurelist.filter((s) => s.structureType == STRUCTURE_TOWER);
			if (extensions){
					extensions.forEach((e) => {
							if (room.memory.fixedBaseOrigin && room.class == 'normal' && !Game.flags['ManualExtensions' + room.name] && structureCache['extension'] && !structureCache['extension'].includes(e.pos.toString())){
									new RoomVisual(room.name).text('X', e.pos, {color: 'red', font: 0.6});
									if (e.structureType != STRUCTURE_SPAWN);
							}
					});
					if (extensions.length < CONTROLLER_STRUCTURES['extension'][room.controller.level]){
							console.log(room.name, 'insufficient extensions');
					}
			}
			if (towers){
					towers.forEach((e) => {
							if (structureCache['tower'] && !structureCache['tower'].includes(e.pos.toString())){
									new RoomVisual(room.name).text('X', e.pos, {color: 'red', font: 0.6});
									// e.destroy()
							}
					});
			}
			buildStructure(room, 'spawn', structureCache['spawn']);
			if (!Game.flags['pray' + room.name] && room.controller.level > 2){
					buildStructure(room, 'tower', structureCache['tower']);
			}
			if (room.siteNumber > 10 && Game.shard.name == 'shard2'){
					return
			}
			buildStructure(room, 'link', structureCache['link']);
			if (structureCache['link'] && structureCache['link'][0]){
					room.memory.storeLinkPos = structureCache['link'][0];
			}

			function placeExtraLink(name,pos){
					let targetPosStr;
					if (name){
							targetPosStr = structureCache[name][0];
					}
					let targetPos;
					if (targetPosStr){
							targetPos = targetPosStr.toPos();
					}
					if (pos){
							targetPos = pos;
					}
					if ((!room.memory.uplink || !Game.getObjectById(room.memory.uplink)) &&
							(room.controller.level === 8 || !room.memory.thoriumMineSupportRoom)){
							return
					}
					if (targetPos){
							let link = targetPos.lookAround(LOOK_STRUCTURES, 0, {filter: (s) => s.structureType == STRUCTURE_LINK})[0];
							if (link){
									if (!room.memory.extraLinks){
											room.memory.extraLinks = {};
									}
									room.memory.extraLinks[link.id] = true;
							} else {
									let site = targetPos.lookAround(LOOK_CONSTRUCTION_SITES, 0, {filter: (s) => s.structureType == STRUCTURE_LINK})[0];
									if (!site){
											targetPos.createConstructionSite(STRUCTURE_LINK);
									}
							}
					}
			}

	//console.log(JSON.stringify(structureCache))
			if (structureCache['factory'] && room.controller.level > 5 && (room.controller.level !== 8 || room.memory.thoriumSupportLinkPos) && (room.controller.level < 7 || !config$1.level7max) &&
					room.memory.priorityEnergyRoom){
					let s1 = room.memory.s1;
					let s2 = room.memory.s2;
					if (s1 && room.memory.sourcePositions && room.memory.sourcePositions[s1] && room.memory.sourcePositions[s1].link){
							let linkPos = room.memory.sourcePositions[s1].link.toPos();
							let link = linkPos.lookAround(LOOK_STRUCTURES, 0, {filter: (s) => s.structureType == STRUCTURE_LINK})[0];
							if (link){
									link.destroy();
							}
					}
					if (s2 && room.memory.sourcePositions && room.memory.sourcePositions[s2] && room.memory.sourcePositions[s2].link){
							let linkPos = room.memory.sourcePositions[s2].link.toPos();
							let link = linkPos.lookAround(LOOK_STRUCTURES, 0, {filter: (s) => s.structureType == STRUCTURE_LINK})[0];
							if (link){
									link.destroy();
							}
					}
					if (!config$1.season || !config$1.season !== 'power'){
							if (room.memory.thoriumMineSupportRoom && room.memory.thoriumSupportLinkPos){
									let link;
									if (room.memory.uplink){
											link = Game.getObjectById(room.memory.uplink);
									}
									if (link && room.controller.level < 8){
											link.destroy();
									} else {
											placeExtraLink(undefined,room.memory.thoriumSupportLinkPos.toPos());
											if (room.controller.level !== 8 || !config$1.processPower){
													placeExtraLink('powerSpawn');
											}
									}
							} else {
									if (room.controller.level !== 8 || !config$1.processPower){
											placeExtraLink('powerSpawn');
									}
							}
					}
					placeExtraLink('factory');
			}
			if ((config$1.season && config$1.season === 'power')|| config$1.processPower){
					buildStructure(room, 'powerSpawn', structureCache['powerSpawn']);
			}
			if (room.memory.thoriumSupportLink && (!room.memory.thoriumMineSupportRoom || !room.memory.thoriumSupportLinkPos)){
					if (Game.getObjectById(room.memory.thoriumSupportLink)){
							Game.getObjectById(room.memory.thoriumSupportLink).destroy();
					}
					delete room.memory.thoriumSupportLink;
			}
			if (room.controller.level > 7 || (room.controller.level > 6 && config$1.level7max)){
					if (room.memory.extraLinks){
							for (let l in room.memory.extraLinks){
									if (room.memory.thoriumMineSupportRoom){
											continue
									}
									if (Game.getObjectById(l)){
											Game.getObjectById(l).destroy();
									} else {
											delete room.memory.extraLinks[l];
									}
							}
					}
					buildStructure(room, 'spawn', structureCache['spawnb']);
					buildStructure(room, 'spawn', structureCache['spawnc']);
					if (!config$1.swc && config$1.marketActive){
							buildStructure(room, 'factory', structureCache['factory']);
					}
					buildStructure(room, 'observer', structureCache['observer']);
					if (config$1.official || config$1.powerCollection){
							buildStructure(room, 'powerSpawn', structureCache['powerSpawn']);
					}
					buildStructure(room, 'nuker', structureCache['nuker']);
			} else if (room.controller.level > 6){
					buildStructure(room, 'spawn', structureCache['spawnb']);
			}
			if (room.controller.level > 1 || true){
					//remote
					Game.cpu.getUsed();
			}
			if (room && structureCache && Memory.sites < 100 && !Game.flags['pray' + room.name]){
					buildStructure(room, 'extension', structureCache['extension']);
					if (structureCache['storage'] && structureCache['storage'][0]){
							let pos = structureCache['storage'][0].toPos();
							if (pos){
									let site = pos.lookAround(LOOK_CONSTRUCTION_SITES,0,{filter:(s)=>s.structureType !== 'storage'})[0];
									if (site){
											site.remove();
									}
							}
					}
					buildStructure(room, 'storage', structureCache['storage']);
					if (room.controller.level > 3 && room.storage && room.controller.level < 7);
					if (room.controller.level > 2 && (Game.gcl.level > 1 || !room.controller.safeMode)){
							let sRamps = structureCache['structureRamps'];
							for (let i in sRamps){
									let pos = sRamps[i].toPos();
									if (pos){
											let structures = pos.lookAround(LOOK_STRUCTURES,0);
											for (let i in structures){
													if (structures[i].structureType !== 'road' && structures[i].structureType !== 'container'
													&& structures[i].structureType !== 'wall' && structures[i].structureType !== 'link' && structures[i].structureType !== 'extension'){
															pos.createConstructionSite('rampart');
															break
													}
											}
									}
							}
					}
					if (room.controller.level > 3 && room.storage  && room.energyCapacityAvailable > 1500 && room.ecoStable && room.storage.my && (room.memory.activateRamparts || (Game.gcl.level > 1 && room.controller.level > 5) || room.controller.level > 6 ||
							!room.controller.safeModeAvailable || room.controller.safeModeCooldown || Game.gcl.level > 2)){
							room.memory.activateRamparts = true;
							buildStructure(room, 'rampart', structureCache['rampart']);
							//let ramparts = room.find(FIND_STRUCTURES, {filter: (s) => s.structureType == STRUCTURE_RAMPART})
							//let walls = room.find(FIND_STRUCTURES, {filter: (s) => s.structureType == STRUCTURE_WALL})
							// for (let i in ramparts){
							// 		let pos = ramparts[i].pos
							// 		if (room.controller.level < 6 && (pos.x < 3 || pos.y < 3 || pos.x > 46 || pos.y > 46)){
							// 				//so as to not remove the outer wall rampart
							// 				continue
							// 		}
							// 		if (structureCache['rampart'] && !structureCache['rampart'].includes(pos.toString()) && room.memory.fixedBaseOrigin
							// 				&& pos.lookAround(LOOK_STRUCTURES, 0, {filter: (s) => s.structureType != STRUCTURE_ROAD && s.structureType != STRUCTURE_EXTENSION}).length == 1){
							// 				ramparts[i].destroy()
							// 				ramparts[i].pos.highlight('black')
							// 		}
							// }
							// for (let i in walls){
							// 		let pos = walls[i].pos
							// 		if (structureCache['rampart'] && structureCache['rampart'].includes(pos.toString())){
							// 				//walls[i].destroy()
							// 		}
							// }
					}
					buildStructure(room, 'terminal', structureCache['terminal']);
					if (structureCache['labPoint']){
							room.memory.labPointOverRide = structureCache['labPoint'][0].toString();
					}
					if (room.energyCapacityAvailable >= 1800){
							let labs = structureCache['lab'];
							if (room.memory.defcon && room.memory.defcon < 4){
									labs = labs.slice(0, 2);
									if (room.memory.labsUp){
											labs = [];
									}
							}
							buildStructure(room, 'lab', labs);
					}
					if (room.energyCapacityAvailable >= 550 && (room.storage || room.memory.storeCont) && structureCache['startRoads']){
							buildStructure(room, 'road', structureCache['startRoads']);
					}
					if (room.controller.level > 5 && room.storage){
							buildStructure(room, 'road', structureCache['road']);
							let plannedRoads = [];
							let roads = room.find(FIND_STRUCTURES, {filter: (s) => s.structureType == STRUCTURE_ROAD});
							for (let i in roads){
									let pos = roads[i].pos;
									if (structureCache['road'] && structureCache['road'].includes(pos.toString())){
											plannedRoads.push(roads[i].id);
									}
							}
							save(room.name, 'roadIDs', plannedRoads);
					}
					if (Game.rooms['rally' + room.name] && false){
							Game.rooms['rally' + room.name].remove();
					}
					if (room && structureCache){
							for (var s in structureCache){
									continue
							}
					}
			}

			function buildStructure(room, sType, poslist){
					if (!poslist || poslist.length < 1){
							return
					}
					for (var i in poslist){
							try {
									let site = poslist[i].toPos();
									if (sType == 'extension' && site && room.memory.blockExtPos && room.memory.blockExtPos.includes(poslist[i])){
											return
									}
									if (site && sType == 'road'){
											let struc = _.filter(site.lookFor(LOOK_STRUCTURES), (s) => s.structureType != 'rampart');
											if (struc.length > 0){

											} else {
													site.createConstructionSite(sType);
											}
									} else if (site){
											site.createConstructionSite(sType);
									}
							} catch (err){
									console.log(err + ' when building ' + sType + ' at ' + poslist[i].x + ',' + poslist[i].y, room.name);
							}
					}
			}
	}

	function sourceStructures(room){
			let sources = room.find(FIND_SOURCES);
			if (room.class == 'restructuring'){
					return
			}
			if (!room.memory.sourcePositions){
					room.memory.sourcePositions = {};
			}
			for (let i in sources){
					if (!room.memory.sourcePositions[sources[i].id]){
							room.memory.sourcePositions[sources[i].id] = {};
					}
			}
			let taken = {};
			for (let sp in room.memory.sourcePositions){
					let sourcePos = room.memory.sourcePositions[sp];
					let source = Game.getObjectById(sp);
					if (source && sourcePos){
							if (!sourcePos.pos){
									let neighbours = source.pos.neighbours(1);
									let topScore, topNeighbour;
									for (let n in neighbours){
											let neighbour = neighbours[n];
											if (!neighbour){
													continue
											}
											if (neighbour.getTerrain() != 'wall' && !neighbour.onEdge() && !neighbour.nearEdge()){
													let score = 0;
													let seconds = neighbour.neighbours(1);
													seconds.forEach((s) => {
															if (s.getTerrain() != 'wall' && !s.onEdge() && !s.nearEdge() && s.getRangeTo(room.controller)> 2){
																	score++;
															}
															if (s.lookAround(LOOK_STRUCTURES, 0, {filter: (s) => s.structureType == STRUCTURE_ROAD})[0]){
																	score++;
															}
													});
													if (!topNeighbour || topScore < score){
															topNeighbour = neighbour;
															topScore = score;
													}
											}
									}
									if (topNeighbour){
											sourcePos.pos = topNeighbour.toString();
									}
							}
							if (room.energyCapacityAvailable < 850 && room.class === 'normal'){
									continue
							}
							let pos = sourcePos.pos.toPos();
							let neighbours = pos.neighbours(1);
							let strs = [];
							neighbours.forEach((s) => strs.push(s.toString()));
							if (pos){
									let path = PathFinder.search(pos, room.controller, {
											roomCallback: function (roomName){
													if (Game.rooms[roomName]){
															return Game.rooms[roomName].structureMatrix
													}
											}
									});
									if (path){
											path.path.forEach((p) => {
													if (strs.includes(p.toString())){
															taken[p.toString()] = true;
													}
											});
									}
							}
							//prevent extensions blocking corridors
							let matrix = room.structureMatrix;
							for (let i in neighbours){
									let dirAway = pos.getDirectionTo(neighbours[i]);
									let neighbour1Step = neighbours[i].movePos(dirAway);
									if (matrix && (neighbours[i].getTerrain()==='wall' || neighbour1Step.getTerrain()==='wall')){
											let dir = neighbours[i].getDirectionTo(pos);
											let possibleBlockPos = pos.movePos(dir);
											if (possibleBlockPos.isNearTo(source)){
													continue
											}
											let deciderPos = possibleBlockPos.movePos(dir);
											if (matrix.get(deciderPos.x,deciderPos.y) === 255 || deciderPos.getTerrain()==='wall'){
													//placing a site on possible blockPos will potentially block a corridor
													taken[possibleBlockPos.toString()] = true;
													possibleBlockPos.highlight('blue');
											}
									}
							}
							if (room.controller.level < 2){
									continue
							}
							let e1, e2, link;
							let e1Check = checkIfPresent('e1', 'extension');
							if (e1Check){
									e1 = e1Check;
							}
							let e2Check = checkIfPresent('e2', 'extension');
							if (e2Check){
									e2 = e2Check;
							}
							let linkCheck = checkIfPresent('link', 'link');
							if (linkCheck){
									link = linkCheck;
									let container = pos.lookAround(LOOK_STRUCTURES, 0, {filter: (s) => s.structureType == STRUCTURE_CONTAINER})[0];
									if (container && checkIfPresent('link', 'link', true)){
											container.destroy();
									}
							}

							function checkIfPresent(variableName, structureType, structureOnly){
									if (sourcePos[variableName] && sourcePos[variableName].toPos()){
											let pos = sourcePos[variableName].toPos();
											let structure = pos.lookAround(LOOK_STRUCTURES, 0, {filter: (s) => s.structureType == structureType});
											let site = pos.lookAround(LOOK_CONSTRUCTION_SITES, 0, {filter: (s) => s.structureType == structureType});
											if (structure[0] || (site[0] && !structureOnly)){
													taken[pos.toString()] = true;
													return pos.toString()
											} else {
													return false
											}
									}
							}

							let isPriorityRoom = false;
							if (room.memory.priorityEnergyRoom || config$1.singleSpawn){
									isPriorityRoom = true;
							}
							if (!link && room.controller.level > 5 && room.class !== 'bunker' && !isPriorityRoom){
									for (let i in neighbours){
											let n = neighbours[i];
											if (n.getTerrain() !== 'wall' && n.getRangeTo(room.controller)>3 && !taken[n.toString()]){
													link = n.toString();
													taken[n.toString()] = true;
													n.createConstructionSite(STRUCTURE_LINK);
													break
											}
									}
							}
							if (!e1){
									for (let i in neighbours){
											let n = neighbours[i];
											if (n.getTerrain() !== 'wall' && n.getRangeTo(room.controller)>3 && !taken[n.toString()]){
													e1 = n.toString();
													taken[n.toString()] = true;
													n.createConstructionSite(STRUCTURE_EXTENSION);
													break
											}
									}
							}
							if (!e2){
									for (let i in neighbours){
											let n = neighbours[i];
											if (n.getTerrain() !== 'wall' && n.getRangeTo(room.controller)>3&& !taken[n.toString()]){
													e2 = n.toString();
													taken[n.toString()] = true;
													n.createConstructionSite(STRUCTURE_EXTENSION);
													break
											}
									}
							}
							if (e1){
									sourcePos.e1 = e1.toString();
							} else {
									delete sourcePos.e1;
							}
							if (e2){
									sourcePos.e2 = e2.toString();
							} else {
									delete sourcePos.e2;
							}
							if (link){
									sourcePos.link = link.toString();
							} else {
									delete sourcePos.link;
							}
					}
			}
	}

	function testStructures(t, poslist, room){
			let colours = {
					'extension': 'yellow',
					'road': 'grey',
					'store': 'pink',
					'terminal': 'blue',
					'link': 'red',
					'lab': 'purple',
					'rampart': 'green',
					'tower': 'orange'
			};
			if (t && colours[t] && poslist && poslist.length > 0){
					try {
							for (var i in poslist){
									let site = poslist[i].toPos();
									if (site){
											new RoomVisual(room.name).circle(site, {fill: colours[t], radius: 0.4});
									}
							}
					} catch (err){
							console.log(err.stack.split("at"));
					}
			} else if (t && t != 'sections' && t != 'upCont'){
					try {
							for (let i in poslist){
									let site = poslist[i].toPos();
									if (site){
											new RoomVisual(room.name).text(t.charAt(0) + t.charAt(1), site, {size: 0.8});
									}
							}
					} catch (err){
							console.log(err.stack.split("at"));
					}
			}
	}
	function buildBunker(room,structureCache,canSafeMode){
			if (room.controller.level < 3){
					return
			}
			let dir = room.memory.fixedBaseDir;
			let pos = room.memory.fixedBaseOrigin.toPos();
			let spawn1 = structureCache['spawn'][2].toPos();
			let spawn2 = structureCache['spawn'][0].toPos();
			let store = structureCache['storage'][0].toPos();
			let term = findRelativePosition(pos,-1,2,dir);
			let lab = findRelativePosition(pos,1,-1,dir);
			let link1 = findRelativePosition(pos,0,2,dir);
			let bunkerOrigin = findRelativePosition(pos,-1,1,dir);
			room.memory.bunkerOrigin = bunkerOrigin.toString();
			room.memory.bunkerExit = findRelativePosition(pos,1,1,dir).toString();
			let towers = [
					findRelativePosition(pos,-2,1,dir),
					findRelativePosition(pos,-2,0,dir),
					findRelativePosition(pos,0,-1,dir)
			];
			let ramps = {};
			let structures = [];
			let towerStructures = towers[0].lookAround(LOOK_STRUCTURES,0,{filter:(s)=>s.my &&
							(s.structureType === 'tower' || s.structureType === 'rampart')});
			buildStructure(towers[0],'rampart');
			if (towerStructures.length === 0){
					return
			}
			buildStructure(towers[0],'tower');
			if (towerStructures.length < 2){
					return
			}
			buildStructure(towers[1],'tower');
			if (room.controller.level > 3 && (canSafeMode || !room.memory.lastAttacked || Game.time-room.memory.lastAttacked>3000)){
					buildStructure(spawn1,'spawn');
					if (room.controller.level > 3){
							buildStructure(store, 'storage');
					}
					if (room.controller.level > 6){
							buildStructure(spawn2,'spawn');
					}
					if (room.controller.level > 4){
							buildStructure(link1,'link');
					}
					if (room.controller.level > 5){
							buildStructure(towers[2],'tower');
							buildStructure(term,'terminal');
							buildStructure(lab,'lab');
							room.mineral.pos.createConstructionSite(STRUCTURE_EXTRACTOR);
					}
			}
			function buildStructure(pos,type){
					if (pos){
							structures.push(pos);
							pos.createConstructionSite(type);
					}
			}
			let checked = {};
			let rampsStr = [];
			for (let s in structures){
					let pos = structures[s];
					if (!checked[pos.toString()]){
							checked[pos.toString()] = true;
							pos.createConstructionSite('rampart');
							rampsStr.push(pos.toString());
					}
					let interval = 2;
					if (room.controller.level > 5){
							interval = 1;
					}
					for (let i = 1; i < 9; i += interval){
							let neighbour = pos.movePos(i);
							if (neighbour && !checked[neighbour.toString()]){
									let nStr = neighbour.toString();
									rampsStr.push(nStr);
									checked[nStr] = true;
									neighbour.createConstructionSite('rampart');
									if (!structures.find((s)=>s.toString() === nStr) && room.controller.level > 4){
											neighbour.createConstructionSite('road');
									}
							}
					}
			}
			for (let i in ramps){
					rampsStr.push(ramps[i].toString());
			}
			room.memory.bunkerRampartPositions = rampsStr;
	}

	function cpuBlock$1(){
			if (Game.cpu.bucket < 1000 || Game.cpu.getUsed() > 100){
					return true
			}
	}
	let allGenerators$1 = {};
	let ticks = {};
	let results = {};
	function runMinCut(origin, sources, sinks, blockFullDFS){
			if (cpuBlock$1() || !origin || !sources || !sinks){
					return
			}
			let originStr = origin.toString();
			if (ticks[originStr] && ticks[originStr] === Game.time){
					return
			}
			ticks[originStr] = Game.time;
			console.log('running min cut');
			if (!allGenerators$1[originStr]){
					allGenerators$1[originStr] = _runMinCut(origin, sources, sinks);
			} else {
					try {
							let ret = allGenerators$1[originStr].next();
							if (ret.done === true || results[originStr]){
									delete allGenerators$1[originStr];
									console.log('min cut done');
									return results[originStr]
							} else {
									console.log(origin,'gen running',ret.value);
							}
					} catch (err){
							console.log('min cut gen',origin,err);
							delete allGenerators$1[originStr];
					}
			}
	}
	function* _runMinCut(origin, sources, sinks, blockFullDFS){
			//in order to avoid building exits, flow is never saturated at level 0 or 1 of the level so bear this in mind if using sinks that are not exits
			//origin is the base origin, basically a point to act as final sink, and to choose the direction of the first step of exit tiles
			//sinks are base walls, the standard ones, minimum distance from base interior
			//sources are exit tiles or closer if that is preferable
			//as capacity is 1 for all edges we can effectively just have a true or false for each edge, false meaning it has been saturated
			let exitBlocks = {};
			let room = Game.rooms[origin.roomName];
			let exits = room.find(FIND_EXIT);
			for (let i in exits){
					let exit = exits[i];
					let neighbours = exit.neighbours();
					for (let n in neighbours){
							let str = neighbours[n].toString();
							exitBlocks[str] = true;
					}
			}
			for (let i in sinks){
					if (sinks[i]);
					if (sinks[i].onEdge()){
							let side = sinks[i].getEdge();
							sinks[i].movePos(side.map8(4),true);
					}
			}
			let sourcesStrings = {};
			let sinkStrings = {};
			let finishedGraph = false;
			let G = createGraph();
			if (cpuBlock$1()){
					yield 'create graph';
			}
			while (!finishedGraph){
					//step 1, build level graph BFS
					//step 2, if sink was not reached then stop
					if (cpuBlock$1()){
							yield 'start while loop';
					}
					Game.cpu.getUsed();
					let reachedSink = formLevelGraph();
					if (cpuBlock$1()){
							yield 'level graph';
					}
					//console.log('level',Game.cpu.getUsed()-cpu)
					if (!reachedSink){
							finishedGraph = true;
					}
					//step 3, using level graph, do multiple DFSs until a blocking flow is reached
					let DFSsuccess = true;
					let augmentingPaths = [];
					let count = 0;
					while (DFSsuccess){
							if (cpuBlock$1()){
									yield 'DFS';
							}
							Game.cpu.getUsed();
							DFSsuccess = DFSmanager(augmentingPaths, count);
							//console.log('DFS',Game.cpu.getUsed()-cpu)
							count++;
					}
			}
			// if (G){
			// 		for (let i in G){
			// 				let pos = i.toPos()
			// 				if (pos){
			// 						for (let j in G[i].edges){
			// 								let pos2 = j.toPos()
			// 								if (!G[i].edges[j] && pos2){
			// 										new RoomVisual(pos2.roomName).line(pos,pos2)
			// 								} else if (j === 'sink'){
			// 										pos.highlight('gold')
			// 								}
			// 						}
			// 				}
			// 		}
			// }
			results[origin.toString()] = findWalls();
			return true

			function findWalls(){
					//runPCs BFS from the source s. The min cut is just the set of edges (u, v) for which u is reachable from s, and v is not.
					let walls = {};
					let fillGapsWalls = {};
					let hasReached = {};
					let hasChecked = {};
					let queue = ['source'];
					let count = 1;
					while (queue.length > 0){
							let current = queue.shift();
							let currentNode = G[current];
							let edges = currentNode.edges;
							for (let e in edges){
									let edge = edges[e];
									if (e === 'sink'){
											//this edge can enter our base, plug the gap
											//new RoomVisual(e.toPos().roomName).line(e.toPos(),current.toPos(),{color:'red'})
											fillGapsWalls[current] = true;
									} else if (edge === false){
											if (!hasReached[e]){
													//new RoomVisual(e.toPos().roomName).line(e.toPos(),current.toPos(),{color:'green'})
													walls[e] = true;
											}
									} else {
											if (walls[e]){
													delete walls[e];
											}
											hasReached[e] = count;
											if (!hasChecked[e]){
													queue.push(e);
													hasChecked[e] = true;
											}
									}
							}
							count++;
					}
					let finalWalls = Object.assign(walls, fillGapsWalls);
					let ret = [];
					for (let i in finalWalls){
							let wall = i.toPos();
							if (wall){
									ret.push(wall);
									wall.highlight('orange');
							}
					}
					for (let i in hasChecked){
							let wall = i;
							if (wall && wall.toPos()){
									wall.toPos().highlight('blue');
							}
					}
					return ret

			}

			function DFSmanager(augmentingPaths, count){
					let currentPath = [];
					let checked = {};
					G['sink'].level;
					let endSearch = false;
					let foundSink = DFS('source');
					if (foundSink){
							augmentingPaths[count] = currentPath;
							for (let i = 1; i < currentPath.length - 1; i++){
									let node = G[currentPath[i]];
									if (node && node.level && !exitBlocks[currentPath[i]] && currentPath[i] && currentPath[i + 1] && node.edges && node.edges[currentPath[i + 1]]){
											if (node.edges[currentPath[i + 1]] !== true){
													let int = Number.parseInt(G[currentPath[i]].edges[currentPath[i + 1]]);
													for (let e in node.edges){
															let edge = node.edges[e];
															if (edge !== true && (edge == int.map8(2) || edge == int.map8(-2))){
																	if (G[e] && G[e].edges[currentPath[i + 1]]){
																			G[e].edges[currentPath[i + 1]] = false;
																	}
															}
													}
											}
											G[currentPath[i]].edges[currentPath[i + 1]] = false;
									}
							}
							return true
					}
					return false

					function DFS(current){
							let node = G[current];
							if (node && !endSearch){
									currentPath.push(current);
									let edges = [];
									for (let i in node.edges){
											if (node.edges[i] && G[i]){
													if (i === 'sink'){
															endSearch = true;
															currentPath.push('sink');
															current.toPos().highlight('gold');
															return true
													} else {
															edges.push(i);
													}
											}
									}
									//order edges by level
									edges.sort((a, b) => G[b].level - G[a].level);
									for (let e in edges){
											let i = edges[e];
											let nextNode = node.edges[i];
											if (!checked[i] && nextNode && G[i] && G[i].level >= node.level && !currentPath.includes(i)){
													let ret = DFS(i);
													if (ret){
															if (current && current.toPos()){
																	current.toPos().highlight('green');
															}
															return true
													} else {
															checked[i] = true;
													}
											}
									}
									currentPath.pop();
									if (current && current.toPos());
									return false

							}
					}
			}

			function formLevelGraph(){
					let visited = {'source': true};
					let queue = [['source', 0]];
					let reachedSink = false;
					while (queue.length > 0){
							let current = queue.shift();
							let node = G[current[0]];
							if (node){
									node.level = current[1];
									for (let i in node.edges){
											if (node.edges[i] && i === 'sink'){
													G['sink'].level = node.level + 1;
													reachedSink = true;
													continue;
											}
											if (node.edges[i] && !visited[i]){
													queue.push([i, node.level + 1]);
													visited[i] = true;
											}
									}
							}
					}
					return reachedSink;
			}

			function createGraph(){
					let graph = {
							//nodes need to be able to store level, and whether their edge in a direction is saturated,
							//if no edge exits in that direction then there is no capacity ie its towards a wall or source
							//store node by x+-+y
							'source': {edges: {}},
							'sink': {}
					};
					let queue = [];
					for (let i in sources){
							//add the sources to the graph
							let source = sources[i];
							if (!source.roomName || source.getTerrain() === 'wall'){
									continue
							}
							sourcesStrings[source.toString()] = true;
							graph.source.edges[source.toString()] = true;
							let dir = source.getDirectionTo(origin);
							let neighbours = [source.movePos(dir), source.movePos(dir.map8(1)), source.movePos(dir.map8(-1))];
							//add the nodes near to the sources to the graph, and to the queue so we can flood
							if (!graph[source.toString()]){
									graph[source.toString()] = {edges: {}};
									for (let n in neighbours){
											if (!neighbours[n] || neighbours[n].getTerrain() === 'wall' || neighbours[n].roomName != origin.roomName || neighbours[n].onEdge()){
													continue
											}
											if (!graph[source.toString()].edges[neighbours[n].toString()]){
													graph[source.toString()].edges[neighbours[n].toString()] = true;
											}
											if (!graph[neighbours[n].toString()]){
													queue.push(neighbours[n]);
													graph[neighbours[n].toString()] = {edges: {}};
											}
									}
							}
					}
					for (let i in sinks){
							let sink = sinks[i];
							if (!sink.roomName || sink.getTerrain() === 'wall'){
									continue
							}
							sinkStrings[sink.toString()] = true;
							//connect all the sinks to the final sink
							if (!graph[sink.toString()]){
									graph[sink.toString()] = {edges: {'sink': true}};
							} else {
									graph[sink.toString()].edges['sink'] = true;
							}
					}
					while (queue.length > 0){
							let currentNode = queue.shift();
							if (!currentNode || !currentNode.roomName){
									continue
							}
							let neighbours = {};
							let graphNode = graph[currentNode.toString()];
							if (sinkStrings[currentNode.toString()]){
									continue
							}
							for (let j = 1; j < 9; j++){
									let neighbour = currentNode.movePos(j);
									if (neighbour){
											neighbours[j] = neighbour;
									}
							}
							for (let j in neighbours){
									let neighbour = neighbours[j];
									let str = neighbour.toString();
									if (!neighbour.roomName || neighbour.getTerrain() === 'wall' || sourcesStrings[str] || neighbour.onEdge()){
											continue
									}
									//new RoomVisual(origin.roomName).line(currentNode,neighbour)
									//add edge for current node we are on
									graphNode.edges[str] = j;
									if (!graph[str]){
											graph[str] = {edges: {}};
											queue.push(neighbour);
									}
							}
					}
					return graph
			}
	}

	playerHeap.roomDesigner = {};
	playerHeap.roomDesigner.saveStructuresAll = {};
	playerHeap.roomDesigner.roomDesignerGenerators = {};
	playerHeap.roomDesigner.origins = {};
	playerHeap.roomDesigner.allStructureLists = {};
	playerHeap.roomDesigner.finalSites = {};
	let designerTick = {};
	function pushDesignerGenerators(){
			for (let i in playerHeap.roomDesigner.roomDesignerGenerators){
					if (Game.cpu.bucket < 200){
							break
					}
					if (designerTick && designerTick[i] === Game.time){
							continue
					}
					designerTick[i] = Game.time;
					if (playerHeap.roomDesigner.roomDesignerGenerators[i] && ready() && Game.rooms[i] && playerHeap.roomDesigner.origins[i]){
							let room = Game.rooms[i];
							console.log(`pushing room designer generation for ${i}`);
							let sites = designRoom(playerHeap.roomDesigner.origins[i].toPos(),Game.rooms[i]);
							if (sites){
									save(room.name, 'structures', sites);
									let positions = [];
									if (sites['road']){
											for (let i in sites['road']){
													let pos = sites['road'][i].toPos();
													if (pos){
															positions.push(pos);
													}
											}
									}
									setRoadPositions(room.name,room.name,positions);
									room.memory.build = config$1.buildVer;
									return
							}
					}
			}
	}
	function cpuBlock(){
			if (Game.cpu.bucket < 200 || Game.cpu.getUsed() > 300){
					return true
			}
	}

	function designRoom(origin,room, force){
			//allow pausing halfway to avoid crashing due to low cpu
			if (!room || cpuBlock() || !origin){
					return
			}
			console.log('designing room', room.hyperlink);
			if (!playerHeap.roomDesigner.roomDesignerGenerators[room.name]){
					playerHeap.roomDesigner.roomDesignerGenerators[room.name] = _designRoom(origin,room);
					playerHeap.roomDesigner.origins[room.name] = origin.toString();
			}
			try {
					let gen = playerHeap.roomDesigner.roomDesignerGenerators[room.name];
					if (gen.value === 'fixed base' && !playerHeap.roomDesigner.allStructureLists[origin.toString()]){
							let fixedBaseDir;
							if (access(room.name) && access(room.name).baseLocation && access(room.name).baseLocation != 'none'){
									fixedBaseDir = access(room.name).baseLocation[1];
							} else {
									return
							}
							if (!fixedBaseDir){
									return
							}
							placeFixedBase(origin,fixedBaseDir);
							return
					}
					let ret = playerHeap.roomDesigner.roomDesignerGenerators[room.name].next();
					// console.log('extension gen ->',ret.value)
					if (ret.done === true){
							delete playerHeap.roomDesigner.roomDesignerGenerators[room.name];
							return playerHeap.roomDesigner.finalSites[room.name]
					}
			} catch (err){
					console.log(err.stack.split("at"), 'design gen');
					delete playerHeap.roomDesigner.roomDesignerGenerators[room.name];
			}
	}
	function* _designRoom(origin, room){
			if (!ready() || Game.cpu.bucket < 500){
					return
			}
			//origin is where the first spawn goes, need to find this to design the room

			let fixedBaseDir;
			if (access(room.name) && access(room.name).baseLocation && access(room.name).baseLocation != 'none'){
					origin = access(room.name).baseLocation[0].toPos();
					fixedBaseDir = access(room.name).baseLocation[1];
			}
			if (!access(origin.roomName)){
					return
			}
			if (!access(room.name).baseLocation){
					console.log('no base location, cant design');
					return
			}
			console.log('fixedBaseDir', fixedBaseDir);
			if (origin && room){
					console.log('designing room', room.name);
					//remote
					//road matrix

					let roomName = room.name;
					//floodfill auto placement
					if (Game.cpu.bucket > 100){
							//core structures
							let structureRamps = [];
							let roadlist = [];
							let roadlist2 = [];
							let roadlist3 = [];
							let outerPerim = [];
							let ramps = [];
							let wallRamps = [];
							let newWallRamps = [];
							if (!playerHeap.roomDesigner.saveStructuresAll[room.name]){
									playerHeap.roomDesigner.saveStructuresAll[room.name] = {};
							}
							let saveStructures = playerHeap.roomDesigner.saveStructuresAll[room.name];
							//flexible base layout
							let extpos = [];
							let structurepos;
							let plannedRoads = new PathFinder.CostMatrix;
							let sources = room.find(FIND_SOURCES);
							if (!fixedBaseDir){
									let visited = {};
									let visxy = [];
									//to do list, rather than being recursive I will push the next node to this list in order to expand outwards
									let todo = [];
									spiral(origin, todo);
									while (todo.length > 0 && visxy.length < (CONTROLLER_STRUCTURES['extension'][8]) * 2){
											spiral(todo[0], todo);
											todo = todo.slice(1);
									}

									function spiral(node, todo){
											let terrain;
											if (node){
													terrain = node.getTerrain();
											}
											if (visited[node] || visited.length > (CONTROLLER_STRUCTURES['extension'][8]) * 2 || !node
													|| (node.x == origin.x && node.y < origin.y) || node.findInRange(FIND_EXIT, 5).length > 1 || (terrain && (terrain == 'wall'))
													|| node.findInRange(FIND_SOURCES, 2).length > 0 || node.inRangeTo(room.controller, 2)){
													return;
											}
											visited[node] = node;
											visxy.push(node.x, node.y);
											var neighboursx = [
													[node.x + 1],
													[node.x + 0],
													[node.x - 1],
													[node.x - 0],
													[node.x + 2],
													[node.x + 2],
													[node.x - 2],
													[node.x - 2]
											];
											var neighboursy = [
													[node.y + 0],
													[node.y + 1],
													[node.y + 0],
													[node.y - 1],
													[node.y + 2],
													[node.y - 2],
													[node.y + 2],
													[node.y - 2]

											];
											for (let i = 0; i < 8; i++){
													node = room.getPositionAt(neighboursx[i], neighboursy[i]);
													if (node){
															terrain = node.getTerrain();
													}
													if (i >= 4){
															todo.push(node);
													} else {
															if (visited[node] || visited.length > (CONTROLLER_STRUCTURES['extension'][8]) * 2 || node.inRangeTo(room.controller, 2) || (terrain && (terrain == 'wall')) ||
																	((node.x <= origin.x + 1 && node.x >= origin.x - 1) && (node.y <= origin.y && node.y >= origin.y - 3)) ||
																	((node.x <= origin.x + 3 && node.x >= origin.x - 3) && (node.y <= origin.y + 1 && node.y >= origin.y - 1)) ||
																	((node.x <= origin.x + 2 && node.x >= origin.x - 2) && (node.y <= origin.y + 3 && node.y >= origin.y))); else {
																	visited[node] = node;
																	visxy.push(node.x, node.y);
															}
													}
											}

									}

									for (i = 0; i < visxy.length; i += 2){
											let epos = room.getPositionAt(visxy[i], visxy[i + 1]);
											extpos.push(epos);
									}
									let spawnpos = [room.getPositionAt(origin.x, origin.y)];
									saveStructures['spawn'] = stringArray(spawnpos);
									structureRamps.push(spawnpos);
									let spawnbpos = [room.getPositionAt(origin.x - 1, origin.y)];
									saveStructures['spawnb'] = stringArray(spawnbpos);
									structureRamps.push(spawnbpos);
									var spawncpos = [room.getPositionAt(origin.x + 1, origin.y)];
									saveStructures['spawnc'] = stringArray(spawncpos);
									structureRamps.push(spawncpos);
									var labpos = [
											room.getPositionAt(origin.x, origin.y + 1),
											room.getPositionAt(origin.x, origin.y + 3),
											room.getPositionAt(origin.x - 1, origin.y + 2),
											room.getPositionAt(origin.x - 2, origin.y + 1),
											room.getPositionAt(origin.x + 1, origin.y + 2),
											room.getPositionAt(origin.x - 1, origin.y + 3),
											room.getPositionAt(origin.x + 1, origin.y + 3),
											room.getPositionAt(origin.x + 2, origin.y + 1),
											room.getPositionAt(origin.x - 2, origin.y + 3),
											room.getPositionAt(origin.x + 2, origin.y + 3)
									];
									labpos.forEach((p) => structureRamps.push(p));
									let factoryPos = [room.getPositionAt(origin.x + 1, origin.y - 5)];
									saveStructures['factory'] = stringArray(factoryPos);
									structureRamps.push(factoryPos);
									saveStructures['lab'] = stringArray(labpos);
									var storepos = [room.getPositionAt(origin.x, origin.y - 3)];
									saveStructures['storage'] = stringArray(storepos);
									structureRamps.push(storepos);
									var linkpos = [room.getPositionAt(origin.x + 1, origin.y - 4)];
									saveStructures['link'] = stringArray(linkpos);
									var termpos = [room.getPositionAt(origin.x - 1, origin.y - 4)];
									saveStructures['terminal'] = stringArray(termpos);
									structureRamps.push(termpos);
									structurepos = extpos.concat(spawnpos, spawnbpos, spawncpos, labpos, storepos, linkpos, termpos, factoryPos);
									let structureobj = {};
									for (i = 0; i < structurepos.length; i++){
											structureobj[structurepos[i]] = 1;
									}
									for (i = 0; i < structurepos.length; i++){
											placeRoads(structurepos[i], structureobj, plannedRoads, roadlist);
									}
									saveStructures['extension'] = stringArray(extpos);
							} else if (fixedBaseDir === 'small'){
									let visited = {};
									let visxy = [];
									//to do list, rather than being recursive I will push the next node to this list in order to expand outwards
									let todo = [];
									spiralSmall(origin, todo);
									while (todo.length > 0 && visxy.length < (CONTROLLER_STRUCTURES['extension'][8]) * 2){
											spiralSmall(todo[0], todo);
											todo = todo.slice(1);
									}
									for (i = 0; i < visxy.length; i += 2){
											let epos = room.getPositionAt(visxy[i], visxy[i + 1]);
											if ((epos.x <= origin.x + 5 && epos.x >= origin.x - 5)&& (epos.y <= origin.y + 5 && epos.y >= origin.y - 5)){
													continue
											}
											extpos.push(epos);
									}
									let midPos = findRelativePosition(origin,-1,-3,1);
									midPos.highlight('brown');
									saveStructures = placeSmallFixedBase(midPos);
									if (saveStructures['extension']){
											saveStructures['extension'] = saveStructures['extension'].concat(stringArray(extpos));
									} else {
											saveStructures['extension'] = stringArray(extpos);
									}
									let structureobj = {};
									structurepos = extpos;
									for (let i in saveStructures){
											let structureType = i;
											if (structureType === 'road'){
													continue
											}
											for (let s in saveStructures[i]){
													let pos = saveStructures[i][s].toPos();
													if (pos){
															structurepos.push(pos);
													}
											}
									}
									if (saveStructures['road']){
											for (let r in saveStructures['road']){
													saveRoadPos(saveStructures['road'][r], plannedRoads, roadlist);
											}
									}
									for (i = 0; i < structurepos.length; i++){
											structureobj[structurepos[i]] = 1;
									}
									for (i = 0; i < structurepos.length; i++){
											placeRoads(structurepos[i], structureobj, plannedRoads, roadlist);
									}
									function spiralSmall(node, todo){
											let terrain;
											if (node){
													terrain = node.getTerrain();
											}
											if (visited[node] || visited.length > (CONTROLLER_STRUCTURES['extension'][8]) * 2 || !node
													 || node.findInRange(FIND_EXIT, 5).length > 1 || (terrain && (terrain == 'wall'))
													|| node.findInRange(FIND_SOURCES, 2).length > 0 || node.inRangeTo(room.controller, 2)){
													return;
											}
											visited[node] = node;
											visxy.push(node.x, node.y);
											var neighboursx = [
													[node.x + 1],
													[node.x + 0],
													[node.x - 1],
													[node.x - 0],
													[node.x + 2],
													[node.x + 2],
													[node.x - 2],
													[node.x - 2]
											];
											var neighboursy = [
													[node.y + 0],
													[node.y + 1],
													[node.y + 0],
													[node.y - 1],
													[node.y + 2],
													[node.y - 2],
													[node.y + 2],
													[node.y - 2]

											];
											for (let i = 0; i < 8; i++){
													node = room.getPositionAt(neighboursx[i], neighboursy[i]);
													if (node){
															terrain = node.getTerrain();
													}
													if (i >= 4){
															todo.push(node);
													} else {
															if (visited[node] || visited.length > (CONTROLLER_STRUCTURES['extension'][8]) * 2 || node.inRangeTo(room.controller, 2) || (terrain && (terrain == 'wall')) ||
																	((node.x <= origin.x + 5 && node.x >= origin.x - 4)&& (node.y <= origin.y + 5 && node.y >= origin.y - 4)) ); else {
																	visited[node] = node;
																	visxy.push(node.x, node.y);
															}
													}
											}

									}
							} else if (origin){
									while (!playerHeap.roomDesigner.allStructureLists[origin.toString()]){
											placeFixedBase(origin, fixedBaseDir);
											console.log('finding fixed base',playerHeap.roomDesigner.allStructureLists[origin.toString()]);
											yield 'fixed base';
									}
									saveStructures = playerHeap.roomDesigner.allStructureLists[origin.toString()];
									if (saveStructures['road']){
											for (let r in saveStructures['road']){
													saveRoadPos(saveStructures['road'][r], plannedRoads, roadlist);
											}
									}
									if (saveStructures['rampart']){
											wallRamps = saveStructures['rampart'];
									}
							} else {
									return
							}
							//walls
							if (roadlist && (extpos || fixedBaseDir) && !Game.flags['ManualWalls' + roomName]){
									let notInRange = {};
									let allObj = {};
									let outer = [];
									if (!fixedBaseDir || fixedBaseDir === 'small'){
											let allPos = roadlist.concat(structurepos);
											for (var p in allPos){
													allObj[allPos[p]] = allPos[p];
											}
											for (var p in allPos){
													if (isOuter(allPos[p], allObj)){
															//new RoomVisual(room.name).circle(allPos[p],{fill:'red',radius:0.5})
															outer.push(allPos[p]);
													}
											}
									}
									let cNeighbours = room.controller.pos.neighbours(1);
									if (cNeighbours){
											for (var i in cNeighbours){
													let terrain = cNeighbours[i].getTerrain();
													if (terrain != 'wall'){
															ramps.push(cNeighbours[i]);
													}
											}
									}
									if (cpuBlock()){
											yield 'a';
									}
									//roads
									for (let s in sources){
											let path = PathFinder.search(origin, {pos: sources[s].pos, range: 1}, {
													plainCost: 2,
													swampCost: 10,
													roomCallback: function (roomName){
															return plannedRoads
													},
											});
											if (path && path.path.length > 0){
													for (let p in path.path){
															if (!path.path[p].isNearTo(sources[s])){
																	saveRoadPos(path.path[p], plannedRoads, roadlist2,true);
															}
													}
											}
									}
									//to controller
									let controller = room.controller;
									if (controller){
											//find controller upgrade pos
											let contPos;
											if (Segments && access(roomName).spaceMatrix2){
													let matrix = PathFinder.CostMatrix.deserialize(access(roomName).spaceMatrix2);
													let neighbours = controller.pos.neighbours(2);
													let possible = [];
													let possible2 = [];
													for (let n in neighbours){
															let neighbour = neighbours[n];
															let score = matrix.get(neighbour.x, neighbour.y);
															if (score === 2){
																	possible.push(neighbour);
															} else if (score === 1){
																	possible2.push(neighbour);
															}
													}
													let best, bestPath;
													let bestLength;
													for (let p in possible){
															let pos = possible[p];
															findBest(pos);
													}
													if (!best){
															for (let p in possible2){
																	let pos = possible2[p];
																	findBest(pos);
															}
													}

													function findBest(pos){
															pos.highlight('red');
															let pathObj = PathFinder.search(origin, {pos: pos, range: 1}, {
																	plainCost: 2,
																	swampCost: 10,
																	roomCallback: function (roomName){
																			return plannedRoads
																	},
															});
															if (!pathObj.incomplete && (!best || bestLength > pathObj.path.length)){
																	best = pos;
																	bestPath = pathObj.path;
																	bestLength = pathObj.path.length;
															}
													}

													if (best && bestPath){
															contPos = best;
															for (let p in bestPath){
																	saveRoadPos(bestPath[p], plannedRoads, roadlist2,true);
															}
													}
											}
											if (!contPos){
													let path = PathFinder.search(origin, {pos: controller.pos, range: 1}, {
															plainCost: 2,
															swampCost: 10,
															roomCallback: function (roomName){
																	return plannedRoads
															},
													});
													if (path){
															for (let p in path.path){
																	saveRoadPos(path.path[p], plannedRoads, roadlist2,true);
															}
													}
											} else {
													saveStructures['upCont'] = contPos.toString();
											}
									}
									let mineral = room.mineral;
									if (mineral){
											let path = PathFinder.search(origin, {pos: mineral.pos, range: 1}, {
													plainCost: 2,
													swampCost: 10,
													roomCallback: function (roomName){
															return plannedRoads
													},
											});
											if (path){
													for (let p in path.path){
															saveRoadPos(path.path[p], plannedRoads, roadlist3);
													}
											}
									}
									if (cpuBlock()){
											console.log('b');
											yield 'b';
									}
									//get roads and ramps here before the wall is made
									if (!fixedBaseDir || fixedBaseDir === 'small'){
											traceWall();
									}
									newWallRamps = checkWall(room, origin, wallRamps);
									if (cpuBlock()){
											console.log('c');
											yield 'c';
									}
									if (!newWallRamps){
											console.log('wall bad',room.name,'designer');
											return
									}
									outerPerim = Array.from(newWallRamps);
									//save outer perimeter so we can better predict where is safe to build
									connectWall(newWallRamps);


									function traceWall(){
											for (var o in outer){
													//finds the neighbours 2 away so ramparts arent made at a range of 2
													let pos = outer[o];
													let ns0 = pos.neighbours(2);
													for (var n in ns0){
															if (!allObj[ns0[n]]){
																	notInRange[ns0[n]] = 1;
																	//new RoomVisual(room.name).circle(ns0[n],{fill:'green',radius:0.5})
															}
													}
											}
											for (var o in outer){
													let pos = outer[o];
													let ns = pos.neighbours(3);
													for (var n in ns){
															if (!allObj[ns[n]] && !notInRange[ns[n]]){
																	let terrain = ns[n].getTerrain();
																	if (terrain != 'wall'){
																			//new RoomVisual(room.name).circle(ns[n],{fill:'blue',radius:0.5})
																			if (ns[n].onEdge()){//finds walls around exit tiles
																					let posNeighbours = ns[n].neighbours(2);
																					for (let p in posNeighbours){
																							if (posNeighbours[p].findInRange(FIND_EXIT, 1).length == 0){
																									wallRamps.push(posNeighbours[p]);
																							}
																					}
																			} else if (ns[n].findInRange(FIND_EXIT, 1).length > 0){//finds walls around exit tiles
																					let posNeighbours = ns[n].neighbours(1);
																					for (let p in posNeighbours){
																							if (posNeighbours[p].findInRange(FIND_EXIT, 1).length == 0){
																									wallRamps.push(posNeighbours[p]);
																							}
																					}
																			} else {//finds walls at 3 range but not 2 range
																					wallRamps.push(ns[n]);
																			}
																	}
															}
													}
											}
									}

									function checkWall(room, origin, wallRamps){
											let wallMatrix = new PathFinder.CostMatrix;
											for (let i in wallRamps){
													if (!wallRamps[i].roomName){
															continue
													}
													wallMatrix.set(wallRamps[i].x, wallRamps[i].y, 255);
											}
											let exits = room.find(FIND_EXIT);
											let memRamps = [];
											for (let i in wallRamps){
													if (!wallRamps[i].roomName){
															continue
													}
													let path1 = PathFinder.search(wallRamps[i], exits, {
															roomCallback: (roomName) => {
																	return wallMatrix
															}, maxRooms: 1
													});
													if (path1 && !path1.incomplete){
															memRamps.push(wallRamps[i]);
													} else {
															room.visual.circle(wallRamps[i], {fill: 'red', radius: 1});
													}
											}
											let wallMatrix2 = new PathFinder.CostMatrix;
											for (let i in memRamps){
													wallMatrix2.set(memRamps[i].x, memRamps[i].y, 255);
											}
											let finalRamps = [];
											for (let i in memRamps){//needs to be done seperate to avoid gaps
													let path2 = PathFinder.search(memRamps[i], origin, {
															roomCallback: (roomName) => {
																	return wallMatrix2
															}, maxRooms: 1
													});
													if (path2 && !path2.incomplete && memRamps[i].findInRange(FIND_EXIT, 1).length == 0){
															finalRamps.push(memRamps[i]);
													} else {
															room.visual.circle(memRamps[i], {fill: 'red', radius: 1});
													}
													let path3 = PathFinder.search(origin, exits, {
															roomCallback: (roomName) => {
																	return wallMatrix2
															}, maxRooms: 1
													});
													if (path3 && !path3.incomplete){
															Game.notify('WALL ERROR: ' + room.name);
													}
											}
											if (finalRamps && finalRamps.length > 0){
													return finalRamps
											}
									}

									function connectWall(rampartArr){
											let checked = {};
											let count = 0;
											let sections = {};
											let wallRampsArr = [];
											rampartArr.forEach((r) => wallRampsArr.push(r.toString()));
											//split wall into sections
											for (let i in rampartArr){
													let pos = rampartArr[i];
													let check = checkRamp(pos);
													if (check){
															count++;
													}
											}
											for (let i in sections){
													let section = sections[i];

													//sort section.members into order -> start with last member as we know this is the end of a wall
													let currentMember = section.members[section.members.length - 1];
													let newMembers = [currentMember];
													while (newMembers.length < section.members.length){
															for (let mem in section.members){
																	let m = section.members[mem];
																	let direction = m.getDirectionTo(currentMember);
																	if (m.isNearTo(currentMember) && (direction % 2 != 0) && !newMembers.includes(m)){
																			currentMember = m;
																			newMembers.push(m);
																			break
																	}
															}
													}
													section.members = newMembers;

													let desiredIntersections = Math.ceil(section.members.length / 20);
													let current = 0;
													//find desired intersection positions
													if (section.roadIntersections.length < desiredIntersections){
															let currentIntersections = [];
															for (let j in section.roadIntersections){
																	//find location of current intersections so don't have any in same portion of wall
																	let index = section.members.findIndex((s) => s.isEqualTo(section.roadIntersections[j]));
																	currentIntersections.push(index);
															}
															let splitAmount = Math.round(section.members.length / desiredIntersections);
															let insertPoint = Math.round(splitAmount / 2);
															while (current < section.members.length){
																	let start = current;
																	let end = start + splitAmount;
																	current += splitAmount;
																	let noIntersectionInSection = true;
																	currentIntersections.forEach((c) => {
																			if (c < end && c > start){
																					noIntersectionInSection = false;
																			}
																	});
																	if (noIntersectionInSection){
																			section.roadIntersections.push(section.members[start + insertPoint]);
																	}
															}
													}
													for (let intersection in section.roadIntersections){
															if (!section.roadIntersections[intersection]){
																	continue
															}
															let path = PathFinder.search(origin, {
																	pos: section.roadIntersections[intersection],
																	range: 0
															}, {
																	plainCost: 2,
																	swampCost: 10,
																	roomCallback: function (roomName){
																			return plannedRoads
																	},
															});
															if (path && path.path.length > 0){
																	for (let p in path.path){
																			if (path.path[p].inRangeTo(section.roadIntersections[intersection], 2)){
																					rampartArr.push(path.path[p]);
																			}
																			saveRoadPos(path.path[p], plannedRoads, roadlist3);
																	}
															}
													}
											}
											saveStructures['sections'] = sections;

											function checkRamp(pos){
													if (checked[pos.toString()] === undefined){
															checked[pos.toString()] = count;
															if (!sections[count]){
																	sections[count] = {
																			members: [],
																			roadIntersections: []
																	};
															}
															let road = plannedRoads.get(pos.x, pos.y);
															if (road === 1){
																	sections[count].roadIntersections.push(pos);
															}
															sections[count].members.push(pos);
															let nearPositions = pos.neighbours(1);
															for (let j in nearPositions){
																	if (nearPositions[j].getDirectionTo(pos) % 2 != 0 && wallRampsArr.includes(nearPositions[j].toString())){
																			checkRamp(nearPositions[j]);
																	}
															}
															return true
													} else {
															return false
													}
											}

									}

							}
							if (roadlist){
									let newRoadList = roadlist.concat(roadlist2, roadlist3);
									saveStructures['road'] = stringArray(newRoadList);
									saveStructures['startRoads'] = stringArray(roadlist2);
							}
							//now save structures is almost complete -> floodfill to find positions that are not used that do not have walls near
							let avoidMatrix = new PathFinder.CostMatrix;
							for (let r in outerPerim){
									let neighbours = outerPerim[r].neighbours(2);
									for (let n in neighbours){
											let neighbour = neighbours[n];
											avoidMatrix.set(neighbour.x, neighbour.y, 255);
											new RoomVisual(room.name).circle(neighbour, {fill: 'orange'});
									}
									let neighbours2 = outerPerim[r].neighbours(3);
									for (let n in neighbours2){
											let neighbour = neighbours2[n];
											if (avoidMatrix.get(neighbour.x, neighbour.y) === 0){
													avoidMatrix.set(neighbour.x, neighbour.y, 1);
													new RoomVisual(room.name).circle(neighbour, {fill: 'yellow'});
											}
									}
							}
							let allPositionsArray = [];
							let freePositions = [];
							let towerPositions = [];
							let visitedFreePos = {};
							for (let i in saveStructures){
									allPositionsArray = allPositionsArray.concat(saveStructures[i]);
							}
							findFreePos(origin);
							if (freePositions && freePositions.length > 0){
									freePositions.sort((a, b) => {
											a.getRangeTo(origin) - b.getRangeTo(origin);
									});
									if (!fixedBaseDir){
											let powerSpawnPos = [freePositions[0]];
											structureRamps.push(freePositions[0]);
											saveStructures['powerSpawn'] = stringArray(powerSpawnPos);
											let nukerPos = [freePositions[1]];
											saveStructures['nuker'] = stringArray(nukerPos);
											structureRamps.push(freePositions[1]);
											let observerPos = [freePositions[2]];
											saveStructures['observer'] = stringArray(observerPos);
									}
							}

							function findFreePos(pos){
									let cost = avoidMatrix.get(pos.x, pos.y);
									let terrain = pos.getTerrain();
									if (cost != 255 && !visitedFreePos[pos] && terrain != 'wall'){
											visitedFreePos[pos] = true;
											let str = pos.toString();
											if (!allPositionsArray.includes(str) && pos.getRangeTo(origin) > 2){
													if (cost === 1 || fixedBaseDir){
															towerPositions.push(pos);
													} else {
															freePositions.push(pos);
													}
											}
											let neighbours = pos.neighbours(1);
											for (let n in neighbours){
													if (neighbours[n].getDirectionTo(pos) % 2 != 0){
															findFreePos(neighbours[n]);
													}
											}
									}
							}

							saveStructures['towerPostions'] = stringArray(towerPositions);
							//towers


							let towerpos = [];
							let outerPerimScores = {};
							for (let i in outerPerim){
									outerPerimScores[outerPerim[i].toString()] = 10;
							}
							if (towerPositions && towerPositions.length > 0){
									if (saveStructures['fillerTower'] && saveStructures['fillerTower'][0]){
											let fillerTower = saveStructures['fillerTower'][0];
											scoreRamps(fillerTower);
											towerpos.push(fillerTower);
									}
									for (let i = 0; i < 6; i++){
											let currentBest;
											let currentScore = 0;
											for (let p in towerPositions){
													if (!towerPositions[p]){
															continue
													}
													let score = 0;
													for (let rInd in outerPerim){
															let ramp = outerPerim[rInd];
															if (ramp && ramp.inRangeTo(towerPositions[p], 4)){
																	score += outerPerimScores[ramp.toString()];
															}
													}
													if ((!currentBest || score > currentScore) && !towerpos.includes(towerPositions[p])){
															currentBest = towerPositions[p];
															currentScore = score;
													}
											}
											if (currentBest){
													towerpos.push(currentBest);
													scoreRamps(currentBest);
											}
									}
									function scoreRamps(tower){
											outerPerim.forEach((ramp) => {
													if (ramp && ramp.inRangeTo(tower, 10)){
															let range = ramp.getRangeTo(tower);
															if (range <= 5){
																	outerPerimScores[ramp.toString()] = Math.floor(outerPerimScores[ramp.toString()] / 2);
															} else {
																	outerPerimScores[ramp.toString()]--;
															}
													}
											});
									}
							}
							let defaultTowerList = [
									room.getPositionAt(origin.x + 3, origin.y),
									room.getPositionAt(origin.x - 3, origin.y),
									room.getPositionAt(origin.x - 2, origin.y - 1),
									room.getPositionAt(origin.x + 2, origin.y - 1)
							];


							if (!towerpos && !fixedBaseDir){
									towerpos = defaultTowerList;
							}
							if (towerpos && towerpos.length < 6 && !fixedBaseDir){
									let list = defaultTowerList;
									let count = 3;
									while (towerpos.length < 6 && count > -1){
											towerpos.push(list[count]);
											count--;
									}
							}
							for (let i in towerpos){
									//new RoomVisual(room.name).circle(towerpos[i], {fill: 'green', radius: 0.7})
									structureRamps.push(towerpos[i]);
							}
							if (fixedBaseDir || fixedBaseDir === 'small'){
									let nukerPos = [];
									let observerPos = [];
									for (let p in towerPositions){
											let pos = towerPositions[p];
											if (pos && !towerpos.find((t)=>pos.isEqualTo(t))){
													if (nukerPos.length === 0){
															nukerPos.push(pos);
															saveStructures['nuker'] = stringArray(nukerPos);
															structureRamps.push(pos);
													} else if (observerPos.length === 0){
															observerPos.push(pos);
															saveStructures['observer'] = stringArray(observerPos);
													} else {
															break
													}
											}
									}
							}
							saveStructures['tower'] = stringArray(towerpos);
							let newramps = ramps.concat(newWallRamps);
							if (saveStructures['sRamps'] && structureRamps){
									structureRamps = structureRamps.concat(saveStructures['sRamps']);
							}
							saveStructures['structureRamps'] = stringArray(structureRamps);
							saveStructures['rampart'] = stringArray(newramps);
							if (fixedBaseDir){
									room.memory.fixedBaseOrigin = origin.toString();
									if (fixedBaseDir === 'small'){
											fixedBaseDir = 1;
											room.memory.fixedBaseOrigin  = findRelativePosition(origin,-1,-3,1).toString();
											room.memory.smallFixedBase = true;
									}
									room.memory.fixedBaseDir = fixedBaseDir;
									// if (!Memory.toRestructure.includes(roomName)){
									// 		Memory.toRestructure.push(roomName)
									// }
							}
							for (let s in saveStructures){
									console.log(s,JSON.stringify(saveStructures[s]));
									testStructures(s, saveStructures[s], room);
							}
							playerHeap.roomDesigner.finalSites[room.name] = saveStructures;
							return saveStructures
					}

					function saveRoadPos(pos, plannedRoads, roadList,duplicate){
							if (plannedRoads.get(pos.x, pos.y) === 0 || duplicate){
									roadList.push(pos);
									plannedRoads.set(pos.x, pos.y, 1);
							}
					}

					function isOuter(pos, obj, include, exclude){
							if (!pos){
									return false
							}
							let neighbours = [
									[pos.x + 1, pos.y],
									[pos.x, pos.y + 1],
									[pos.x - 1, pos.y],
									[pos.x, pos.y - 1],
									[pos.x + 1, pos.y + 1],
									[pos.x + 1, pos.y - 1],
									[pos.x - 1, pos.y + 1],
									[pos.x - 1, pos.y - 1]
							];
							for (var n in neighbours){
									if (neighbours[n][0] < 50 && neighbours[n][0] > 0 && neighbours[n][1] < 50 && neighbours[n][1] > 0){
											var npos = room.getPositionAt(neighbours[n][0], neighbours[n][1]);
									} else {
											var npos = null;
									}
									if (npos){
											let terrain = npos.getTerrain();
											if (!obj[npos] && terrain != 'wall' && !include){
													return true
											} else if (include && include[npos] && !include[pos] && terrain != 'wall' && (!exclude || (exclude && !exclude[pos]))){
													return true
											}
									}
							}
							return false
					}

					function placeRoads(siteList, obj, plannedRoads, roadList){
							if (!siteList){
									return
							}
							if (!siteList.x){
									console.log(JSON.stringify(siteList), 'placeroad error');
							}
							let nextx = [
									siteList.x + 1,
									siteList.x - 1,
									siteList.x,
									siteList.x
							];
							let nexty = [
									siteList.y,
									siteList.y,
									siteList.y + 1,
									siteList.y - 1
							];
							for (var j = 0; j < 8; j++){
									let testpos = room.getPositionAt(nextx[j], nexty[j]);
									if (testpos){
											let terrain = testpos.getTerrain();
											if (terrain && terrain != 'wall' && !obj[testpos]){
													roadList.push(testpos);
													//save to matrix so we know where roads are planned to more efficiently build roads
													plannedRoads.set(nextx[j], nexty[j], 1);
											}
									}
							}
					}


			}
	}
	function stringArray(arr){
			//array of roompos
			let ret = [];
			for (var i in arr){
					ret.push(arr[i].toString());
			}
			return ret
	}
	function placeSmallFixedBase(pos){
			let dir = 1;
			if (pos); else {
					return
			}

			let structures = {};
			if (pos && pos.roomName){
					structures['storage'] = [findRelativePosition(pos, 0, 1, dir)];
					structures['spawn'] = [findRelativePosition(pos, 1, 0, dir),findRelativePosition(pos, 0, -1, dir), findRelativePosition(pos, -1, 0, dir)];
					structures['terminal'] = [findRelativePosition(pos, 0, 3, dir)];
					structures['link'] = [findRelativePosition(pos, 1, 2, dir)];
					structures['factory'] = [findRelativePosition(pos, 1, 3, dir)];
					structures['powerSpawn'] = [findRelativePosition(pos, -1, 2, dir)];
					structures['lab'] = [
							findRelativePosition(pos, 1, 4, dir),
							findRelativePosition(pos, 0, 6, dir),
							findRelativePosition(pos, 0, 4, dir),
							findRelativePosition(pos, -1, 5, dir),
							findRelativePosition(pos, 1, 5, dir),
							findRelativePosition(pos, -1, 6, dir),
							findRelativePosition(pos, 2, 5, dir),
							findRelativePosition(pos, -2, 5, dir),
							findRelativePosition(pos, 2, 6, dir),
							findRelativePosition(pos, -2, 6, dir)
					];
					structures['labPoint'] = [findRelativePosition(pos, 0, 5, dir)];
					let sRamps = [];
					for (let s in structures){
							for (let p in structures[s]){
									if (s === 'link'){
											continue
									}
									//structures[s][p].highlight('green')
									sRamps.push(structures[s][p]);
							}
					}
					structures['sRamps'] = sRamps;
					let extensions = [];
					structures['extension'] = extensions;
					structures['staticFillerExtensions'] = getStaticFillerStructure(pos,dir,extensions);
					structures['staticFillerSpots'] = [
							findRelativePosition(pos, 2, 1, dir),
							findRelativePosition(pos, 4, 2, dir),
							findRelativePosition(pos, 4, 0, dir),
							findRelativePosition(pos, 4, 4, dir),
					];
					structures['staticFillerContainer'] = [
							findRelativePosition(pos, 3, 1, dir),
					];
					structures['fillerTower'] = [
							findRelativePosition(pos, 4, 3, dir),
					];
					for (let i in structures['staticFillerSpots']){
							structures['staticFillerSpots'][i].highlight('green');
					}
					structures['keepPositionFree'] = [
							findRelativePosition(pos, 5, 3, dir),
							findRelativePosition(pos, 2, 3, dir),
							findRelativePosition(pos, 2, 4, dir),
					];

					for (let i in structures){
							structures[i] = stringArray(structures[i]);
					}

					structures['road'] = placeLine(findRelativePosition(pos, 6, -2, dir), dir, 10).concat(
							placeLine(findRelativePosition(pos, -3, -2, dir), dir, 10),
							placeLine(findRelativePosition(pos, -2, -2, dir), dir.map8(2), 8),
							placeLine(findRelativePosition(pos, -2, 7, dir), dir.map8(2), 8),
							placeLine(findRelativePosition(pos, -1, 3, dir), dir, 1),
							placeLine(findRelativePosition(pos, -1, 4, dir), dir.map8(1), 3),
							placeLine(findRelativePosition(pos, -2, 2, dir), dir.map8(3), 4),
							placeLine(findRelativePosition(pos, -1, -1, dir), dir.map8(1), 1),
					);
			}
			return structures
	}
	function findSmallBaseLocation(room, serializedMatrix){
			let matrix = PathFinder.CostMatrix.deserialize(serializedMatrix);
			let highScores = [];
			let availablePoints = [];
			let directions = {};
			let spawnsLength = room.find(FIND_STRUCTURES, {filter: (s) => s.structureType === STRUCTURE_SPAWN}).length;
			for (let x = 0; x < 50; x++){
					for (let y = 0; y < 50; y++){
							let score = matrix.get(x, y);
							let pos = new RoomPosition(x, y, room.name);
							if (score > 3 && (score < 9 || spawnsLength > 0) && score != 255){
									pos.highlight();
									highScores.push(pos);
							}
							//new RoomVisual(room.name).text(score,pos)
					}
			}
			for (let i in highScores){
					let pos = highScores[i];
					let fits = true;
					for (let d = 3; d < 6; d ++){
							let newPos = pos.movePos(d);
							if (matrix.get(newPos.x,newPos.y) <4){
									fits = false;
									break
							}
					}
					if (fits){
							pos.highlight('gold');
							availablePoints.push(pos);
							directions[pos.toString()] = [1];
					}
			}
			let sources = room.find(FIND_SOURCES);
			let chosenPoint;
			let currentScore;
			let spawns = room.find(FIND_STRUCTURES, {filter: (s) => s.my && s.structureType == STRUCTURE_SPAWN});
			findBestBasePoint(availablePoints);
			if (chosenPoint){
					chosenPoint.highlight('red');
					return [chosenPoint.toString(), 'small']
			}

			function findBestBasePoint(arr){
					if (arr && arr.length > 0){
							if (spawns && spawns[0]){
									for (let i in arr){
											let point = arr[i];
											if (point && point.getRangeTo(spawns[0])===3){
													let dir = point.getDirectionTo(spawns[0]);
													if (dir && dir === 5){
															chosenPoint = point;
															return
													}
											}
									}
							}
							//todo flood out from sources and controller to score a matrix rather than pathing hundreds of times
							for (let i in arr){
									let point = arr[i];
									let pointScore = 0;
									let controllerRange = point.getRangeTo(room.controller);
									if (controllerRange < 25){
											pointScore += (25-controllerRange);
									}
									for (let i in sources){
											let range = point.getRangeTo(sources[i]);
											let pathObj = PathFinder.search(point,{pos:sources[i].pos,range:1},{maxOps:100,maxRooms:1,swampCost:3});
											if (pathObj && pathObj.path && !pathObj.incomplete){
													range = pathObj.path.length;
											}
											if (range < 25){
													let adjust = 3;
													if (Memory.myRooms.length === 1){
															adjust = 1;
													}
													pointScore += Math.ceil((25-range)/adjust);
											}
									}
									if ((pointScore > 0 && !chosenPoint) || pointScore > currentScore){
											chosenPoint = point;
											currentScore = pointScore;
									}
							}
							if (!chosenPoint){
									let lowest;
									let lowestScore;
									for (let i in arr){
											let point = arr[i];
											let range = point.getRangeTo(room.controller);
											if (!lowest || range < lowestScore){
													lowest = point;
													lowestScore = range;
											}
									}
									if (lowest){
											chosenPoint = lowest;
									}
							}
					}
			}
	}
	function placeFixedBase(pos, dir){
			let structures = {};
			if (pos && pos.roomName){
					structures['storage'] = [findRelativePosition(pos, 0, 1, dir)];
					structures['spawn'] = [findRelativePosition(pos, 1, 0, dir),findRelativePosition(pos, 0, -1, dir), findRelativePosition(pos, -1, 0, dir)];
					structures['terminal'] = [findRelativePosition(pos, 0, 3, dir)];
					structures['link'] = [findRelativePosition(pos, 1, 2, dir)];
					structures['factory'] = [findRelativePosition(pos, 1, 3, dir)];
					structures['powerSpawn'] = [findRelativePosition(pos, -1, 2, dir)];
					structures['lab'] = [
							findRelativePosition(pos, 1, 4, dir),
							findRelativePosition(pos, 0, 6, dir),
							findRelativePosition(pos, 0, 4, dir),
							findRelativePosition(pos, -1, 5, dir),
							findRelativePosition(pos, 1, 5, dir),
							findRelativePosition(pos, -1, 6, dir),
							findRelativePosition(pos, 2, 5, dir),
							findRelativePosition(pos, -2, 5, dir),
							findRelativePosition(pos, 2, 6, dir),
							findRelativePosition(pos, -2, 6, dir)
					];
					structures['labPoint'] = [findRelativePosition(pos, 0, 5, dir)];
					let sRamps = [];
					for (let s in structures){
							for (let p in structures[s]){
									if (s === 'link'){
											continue
									}
									//structures[s][p].highlight('green')
									sRamps.push(structures[s][p]);
							}
					}
					structures['sRamps'] = sRamps;
					let extensions = [];
					structures['extension'] = extensions;
					structures['staticFillerExtensions'] = getStaticFillerStructure(pos,dir,extensions);
					structures['staticFillerSpots'] = [
							findRelativePosition(pos, 2, 1, dir),
							findRelativePosition(pos, 4, 2, dir),
							findRelativePosition(pos, 4, 0, dir),
							findRelativePosition(pos, 4, 4, dir),
					];
					structures['staticFillerContainer'] = [
							findRelativePosition(pos, 3, 1, dir),
					];
					structures['fillerTower'] = [
							findRelativePosition(pos, 4, 3, dir),
					];
					for (let i in structures['staticFillerSpots']){
							structures['staticFillerSpots'][i].highlight('green');
					}
					structures['keepPositionFree'] = [
							findRelativePosition(pos, 5, 3, dir),
							findRelativePosition(pos, 2, 3, dir),
							findRelativePosition(pos, 2, 4, dir),
					];
					structures['arms'] = [
							//placeArm(findRelativePosition(pos, 3, 3, dir), dir.map8(1), extensions),
							//placeArm(findRelativePosition(pos, 2, 0, dir), dir.map8(2), extensions),
							placeArm(findRelativePosition(pos, 3, -3, dir), dir.map8(3), extensions),
							placeArm(findRelativePosition(pos, 0, -2, dir), dir.map8(4), extensions),
							placeArm(findRelativePosition(pos, -3, -3, dir), dir.map8(5), extensions),
							placeArm(findRelativePosition(pos, -2, 0, dir), dir.map8(6), extensions),
							placeArm(findRelativePosition(pos, -3, 3, dir), dir.map8(7), extensions)
					];
					for (let i in structures){
							structures[i] = stringArray(structures[i]);
					}

					structures['road'] = placeLine(findRelativePosition(pos, 1, -1, dir), dir.map8(3), 4).concat(
							//placeLine(findRelativePosition(pos, 2, 0, dir), dir.map8(2), 4),
							//placeLine(pos, dir.map8(1), 5),
							placeLine(findRelativePosition(pos, 0, -2, dir), dir.map8(4), 4),
							placeLine(findRelativePosition(pos, -1, -1, dir), dir.map8(5), 5),
							placeLine(findRelativePosition(pos, -2, 0, dir), dir.map8(6), 4),
							placeLine(findRelativePosition(pos, -1, 1, dir), dir.map8(7), 4),
							placeLine(findRelativePosition(pos, -6, -6, dir), dir, 14),
							placeLine(findRelativePosition(pos, 6, -6, dir), dir, 14),
							placeLine(findRelativePosition(pos, -5, -6, dir), dir.map8(2), 11),
							placeLine(findRelativePosition(pos, -5, 7, dir), dir.map8(2), 11),
							placeLine(findRelativePosition(pos, -1, 3, dir), dir, 1),
							placeLine(findRelativePosition(pos, -1, 4, dir), dir.map8(1), 3),
							placeLine(findRelativePosition(pos, -5, 4, dir), dir.map8(1), 3),
							//placeLine(findRelativePosition(pos, 5, 4, dir), dir.map8(-1), 3),
					);
					let baseRamps = placeLine(findRelativePosition(pos, 9, -9, dir), dir, 20).concat(
							placeLine(findRelativePosition(pos, -9, -9, dir), dir, 20),
							placeLine(findRelativePosition(pos, -8, -9, dir), dir.map8(2), 17),
							placeLine(findRelativePosition(pos, -8, 10, dir), dir.map8(2), 17)
					);

					let minCutSources = placeLine(findRelativePosition(pos, 15, -15, dir), dir, 30).concat(
							placeLine(findRelativePosition(pos, -15, -15, dir), dir, 30),
							placeLine(findRelativePosition(pos, -14, -15, dir), dir.map8(2), 25),
							placeLine(findRelativePosition(pos, -14, 15, dir), dir.map8(2), 25)
					);
					let exits = Game.rooms[pos.roomName].find(FIND_EXIT);
					minCutSources = minCutSources.concat(exits);
					let mincutResult = runMinCut(pos, minCutSources, baseRamps);
					if (!mincutResult){
							console.log('min cut progressing');
							return
					}
					structures['rampart'] =  mincutResult;
					if (Game.rooms[pos.roomName] && exits.length < 20){
							let minCutToExits = runMinCut(pos, exits, baseRamps);
							if (minCutToExits && minCutToExits.length <= 20){
									if (minCutToExits && minCutToExits.length < 10 && minCutToExits.length < structures['rampart'].length - 5){
											structures['rampart'] = minCutToExits;
									} else {
											let maxX, minX, maxY, minY;
											for (let i in minCutToExits){
													let thisPos = minCutToExits[i];
													if (maxX === undefined || thisPos.x > maxX){
															maxX = thisPos.x;
													}
													if (minX === undefined || thisPos.x < minX){
															minX = thisPos.x;
													}
													if (maxY === undefined || thisPos.x > maxY){
															maxY = thisPos.y;
													}
													if (minY === undefined || thisPos.x < minY){
															minY = thisPos.y;
													}
											}
											let xDif = maxX - minX;
											let yDif = maxY - minY;
											let area = xDif * yDif;
											if (area <= 625){
													structures['rampart'] = minCutToExits;
											}
									}
							}
					}
			}
			playerHeap.roomDesigner.allStructureLists[pos.toString()] = structures;
	}

	function getStaticFillerStructure(pos,dir,extensions){
			let positions = [
					findRelativePosition(pos,2,2,dir),
					findRelativePosition(pos,3,0,dir),
					findRelativePosition(pos,3,-1,dir),
					findRelativePosition(pos,4,-1,dir),
					findRelativePosition(pos,4,1,dir),
			].concat(placeLine(findRelativePosition(pos,5,-1,dir),dir,4),
					placeLine(findRelativePosition(pos,3,2,dir),dir,4),
					[
							findRelativePosition(pos,4,5,dir),
							findRelativePosition(pos,5,5,dir),
							findRelativePosition(pos,5,4,dir),
					]);
			for (let i in positions){
					positions[i].highlight('orange');
					extensions.push(positions[i]);
			}
			return positions
	}

	function findRelativePosition(start, xOffset, yOffset, dir){
			let pos = new RoomPosition(start.x, start.y, start.roomName);
			if (xOffset){
					while (xOffset !== 0){
							if (xOffset < 0){
									pos.movePos(dir.map8(-2), true);
									xOffset++;
							} else if (xOffset > 0){
									pos.movePos(dir.map8(2), true);
									xOffset--;
							}
					}
			}
			if (yOffset){
					while (yOffset !== 0){
							if (yOffset < 0){
									pos.movePos(dir.map8(4), true);
									yOffset++;
							} else if (yOffset > 0){
									pos.movePos(dir, true);
									yOffset--;
							}
					}
			}
			if (pos.roomName != start.roomName){
					return false
			}
			//pos.highlight()
			return pos
	}

	function placeLine(start, dir, length){
			if (!start || !start.roomName){
					return
			}
			let current = new RoomPosition(start.x, start.y, start.roomName);
			let line = [];
			if (current.getTerrain() != 'wall'){
					line.push(current);
			}
			//current.highlight('white')
			let count = 1;
			while (count < length && current){
					current = current.movePos(dir);
					if (current && current.roomName && current.roomName == start.roomName && current.getTerrain() != 'wall'){
							line.push(current);
							//current.highlight('white')
					}
					count++;
			}
			return line
	}

	function placeArm(start, dir, extArr){
			if (!start){
					return
			}
			let current = new RoomPosition(start.x, start.y, start.roomName);
			let extensions = [];
			if (dir && dir % 2 == 0){
					//diagonal
					let count = 0;
					while (count < 2){
							extensions.push(current.movePos(dir.map8(2)), current.movePos(dir.map8(-2))
									, current.movePos(dir.map8(-3)), current.movePos(dir.map8(3)));
							current.movePos(dir, true);
							count++;
					}
			} else {
					//horizontal
					let count = 0;
					while (count < 4){
							extensions.push(current.movePos(dir.map8(2)), current.movePos(dir.map8(-2)));
							current.movePos(dir, true);
							count++;
					}
			}
			for (let i in extensions){
					extensions[i].highlight('yellow');
					extArr.push(extensions[i]);
			}
			return extensions
	}

	function findBaseLocation(room, serializedMatrix){
			let matrix = PathFinder.CostMatrix.deserialize(serializedMatrix);
			let highScores = [];
			let availablePoints = [];
			let directions = {};
			let spawnsLength = room.find(FIND_STRUCTURES, {filter: (s) => s.structureType === STRUCTURE_SPAWN}).length;
			for (let x = 0; x < 50; x++){
					for (let y = 0; y < 50; y++){
							let score = matrix.get(x, y);
							let pos = new RoomPosition(x, y, room.name);
							if (score > 5 && (score < 9 || spawnsLength > 0) && score != 255){
									pos.highlight();
									highScores.push(pos);
							}
							//new RoomVisual(room.name).text(score,pos)
					}
			}
			for (let i in highScores){
					let pos = highScores[i];
					for (let i = 1; i < 8; i += 2){
							let fits = checkDirection(pos, i);
							if (fits){
									pos.highlight('gold');
									availablePoints.push(pos);
									break
							}
					}
			}
			let sources = room.find(FIND_SOURCES);
			let chosenPoint;
			let currentScore;
			let spawns = room.find(FIND_STRUCTURES, {filter: (s) => s.my && s.structureType == STRUCTURE_SPAWN});
			findBestBasePoint(availablePoints);
			if (chosenPoint){
					chosenPoint.highlight('red');
					return [chosenPoint.toString(), directions[chosenPoint.toString()]]
			}

			function findBestBasePoint(arr){
					if (arr && arr.length > 0){
							if (room.storage && room.storage.my){
									for (let i in arr){
											let point = arr[i];
											if (point && point.isNearTo(room.storage)){
													let dir = point.getDirectionTo(room.storage);
													if (dir){
															let check = checkDirection(point, dir);
															if (check){
																	chosenPoint = point;
																	return
															}
													}
											}
									}
							}
							if (spawns && spawns[0]){
									for (let i in arr){
											let point = arr[i];
											if (point && point.isNearTo(spawns[0])){
													let dir = point.getDirectionTo(spawns[0]);
													if (dir){
															dir = dir.map8(4);
															let check = checkDirection(point, dir);
															if (check){
																	chosenPoint = point;
																	return
															}
													}
											}
									}
							}
							//todo flood out from sources and controller to score a matrix rather than pathing hundreds of times
							for (let i in arr){
									let point = arr[i];
									let pointScore = 0;
									let controllerRange = point.getRangeTo(room.controller);
									if (controllerRange < 25){
											pointScore += (25-controllerRange);
									}
									for (let i in sources){
											let range = point.getRangeTo(sources[i]);
											let pathObj = PathFinder.search(point,{pos:sources[i].pos,range:1},{maxOps:100,maxRooms:1,swampCost:3});
											if (pathObj && pathObj.path && !pathObj.incomplete){
													range = pathObj.path.length;
											}
											if (range < 25){
													let adjust = 3;
													if (Memory.myRooms.length === 1){
															adjust = 1;
													}
													pointScore += Math.ceil((25-range)/adjust);
											}
									}
									if ((pointScore > 0 && !chosenPoint) || pointScore > currentScore){
											chosenPoint = point;
											currentScore = pointScore;
									}
							}
							if (!chosenPoint){
									let lowest;
									let lowestScore;
									for (let i in arr){
											let point = arr[i];
											let range = point.getRangeTo(room.controller);
											if (!lowest || range < lowestScore){
													lowest = point;
													lowestScore = range;
											}
									}
									if (lowest){
											chosenPoint = lowest;
									}
							}
					}
			}

			function checkDirection(pos, dir){
					if (dir % 2 == 0){
							return false
					}
					let current = pos;
					let count = 0;
					let ret = true;
					while (count < 2){
							current = current.movePos(dir);
							let score = matrix.get(current.x, current.y);
							if (score < 5){
									ret = false;
									break
							}
							count++;
					}
					if (ret){
							directions[pos.toString()] = dir;
					}
					return ret
			}
	}

	function findSpace(room, controller,lastTry){
			//todo add generator
			if (room && controller){
					controller = room.controller;
			}
			if (!room){
					return
			}
			let cpu = Game.cpu.getUsed();
			let matrix = new PathFinder.CostMatrix;
			let queue = [];
			for (let x = 0; x < 50; x++){
					for (let y = 0; y < 50; y++){
							let pos = new RoomPosition(x, y, room.name);
							if (pos.getTerrain() == 'wall' || pos.onEdge()){
									matrix.set(x, y, 255);
									queue.push(pos);
							}
					}
			}
			let exits = room.find(FIND_EXIT);
			let done = {};
			let exitRange = 2;
			if (controller){
					exitRange = 5;
			}
			if (lastTry){
					exitRange = 4;
			}
			for (let i in exits){
					let pos = exits[i];
					//pos.highlight()
					matrix.set(pos.x, pos.y, 255);
					let neighbours = pos.neighbours(exitRange,true);
					for (let i in neighbours){
							let neighbour = neighbours[i];
							//neighbour.highlight()
							if (!done[neighbour]){
									matrix.set(neighbour.x, neighbour.y, 255);
									queue.push(neighbour);
									done[neighbour] = true;
							}
					}
			}
			if (controller){
					let neighbours = room.controller.pos.neighbours(2, true);
					for (let i in neighbours){
							let neighbour = neighbours[i];
							if (!done[neighbour]){
									matrix.set(neighbour.x, neighbour.y, 255);
									queue.push(neighbour);
									done[neighbour] = true;
							}
					}
			}
			let sources = room.find(FIND_SOURCES);
			for (let i in sources){
					let pos = sources[i].pos;
					let neighbours = pos.neighbours(2);
					for (let i in neighbours){
							let neighbour = neighbours[i];
							if (!done[neighbour]){
									matrix.set(neighbour.x, neighbour.y, 255);
									queue.push(neighbour);
									done[neighbour] = true;
							}
					}
					neighbours = pos.neighbours(1);
					for (let i in neighbours){
							let neighbour = neighbours[i];
							if (!done[neighbour]){
									matrix.set(neighbour.x, neighbour.y, 255);
									queue.push(neighbour);
									done[neighbour] = true;
							}
					}
			}
			while (queue.length > 0){
					let firstItem = queue.shift();
					let neighbours = [];
					let get = matrix.get(firstItem.x, firstItem.y);
					if (get === 255){
							get = 0;
					}
					let nextCount = get + 1;
					for (let d = 1; d < 9; d++){
							if (nextCount === 1 && d %2 === 0){
									//allow base to squeeze into a tighter space?
									continue
							}
							let newPos = firstItem.movePos(d);
							if (newPos){
									neighbours.push(newPos);
							}
					}
					for (let i in neighbours){
							let neighbour = neighbours[i];
							let newGet = matrix.get(neighbour.x, neighbour.y);
							if (!newGet && neighbour.roomName == room.name && !neighbour.onEdge()){
									//new RoomVisual(room.name).text(nextCount, neighbour)
									matrix.set(neighbour.x, neighbour.y, nextCount);
									queue.push(neighbour);
							}
					}
			}
			console.log('find space cpu ', Game.cpu.getUsed() - cpu);
			return matrix.serialize()
	}

	function run$19(creep){
		var targetflag = Game.flags['steal' + creep.home.name];
		var homeRoom = Game.rooms[creep.name.split(' ')[2]];
		homeRoom.name;
		var stores = homeRoom.storage;
		if (_.sum(creep.store) == creep.store.getCapacity()){
			creep.memory.dropping = true;
		} else if (_.sum(creep.store) == 0){
			if (creep.ticksToLive < 400){
				creep.memory.reason = 'redundant';
				creep.memory.role = 'recycle';
			}
			delete creep.memory.dropping;
		}
		if (!targetflag && !creep.memory.dropping){
				creep.startNap(5);
				return
		}
		if (creep.memory.dropping){
				let targetRoom;
				if (targetflag && targetflag.pos && targetflag.pos.roomName && Game.rooms[targetflag.pos.roomName]){
						targetRoom = Game.rooms[targetflag.pos.roomName];
						//console.log('stealing from',targetRoom.name)
				}
				if (creep.store['energy'] && targetRoom && targetRoom.controller &&
						targetRoom.controller.owner && !targetRoom.controller.my && config.official){
						if (creep.store['energy'] >= 50){
								creep.drop('energy',50);
						} else {
								creep.drop('energy');
						}
				}
			if (creep.pos.isNearTo(stores)){
				for (var i in creep.store){
					creep.transfer(stores, i);
				}
			} else {
				creep.goTo(stores);
			}
		} else {
			let target;
			if (targetflag && creep.room.name == targetflag.pos.roomName){
					if (creep.num < 2 && creep.room.name === 'E14S3' && creep.room.find(FIND_RUINS).length === 0){
							targetflag.remove();
							return
					}
				let structures = creep.room.find(FIND_STRUCTURES, {
					filter: (s) => (s.structureType == STRUCTURE_STORAGE || s.structureType == STRUCTURE_TERMINAL ||
						s.structureType == STRUCTURE_LAB || s.structureType == STRUCTURE_FACTORY) && s.store && ((s.store.getUsedCapacity() > 0 && s.structureType !== 'lab') || (s.mineralType && s.store[s.mineralType]>0))
				});
					if (!structures[0]){
							structures = creep.room.find(FIND_RUINS,{filter:(s)=> s.store.getUsedCapacity()>0 && s.store.getUsedCapacity() !== s.store['energy']});
					}
				target = structures[0];
					if (target){
							new RoomVisual(creep.room.name).line(creep.pos,target.pos);
					}
			} else {
				creep.goTo(targetflag);
			}
			if (target){
					if (target && creep.pos.isNearTo(target)){
							if (target.store){
									for (let i in target.store){
											if (i === 'energy'){
													continue
											}
											creep.withdraw(target,i);
											break
									}
							}
					} else {
							creep.moveTo(target,{range:1});
					}
			} else if (targetflag && creep.room.name == targetflag.pos.roomName){
					let drops = creep.pos.findClosestByRange(FIND_DROPPED_RESOURCES,{filter:(r)=>r.resourceType !== 'energy'});
					creep.goAndPickup(drops);
				//no resource left in room
					if (!drops){
							let flags = creep.room.find(FIND_FLAGS);
							for (let f in flags){
									if (flags[f] && flags[f].name.split('-')[0]==='siege'){
											return
									}
							}
							targetflag.remove();
					}
			}
		}
	}





	let spawnCode$E = {
		priority: (room, countFunction) => {
			let priority = 40;
			return priority
		},
		isRequired: (room, countFunction) => {
			let numberRequired = 0;
			if (!room.ecoStable || room.armedHostiles || room.memory.defcon < 5){
				return false
			}
			if (Game.flags['steal' + room.name]){
				numberRequired = 2;
			}
			return countFunction('thief', room) < numberRequired;
		},
		spawn: (room, role, body) => {
			//decide if we need any other options
			if (body){
				//options -> TTL, creepnumber
				room.spawnCreep(role, body);
			}
		},
		body: (room, countFunction) => {
			if (room.memory.roadsDown === undefined){
				room.memory.roadsDown = false;
			}
			let key = room.energyCapacityAvailable + ':' + room.memory.roadsDown;
				if (getCachedBody('thief',key)){
						return getCachedBody('thief',key)
				}
			let bodyObject = {
				body: [],
				cost: 0
			};
			//decide on what body to have
			bodyObject.body = room.makeBody([CARRY], false);

			if (bodyObject.body && bodyObject.body.length > 0){
				bodyObject.cost += Game.getBodyCost(bodyObject.body);
			}
				cacheBody('thief',key,bodyObject);
			return bodyObject
		}
	};

	var thief = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$19,
		spawnCode: spawnCode$E
	});

	function runExpansionManager(){
			if (Memory.roomShortList){
					for (let i in Memory.roomShortList){
							let roomMem = Memory.roomShortList[i];
							if (!roomMem.origin || (config.symbolCollection && (!roomMem.symbol || Memory.decodersAvailable[roomMem.symbol]))){
									delete Memory.roomShortList[i];
							}
					}
			}
			if ((Game.time % 1000 == 0 || (Game.time % 100 === 0 && Game.cpu.bucket > 9000)) && canAutoExpand() && Memory.roomShortList && Memory.myRooms && Game.gcl.level > Memory.myRooms.length){
					let shortListObj = Memory.roomShortList;
					let bestScore = 0;
					let bestRoom;
					let currentPath;
					let rally;
					Memory.expansionFinalScores = [];
					for (let i in shortListObj){
							let newScore = shortListObj[i].score;
							if (!shortListObj[i].origin || !Memory.roomGrades || !Memory.roomGrades[i] || !Memory.roomGrades[i].data){
									continue
									//no point auto settling rooms that we can't build an auto base
							}
							if (config.symbolCollection && (!shortListObj[i].symbol ||
									(Memory.decodersAvailable && Memory.decodersAvailable[shortListObj[i].symbol]))){
									continue
							}
							if (Memory.blockClaims && Memory.blockClaims[i] && Memory.blockClaims[i] > Game.time){
									continue
							} else if (Memory.blockClaims && Memory.blockClaims[i]){
									delete Memory.blockClaims[i];
							}
							//check if can reach room to claim
							let canReach = false;
							let pathObj;
							for (let j in Memory.myRooms){
									let range = Game.map.getRoomLinearDistance(Memory.myRooms[j], i);
									rally = Game.flags['rally' + Memory.myRooms[j]];
									if (range <= 10 && rally && rally.pos){
											let pos = new RoomPosition(25, 25, i);
											pathObj = PathFinder.search(rally.pos, {pos: pos, range: 25}, {
													swampCost: 1,
													roomCallback: function (roomName){
															if (Game.map.isCoreRoom(roomName)){
																	return false
															}
															if (Memory.ownedRooms[roomName]){
																	return false
															}
															if (Memory.dangerRooms[roomName]){
																	return false
															}
															if (Game.map.getRoomType(roomName) == 'SK'){
																	let matrix = Game.map.getSKMatrix(roomName);
																	if (matrix){
																			if (pos && pos.roomName === roomName){
																					let neighbours = pos.neighbours(8, true);
																					for (let n in neighbours){
																							let neighbour = neighbours[n];
																							let terrain = neighbour.getTerrain();
																							if (terrain === 'plain'){
																									matrix.set(neighbour.x, neighbour.y, 1);
																							} else if (terrain === 'swamp'){
																									matrix.set(neighbour.x, neighbour.y, 5);
																							}
																					}
																			}
																			return matrix
																	} else {
																			return false
																	}
															} else {
																	if (Game.rooms[roomName]){
																			return Game.rooms[roomName].structureMatrix
																	}
															}
													}
											});

											if (pathObj && !pathObj.incomplete && pathObj.path.length <= 550){
													canReach = true;
													break
											}
									}
							}
							if (!canReach){
									continue
							}
							let nearRooms = Game.map.roomsAround(i, 3);
							//want separation from enemy rooms and to some extent,
							//my rooms - note rooms that are immediately next to another room should not be on short list
							let enemyCount = 0;
							let myRoomCount = 0;
							for (let n in nearRooms){
									let nearRoomName = nearRooms[n];
									if (nearRoomName && Memory.ownedRooms[nearRoomName]){
											enemyCount++;
											if (Memory.knownBots && Memory.knownBots[Memory.ownedRooms[nearRoomName].owner]
											&& Memory.knownBots[Memory.ownedRooms[nearRoomName].owner].powerBalance){
													if (Memory.knownBots[Memory.ownedRooms[nearRoomName].owner].powerBalance > 1.5){
															//this bot is stronger than us, avoid
															enemyCount+= 3;
													} else if (Memory.knownBots[Memory.ownedRooms[nearRoomName].owner].powerBalance > 1){
															//this bot is slightly stronger than us, avoid
															enemyCount++;
													}
											}
									}
									if (Memory.myRooms.includes(nearRoomName)){
											myRoomCount++;
									}
							}
							newScore -= enemyCount * 4;
							newScore -= myRoomCount * 2;
							let mineral = Memory.roomGrades[i].data.charAt(1);
							if (Memory.mineralsWithAccess && !Memory.mineralsWithAccess[mineral]){
									newScore += 5;
									if (config.symbolCollection){
											//minerals less important, undo this term
											newScore -= 1;
									}
							} else if (Memory.mineralsWithAccess){
									let numberOfRoomsForEachMin = Math.round(Game.gcl.level / 7);
									newScore += numberOfRoomsForEachMin - Number.parseInt(Memory.mineralsWithAccess[mineral]);
							}
							Memory.expansionFinalScores.push([i, newScore]);
							if (!bestRoom || newScore > bestScore){
									bestRoom = i;
									bestScore = newScore;
									let end = pathObj.path[pathObj.path.length - 1].toString();
									let serialPath = PathFinder.serializePath(rally.pos, pathObj);
									currentPath = {path: serialPath, end: end};
							}
					}
					if (bestRoom){
							if (bestRoom && Game.rooms[bestRoom] && Game.rooms[bestRoom].controller.my){
									delete Memory.roomShortList[bestRoom];
							} else {
									if (Memory.expansionTarget && Memory.expansionTarget != bestRoom){
											delete Memory.nextClaims[Memory.expansionTarget];
									}
									Memory.expansionTarget = bestRoom;
									Memory.expansionPath = currentPath;
									Memory.nextClaims[bestRoom] = true;
							}
					}
			}
	}
	function canAutoExpand(){
			if (config.autoExpand && Memory.myRooms && (config.autoExpand === true || config.autoExpand > Memory.myRooms.length)){
					return true
			}
			return false
	}

	function blockKeyPositions (costs,room,filler){
			if (room.class !== 'normal' && room.class !== 'bunker'){
					return costs
			}
			if (room.storage){
					if (room.memory.transferPos){
							let tp = room.memory.transferPos.toPos();
							costs.set(tp.x, tp.y, 0xff);
					} else {
							costs.set(room.storage.pos.x, room.storage.pos.y - 1, 0xff);
					}
			}
			if (room.class === 'bunker' && room.memory.bunkerOrigin){
					let bunkerOrigin = room.memory.bunkerOrigin.toPos();
					costs.set(bunkerOrigin.x, bunkerOrigin.y, 0xff);
			}

			if (room.memory.staticFillerSpots && room.memory.staticFillerContainer && Game.getObjectById(room.memory.staticFillerContainer) && !filler){
					for (let i in room.memory.staticFillerSpots){
							let pos = room.memory.staticFillerSpots[i].toPos();
							costs.set(pos.x, pos.y, 0xff);
					}
			}
			return costs
	}

	function run$18(creep){
			var homeRoom = Game.rooms[creep.name.split(' ')[2]];
			var homeRoomName = homeRoom.name;
			var homeflag = Game.flags['RP' + homeRoomName];
			if (creep.memory.retreat == true){
				if (creep.fatigue == 0){
					creep.moveTo(homeflag);
				}
			} else {
				let target = creep.home.mineral;
				let cont = null;
				if (creep.memory.container){
					cont = Game.getObjectById(creep.memory.container);
				}
				if (target){
					if ((cont && _.sum(cont.store) < cont.store.getCapacity()) || !cont){
						if (cont && !creep.pos.isEqualTo(cont.pos)){
							creep.pullTo(cont, true);
						} else if (!cont){
							creep.pullTo(target);
							creep.findContainer(target);
						} else {
							let ret = creep.harvest(target);
							if (ret === -11 || ret === 0){
								creep.startNap(4);
							}
						}
					}
				} else if (Game.flags['rally' + creep.home.name]){
					if (!creep.pos.inRangeTo(Game.flags['rally' + creep.home.name])){
						creep.pullTo(Game.flags['rally' + creep.home.name]);
					}
				}
			}
		}



	let spawnCode$D = {
		priority: (room, countFunction) => {
			let priority = 45;
			return priority
		},
		isRequired: (room, countFunction) => {
			let numberRequired = 0;
			if (room.memory.armedHostiles || !room.ecoStable || room.memory.bigSites || room.memory.mineThorium){
				return false
			}
				if (room.storeFillRatio && room.storeFillRatio > 0.85){
						return false
				}
			let terminal = room.terminal;
			if (room.memory.minactive == true && terminal && (terminal.store.getUsedCapacity() < (0.9 * terminal.store.getCapacity())) && room.memory.min && room.total(room.memory.min) < (config.excess*1.2)){
				numberRequired = 1;
					let container;
					if (room.memory.mineralContainer){
							container = Game.getObjectById(room.memory.mineralContainer);
					}
					if (!container){
							delete room.memory.mineralContainer;
							let container = room.mineral.pos.lookAround(LOOK_STRUCTURES,1,{filter:(s)=>s.structureType === 'container'})[0];
							if (container){
									room.memory.mineralContainer = container.id;
							} else {
									let sites = room.mineral.pos.lookAround(LOOK_CONSTRUCTION_SITES,1,{filter:(s)=>s.structureType === 'container'})[0];
									if (!sites){
											let pathObj = PathFinder.search(room.terminal.pos,{pos:room.mineral.pos,range:1});
											if (!pathObj.incomplete){
												pathObj.path[pathObj.path.length-1].createConstructionSite('container');
											}
									}
									return false
							}
					}
			} else {
				numberRequired = 0;
			}
			let extractor = room.findStructures('extractor')[0];
				if (!extractor){
						return false
				}
			return countFunction('Mminer', room) < numberRequired;
		},
		spawn: (room, role, body) => {
			//decide if we need any other options
			if (body){
				//options -> TTL, creepnumber
				//console.log('trying to spawn Mminer')
				room.spawnCreep(role, body);
			}
		},
		body: (room, countFunction) => {
			if (room.memory.roadsDown === undefined){
				room.memory.roadsDown = false;
			}
			let key = room.energyCapacityAvailable + ':' + room.memory.roadsDown;
				if (getCachedBody('Mminer',key)){
						return getCachedBody('Mminer',key)
				}
			let bodyObject = {
				body: [],
				cost: 0
			};
			//decide on what body to have
			let max = 50;
			if (room.controller.level < 8){
				max = 20;
			}
			bodyObject.body = room.makeBody([WORK], false, {oneMove: true, maxParts: max});
			if (bodyObject.body && bodyObject.body.length > 0){
				bodyObject.cost += Game.getBodyCost(bodyObject.body);
			}
				cacheBody('Mminer',key,bodyObject);
			return bodyObject
		}
	};

	var Mminer = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$18,
		spawnCode: spawnCode$D
	});

	function run$17(creep){
			if ((creep.ticksToLive < 4 && creep.store.getUsedCapacity()===0) || creep.home.controller.level === 6){
					creep.suicide();
					return
			}
			if (!creep.memory.assignedPath){
					assignToBrigade(creep);
					creep.rally(1);
					return
			} else {
					let cIndex = index(creep);
					new RoomVisual(creep.pos.roomName).text(cIndex,creep.pos);
					if (cIndex === undefined || cIndex === false){
							delete creep.memory.assignedPath;
							return
					}
			}
			if (creep.acted){
					return
			}
			if (!creep.memory.assignedPath){
							creep.startNap(2);
			}
			if (creep.store['energy'] === 0){
					relayUpPath(creep);
			} else {
					if (creep.store.getFreeCapacity() && creep.memory.container){
							let container = Game.getObjectById(creep.memory.container);
							creep.withdraw(container,'energy');
					}
					relayDownPathToDrop(creep);
			}
	}



	let spawnCode$C = {
			priority: (room, countFunction) => {
					let priority = 30;
					priority += countFunction('thoriumMineHauler', room);
					return priority
			},
			isRequired: (room, countFunction) => {
					if (!config$1.season || config$1.season !== 'thorium'){
							return false
					}
					if (!room.memory.thoriumMineSupportRoom || !Game.rooms[room.memory.thoriumMineSupportRoom]
					|| !room.memory.thoriumSupportLinkPos){
							return false
					}
					room = Game.rooms[room.memory.thoriumMineSupportRoom];
					if (room.class !== 'thoriumMine'){
							return
					}
					if (!room.memory.buckets){
							console.log('no bucket');
							return
					}
					let num = Number.parseInt(room.memory.buckets)+ 3;
					if (room.controller.level === 6){
							num = 0;
					}
					if (!num){
							return
					}
					return countFunction('thoriumMineHauler', room) < num;
			},
			spawn: (room, role, body) => {
					//decide if we need any other options
					if (!room.memory.thoriumMineSupportRoom || !Game.rooms[room.memory.thoriumMineSupportRoom]){
							return
					}
					let requestingRoomName = room.memory.thoriumMineSupportRoom;
					if (body){
							//options -> TTL, creepnumber
							room.spawnCreep(role, body,{assignedHomeName:requestingRoomName});
					}
			},
			body: (room, countFunction) => {
					let workTime = true;
					if (room.findStructures('tower')[0]){
							workTime = false;
					}
					if (room.memory.bigSites || (room.memory.buildRoads && room.memory.buildRoads > Game.time)){
							workTime = true;
					}
					let key = room.energyCapacityAvailable+workTime;
					let count = countFunction('thoriumMineHauler',room);
					if (getCachedBody('thoriumMineHauler',key)){
							return getCachedBody('thoriumMineHauler',key)
					}
					let bodyObject = {
							body: [],
							cost: 0
					};
					let max = 6;
					if (room.memory.roleNumbers && room.memory.roleNumbers.thoriumMineHaulerParts){
							max = room.memory.roleNumbers.thoriumMineHaulerParts;
					}
					if (room.controller.level === 6){
							max = 6;
					}
					//decide on what body to have
					if (count <= 3 && workTime && room.energyAvailable <= 300){
							bodyObject.body = room.makeBody([CARRY], true, {maxParts: 6,fixedSection: [WORK,CARRY,MOVE]});
					} else if (count <= 3 || room.energyAvailable <= 300){
							bodyObject.body = room.makeBody([CARRY], true, {maxParts: 6});
					} else if (workTime || room.controller.level < 3){
							bodyObject.body = room.makeBody([CARRY], true, {maxParts: max, fixedSection: [WORK,CARRY,MOVE]});
					} else {
							bodyObject.body = room.makeBody([CARRY], true,{maxParts: max});
					}
					if (bodyObject.body && bodyObject.body.length > 0){
							bodyObject.cost += Game.getBodyCost(bodyObject.body);
					}
					cacheBody('thoriumMineHauler',key,bodyObject);
					return bodyObject
			}
	};

	var thoriumMineHauler = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$17,
		spawnCode: spawnCode$C
	});

	function run$16(creep){
			if (creep.home.controller.level === 6 && (creep.num>1 || creep.body.length > 20)){
					creep.suicide();
			}
			if (!creep.store.getCapacity()){
					creep.suicide();
			}
			if (creep.home.memory.spawn){
					let spawn = Game.spawns[creep.home.memory.spawn];
					if (spawn){
							if (!creep.home.memory.workerPositions){
									let neighbours = spawn.pos.neighbours();
									let positions = [];
									for (let i in neighbours){
											if (neighbours[i].isWalkable() && neighbours[i].getRangeTo(creep.home.controller)<= 3){
													let canPush = true;
													if (creep.home.memory.brigade){
															for (let b in creep.home.memory.brigade.paths){
																	let brigadePath = creep.home.memory.brigade.paths[b].path;
																	if (brigadePath && brigadePath[brigadePath.length-2]
																			&& brigadePath[brigadePath.length-2].toPos().isEqualTo(neighbours[i])){
																			canPush = false;
																	}
															}
													}
													if (creep.home.memory.tPos && creep.home.memory.tPos.toPos().isEqualTo(neighbours[i])){
															canPush = false;
													}
													if (canPush){
															positions.push(neighbours[i].toString());
													}
											}
									}
									creep.home.memory.workerPositions = positions;
							}
							let upgraded = false;
							if (creep.memory.upgrade){
									let ret = creep.upgradeController(creep.home.controller);
									if (ret === -9){
											creep.moveTo(creep.home.controller,{range:3});
											return
									}
									upgraded = true;
							}
							if (creep.pos.isNearTo(spawn)){
									if (creep.store['energy']> 0 && !upgraded){
											let ret = creep.upgradeController(creep.home.controller);
											if (ret === -9){
													creep.moveTo(creep.home.controller,{range:3});
													creep.memory.upgrade = true;
											}
											upgraded = true;
									}
									if (creep.home.memory.workerPositions && creep.home.memory.workerPositions[creep.num-1] &&
											!creep.home.memory.workerPositions[creep.num-1].toPos().isEqualTo(creep.pos)){
											if (creep.pos.isNearTo(creep.home.memory.workerPositions[creep.num-1].toPos())){
													creep.say('here');
													creep.move(creep.pos.getDirectionTo(creep.home.memory.workerPositions[creep.num-1].toPos()));
											} else {
													creep.say('here2');
													creep.moveTo(creep.home.memory.workerPositions[creep.num-1].toPos(),{range:0});
											}
									}
									if ((creep.store['energy'] <= creep.countParts('work')|| upgraded) && spawn.store['energy']>100){
											let amount = creep.store.getCapacity();
											if (upgraded){
													amount = creep.countParts('work');
											}
											if (amount > 100){
													amount = 100;
											}
											creep.withdraw(spawn,'energy',amount);
									}
							} else {
									if (creep.home.memory.workerPositions && creep.home.memory.workerPositions[creep.num-1]){
											let pos = creep.home.memory.workerPositions[creep.num-1].toPos();
											new RoomVisual(creep.pos.roomName).line(pos,creep.pos);
											creep.moveTo(pos,{range:0});
									} else {
											creep.moveTo(spawn,{range:1});
									}
							}
					}
			}
	}

	let spawnCode$B = {
			priority: (room, countFunction) => {
					let priority = 25;
					if (Memory.excessEnergy < 0 && countFunction('thoriumMineWorker',room)>0){
							priority = 50;
					}
					return priority
			},
			isRequired: (room, countFunction) => {
					if (!config$1.season || config$1.season !== 'thorium'){
							return false
					}
					let num = 1;
					if (!room.memory.thoriumMineSupportRoom || !Game.rooms[room.memory.thoriumMineSupportRoom]){
							return false
					}
					let homeLevel = room.controller.level;
					room = Game.rooms[room.memory.thoriumMineSupportRoom];
					if ((countRole('thoriumMineHauler',room) > Number.parseInt(room.memory.buckets)*0.5
									|| room.memory.fillerNum)
							&& room.memory.roleNumbers && room.memory.roleNumbers.thoriumMineWorkerParts){
							let parts = room.memory.roleNumbers.thoriumMineWorkerParts;
							if (room.memory.fillModeWorkerParts){
									parts = room.memory.fillModeWorkerParts;
							}
							num = Math.round(Game.bodySizeToNumberNeeded(parts,spawnCode$B.body(room).body));
							if (room.memory.fillerNum){
									num = 4;
									if (Memory.excessEnergy && Memory.excessEnergy > 100000){
											num++;
									}
							}
							if (!room.storage || room.storage.store['energy'] < 10000){
									if (num > 3){
											num = 3;
									}
							} else if (room.storage.store['energy'] < 30000){
									if (num > 4){
											num = 4;
									}
							} else if (room.storage.store['energy'] < 50000){
									if (num > 5){
											num = 5;
									}
							}
							if (homeLevel < 7){
									num += 2;
							}
							if (room.memory.workerPositions && num > room.memory.workerPositions.length){
									num = room.memory.workerPositions.length;
							}
							if ( room.controller.level === 6){
									num = 0;
							}
					}
					if (!room.memory.spawn || !Game.spawns[room.memory.spawn]){
							return false
					}
					if (room.class !== 'thoriumMine'){
							return false
					}
					return countFunction('thoriumMineWorker', room) < num;
			},
			spawn: (room, role, body) => {
					//decide if we need any other options
					if (!room.memory.thoriumMineSupportRoom || !Game.rooms[room.memory.thoriumMineSupportRoom]){
							return
					}
					let requestingRoomName = room.memory.thoriumMineSupportRoom;
					if (body){
							//options -> TTL, creepnumber
							room.spawnCreep(role, body,{assignedHomeName:requestingRoomName});
					}
			},
			body: (room, countFunction) => {
					let key = room.energyCapacityAvailable;
					if (getCachedBody('thoriumMineWorker',key)){
							return getCachedBody('thoriumMineWorker',key)
					}
					let bodyObject = {
							body: [],
							cost: 0
					};
					let max = 50;
					//decide on what body to have
					bodyObject.body = room.makeBody([WORK,WORK,WORK,WORK,WORK,MOVE], false, {noMove: true, fixedSection:[CARRY,CARRY], maxParts: max});
					if (bodyObject.body && bodyObject.body.length > 0){
							bodyObject.cost += Game.getBodyCost(bodyObject.body);
					}
					cacheBody('thoriumMineWorker',key,bodyObject);
					return bodyObject
			}
	};

	var thoriumMineWorker = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$16,
		spawnCode: spawnCode$B
	});

	const mineRooms = 2;
	let lastSent;
	let noOtherStock = false;
	function runThoriumManager(){
			findMine();
			let reactorHomeRooms = [];
			if (config.reactors){
					for (let i in config.reactors){
							reactorHomeRooms.push(config.reactors[i].homeRoom);
					}
			}
			let thoriumTarget = 5000;
			let reactorHomeRoomNeedingT = reactorHomeRooms[0];
			let otherStock = false;
			for (let i in reactorHomeRooms){
					let homeRoom = Game.rooms[reactorHomeRooms[i]];
					if (homeRoom.total('T')< thoriumTarget){
							reactorHomeRoomNeedingT = reactorHomeRooms[i];
							break
					}
			}
			///console.log('T destination',reactorHomeRoomNeedingT,'list',reactorHomeRooms)
			//console.log('T transfer blocked', noOtherStock)
			for (let i in Game.myRooms){
					let room = Game.myRooms[i];
					delete room.memory.thoriumMineSupportRoom;
					if (Game.time % 50 === 0){
							delete room.memory.mineThorium;
					}
					if (room.class === 'normal' && room.controller.level > 5 && room.terminal && Game.time % 50 === 0){
							let thorium = room.find(FIND_MINERALS,{filter: (m)=> m.mineralType === 'T'})[0];
							let extractor = room.findStructures('extractor')[0];
							if (extractor && thorium && thorium.mineralAmount > 10000 && !extractor.pos.isEqualTo(thorium.pos)){
									extractor.destroy();
									console.log('destroy 1');
							} else if (extractor && thorium && extractor.pos.isEqualTo(thorium.pos) && thorium.mineralAmount > 100){
									room.memory.mineThorium = true;
							} else if (extractor && thorium && extractor.pos.isEqualTo(thorium.pos)){
									extractor.destroy();
									console.log(room.name,'destroy 2');
							} else if (thorium && thorium.mineralAmount > 10000){
									thorium.pos.createConstructionSite('extractor');
							}
					}
					if ((!noOtherStock || Game.time > noOtherStock) && room.terminal && room.terminal.store['T'] && room.terminal.store['T']>100 && (!room.memory.reactor || room.total('T') > thoriumTarget+3000)){
							if (!room.terminal.cooldown && Game.time % 3 === 0 && (Game.getResourceTotal('T')<5000 || !lastSent || Game.time-lastSent>25)){
									let amount = room.terminal.store['T'];
									if (amount > 1000){
											amount = 1000;
									}
									if (amount > room.terminal.store['energy']){
											amount = room.terminal.store['energy'];
									}
									let ret = room.send(reactorHomeRoomNeedingT,'T',amount);
									//console.log('T send',room.name,ret)
									if (ret === 0){
											lastSent = Game.time;
									}
							}
							otherStock = true;
					}
			}
			if (!otherStock){
					noOtherStock = Game.time+200;
			}
			// let homeRoomAccess = {}
			// for ( let i in Memory.thoriumDeposits){
			// 		let depo = Memory.thoriumDeposits[i]
			// 		if (depo.amount && depo.room && !depo.cannotBuild){
			// 				Game.map.visual.text(depo.amount, new RoomPosition(10, 30, depo.room))
			// 				//Game.map.visual.line(new RoomPosition(25, 25, depo.room),new RoomPosition(25, 25, depo.homeRoom))
			// 		}
			// 		if (depo.homeRoom && depo.amount && !depo.cannotBuild &&  Memory.thoriumDeposits[i].amount > 40000){
			// 				if (depo.homeRoomRange < 200){
			// 						if (!homeRoomAccess[depo.homeRoom]){
			// 								homeRoomAccess[depo.homeRoom] = 0
			// 						}
			// 						homeRoomAccess[depo.homeRoom] += depo.amount
			// 				}
			// 		}
			// }
			// for (let i in homeRoomAccess){
			// 		//Game.map.visual.text(homeRoomAccess[i], new RoomPosition(10, 40, i))
			// 		console.log(`${i} has ${homeRoomAccess[i]} T nearby`)
			// }
			runReactors();
	}
	function runReactors(){
			for (let i in Game.myRooms){
					delete Game.myRooms[i].memory.reactor;
			}
			if (config.reactors){
					for (let i in config.reactors){
							let reactorRoomName = i;
							let reactorRoom = Game.rooms[reactorRoomName];
							let homeRoom = Game.rooms[config.reactors[i].homeRoom];
							if (!reactorRoom){
									sendVisionCreep(i);
							} else {
									if (reactorRoom.memory.armedHostiles){
											requestSquadsViaCombatManager(reactorRoomName,'D');
									} else if (reactorRoom.hostileList){
											for (let i in reactorRoom.hostileList){
													let hos = reactorRoom.hostileList[i];
													if (hos.stats() && hos.stats().claim && !hos.isWhiteListed && hos.owner && hos.owner.username &&
													(!config.reactors[i].share || !config.reactors[i].includes(hos.owner.username))){
															requestSquadsViaCombatManager(reactorRoomName,'D');
													}
											}
									}
									let reactor;
									if (homeRoom.memory.reactor){
											reactor = Game.getObjectById(homeRoom.memory.reactor);
									}
									if (!reactor){
											reactor = reactorRoom.find(FIND_REACTORS)[0];
									}
									if (reactor && !reactor.my){
											homeRoom.sendClaimer(reactorRoomName);
									} else {
											homeRoom.memory.reactor = reactor.id;
											let num = 14;
											if (reactor.store['T'] && reactor.store['T']>0){
													num = Math.ceil((1400-reactor.store['T'])/99);
											}
											if (num < 3){
													num = 3;
											}
											//console.log('reactor hauler num',num)
											homeRoom.memory.reactorHaulers = num;
											if (reactor.store['T'] < 902){
													let nearCreeps = reactor.pos.lookAround(LOOK_CREEPS,1,{filter:(c)=>c.my && c.store['T']> 0});
													if (nearCreeps.length > 0){
															nearCreeps.sort((a,b)=>{a.ticksToLive-b.ticksToLive;});
															let nearCreep = nearCreeps[0];
															if (nearCreep){
																	let store = nearCreep.store['T'];
																	if (reactor.store.getFreeCapacity('T')>= store){
																			nearCreep.transfer(reactor,'T');
																	}
															}
													}
											}
									}
							}
					}
			}
	}
	let claimMine;
	let activeMines = 0;
	function findMine(){
			activeMines = 0;
			for (let i in Game.rooms){
					if (Game.rooms[i] && Game.rooms[i].class === 'thoriumMine'){
							activeMines++;
					}
			}
			if (claimMine){
					let mine = Memory.thoriumDeposits[claimMine];
					let homeRoom = Game.rooms[mine.homeRoom];
					let room = Game.rooms[mine.room];
					console.log('claiming mine',mine.room);
					if (!room){
							sendVisionCreep(mine.room);
					} else if (!room.controller.my){
							homeRoom.sendClaimer(room.name);
					} else {
							claimMine = undefined;
					}
					if (!Memory.rooms[mine.room]){
							Memory.rooms[mine.room] = {};
					}
					Memory.rooms[mine.room].isThoriumMine = true;
					return
			}
			if (activeMines < mineRooms && Game.myRooms.length < Game.gcl.level){
					if (Memory.thoriumDeposits){
							//find rooms that are not claimed and sort by thorium deposit size and then distance to nearest room
							let best,bestScore;
							for (let i in Memory.thoriumDeposits){
									if (Memory.thoriumDeposits[i].room === Memory.thoriumDeposits[i].homeRoom || Memory.thoriumDeposits[i].cannotBuild){
											continue
									}
									if (Memory.ownedRooms[Memory.thoriumDeposits[i].room] || !Memory.thoriumDeposits[i].homeRoomRange){
											continue
									}
									if (Game.rooms[Memory.thoriumDeposits[i].room] && Game.rooms[Memory.thoriumDeposits[i].room].controller.my){
											continue
									}
									if (!Game.rooms[Memory.thoriumDeposits[i].homeRoom] || !Game.rooms[Memory.thoriumDeposits[i].homeRoom].controller.my ||
											Game.rooms[Memory.thoriumDeposits[i].homeRoom].memory.thoriumMineSupportRoom){
											continue
									}
									if (Memory.thoriumDeposits[i].homeRoomRange > 130 || Memory.thoriumDeposits[i].amount < 40000){
											continue
									}
									let parts = getRoleNumbers(Memory.thoriumDeposits[i].room,Memory.thoriumDeposits[i].homeRoomRange);
									let time = getRCLTime(parts.thoriumMineWorkerParts,Memory.thoriumDeposits[i].amount);
									let freeSpaces = Memory.thoriumDeposits[i].freeSpaces;
									if (!freeSpaces){
											continue
									}
									if (freeSpaces > 3){
											freeSpaces = 3;
									}
									let miningTime = Memory.thoriumDeposits[i].amount/((40*freeSpaces)/EXTRACTOR_COOLDOWN);
									time += miningTime;
									let score = Memory.thoriumDeposits[i].amount/time;
									//console.log(Memory.thoriumDeposits[i].room,'t',time,'d',Memory.thoriumDeposits[i].homeRoomRange,'s',score)
									if (!best || bestScore < score){
											bestScore = score;
											best = i;
									}
							}
							//console.log('best',bestScore,JSON.stringify(Memory.thoriumDeposits[best]))
							if (best){
									claimMine = best;
							}
					}
			}
	}
	function runThoriumMine(room){
			let thorium;
			if (room.memory.thorium){
					thorium = Game.getObjectById(room.memory.thorium);
			}
			if (!thorium){
					thorium = room.find(FIND_MINERALS,{filter:(s)=>s.mineralType === 'T'})[0];
			}
			if (!room.memory.mineStart && thorium){
					room.memory.mineStart = Game.time;
					room.memory.depositSize = thorium.mineralAmount;
			}
			let spawn;
			if (room.memory.spawn){
					spawn = Game.spawns[room.memory.spawn];
			} else {
					spawn = room.findStructures(['spawn'])[0];
			}
			if (room.terminal && room.memory.supportRoom && Game.rooms[room.memory.supportRoom]){
					let supportRoom = Game.rooms[room.memory.supportRoom];
					if (room.terminal.store['energy']<1000){
							supportRoom.send(room.name,'energy',200);
					}
					if (room.terminal.store['T'] && !room.terminal.cooldown){
							let amount = room.terminal.store['T'];
							if (amount > room.terminal.store['energy']){
									amount = room.terminal.store['energy'];
							}
							room.send(supportRoom.name,'T',amount);
					}
			}
			if (!thorium && (!room.terminal || !room.terminal.store['T']) && room.controller.level >= 6 && room.class === 'thoriumMine' && Game.myRooms.length > 3
					&& (Game.time+Math.round(Math.random()*10))% 10 === 0){
					let supportRoom = Game.rooms[room.memory.supportRoom];
					if (room.memory.thorium){
							delete Memory.thoriumDeposits[room.memory.thorium];
							delete supportRoom.memory.thoriumSupportLinkPos;
					}
					if (!Memory.stripMineAudit){
							Memory.stripMineAudit = {};
					}
					if (room.memory.mineStart && room.memory.depositSize){
							Memory.stripMineAudit[room.name] = {
									time:Game.time-room.memory.mineStart,
									size:room.memory.depositSize
							};
					}
					room.controller.unclaim();
					console.log(`announcement|${Game.shard.name}|want to unclaim ${room.hyperlink}`);
					return
			}
			if (thorium){
					room.memory.thorium = thorium.id;
			} else {
					return
			}
			let roomMem = Memory.thoriumDeposits[thorium.id];
			let supportRoom = Game.rooms[roomMem.homeRoom];
			if (supportRoom && room.controller.level < 6 && Game.flags['low'+room.name]){
					supportRoom.sendColonists(room.name);
					delete room.memory.thoriumSupportFillPos;
					return
			}
			if (room.controller.level >= 6 && room.terminal){
					delete supportRoom.memory.thoriumMineSupportRoom;
					delete supportRoom.memory.thoriumSupportFillPos;
					delete supportRoom.memory.thoriumMineBuildTerminal;
					delete room.memory.fillerNum;
					if (room.controller.ticksToDowngrade < 5000){
							supportRoom.sendColonists(room.name);
					}
					if (supportRoom.memory.thoriumSupportLink && Game.getObjectById(supportRoom.memory.thoriumSupportLink)){
							Game.getObjectById(supportRoom.memory.thoriumSupportLink).destroy();
					} else {
							delete supportRoom.memory.thoriumSupportLink;
					}
					if (room.memory.thoriumMinePositions){
							let start = room.terminal;
							let visited = {};
							recurseAndMine(start);
							function recurseAndMine(object){
									let str = object.pos.toString();
									if (visited[str]){
											return
									}
									visited[str] = true;
									let nearCreeps = object.pos.lookAround(LOOK_CREEPS,1,{filter:(c)=>c.role === 'thoriumMiner'});
									for (let c in nearCreeps){
											let nearCreep = nearCreeps[c];
											if (visited[nearCreep.pos.toString()]){
													continue
											}
											nearCreep.harvest(thorium);
											if (nearCreep.store['T']){
													nearCreep.transfer(object,'T');
											}
											recurseAndMine(nearCreep);
									}
							}
					}
			} else {
					supportRoom.memory.thoriumMineSupportRoom = room.name;
					if (room.controller.level >= 6){
							supportRoom.memory.thoriumMineBuildTerminal = true;
					}
			}
			room.memory.supportRoom = roomMem.homeRoom;
			if (room.controller.level > 5){
					thorium.pos.createConstructionSite('extractor');
					if (!room.memory.thoriumMinePositions){
							room.memory.thoriumMinePositions = joinedUpPositionsAroundPos(thorium.pos);
					} else {
							if (!room.memory.thoriumFreePositions){
									room.memory.thoriumFreePositions = thorium.pos.freeSpacesAround;
							}
							let freePositions = room.memory.thoriumFreePositions;
							let haulersNeeded = false;
							if (room.memory.thoriumMinePositions.length < freePositions){
									haulersNeeded = true;
							}
							supportRoom.sendThoriumMiners(room.name,freePositions,haulersNeeded);
							if (!room.memory.terminalPos){
									for (let i in room.memory.thoriumMinePositions){
											let pos = room.memory.thoriumMinePositions[i].toPos();
											let dir = thorium.pos.getDirectionTo(pos);
											let termPos = pos.movePos(dir);
											if (termPos && termPos.isWalkable() && !termPos.onEdge() && !termPos.nearEdge()){
													room.memory.terminalPos = termPos.toString();
													break
											}
									}
									if (!room.memory.terminalPos){
											let pos = room.memory.thoriumMinePositions[0].toPos();
											let freeSpaces = pos.freeSpacesAround;
											if (freeSpaces > 1){
													let neighbours = pos.neighbours();
													for (let i in neighbours){
															if (neighbours[i].isWalkable()){
																	room.memory.terminalPos = neighbours[i].toString();
																	break
															}
													}
											}
									}
							} else {
									if (!room.terminal){
											let termPos = room.memory.terminalPos.toPos();
											if (termPos){
													let site = termPos.lookAround(LOOK_CONSTRUCTION_SITES)[0];
													if (site && site.structureType !== 'terminal'){
															site.remove();
													} else if (!site){
															console.log('newTerm',termPos.createConstructionSite('terminal'));
													}
											}
									}
							}
					}
			}
			if (!spawn){
					delete room.memory.spawn;
					supportRoom.sendColonists(room.name);
					let pos = roomMem.basePosition.toPos();
					if (pos){
							pos.createConstructionSite('spawn');
					} else {
							throw('no base pos')
					}
			} else {
					room.memory.spawn = spawn.name;
			}
			if (room.controller.level < 2 || room.memory.bigSites){
					supportRoom.sendColonists(room.name);
			}
			if (!room.memory.roleNumbers){
					let numbers = getRoleNumbers(room,roomMem.homeRoomRange);
					console.log('getting role numbers');
					room.memory.roleNumbers = numbers;
			}
			let mode = 'brigade';
			if (Game.myRooms.length > 4 || true){
					mode = 'filler';
			}
			room.memory.roadsDown = true;
			if (!room.memory.energySupplyPath){
					let pathObj = PathFinder.search(roomMem.basePosition.toPos(),{pos:supportRoom.storage.pos,range:3}, {
							maxOps:10000,
									roomCallback: function (roomName){
											let pathingRoom = Game.rooms[roomName];
											if (Memory.ownedRooms[roomName]){
													return false
											}
											if (Game.map.isCoreRoom(roomName)){
													return false
											}
											let costs = new PathFinder.CostMatrix;
											if (pathingRoom && pathingRoom.controller && pathingRoom.controller.owner && pathingRoom.memory.upgraderPositions){
													for (let i in pathingRoom.memory.upgraderPositions){
															let pos = pathingRoom.memory.upgraderPositions[i].toPos();
															if (pos){
																	costs.set(pos.x, pos.y, 20);
															}
													}
											}
											if (Game.map.getRoomType(roomName) == 'SK'){
													return false
											}
											if (mode === 'brigade' && ready() && access(supportRoom.name) && access(supportRoom.name).roadPositions){
													let positions = getRoadPositions(supportRoom.name,roomName);
													if (positions){
															for (let i in positions){
																	let positionObj = positions[i];
																	let get = costs.get(positionObj.x, positionObj.y);
																	if (get > 40){
																			continue
																	}
																	//avoid current paths
																	costs.set(positionObj.x, positionObj.y, 30);
															}
													}
											}
											if (!pathingRoom) return costs;
											pathingRoom.find(FIND_STRUCTURES).forEach(function (struct){
													if (struct.structureType === STRUCTURE_ROAD){
															// Don't roads over plain tiles
															let num = 30;
															if (mode !== 'brigade'){
																	num = 1;
															}
															costs.set(struct.pos.x, struct.pos.y, num);
													} else if (struct.structureType !== STRUCTURE_RAMPART ||
															!struct.my){
															// Can't walk through non-walkable buildings
															costs.set(struct.pos.x, struct.pos.y, 0xff);
													}
											});
											if (pathingRoom.memory.fixedBaseOrigin){
													let origin = pathingRoom.memory.fixedBaseOrigin.toPos();
													if (origin){
															costs.set(origin.x, origin.y, 1);
													}
											}
											pathingRoom.find(FIND_CONSTRUCTION_SITES).forEach((s) => {
													if (s.my && s.structureType != STRUCTURE_ROAD && s.structureType != STRUCTURE_CONTAINER && s.structureType != STRUCTURE_RAMPART){
															costs.set(s.pos.x, s.pos.y, 0xff);
													}
											});
											pathingRoom.find(FIND_EXIT).forEach((e) => {
													if (e.oppositeEdge() && (Memory.ownedRooms[e.oppositeEdge().roomName] || Game.map.isCoreRoom(e.oppositeEdge().roomName))){
															costs.set(e.x, e.y, 0xff);
													} else {
															costs.set(e.x,e.y,20);
													}
											});
											costs = blockKeyPositions(costs, pathingRoom);
											return costs;
									}
							}
					);
					console.log('energy supply path',JSON.stringify(pathObj));

					let path;
					if (pathObj && !pathObj.incomplete){
							for (let i in pathObj.path){
									let pos = pathObj.path[i];
									if (pos.roomName === supportRoom.name && !pos.onEdge() && !pos.nearEdge()){
											let range = pos.getRangeTo(supportRoom.storage.pos);
											if (range && range <= 14){
													path = pathObj.path.slice(0,i);
													pathObj.path = path;
													break
											}
									}
							}
					}
					if (path){
							room.memory.energySupplyPathEnd = path[path.length-1].toString();
							room.memory.energySupplyPath = PathFinder.serializePath(roomMem.basePosition.toPos(),pathObj);
					}
			} else if (mode === 'brigade') {
					supportRoom.memory.thoriumSupportLinkPos = room.memory.energySupplyPathEnd;
					delete supportRoom.memory.thoriumSupportFillPos;
			} else {
					delete supportRoom.memory.thoriumSupportLinkPos;
			}
			if (mode === 'brigade'){
					runRelayMode(room,supportRoom);
			} else if (room.controller.level < 6 || !room.terminal){
					let spawnPos;
					if (spawn){
							spawnPos = spawn.pos;
					} else {
							spawnPos = roomMem.basePosition.toPos();
					}
					runFillerMode(room,supportRoom,spawnPos,roomMem.homeRoomRange);
			}
			if (!spawn){
					return
			}
			if (spawn && spawn.store['energy']>=50){
					let workers = spawn.pos.lookAround(LOOK_CREEPS,1,{filter: (c)=>c.my && c.role !== 'colonist' && c.ticksToLive < 1450});
					let worker = workers.sort((a,b)=>a.ticksToLive-b.ticksToLive)[0];
					if (worker){
							spawn.renewCreep(worker);
					}
			}
	}
	function joinedUpPositionsAroundPos(thoriumPos){
			let chains = {};
			let visited = {};
			let neighbours = thoriumPos.neighbours();
			for (let i in neighbours){
					getChain(neighbours[i],neighbours[i].toString());
			}
			let best,bestLength;
			for (let i in chains){
					if (!best || bestLength < chains[i].length){
							best = chains[i];
							bestLength = chains[i].length;
					}
			}
			return best
			function getChain(currentPos,startStr){
					if (visited[currentPos.toString()]){
							return
					}
					visited[currentPos.toString()] = true;
					if (!currentPos.isWalkable()){
							return;
					}
					if (!chains[startStr]){
							chains[startStr] = [];
					}
					chains[startStr].push(currentPos.toString());
					let dir = currentPos.getDirectionTo(thoriumPos);
					let nearPositions;
					if (dir % 2 !== 0){
							nearPositions = [currentPos.movePos(dir.map8(1)),currentPos.movePos(dir.map8(2)),
									currentPos.movePos(dir.map8(-1)),currentPos.movePos(dir.map8(-2))];
					} else {
							nearPositions = [currentPos.movePos(dir.map8(1)), currentPos.movePos(dir.map8(-1))];
					}
					for (let i in nearPositions){
							getChain(nearPositions[i],startStr);
					}
			}
	}

	function runFillerMode(room,supportRoom,spawnPos,distance){
			if (!room.storage && spawnPos){
					let drops = spawnPos.lookAround(LOOK_ENERGY,3);
					let count = 0;
					for (let i in drops){
							count += drops[i].amount;
					}
					if (count > 1000){
							room.memory.lotsOfDroppedEnergy = true;
					} else {
							delete room.memory.lotsOfDroppedEnergy;
					}
			} else {
					delete room.memory.lotsOfDroppedEnergy;
			}
			if (spawnPos && room.memory.energySupplyPath){
					let arr = room.memory.energySupplyPath.split('');
					let tPos = spawnPos.movePos(arr[0]);
					room.memory.tPos = tPos.toString();
					let storePos = tPos.movePos(arr[1]);
					supportRoom.memory.thoriumSupportFillPos = storePos.toString();
					if (storePos){
							if (room.controller.level > 3){
									if (!room.storage){
											let cont = storePos.lookAround(LOOK_STRUCTURES,0,{filter:(s)=>s.structureType === 'container'})[0];
											if (cont){
													cont.destroy();
											} else {
													let site = storePos.lookAround(LOOK_CONSTRUCTION_SITES,0)[0];
													if (site && site.structureType === 'storage'){
															let workers = site.pos.lookAround(LOOK_CREEPS,3,{filter:(c)=>c.role === 'thoriumMineWorker'});
															workers.forEach((c)=>c.build(site));
													} else if (site){
															site.remove();
															storePos.createConstructionSite('storage');
													} else {
															storePos.createConstructionSite('storage');
													}
											}
									}
							} else {
									let cont = storePos.lookAround(LOOK_STRUCTURES,0,{filter:(s)=>s.structureType === 'container'})[0];
									if (!cont){
											let site = storePos.lookAround(LOOK_CONSTRUCTION_SITES,0,{filter:(s)=>s.structureType === 'container'})[0];
											if (site){
													let workers = site.pos.lookAround(LOOK_CREEPS,3,{filter:(c)=>c.role === 'thoriumMineWorker'});
													workers.forEach((c)=>c.build(site));
											} else {
													storePos.createConstructionSite('container');
											}
									}
							}
					}
					let fillerNum = 6;
					let workParts = 200;
					if (Game.myRooms.length < 5){
							workParts = 100;
					} else if (Game.myRooms.length < 7){
							workParts = 150;
					}
					if (Memory.excessEnergy > 100000){
							workParts += 50;
					}
					if (Memory.excessEnergy > 200000){
							workParts += 100;
					}
					if (distance){
							let newFillerNum = Math.ceil((distance*2*workParts)/1650);
							newFillerNum += 3;
							if (newFillerNum > 30){
									newFillerNum = 30;
							}
							if (newFillerNum){
									fillerNum = newFillerNum;
							}
					}
					room.memory.fillModeWorkerParts = workParts;
					room.memory.fillerNum = fillerNum;
					if (storePos){
							let towerPos = storePos.movePos(arr[2]);
							if (towerPos && Game.time % 100 === 0 && room.controller.level > 2){
									let tower = towerPos.lookAround(LOOK_STRUCTURES,0,{filter:(s)=>s.structureType === 'tower'})[0];
									if (!tower){
											towerPos.createConstructionSite('tower');
									} else {
											room.memory.towerID = tower.id;
									}
							}
					}
			}
	}
	function runRelayMode(room,supportRoom){
			if (Game.time % 100 == 0 && supportRoom.memory.thoriumSupportLinkPos && !supportRoom.memory.thoriumSupportLink){
					let linkPos = supportRoom.memory.thoriumSupportLinkPos.toPos();
					if (linkPos){
							linkPos.createConstructionSite('link');
					}
			}
			if (!room.memory.brigade && supportRoom.memory.thoriumSupportLinkPos){
					let reversedPath = PathFinder.reverseSerializedPath(room.memory.energySupplyPath);
					let pathObj = {
							sourcePosStr: supportRoom.memory.thoriumSupportLinkPos
					};
					let path = [];
					let pos = supportRoom.memory.thoriumSupportLinkPos.toPos();
					reversedPath = reversedPath.split('');
					while (reversedPath.length > 0){
							let newPos = pos.movePos(reversedPath[0],false,false);
							path.push(newPos);
							pos = newPos;
							reversedPath.shift();
					}
					pathObj.path = path;
					room.memory.brigade = {
							sources: [supportRoom.memory.thoriumSupportLinkPos],
							paths: {}
					};
					generateBrigadePaths(room,[pathObj],1);
			} else {
					clearPaths(room);
					let avoid = {};
					//drawInEnergy('tower')
					//drawInEnergy('extension')
					for (let i in room.memory.brigade.paths){
							for (let p in room.memory.brigade.paths[i].path){
									avoid[room.memory.brigade.paths[i].path[p]] = true;
							}
							for (let p in room.memory.brigade.paths[i].creepPositions){
									room.memory.brigade.paths[i].creepPositions[p].toPos();
									//new RoomVisual(pos.roomName).text(p,pos)
							}
							//placeSitesAlongRoad(i,'extension')
							//placeSitesAlongRoad(i,'tower')
					}

			}
	}
	function checkCanBuildMine(room,depositId){
			if (!room || !room.controller){
					return
			}
			let neighbours = room.controller.pos.neighbours(2);
			let bestPosition,bestScore;
			for (let i in neighbours){
					let neighbour = neighbours[i];
					if (neighbour.getTerrain() === 'wall'){
							continue
					}
					let score = 0;
					let secondNeighbours = neighbour.neighbours();
					for (let s in secondNeighbours){
							let terrain = secondNeighbours[s].getTerrain();
							if (terrain === 'swamp'){
									score += 0.5;
							} else if (terrain === 'plain'){
									score ++;
							}
					}
					if (score && score>4
							&& (!bestPosition || bestScore < score)){
							bestScore = score;
							bestPosition = neighbour;
					}
			}
			if (bestPosition){
					Memory.thoriumDeposits[depositId].basePosition = bestPosition.toString();
					return true
			} else {
					Memory.thoriumDeposits[depositId].cannotBuild = true;
					return false
			}

	}
	function getRoleNumbers(room,distance){
			let ticksRemaining = 1500;
			let thoriumMineWorkerParts = 0;
			let thoriumMineHaulerParts = 0;
			//account for overseer body
			let energyIn = 0;
			while (ticksRemaining > 0){
					if (energyIn > 0){
							let ret = addBody(energyIn);
							if (!ret){
									break
							} else {
									thoriumMineWorkerParts += energyIn;
									energyIn = 0;
							}
					} else {
							let ret = ticksRemaining > (distance/2)*3*3;
							if (!ret){
									break
							} else {
									thoriumMineHaulerParts+= 3;
									energyIn += 50;
									//add 3 parts to each hauler in chain
									// will have a hauler on every other tile of path
									//each part takes 3 ticks
									ticksRemaining -= (distance/2)*3*3;
							}
					}
			}
			//console.log(`distance ${distance}, worker parts ${thoriumMineWorkerParts}, hauler parts ${thoriumMineHaulerParts},ticksLeftOver ${ticksRemaining}, energyNotUsed ${energyIn}}`)
			return {
					thoriumMineWorkerParts : thoriumMineWorkerParts,
					thoriumMineHaulerParts : thoriumMineHaulerParts,
			}
			function addBody(parts){
					let renewTimePerCreep = 1500/Math.floor(600/parts);
					if (ticksRemaining > renewTimePerCreep){
							ticksRemaining -= renewTimePerCreep;
							return true
					}
					return false
			}
	}
	function getRCLTime(upgradePower,amount){
			//guess of speed to RCL + speed to mine out depo
			return (1800000/upgradePower) + amount/(upgradePower/5)
	}

	let boostLevels = [
			{level:10,mustHave:['XUH2O', 'XZH2O', 'XGHO2', 'XLHO2', 'XKHO2'],oneOf:[]},
			{level:9,mustHave:[ 'XGHO2', 'XLHO2'],oneOf:[]},
			{level:8,mustHave:[ 'XLHO2'],oneOf:[]},
			{level:7,mustHave:['UH2O', 'ZH2O', 'GHO2', 'LHO2', 'KHO2'],oneOf:[]},
			{level:6,mustHave:[ 'GHO2', 'LHO2'],oneOf:[]},
			{level:5,mustHave:[ 'LHO2'],oneOf:[]},
			{level:4,mustHave:['ZH','LO','UH','KO','GO'],oneOf:[]},
			{level:3,mustHave:['LO','GO'],oneOf:[]},
			{level:2,mustHave:['LO'],oneOf:['UH','KO']},
			{level:1,mustHave:['LO']}
	];
	function runBotIntelManager(){
			//check the known bots and rank them on several parameters
			if (!Memory.knownBots){
					Memory.knownBots = {};
			}
			if (Game.time % 500 === 0){
					let maxRooms = {};
					let count = {};
					for (let i in Memory.ownedRooms){
							if (!Memory.knownBots[Memory.ownedRooms[i].owner]){
									Memory.knownBots[Memory.ownedRooms[i].owner] = {};
							}
							if (!maxRooms[Memory.ownedRooms[i].owner] || Memory.ownedRooms[i].level > maxRooms[Memory.ownedRooms[i].owner]){
									maxRooms[Memory.ownedRooms[i].owner] = Memory.ownedRooms[i].level;
							}
							if (!count[Memory.ownedRooms[i].owner]){
									count[Memory.ownedRooms[i].owner] = 0;
							}
							count[Memory.ownedRooms[i].owner]++;
					}
					for (let i in Game.myRooms){
							if (!Memory.knownBots[Game.username]){
									Memory.knownBots[Game.username] = {};
							}
							if (!maxRooms[Game.username] || Memory.ownedRooms[i].level > maxRooms[Game.username]){
									maxRooms[Game.username] = Memory.ownedRooms[i].level;
							}
							if (!count[Game.username]){
									count[Game.username] = 0;
							}
							count[Game.username]++;
					}
					for (let i in maxRooms){
							Memory.knownBots[i].maxRoomLevel = maxRooms[i];
					}
					for (let i in count){
							Memory.knownBots[i].knownRoomCount = count[i];
					}
					assessBotStrengths();
			}

	}
	function assessBotStrengths(){
			for (let i in config.warboosts){
					if (Game.getResourceTotal(i)>3000){
							recordBoostAccess(Game.username,i);
					}
			}
			let myBoostLevel = checkBoostAccess(Game.username);
			let myMaxRoomLevel = Memory.knownBots[Game.username].maxRoomLevel;
			let myScore = myBoostLevel+myMaxRoomLevel;
			for (let i in Memory.knownBots){
					if (i === Game.username){
							continue
					}
					let boostLevel = checkBoostAccess(i);
					Memory.knownBots[i].boostLevel = boostLevel;
					let maxRoomLevel = Memory.knownBots[i].maxRoomLevel;
					let score = boostLevel+maxRoomLevel;
					let powerBalance = score/myScore;
					//higher is stronger than me
					Memory.knownBots[i].powerBalance = powerBalance;
			}
	}
	function checkBoostAccess(user){
			if (!Memory.knownBots[user]){return}
			for (let i in boostLevels){
					if (boostLevels[i].oneOf && boostLevels[i].oneOf.length > 0){
							let canContinue = false;
							for (let j in boostLevels[i].oneOf){
									if (Memory.knownBots[user].boostAccess[boostLevels[i].oneOf[j]] &&
											Memory.knownBots[user].boostAccess[boostLevels[i].oneOf[j]] > Game.time-10000){
											canContinue = true;
											break
									}
							}
							if (!canContinue){
									continue
							}
					}
					if (boostLevels[i].mustHave && boostLevels.mustHave.length > 0){
							let allMet = true;
							for (let j in boostLevels[i].mustHave){
									if (!Memory.knownBots[user].boostAccess[boostLevels[i].mustHave[j]] ||
											Memory.knownBots[user].boostAccess[boostLevels[i].mustHave[j]] <= Game.time-10000){
											allMet = false;
											break
									}
							}
							if (allMet){
									return boostLevels[i].level
							}
					}
			}
	}
	function recordBoostAccess(username,boost){
			if (Memory.knownBots[username]){
					if (!Memory.knownBots[username].boostAccess){
							Memory.knownBots[username].boostAccess = {};
					}
					Memory.knownBots[username].boostAccess[boost] = Game.time;
			}
	}

	let yieldRoomNames;
	let nukeLaunched$1 = 0;
	let ourRoomStatus;
	playerHeap.roomDistancesAll = {};
	playerHeap.roomsAssessedForLooting = {};
	playerHeap.lastViewed = {};
	playerHeap.myRoomsAll = {};
	function observe(room){
			let roomName = room.name;
			if (!ourRoomStatus && Game.map.getRoomStatus(roomName) && Game.map.getRoomStatus(roomName).status){
					ourRoomStatus = Game.map.getRoomStatus(roomName).status;
			} else if (!ourRoomStatus) {
					console.log('no status', Game.map.getRoomStatus(roomName),Game.map.getRoomStatus(roomName).status);
					return
			}
			let roomDistances;
			if (playerHeap.roomDistancesAll[room.name]){
					roomDistances = playerHeap.roomDistancesAll[room.name];
			}
			let observer = Game.getObjectById(room.memory.observer);
			let myRooms = [];
			if (!roomDistances && Game.myRooms.length < 20){
					if (Game.cpu.bucket > 2000 || (config$1.season && Game.cpu.bucket > 1000)){
							console.log('finding room distances',room.name);
							let distances = {};
							findDistances(room.name, distances);
							roomDistances = distances;
							playerHeap.roomDistancesAll[room.name] = distances;

							function findDistances(start, obj){
									let toCheck = [start];
									let count = 0;
									while (toCheck.length > 0 && count < 10){
											count++;
											let newCheck = [];
											for (let i in toCheck){
													let checkRoom = toCheck[i];
													Game.map.getRoomType(checkRoom);
													if (Memory.ownedRooms[checkRoom]){
															continue
													}
													if (!Game.map.getRoomStatus(checkRoom) || Game.map.getRoomStatus(checkRoom).status === 'closed'){
															continue
													}
													if (!obj[checkRoom]){
															obj[checkRoom] = count;
															let exits = Game.map.describeExits(checkRoom);
															for (let e in exits){
																	if (exits[e] && !obj[exits[e]]){
																			newCheck.push(exits[e]);
																	}
															}
													}
											}
											toCheck = newCheck;
									}
							}
					}
			} else {
					//likely too much memory than its worth
					delete room.memory.roomDistances;
			}
			if (playerHeap.myRoomsAll[room.name]){
					myRooms = playerHeap.myRoomsAll[room.name];
			} else {
					if (Memory.myRooms){
							for (let i in Memory.myRooms){
									let myRoom = Memory.myRooms[i];
									if (Game.map.getRoomLinearDistance(myRoom, room.name) < 20 && Game.rooms[myRoom].storage){
											myRooms.push(myRoom);
									}
							}
					}
					playerHeap.myRoomsAll[room.name] = myRooms;
			}

			let finalrooms = [];
			if (!room.memory.observeRooms|| (roomDistances &&(Game.time+room.index*10) % 1000 === 0) || Game.time % 10000 == 32 || (Game.cpu.bucket > 5000 && Game.time % 3000 === 0)){
					var split = room.name.split(/[A-Z]/);
					var x = split[1];
					var y = split[2];
					{
							//room is on edge of sector
							var letters = room.name.match(/[A-Z]/g);
							var xlist = [];
							var xDir = [];
							let adjuster = 5;
							if (!config$1.official){
									adjuster = 10;
							}
							for (let i = -adjuster; i <= adjuster; i++){
									var num = Number.parseInt(x) + i;
									if (num > -1){
											xlist.push(num);
											xDir.push(letters[0]);
									} else {
											var num = Math.abs(num) - 1;
											xlist.push(num);
											if (letters[0] == 'E'){
													xDir.push('W');
											} else {
													xDir.push('E');
											}
									}
							}
							var ylist = [];
							var yDir = [];
							for (let i = -adjuster; i <= adjuster; i++){
									var num = Number.parseInt(y) + i;
									if (num > -1){
											ylist.push(num);
											yDir.push(letters[1]);
									} else {
											var num = Math.abs(num) - 1;
											ylist.push(num);
											if (letters[1] == 'N'){
													yDir.push('S');
											} else {
													yDir.push('N');
											}
									}
							}
							var rooms = [];
							for (let n in xlist){
									for (var ycheck in ylist){
											rooms.push(xDir[n] + xlist[n] + yDir[ycheck] + ylist[ycheck]);
									}
							}
							for (let n in rooms){
									let dist;
									let close = true;
									if (roomDistances && roomDistances[rooms[n]]){
											dist = roomDistances[rooms[n]];
									}
									if (!dist){
											dist = Game.map.getRoomLinearDistance(room.name,rooms[n]);
											close = false;
									}
									if (dist <= 20){
											let otherRoomIsCloser;
											for (let j in myRooms){
													if (myRooms[j] === room.name){
															continue
													}
													//check if any of my other rooms are closer to this room so we aren't observing twice
													let dist2;
													//closerooms are normally worked out using route rather than linear distance -
													// we should only compare 2 close room values or 2 linear values otherwise the map gets odd
													if (playerHeap.roomDistancesAll[myRooms[j]] && close && playerHeap.roomDistancesAll[myRooms[j]][rooms[n]]){
															dist2 = playerHeap.roomDistancesAll[myRooms[j]][rooms[n]];
													} else  {
															dist2 = Game.map.getRoomLinearDistance(myRooms[j],rooms[n]);
															if (close){
																	dist = Game.map.getRoomLinearDistance(room.name,rooms[n]);
															}
													}
													if ((dist2 < dist && room.controller.level <= Game.rooms[myRooms[j]].controller.level) ||
															(room.controller.level < 8 && (Game.map.getRoomType(rooms[n]) === 'highway' ||
																			(config$1.mineralCollectionLevel && room.controller.level < config$1.mineralCollectionLevel))
																	&& dist2 <= 10 && Game.rooms[myRooms[j]].controller.level === 8)){
															otherRoomIsCloser = true;
															break
													}
											}
											if (!otherRoomIsCloser && Game.map.getRoomStatus(rooms[n]).status === ourRoomStatus){
													finalrooms.push(rooms[n]);
													if (dist < 10 && config$1.season && config$1.season === 'caravan' && Game.map.getRoomType(rooms[n])==='highway'){
															//highways are more important to look at
															let count = (10-dist)*2;
															while (count > 0){
																	count--;
																	finalrooms.push(rooms[n]);
															}
													}
											}
									}
							}
							shuffleArray(finalrooms);
							room.memory.observeRooms = finalrooms;
					}
					function shuffleArray(array) {
							for (let i = array.length - 1; i > 0; i--) {
									const j = Math.floor(Math.random() * (i + 1));
									[array[i], array[j]] = [array[j], array[i]];
							}
					}
			} else {
					finalrooms = room.memory.observeRooms;
			}
			// if (finalrooms && finalrooms.length > 0){
			// 		var colorArray = ['#FF6633', '#FFB399', '#FF33FF', '#FFFF99', '#00B3E6',
			// 				'#E6B333', '#3366E6', '#999966', '#99FF99', '#B34D4D',
			// 				'#80B300', '#809900', '#E6B3B3', '#6680B3', '#66991A',
			// 				'#FF99E6', '#CCFF1A', '#FF1A66', '#E6331A', '#33FFCC',
			// 				'#66994D', '#B366CC', '#4D8000', '#B33300', '#CC80CC',
			// 				'#66664D', '#991AFF', '#E666FF', '#4DB3FF', '#1AB399',
			// 				'#E666B3', '#33991A', '#CC9999', '#B3B31A', '#00E680',
			// 				'#4D8066', '#809980', '#E6FF80', '#1AFF33', '#999933',
			// 				'#FF3380', '#CCCC00', '#66E64D', '#4D80CC', '#9900B3',
			// 				'#E64D66', '#4DB380', '#FF4D4D', '#99E6E6', '#6666FF']
			// 		let colour = 'red'
			// 		if (room.index && colorArray[room.index]){
			// 				colour = colorArray[room.index]
			// 		}
			// 		let homePos = new RoomPosition (0,0,room.name)
			// 		Game.map.visual.rect(homePos,50,50,{fill:colour})
			// 		//todo fix the fact that some rooms have overlapping observe territories
			// 		for (let i in finalrooms){
			// 				let a = new RoomPosition (0,0,finalrooms[i])
			// 				Game.map.visual.rect(a,50,50,{fill:colour})
			// 				if (roomDistances){
			// 						let roomDistance = roomDistances[finalrooms[i]]
			// 						if (roomDistance){
			// 								let a = new RoomPosition (25,25,finalrooms[i])
			// 								Game.map.visual.text(roomDistance,a)
			// 						}
			// 				}
			// 		}
			// }
			if (observer && finalrooms && finalrooms.length > 0){
					delete room.memory.observeStatus;
					let homeRoom = room;
					let cycleLength = 100;
					if (!config$1.official){
							cycleLength = 400;
					}
					if ((config$1.season && config$1.season === 'caravan') || config$1.private || finalrooms.length > cycleLength){
							cycleLength = finalrooms.length;
					}
					if (Game.cpu.bucket > 9000 && !config$1.conserveCpu){
							cycleLength = finalrooms.length;
					}
					// if (homeRoom.name === 'E13S9'){
					// 		finalrooms = ['E13S6','E13S6','E13S6','E13S6','E13S6','E13S6']
					// 		cycleLength = 6
					// }
					let index = room.index;
					let currentRoomNum = (Game.time + index) % cycleLength;
					if (currentRoomNum && finalrooms[currentRoomNum]){
							let nextRoom = finalrooms[currentRoomNum + 1];
							if (!nextRoom){
									nextRoom = finalrooms[0];
							}
							observer.observeRoom(nextRoom);
							new RoomVisual(observer.room.name).text('Observing in room ' + finalrooms[currentRoomNum], 4, 48);
							let room = Game.rooms[finalrooms[currentRoomNum]];
							if (room && (room.type == 'highway')){
									if (room.memory.hostiles && (config$1.official || config$1.caravans)){
											let hos = Game.getObjectById(room.memory.hostiles);
											if (hos && hos.owner.username == 'Screeps'){
													let Screeps = room.find(FIND_CREEPS, {filter: (c) => c.owner.username == 'Screeps'});
													let early = false;
													if (Screeps.length > 0){
															let obj = {};
															for (let i in Screeps){
																	if (Screeps[i].ticksToLive > 1200){
																			early = true;
																	}
																	let type = Screeps[i].getType();
																	if (type){
																			if (!obj[type]){
																					obj[type] = 1;
																			} else {
																					obj[type] = 1 + obj[type];
																			}
																	}
															}
															if (early){
																	let newRoom = findCorridor(room);
																	let mes = ('There is a convoy in ' + room.name + ' at ' + Game.time + ' on route to ' + newRoom + ' : ' + JSON.stringify(obj));
																	//Game.notify(mes)
																	console.log('obs 149', mes);
																	if (!Memory.convoys){
																			Memory.convoys = {
																					newRoom: [Game.time]
																			};
																	} else {
																			Memory.convoys[newRoom] = [Game.time];
																	}
															}
													}
											}
									}

									//find corridor
									function findCorridor(room){
											let split = room.name.split(/[A-Z]/);
											let dir = room.name.split(/\d+/);
											let x = split[1];
											let xlast = x.charAt(x.length - 1);
											let y = split[2];
											let ylast = y.charAt(y.length - 1);
											let endRoom;
											if (xlast % 10 == 0 && ylast % 10 == 0){
													return undefined
											} else if (xlast % 10 == 0){
													//horizontal corridor
													if (ylast < 5){
															//end is y9
															endRoom = dir[0] + x + dir[1] + y.slice(0, y.length - 1) + '9';
													} else if (ylast > 5){
															//end is y1
															endRoom = dir[0] + x + dir[1] + y.slice(0, y.length - 1) + '1';
													}
											} else if (ylast % 10 == 0){
													//vertical corridor
													if (xlast < 5){
															//end is x9
															endRoom = dir[0] + x.slice(0, x.length - 1) + '9' + dir[1] + y;
													} else if (xlast > 5){
															//end is x1
															endRoom = dir[0] + x.slice(0, x.length - 1) + '1' + dir[1] + y;
													}
											}
											return endRoom
									}

							}

							if (room){
									evaluateRoom(room, homeRoom);
							}
					} else if (config$1.attackRooms && (Game.time + index)%3===0){
							for (let i in config$1.attackRooms){
									let obj = config$1.attackRooms[i];
									if (obj[0] && obj[0]=== Game.shard.name && obj[1] && !Game.rooms[obj[1]] && Game.map.getRoomLinearDistance(obj[1],room.name)<=10){
											observer.observeRoom(obj[1]);
									}
							}
					}

			} else if (finalrooms && finalrooms.length > 0){
					if (!room.memory.observeStatus){
							room.memory.observeStatus = {};
							for (let i in finalrooms){
									if (Game.map.getRoomType(finalrooms[i]) == 'normal' && Game.map.getRoomLinearDistance(finalrooms[i], room.name) < 11){
											room.memory.observeStatus[finalrooms[i]] = Game.time;
									}
							}
					}
					let currentRoom;
					let currentTime;
					if (room.memory.currentObserveRoom){
							currentRoom = room.memory.currentObserveRoom;
							currentTime = room.memory.observeStatus[room.memory.currentObserveRoom];
					}
					for (let name in room.memory.observeStatus){
							if (!finalrooms.includes(name)){
									delete room.memory.observeStatus[name];
									continue
							}
							if (!currentRoom){
									currentRoom = name;
									currentTime = room.memory.observeStatus[name];
							} else if (name != currentRoom){
									if (currentTime > room.memory.observeStatus[name]){
											currentRoom = name;
											currentTime = room.memory.observeStatus[name];
									}
							}
					}
					if (currentRoom && (room.memory.currentObserveRoom != currentRoom || !room.memory.observeSearchTime)){
							room.memory.currentObserveRoom = currentRoom;
							room.memory.observeSearchTime = Game.time;
					} else if (currentRoom){
							if (room.memory.observeSearchTime){
									if (room.memory.observeSearchTime < Game.time - 2000){
											room.memory.observeStatus[currentRoom] = Game.time + 10000;
									}
							}
					}
			}
	}

	function evaluateRoom(room, homeRoom){
			if (!room || !homeRoom){
					return
			}
			let interval = 100;
			let roomType = Game.map.getRoomType(room);
			if (roomType === 'highway'){
					interval = 50;
					if (!config$1.official && !config$1.powerCollection && !config$1.depositMine && !config$1.caravans){
							interval = 200;
					}
			} else if (roomType === 'normal'){
					interval = 100;
			} else {
					interval = 50;
			}
			if (config$1.official){
					if (roomType === 'highway'){
							interval = 100;
					} else if (roomType === 'normal'){
							interval = 5000;
					} else {
							interval = 300;
					}
					if (room.controller && room.controller.owner){
							interval = 100;
					}
					if (interval < 1000 && room.memory.hibernate){
							interval = 1000;
					}
			}
			if (room.controller && !room.controller.owner && config$1.conserveCpu
					&& !room.memory.hostiles && playerHeap.lastViewed[room.name] > Game.time-1000 && getDist(homeRoom.name,room.name)>3){
					//unlikely worth looking at empty rooms too often, far enough away that core detection is low prio
					return
			}
			if (playerHeap.lastViewed[room.name] && config$1.conserveCpu && playerHeap.lastViewed[room.name] > Game.time-interval){
					return
			}
			playerHeap.lastViewed[room.name] = Game.time;
			if (config$1.mapVisual){
					Game.map.visual.text('\u{1F440}', new RoomPosition(10, 10, room.name));
					Game.map.visual.line(new RoomPosition(1, 1, room.name), new RoomPosition(5, 5, homeRoom.name));
			}
			if (config$1.highwayWalls){
					if (!Memory.highwayWalls){
							Memory.highwayWalls = {};
					}
					assessHighwayWalls(room);
			}
			let roomDistances;
			if (playerHeap.roomDistancesAll[homeRoom.name]){
					roomDistances = playerHeap.roomDistancesAll[homeRoom.name];
			}
			if (config$1.season && config$1.season === 'caravan' && Game.map.getRoomType(room.name) === 'highway'){
					//send vision creeps to end of highway rooms to pick up caravans early
					let COs = /\w(\d+)\w(\d+)/.exec(room.name);
					let lastX = COs[1].slice(-1);
					let lastY = COs[2].slice(-1);
					let nonZero;
					if (lastX[0] !== 0){
							nonZero = lastX;
					}
					if (lastY[0] !== 0){
							nonZero = lastY;
					}
					if (!nonZero || nonZero === 9 || nonZero === 1){
							homeRoom.sendVisionCreep(room.name);
					}
			}
			//power
			let distance = getDist(homeRoom.name, room.name);
			let linearDistance = Game.map.getRoomLinearDistance(homeRoom.name, room.name);
			if (config$1.swampyGround || (Game.cpu.bucket > 9000 && !config$1.conserveCpu)){
					let route = getRoute(homeRoom.name, room.name);
					if (route){
							distance = 0;
							for (let r in route){
									let roomName = route[r].room;
									let change = 0.8;
									if (config$1.swampyGround && Game.map.getRoomType(roomName) !== 'highway'){
											change = 2;
									}
									if (Memory.myRooms.includes(roomName) || (homeRoom.memory.remoteRooms && homeRoom.memory.remoteRooms[roomName])){
											change = 0.5;
									}
									distance += change;
							}
					}
			}
			if (distance <= 10 && ((!roomDistances && distance < 6) || (roomDistances && roomDistances[room.name] && roomDistances[room.name]<10))){
					let roomName = room.name;
					let powerBanks;
					let deposits;
					let yieldNamesList;
					if (config$1.official){
							yieldNamesList = ['Montblanc'];
					}
					let blockRoom = false;
					if (Game.map.getRoomType(roomName) === 'highway' && config$1.powerCollection && !room.memory.hibernate){
							powerBanks = room.find(FIND_STRUCTURES, {filter: (s) => s.structureType == STRUCTURE_POWER_BANK});
					}
					if (config$1.depositMine && !room.memory.hibernate){
							deposits = room.find(FIND_DEPOSITS);
					}
					if (yieldNamesList && yieldNamesList.length > 0){
							if (!yieldRoomNames){
									yieldRoomNames = [];
									if (Memory.ownedRooms){
											for (let i in Memory.ownedRooms){
													let owner = Memory.ownedRooms[i].owner;
													if (yieldNamesList.find((n) => n === owner)){
															yieldRoomNames.push(i);
													}
											}
									}
							}
							for (let i in yieldRoomNames){
									let yieldDistance = getDist(room.name, yieldRoomNames[i]);
									if (yieldDistance < linearDistance){
											blockRoom = true;
											break;
									}
							}
					}
					if (!Memory.deposits){
							Memory.deposits = {};
					}
					if (!homeRoom.storage){
							return
					}
					if (deposits && homeRoom.terminal && homeRoom.controller.level > 5 && config$1.depositMine && !homeRoom.memory.hibernate && !homeRoom.memory.faceClaimed){
							for (let i in deposits){
									let deposit = deposits[i];
									let allowedRange = 4;
									if (homeRoom.controller.level > 7){
											allowedRange = 7;
									}
									if (deposit && distance < allowedRange){
											createMemory(homeRoom.name, room.name, deposit);
									}
							}
					}
					function createMemory(closest, depRoom, deposit){
							let closeRoom = Game.rooms[closest];
							if (closeRoom && !Memory.deposits[deposit.pos.toString()]){
									let path = savePath(closeRoom, deposit.pos);
									let decay = deposit.ticksToDecay;
									if (decay < 500){
											decay = 500;
									}
									let spots = getSpots(deposit.pos);
									if (path){
											Memory.deposits[deposit.pos.toString()] = {
													id: deposit.id,
													closestRoom: closest,
													path: path,
													expiry: Game.time + decay,
													lastCooldown: deposit.lastCooldown,
													spots:spots
											};
									}
							} else if (closeRoom && Memory.deposits[deposit.pos.toString()].closestRoom === closest){
									let spots = getSpots(deposit.pos);
									let decay = deposit.ticksToDecay;
									if (decay < 500){
											decay = 500;
									}
									Memory.deposits[deposit.pos.toString()].expiry = Game.time + decay;
									Memory.deposits[deposit.pos.toString()].lastCooldown = deposit.lastCooldown;
									Memory.deposits[deposit.pos.toString()].spots = spots;
							}
							function getSpots(pos){
									let neighbours = pos.neighbours();
									let spots = 0;
									for (let n in neighbours){
											let neighbour = neighbours[n];
											if (neighbour.getTerrain() === 'wall' ||
													(Memory.rooms[neighbour.roomName] && Memory.rooms[neighbour.roomName].hostiles && neighbour.lookAround(LOOK_CREEPS,0,{filter:(c)=>!c.my}).length > 0)){
													continue
											}
											spots++;
									}
									return spots
							}
					}

					function savePath(room, pos){
							if (!pos){
									return
							}
							let start = room.getPositionAt(room.storage.pos.x, room.storage.pos.y + 1);
							if (room.memory.storageWithdawPos){
									start = room.memory.storageWithdawPos.toPos();
							}
							//find path if loadPath return null and creep is near container (as this means the path will no be on the unwalkable mining spot)
							let path = PathFinder.search(start, {pos: pos, range: 1}, {
									plainCost: 1,
									swampCost: 5,
									maxOps: 10000,
									roomCallback: function (roomName){
											if (Game.map.getRoomType(roomName) == 'SK' || Memory.ownedRooms[roomName] || (Memory.dangerRooms && Memory.dangerRooms[roomName])){
													return false
											}
											let room = Game.rooms[roomName];
											if (!room) return;
											let costs = new PathFinder.CostMatrix;
											room.find(FIND_STRUCTURES).forEach(function (struct){
													if (struct.structureType === STRUCTURE_ROAD){
															// Favor roads over plain tiles
															costs.set(struct.pos.x, struct.pos.y, 3);
													} else if (struct.structureType !== STRUCTURE_RAMPART ||
															!struct.my){
															// Can't walk through non-walkable buildings
															costs.set(struct.pos.x, struct.pos.y, 0xff);
													}
											});
											costs = blockKeyPositions(costs,room);
											return costs;
									},
							});
							if (path.incomplete){
									return null
							}
							//serialize
							let sPath = PathFinder.serializePath(start, path);
							//save, with an expiry in order to ensure fresh paths
							let pathObj = {
									pos: pos.toString(),
									path: {
											sPath: sPath,
											start: start.toString(),
											end: path.path[path.path.length - 1].toString()
									}
							};
							//path obj needs serialized path as well as a start pos and end pos
							return pathObj
					}

					function sendPowerSquad(){
							if (Game.energyCrisis || (homeRoom.memory.hibernate && !Game.energyCaution) || Memory.emergency || homeRoom.memory.armedHostiles || homeRoom.memory.faceClaimed ||
									!homeRoom.ecoStable || homeRoom.memory.thoriumMineSupportRoom || (homeRoom.memory.adjustedLowWallHits && homeRoom.memory.adjustedLowWallHits< config$1.minWalls[7]) || !config$1.powerCollection){
									return
							}
							if (!Game.map.canHighwayMineRoom(room.name)){
									return
							}
							console.log('requesting power squad');
							let toBoost = true;
							if (!config$1.official || homeRoom.total('ZO') < 6000 || homeRoom.total('UH') < 6000 || homeRoom.total('LO') < 6000 || homeRoom.total('KO') < 6000){
									toBoost = false;
							}
							if (!Memory.boostPowerSquads){
									toBoost = false;
							}
							if (Memory.contestedRooms[room.name]){
									if (config$1.season === 'power'){
											if (toBoost){
													requestSquad(homeRoom, room.name, {
															type: 'P',
															attackers: 1,
															medics: 1,
															boosted: 1
													});
											} else {
													requestSquad(homeRoom, room.name, {
															type: 'P',
															attackers: 2,
															medics: 1,
															boosted: 0
													});
											}
									} else {
											if (toBoost){
													requestSquad(homeRoom, room.name, {
															type: 'P',
															attackers: 1,
															medics: 1,
															boosted: 1
													});
											} else {
													requestSquad(homeRoom, room.name, {
															type: 'P',
															attackers: 2,
															medics: 2,
															boosted: 0
													});
											}
									}
							} else {
									if (config$1.season === 'power'){
											if (toBoost){
													requestSquad(homeRoom, room.name, {
															type: 'P',
															attackers: 1,
															medics: 1,
															boosted: 1
													});
											} else if (homeRoom.controller.level < 5){
													requestSquad(homeRoom, room.name, {
															type: 'P',
															attackers: 3,
															medics: 0,
															boosted: 0,
															numberOfSquads: 2
													});
													requestSquad(homeRoom, room.name, {
															type: 'P',
															snipers: 3,
															medics: 0,
															boosted: 0,
															numberOfSquads: 2
													});
											} else if (homeRoom.controller.level < 7){
													requestSquad(homeRoom, room.name, {
															type: 'P',
															attackers: 1,
															medics: 0,
															boosted: 0,
															numberOfSquads: 3
													});
													requestSquad(homeRoom, room.name, {
															type: 'P',
															attackers: 1,
															medics: 0,
															boosted: 0,
															numberOfSquads: 3
													});
													requestSquad(homeRoom, room.name, {
															type: 'P',
															attackers: 1,
															medics: 0,
															boosted: 0,
															numberOfSquads: 3
													});
											} else {
													requestSquad(homeRoom, room.name, {
															type: 'P',
															attackers: 2,
															medics: 0,
															boosted: 0
													});
											}
									} else {
											if (toBoost){
													requestSquad(homeRoom, room.name, {
															type: 'P',
															attackers: 1,
															medics: 1,
															boosted: 1
													});
											} else {
													requestSquad(homeRoom, room.name, {
															type: 'P',
															attackers: 1,
															medics: 2,
															boosted: 0
													});
											}
									}
							}
					}

					if (Memory.powerBanks && powerBanks && powerBanks.length > 0 && ((config$1.season && config$1.season === 'power') || homeRoom.controller.level > 7)){
							let allowNewPowerBank = true;
							if (Game.gcl.level < 30 || (homeRoom.memory.blockPowerSquads && homeRoom.memory.blockPowerSquads > Game.time)){
									//likely want to focus on praising more - only one bank per room
									for (let i in Memory.powerBanks){
											let bankObj  = Memory.powerBanks[i];
											if (bankObj.homeRoom === homeRoom.name && Game.time<(bankObj.time+POWER_BANK_DECAY) && !bankObj.complete){
													allowNewPowerBank = false;
													break
											}
									}
							}
							if (homeRoom.memory.blockOptionalSpawning && homeRoom.memory.blockOptionalSpawning>Game.time){
									allowNewPowerBank =  false;
							}
							if (!allowNewPowerBank){
									console.log('block new PB',room.name,homeRoom.name);
							}
							for (let p in powerBanks){
									let pb = powerBanks[p];
									let powerBankThreshold = 3000,maxPowerStore = 30000;
									if (Memory.minimumPowerBankAmount){
											powerBankThreshold = Memory.minimumPowerBankAmount;
									}
									if (config$1.powerBankThreshold){
											powerBankThreshold = config$1.powerBankThreshold;
									}
									if (config$1.powerStoreMax){
											maxPowerStore = config$1.powerStoreMax;
									}
									if (Memory.powerBanks[pb.id] && Memory.powerBanks[pb.id].homeRoom !== homeRoom.name); else if (Memory.powerBanks[pb.id]){
											sendPowerSquad();
									} else if (allowNewPowerBank && config$1.powerCollection && !blockRoom && powerBanks[0] && powerBanks[0].ticksToDecay > 4500 && powerBanks[0].power >= powerBankThreshold &&
											(!config$1.official || homeRoom.memory.adjustedLowWallHits > 1000000) && (!homeRoom.memory.alert || homeRoom.memory.alert != 'high') &&
											homeRoom.storage && homeRoom.total('energy') > homeRoom.memory.reserve * 0.8
											&& homeRoom.total('power') < maxPowerStore && homeRoom.storeFillRatio && homeRoom.storeFillRatio < 0.85){
											//tracking the powerbank
											if (!Memory.powerBanks[pb.id]){
													Memory.powerBanks[pb.id] = {
															room: pb.room.name,
															time: Game.time,
															homeRoom: homeRoom.name,
															start: "https://screeps.com/a/#!/history/" + Game.shard.name + "/" + pb.room.name + "?t=" + Game.time,
															complete: false
													};
											}
											homeRoom.memory.powernum = Math.ceil(powerBanks[0].power / 1250);
											console.log('placing power flag for ' + homeRoom.name + ' at ' + room.name);
											sendPowerSquad();
											//create a path for the workers to use

											let start = homeRoom.getPositionAt(homeRoom.storage.pos.x, homeRoom.storage.pos.y + 1);
											if (room.memory.storageWithdawPos){
													start = room.memory.storageWithdawPos.toPos();
											}
											let path;
											if (!Memory.powerPaths[homeRoom.name] || !Memory.powerPaths[homeRoom.name][room.name] || Memory.powerPaths[homeRoom.name][room.name].expiry < Game.time){
													path = PathFinder.search(start, {pos: powerBanks[0].pos, range: 1}, {
															plainCost: 1,
															swampCost: 10,
															roomCallback: function (roomName){
																	if (Game.map.getRoomType(roomName) == 'SK' || Memory.ownedRooms[roomName] || (Memory.dangerRooms && Memory.dangerRooms[roomName])){
																			return false
																	}
																	let room = Game.rooms[roomName];
																	if (!room || !room.controller) return;
																	let costs = new PathFinder.CostMatrix;
																	room.find(FIND_STRUCTURES).forEach(function (struct){
																			if (struct.structureType === STRUCTURE_ROAD){
																					// Don't roads over plain tiles
																					costs.set(struct.pos.x, struct.pos.y, 3);
																			} else if (struct.structureType !== STRUCTURE_RAMPART ||
																					!struct.my){
																					// Can't walk through non-walkable buildings
																					costs.set(struct.pos.x, struct.pos.y, 0xff);
																			}
																	});
																	costs = blockKeyPositions(costs,room);
																	return costs;
															},
													});
											}
											if (path && path.incomplete); else if (path){
													//serialize
													let sPath = PathFinder.serializePath(start, path);
													//save, with an expiry in order to ensure fresh paths
													if (!Memory.powerPaths[homeRoom.name]){
															Memory.powerPaths[homeRoom.name] = {};
													}
													Memory.powerPaths[homeRoom.name][room.name] = {
															path: {
																	sPath: sPath,
																	start: start.toString(),
																	end: path.path[path.path.length - 1].toString()
															},
															expiry: Game.time + 5000
													};
											}
									}
							}
					}
			}


			let core;
			if (room.type === 'SK' || room.type === 'centre' || (room.controller && room.controller.reservation && room.controller.reservation.username === 'Invader') ||
					(room.controller && room.controller.owner && room.controller.owner.username === 'Invader')){
					core = room.find(FIND_STRUCTURES, {filter: (s) => s.structureType == STRUCTURE_INVADER_CORE})[0];
			}
			if ((config$1.official || config$1.portalTravelEnabled) && (room.type === 'highway' || room.type === 'centre') && (Game.cpu.bucket > 9000 || (Game.time.toString().slice(-4,-2) === '11' || Game.time.toString().slice(-4,-2) === '12'))){
					let portals = room.find(FIND_STRUCTURES, {filter: (s) => s.structureType == STRUCTURE_PORTAL});
					addPortals(portals);
			}
			if (room.controller  && Game.cpu.bucket > 1000 && !room.controller.owner && config$1.season && config$1.season === 'thorium'&& homeRoom.storage){
					if (!Memory.thoriumDeposits){
							Memory.thoriumDeposits = {};
					}
					let thorium = room.find(FIND_MINERALS,{filter:(m)=>m.mineralType === 'T'})[0];
					if (thorium && (!Memory.thoriumDeposits[thorium.id] || !Memory.thoriumDeposits[thorium.id].freeSpaces || !Memory.thoriumDeposits[thorium.id].expiry ||
							Memory.thoriumDeposits[thorium.id].expiry < Game.time) && (!Memory.thoriumDeposits[thorium.id] || !Memory.thoriumDeposits[thorium.id].cannotBuild)){
							let nearRooms = [];
							for (let i in Memory.myRooms){
									let roomName = Memory.myRooms[i];
									let dist = getDist(roomName,room.name);
									if (dist <= 5){
											if (Game.rooms[roomName] && Game.rooms[roomName].controller.level > 5 && Game.rooms[roomName].terminal
											&& (dist <= 2 || Game.rooms[roomName].controller.level > 6)){
													nearRooms.push(Game.rooms[roomName]);
											}
									}
							}
							for (let i in nearRooms){
									findTRoute(nearRooms[i], room);
							}
					}
					function findTRoute(homeRoom,room){
							if (!Memory.thoriumDeposits[thorium.id]){
									Memory.thoriumDeposits[thorium.id] = {
											room : room.name,
											amount : thorium.mineralAmount,
											expiry : Game.time+10000
									};
							} else {
									Memory.thoriumDeposits[thorium.id].amount = thorium.mineralAmount;
							}

							Memory.thoriumDeposits[thorium.id].freeSpaces = thorium.pos.freeSpacesAround;
							console.log('searching for T route',room.name,homeRoom);
							let route = PathFinder.search(homeRoom.storage.pos,{pos:room.controller.pos,range:1},{
									roomCallback: function (roomName){
											if (Game.map.isCoreRoom(roomName)&& !config$1.canPassThroughRooms.includes(roomName)){
													return false
											}
											if (Memory.ownedRooms[roomName] && !config$1.canPassThroughRooms.includes(roomName)){
													return false
											}
											if (Game.map.getRoomType(roomName) == 'SK'){
													return false
											} else {
													if (Game.map.getRoomType(roomName) !== 'highway' && Game.rooms[roomName]){
															return Game.rooms[roomName].structureMatrix
													}
											}
									}
							});
							let routeLength;
							if (route && !route.incomplete){
									routeLength = route.path.length;
							}
							if (routeLength && (!Memory.thoriumDeposits[thorium.id].homeRoom || routeLength < Memory.thoriumDeposits[thorium.id].homeRoomRange)){
									checkCanBuildMine(room,thorium.id);
									Memory.thoriumDeposits[thorium.id].homeRoom = homeRoom.name;
									Memory.thoriumDeposits[thorium.id].homeRoomRange = routeLength;
							}
					}
			}
			let sector = Memory.sectors[room.sector];
			if (!sector){
					Memory.sectors[room.sector] = {};
			}
			if (core && core.level > 0){
					Memory.sectors[room.sector].invaderCore = room.name;
			} else if (Memory.sectors[room.sector].invaderCore === room.name && room.sector === homeRoom.sector && homeRoom.controller.level > 5){
					//still containers to loot, send guards and haulers
					requestSquad(homeRoom, room.name, {type: 'DC'});
					homeRoom.sendCoreHauler(room.name);
			} else if (Memory.highLevelCore && Memory.highLevelCore === room.name){
					//high level core defeated
					delete Memory.highLevelCore;
			}
			if ((!homeRoom.memory.defcon || homeRoom.memory.defcon === 5) && (!homeRoom.memory.alert || homeRoom.memory.alert != 'high') && !homeRoom.memory.faceClaimed
					&& core && room.sector === homeRoom.sector && (!core.ticksToDeploy || core.ticksToDeploy === 0) && core.level !== undefined){
					if (!Memory.coreRooms){
							Memory.coreRooms = {};
					}
					if (!sector){
							Memory.sectors[room.sector] = {};
					}
					if (core.level > 0 && sector && !Memory.coreRooms[room.name]){
							Memory.coreRooms[room.name] = homeRoom.name;
					}
					if (!homeRoom.memory.hibernate && (core.level === 0 || !Memory.emergency)){
							if (core.level === 0 && sector && (homeRoom.memory.remoteRooms[room.name]||
									(!sector.invaderCore && room.sector == homeRoom.sector) || getDist(room.name, homeRoom.name) < 2)){
									if (homeRoom.controller.level > 6){
											requestSquad(homeRoom, room.name, {type: 'C', attackers: 1, medics: 0});
									}
									if (homeRoom.memory.remoteRooms && homeRoom.memory.remoteRooms[room.name]){
											homeRoom.memory.remoteRooms[room.name].coreDetected = Game.time+500;
									}
							} else if (core.level && (config$1.official || core.level === 1 || (Game.canBoost(config$1.boostLevels[5]) && Game.cpu.bucket > 500 && Game.market.credits < config$1.maxCredits)) && core.level <= 3){
									console.log('request combat squads C',room.name);
									if (core.level > 2);
									requestSquadsViaCombatManager(room.name,'C',{rangedNeeded:true});
							} else if (core.level === 4 && config$1.official && sector && (!Memory.highLevelCore || Memory.highLevelCore === room.name)){
									let nearBy = 0;
									if (!Memory.highLevelCore){
											Game.myRooms.forEach((myRoom)=>{
													if (myRoom.controller && myRoom.controller.level === 8 && !myRoom.memory.alert && myRoom.memory.defcon === 5 && nearBy < 2){
															let range = Game.map.getRoomLinearDistance(myRoom.name,room.name);
															if (range < 6){
																	nearBy++;
															}
													}
											});
									}
									if (nearBy >= 2 || Memory.highLevelCore === room.name){
											let nuke = room.find(FIND_NUKES)[0];
											let timeLeft = core.effects[0].ticksRemaining;
											if (nuke && nuke.timeToLand < timeLeft); else if (!nuke){
													let nukeNeeded = false;
													let enemyCreeps = room.find(FIND_HOSTILE_CREEPS,{filter:(c)=> c.owner.username === 'Invader'});
													for (let i in enemyCreeps){
															let stats = enemyCreeps[i].stats();
															if (stats.work > 0){
																	//repair creep present - nuke needed
																	nukeNeeded = true;
																	break
															}
													}
													if (nukeNeeded && timeLeft > NUKE_LAND_TIME){
															if (homeRoom.memory.nuker){
																	let nuker = Game.getObjectById(homeRoom.memory.nuker);
																	if (nuker && !nuker.cooldown && nuker.store['energy'] === NUKER_ENERGY_CAPACITY && nuker.store['G'] === NUKER_GHODIUM_CAPACITY){
																			nuker.launchNuke(core.pos);
																	}
															}
													}
											}
											if (Memory.highLevelCore === room.name){
													delete Memory.highLevelCore;
											}
									}
							} else if (!homeRoom.memory.alert && core.level === 5 && sector && config$1.official);
					}
			}
			if (!homeRoom.memory.sourcelist){
					homeRoom.memory.sourcelist = {};
			}
			if (room.controller && room.controller.owner && !room.controller.my){
					if (config$1.hitList && config$1.hitList.includes(room.controller.owner.username) && !room.controller.safeMode && room.memory.hostiles){
							let hosSpawn = room.find(FIND_STRUCTURES,(s)=>s.structureType===STRUCTURE_SPAWN && !s.my && s.owner && s.owner.username &&  config$1.hitList.includes(s.owner.username));
							if ((!Memory.currentHitRoom || Memory.currentHitRoom === room.name) && hosSpawn[0]){
									Memory.currentHitRoom = room.name;
									requestSquadsViaCombatManager(room.name,'R');
							} else {
									delete Memory.currentHitRoom;
							}
					} else if (Memory.currentHitRoom && Memory.currentHitRoom === room.name){
							delete Memory.currentHitRoom;
					}
					if (room.controller.owner.username.isEnemy || (config$1.autoClearNewClaims && !room.controller.isWhiteListed)){
							getIntel(room);
							if (room.controller.level < 6 && Game.map.getRoomLinearDistance(room.name,homeRoom.name)<=10 && getDist(room.name,homeRoom.name,true) <= 10 && (!config$1.ignoreAutoAttackTarget || !config$1.ignoreAutoAttackTarget.includes(room.name))
									&& !Game.energyCrisis && !Memory.emergency && homeRoom.total('energy') > homeRoom.memory.reserve*1.2 && homeRoom.controller.level > (room.controller.level)){
									requestSquadsViaCombatManager(room,'R',{maxLevel:0});
							}
					}
					//if not saved to homeRoom.memory.hostileRooms -> save it so can automate attacks
					//possibly save to a global as well?
			} else if (room && room.controller && room.controller.reservation && (room.controller.reservation.username.isEnemy
							|| (config$1.attackAll && room.controller.reservation.username !== Game.username)) &&
					(room.controller.reservation.username && (!config$1.allies || !config$1.allies.includes(room.controller.reservation.username)))){
					//save to homeRoom.memory.hostileRemotes -> auto harass
					if (!homeRoom.memory.hostileRemotes){
							homeRoom.memory.hostileRemotes = {};
					}
					if (!homeRoom.memory.hostileRemotes[room.name]){
							homeRoom.memory.hostileRemotes[room.name] = Game.time + 10000;
					}
			} else if (room && room.controller && !room.controller.owner){
					let nukes = room.find(FIND_NUKES);
					if (nukes.length > 0){
							console.log(`announcement|${Game.shard.name}|sussy nuke in ${room.name} - someone about to move in?`);
							if (Memory.territory && Memory.territory[room.name]){
									requestSquadsViaCombatManager(room.name,'D');
							}
					}
					if (!room.controller.reservation && homeRoom.memory.hostileRemotes && homeRoom.memory.hostileRemotes[room.name]){
							delete homeRoom.memory.hostileRemotes[room.name];
					}
					let range = getDist(room.name, homeRoom.name);
					if (range < 3 && (Game.cpu.bucket > 9000 || Game.time.toString().slice(-4,-3) === '1')
							&& (!config$1.highwayWalls || Game.map.getSector(room.name) == Game.map.getSector(homeRoom.name))){
							let sources = room.find(FIND_SOURCES);
							for (let s in sources){
									let source = sources[s];
									if (homeRoom.memory.sourcelist[source.pos.toString()]){
											continue
									}
									let path = PathFinder.search(source.pos, Game.spawns[homeRoom.memory.spawn], {range: 1});
									let distance = 0;
									if (path){
											for (var p in path.path){
													let pos = path.path[p];
													if (pos){
															new RoomVisual(pos.roomName).circle(pos);
													}
													if (path.path[p].lookFor(LOOK_TERRAIN) == 'swamp'){
															distance = distance + 5;
													} else {
															distance = distance + 1;
													}
													if (Game.rooms[pos.roomName] && (Game.rooms[pos.roomName].type == 'SK')){
															distance = 2000;
													}
											}
											if (path.incomplete != true && distance){
													console.log('Obs: path complete from ' + room);
													homeRoom.memory.sourcelist[source.pos.toString()] = distance;
											} else {
													console.log('Obs: path incomplete from ' + room);
													homeRoom.memory.sourcelist[source.pos.toString()] = 2000;
											}
									} else {
											console.log('Obs: no path for ' + room);
									}
							}
					}
					if (!playerHeap.roomsAssessedForLooting[room.name] && false){
							assessRoomForLooting(room,range,homeRoom);
							if (room.storage && !room.storage.my){
									console.log('foreign store',room.name,room.storage.store.getUsedCapacity());
							}
					}
			} else if (room.controller && room.controller.owner && (!room.controller.my || room.class === 'normal'
					|| room.class === 'bunker')){
					let range = getDist(room.name, homeRoom.name);
					if (range < 3 && (Game.cpu.bucket > 9000 || Game.time.toString().slice(-4,-3) === '1')){
							let sources = room.find(FIND_SOURCES);
							for (let s in sources){
									let source = sources[s];
									if (homeRoom.memory.sourcelist[source.pos.toString()]){
											delete homeRoom.memory.sourcelist[source.pos.toString()];
									}
							}
					}
			}
			{
					//bombarding
					let bombardRoom = false;
					let bombardFrequency = 5000;
					let obliterate = true;
					let forceLaunch = false;
					if (config$1.bombard){
							for (let b in config$1.bombard){
									let targetObj = config$1.bombard[b];
									if (targetObj && targetObj.targetRoom  && targetObj.shard && targetObj.shard === Game.shard.name && targetObj.targetRoom === room.name){
											bombardRoom = true;
											if (targetObj.obliterate){
													bombardFrequency = 3000;
													obliterate = true;
											}
											if (targetObj.forceLaunch){
													forceLaunch = true;
											}
											if (targetObj.frequency){
													bombardFrequency = targetObj.frequency;
											}
									}
							}
					}
					if (config$1.bombard && ((room.controller && room.controller.owner) || forceLaunch)
							&& ((room.controller && room.controller.owner && config$1.bombard.includes(room.controller.owner.username)) || bombardRoom)){
							//fire the nukes!
							let currentNukes = room.find(FIND_NUKES, {filter: (n) => n.timeToLand > (NUKE_LAND_TIME - bombardFrequency)})[0];
							let nuker;
							if (!currentNukes){
									for (let r in Game.myRooms){
											let myRoom = Game.myRooms[r];
											let range = Game.map.getRoomLinearDistance(room.name,myRoom.name);
											if (range <= 10 && myRoom.memory.nuker){
													let myNuker = Game.getObjectById(myRoom.memory.nuker);
													if (myNuker && myNuker.store['energy'] === NUKER_ENERGY_CAPACITY && myNuker.store['G'] === NUKER_GHODIUM_CAPACITY && !myNuker.cooldown){
															nuker = myNuker;
															break
													}
											}
									}
							}
							console.log('*************',bombardRoom,currentNukes,nuker);
							if (!currentNukes && nuker){
									let structures = room.find(FIND_STRUCTURES, {filter: (s) => s.structureType != STRUCTURE_RAMPART && s.structureType != STRUCTURE_WALL && CONSTRUCTION_COST[s.structureType] > 10000});
									let best, bestCost;
									for (let s in structures){
											let cost = 0;
											let checkStructure = structures[s];
											let nearStructures = checkStructure.pos.lookAround(LOOK_STRUCTURES, 2, {filter: (s) => CONSTRUCTION_COST[s.structureType] > 10000});
											for (let n in nearStructures){
													cost += CONSTRUCTION_COST[nearStructures[n].structureType];
													if (nearStructures[n].structureType === STRUCTURE_SPAWN){
															cost += 10000;
													}
											}
											if (cost >= NUKER_ENERGY_CAPACITY * 0.5 || (obliterate && cost >= 10000)){
													if (!best || cost > bestCost){
															best = checkStructure.pos;
															bestCost = cost;
													}
											}
									}
									if ((!best && forceLaunch) || (room.controller && room.controller.my)){
											best = new RoomPosition(0,0,room.name);
									}
									if (best && (!nukeLaunched$1 || Game.time !== nukeLaunched$1)){
											//console.log('can nuke: ', best, bestCost, room.controller.owner.username)
											console.log(`announcement|${Game.shard.name}|bombard ${room.name} from homeRoom`);
											nuker.launchNuke(best);
											nukeLaunched$1 = Game.time;
									}
							}
					}

			}
			//room grading
			if (room.controller){
					if (!Memory.roomGrades){
							Memory.roomGrades = {};
					}
					if (!Memory.roomShortList){
							Memory.roomShortList = {};
					}
					if (!Memory.ownedRooms){
							Memory.ownedRooms = {};
					}
					if (canAutoExpand()){
							let sources = room.find(FIND_SOURCES).length;
							let min = room.mineral.mineralType;
							let owner = 0;
							if (room.controller.owner){
									owner = 1;
							}
							let nearRooms = Game.map.describeExits(room.name);
							let totalSources = sources;
							let remoteOwned = 0;
							for (let i in nearRooms){
									if (Memory.roomGrades[nearRooms[i]] && Memory.roomGrades[nearRooms[i]].data){
											totalSources += Number.parseInt(Memory.roomGrades[nearRooms[i]].data.charAt(0));
											if (Memory.roomGrades[nearRooms[i]].data.charAt(2) === '1'){
													remoteOwned = 1;
											}
									}
							}
							let score = 0;
							let range = getDist(homeRoom.name,room.name,true);
							let desiredRange = config$1.desiredRoomSpacing;
							if (!desiredRange){
									desiredRange = 5;
							}
							let maxRange = desiredRange*2;
							if (maxRange > 11){
									maxRange = 11;
							}
							if (range <= desiredRange){
									score += Math.abs(range-desiredRange);
							} else if (range > desiredRange && range <= maxRange){
									score += Math.abs(maxRange-range);
							} else {
									score -= 5;
							}
							if (sources < 2 || owner > 0); else {
									score = totalSources;
									if (edgeRoom(room) && config$1.official){
											score += 2;
									}
									if (remoteOwned > 0){
											//this room is next to an owned room, best avoided
											score = 0;
									}
							}
							let str = sources + min + owner + ',' + totalSources + ',' + score;
							Memory.roomGrades[room.name] = {data:str,expiry:Game.time+5000};
							if (Game.cpu.bucket > 1000 && (score >= 8 || Memory.roomShortList[room.name])){
									let origin;
									if (!Memory.origins){
											Memory.origins = {};
									}
									if (Memory.origins[room.name] !== undefined){
											origin = Memory.origins[room.name];
									} else {
											let matrix = findSpace(room,true);
											let baseLocation;
											if (matrix){
													baseLocation = findBaseLocation(room, matrix);
											}
											if (!baseLocation){
													baseLocation = false;
											}
											if (baseLocation){
													origin = baseLocation;
											}
									}
									Memory.origins[room.name] = origin;
									let symbol;
									if (config$1.symbolCollection){
											let decoder = room.find(FIND_SYMBOL_DECODERS)[0];
											if (decoder && decoder.resourceType){
													symbol = decoder.resourceType;
											}
									}
									if (origin){
											Memory.roomShortList[room.name] = {
													score: score,
													origin: origin,
													symbol: symbol
											};
									}
							} else if (score >= 6 || Memory.roomShortList[room.name]) {
									Memory.roomGrades[room.name].expiry = Game.time + 50;
							} else if (score < 6 && Memory.roomShortList[room.name]){
									delete Memory.roomShortList[room.name];
							}

							function edgeRoom(room){
									var split = room.name.split(/[A-Z]/);
									var x = split[1];
									var xlast = x.charAt(x.length - 1);
									var y = split[2];
									var ylast = y.charAt(y.length - 1);
									if ((xlast == 1 || xlast == 9) || (ylast == 1 || ylast == 9)){
											let nearRooms = Game.map.describeExits(room.name);
											for (let i in nearRooms){
													if (Game.map.getRoomType(nearRooms[i]) === 'highway'){
															return true
													}
											}
									}
									return false
							}
					}

					//map generation for pathing
					if (room.controller.owner && !room.controller.my){
							if (!homeRoom.memory.territory || !homeRoom.memory.territory[room.name]); else {
									//Invasion detected
									console.log('UNAUTHORIZED ROOM CLAIM', room.name);
									Game.notify('UNAUTHORIZED ROOM CLAIM' + room.name);
							}
							if (config$1.dangerousEnemies && config$1.dangerousEnemies.includes(room.controller.owner.username)){
									homeRoom.memory.alert = 'high';
									//todo find a way of removing high alert
									for (let i in Memory.myRooms){
											let roomName = Memory.myRooms[i];
											let range = getDist(roomName, room.name);
											if (range <= 10 && Game.rooms[roomName] && Game.rooms[roomName].controller && Game.rooms[roomName].controller.my
													&& Game.rooms[roomName].controller.level > 6){
													Game.rooms[roomName].memory.alert = 'high';
											}
									}
							}
							if (room.controller.owner.username && room.controller.owner.username.isEnemy && room.controller.level < 8){
									let alertStr = `enermy alert in ${room.name},player: ${room.controller.owner.username}, currently level ${room.controller.level}`;
									console.log('obs 739', alertStr);
									Game.notify(alertStr, 0);
									if (!room.controller.safeMode || room.controller.safeMode < 500);
							}
					} else {
							if (Memory.ownedRooms[room.name]){
									delete Memory.ownedRooms[room.name];
							}
					}
			}
			function assessHighwayWalls(room){
					let mem = Memory.highwayWalls;
					let sector = Game.map.getSector(room.name);
					let side = Game.map.getHighwaySide(room.name);
					if (side && side != 'corner'){
							if (!mem[sector]){
									mem[sector] = {};
							}
							if (!mem[sector][side]){
									mem[sector][side] = {};
							}
							let COs = /\w(\d+)\w(\d+)/.exec(room.name);
							let roomNum = COs[1];
							if (side == 'y'){
									roomNum = COs[2];
							}
							if (!mem[sector][side][roomNum]){
									mem[sector][side][roomNum] = {};
							}
							let memoryLocation = mem[sector][side][roomNum];
							let exits = room.find(FIND_EXIT);
							let walls = {};
							let edgesArrays = [];
							let edges = {};
							let count = 500;
							let exitObj = {};
							if (memoryLocation.route && memoryLocation.totalHits && memoryLocation.expiry > Game.time){
									return
							}
							if (Memory.openHighwayWalls && Memory.openHighwayWalls.rooms && Memory.openHighwayWalls.rooms.includes(room.name)){
									return
							}
							if (Memory.openHighwayWalls && Memory.openHighwayWalls.sectors){
									let thisSectors = Game.map.getHighwaySectors(room.name);
									let arr = [];
									for (let i in thisSectors){
											arr.push(thisSectors[i]);
									}
									if (arr.length > 1){
											if (Memory.openHighwayWalls.sectors[arr[0]] && Memory.openHighwayWalls.sectors[arr[0]][arr[1]]){
													return
											}
									}
							}

							let someEdgeWalls = false;
							for (let i in exits){
									let exit = exits[i];
									let wall = exit.lookAround(LOOK_STRUCTURES, 0, {filter: (s) => s.structureType == STRUCTURE_WALL})[0];
									if (wall && wall.pos){
											if (wall.pos.getEdge()){
													someEdgeWalls = true;
													if (!exitObj[wall.pos.getEdge()]){
															exitObj[wall.pos.getEdge()] = [];
													}
													exitObj[wall.pos.getEdge()].push(exit);
													walls[wall.pos] = {hits: wall.hits, connectedExit: wall.pos.getEdge()};
											}
									}
							}
							let roomIsBlocked = false;
							for (let exitSide in exitObj){
									let queue = exitObj[exitSide];
									floodWallConnectedToExitFromOneSide(queue);
							}

							function floodWallConnectedToExitFromOneSide(wallQueue){
									while (wallQueue.length > 0 && count > 0){
											count--;
											let wallPos = wallQueue.shift();
											let neighbours = [wallPos.movePos(1), wallPos.movePos(3), wallPos.movePos(5), wallPos.movePos(7)];
											for (let n in neighbours){
													let neighbour = neighbours[n];
													if (neighbour && !walls[neighbour] && neighbour.roomName === room.name){
															new RoomVisual(room.name).text(walls[wallPos].connectedExit, neighbour);
															let nWall = neighbour.lookAround(LOOK_STRUCTURES, 0, {filter: (s) => s.structureType == STRUCTURE_WALL})[0];
															if (nWall && nWall.pos){
																	wallQueue.push(nWall.pos);
																	walls[nWall.pos] = {hits: nWall.hits, connectedExit: walls[wallPos].connectedExit};
															} else {
																	//this wall is on an edge
																	if (!edges[neighbour] && !neighbour.onEdge()){
																			edges[neighbour] = walls[wallPos].connectedExit;
																			let foundArray = false;
																			for (let i in edgesArrays){
																					let lastItems = edgesArrays[i].slice(-3);
																					let isOnThisArray = false;
																					for (let l in lastItems){
																							if (lastItems[l] && lastItems[l].isNearTo(neighbour) && edges[lastItems[l]] === walls[wallPos].connectedExit){
																									isOnThisArray = true;
																									break
																							}
																					}
																					if (isOnThisArray){
																							//join a wall if it is near to another wall near an edge -> STOP, WON'T work if wall is 2 thick
																							foundArray = true;
																							edgesArrays[i].push(neighbour);
																							break
																					}
																			}
																			if (!foundArray){
																					edgesArrays.push([neighbour]);
																			}
																	}
															}
													} else if (neighbour.roomName === room.name){
															if (walls[neighbour].connectedExit && walls[wallPos].connectedExit && walls[neighbour].connectedExit != walls[wallPos].connectedExit){
																	//this wall reaches another exit
																	roomIsBlocked = true;
															}
													}
											}
									}
							}

							// for (let i in edgesArrays){
							// 		let colors = ['red','blue','green','gold','orange','purple','black','grey']
							// 		let color = colors[i]
							// 		if (!color){
							// 				color = 'white'
							// 		}
							// 		for (let p in edgesArrays[i]){
							// 				edgesArrays[i][p].highlight(color)
							// 		}
							// }
							room.display(`room is blocked`, roomIsBlocked);
							if (roomIsBlocked && edgesArrays.length == 2){
									let targetEdges = {};
									for (let i in edgesArrays[1]){
											targetEdges[edgesArrays[1][i]] = true;
									}
									let queue = [];
									//visited also contains cumulative hits for a route
									let visited = {};
									for (let i in edgesArrays[0]){
											let edge = edgesArrays[0][i];
											let neighbours = edge.neighbours();
											for (let n in neighbours){
													let neighbour = neighbours[n];
													if (neighbour.getTerrain() == 'wall'){
															continue
													}
													if (!visited[neighbour] && walls[neighbour]){
															visited[neighbour] = {
																	cumulativeHits: walls[neighbour].hits,
															};
															placeInQueue(queue, neighbour);
													}
											}
									}
									let foundLastItem;
									while (queue.length > 0 && !foundLastItem){
											let current = queue.shift();
											let neighbours = current.neighbours();
											let currentHits = visited[current].cumulativeHits;
											for (let n in neighbours){
													let neighbour = neighbours[n];
													if (neighbour.getTerrain() == 'wall'){
															continue
													}
													if (targetEdges[neighbour]){
															//found a route
															foundLastItem = current;
															current.highlight();
															break
													}
													if (!visited[neighbour] && walls[neighbour]){
															visited[neighbour] = {
																	cumulativeHits: walls[neighbour].hits + currentHits,
																	lastNode: current
															};
															placeInQueue(queue, neighbour, visited[neighbour].cumulativeHits);
													}
											}
									}
									if (foundLastItem){
											let arr = [foundLastItem];
											let totalHits = visited[foundLastItem].cumulativeHits;
											while (arr[arr.length - 1] && visited[arr[arr.length - 1]] && visited[arr[arr.length - 1]].lastNode){
													arr.push(visited[arr[arr.length - 1]].lastNode);
											}
											for (let i in arr){
													arr[i].highlight();
													arr[i] = arr[i].toString();
											}
											memoryLocation.route = arr;
											memoryLocation.totalHits = totalHits;
											memoryLocation.expiry = Game.time + 10000;
									}

									function placeInQueue(queue, neighbour, hits){
											if (queue.length === 0){
													queue.push(neighbour);
													return
											}
											let neighbourHits = walls[neighbour].hits;
											if (hits){
													neighbourHits = hits;
											}
											let foundIndexOfLargerItem = queue.findIndex((element) => {
													let elementHits = walls[element].hits;
													if (visited[element]){
															elementHits = visited[element].cumulativeHits;
													}
													if (elementHits > neighbourHits){
															return true
													}
											});
											if (foundIndexOfLargerItem != undefined){
													if (foundIndexOfLargerItem == -1){
															queue.push(neighbour);
													} else {
															queue.splice(foundIndexOfLargerItem, 0, neighbour);
													}
											}
									}
							} else if (!roomIsBlocked && someEdgeWalls){
									//open room
									console.log('trying to log as open', room.name);
									logHighwayAsOpen(room.name);
							}
					}
			}
	}

	function logHighwayAsOpen(roomName){
			if (!Memory.openHighwayWalls){
					Memory.openHighwayWalls = {
							sectors: {},
							rooms: []
					};
			}
			if (Game.map.getRoomType(roomName) == 'highway'){
					let sectors;
					let sectorsObj = Game.map.getHighwaySectors(roomName);
					if (sectorsObj){
							sectors = Object.values(sectorsObj);
					}
					if (sectors && sectors.length == 2){
							saveSector(roomName, sectors[0], sectors[1]);
							saveSector(roomName, sectors[1], sectors[0]);
							if (!Memory.openHighwayWalls.rooms.includes(roomName)){
									Memory.openHighwayWalls.rooms.push(roomName);
							}
					}

					function saveSector(roomName, thisSector, thatSector){
							if (!Memory.openHighwayWalls.sectors[thisSector]){
									Memory.openHighwayWalls.sectors[thisSector] = {};
							}
							if (!Memory.openHighwayWalls.sectors[thisSector][thatSector]){
									Memory.openHighwayWalls.sectors[thisSector][thatSector] = [roomName];
							} else if (!Memory.openHighwayWalls.sectors[thisSector][thatSector].includes(roomName)){
									Memory.openHighwayWalls.sectors[thisSector][thatSector].push(roomName);
							}
					}
			}
	}
	function addPortals(portals){
			let room;
			for (let p in portals){
					let portal = portals[p];
					room = portal.room;
					if (portal){
							if (!Memory.portals){
									Memory.portals = {};
							}
							if (portal.destination.shard){
									if (!Memory.portals[portal.destination.shard]){
											Memory.portals[portal.destination.shard] = {};
									}
									Memory.portals[portal.destination.shard][room.name] = portal.pos.toString();
							} else if (portal.destination.roomName) {
									//intraShard
									if (!Memory.portals){
											Memory.portals = {};
									}
									if (!Memory.portals[room.name]){
											Memory.portals[room.name] = {};
									}
									if (!Memory.portals[room.name][portal.destination.roomName]){
											Memory.portals[room.name][portal.destination.roomName] = [];
									}
									let posStr = portal.destination.toString();
									if (!Memory.portals[room.name][portal.destination.roomName].includes(posStr)){
											Memory.portals[room.name][portal.destination.roomName].push(posStr);
									}
							}
					}
			}
			if (!room){
					return
			}
			if (portals.length > 0){
					if (room.type === 'centre'){
							addPortalSector(Game.map.getSector(room.name), portals[0]);
					}
			} else if (room.type === 'centre'){
					deletePortalSector(Game.map.getSector(room.name));
			}
	}
	function addPortalSector(sector, portal){
			if (Memory.sectors && Memory.sectors[sector] && portal && portal.destination && portal.destination.roomName){
					let mem = Memory.sectors[sector];
					mem.portal = portal.destination.roomName;
			}
	}

	function deletePortalSector(sector){
			if (Memory.sectors && Memory.sectors[sector]){
					delete Memory.sectors[sector].portal;
			}
	}
	function getDist(a, b,forceLocal){
			let roomDistancesA,roomDistancesB;
			if (playerHeap.roomDistancesAll[a]){
					roomDistancesA = playerHeap.roomDistancesAll[a];
			}
			if (playerHeap.roomDistancesAll[b]){
					roomDistancesB = playerHeap.roomDistancesAll[b];
			}
			if (roomDistancesA && roomDistancesA[b]){
					return roomDistancesA[b]
			}
			if (roomDistancesB && roomDistancesB[a]){
					return roomDistancesB[a]
			}
			if (forceLocal){
					let linear = Game.map.getRoomLinearDistance(a, b);
					if (linear < 15){
							let route = getRoute(a, b);
							if (route){
									return route.length
							}
					}
					return false
			}
			if ((config$1.swampyGround && Game.cpu.bucket > 5000) || Game.cpu.bucket > 9000){
					let route = getRoute(a, b);
					if (route){
							return route.length
					} else {
							return Game.map.getRoomLinearDistance(a, b)
					}
			} else {
					return Game.map.getRoomLinearDistance(a, b)
			}
	}
	function assessRoomForLooting (room,roomDistance,homeRoom){
			//todo test before implementing
			let thiefBody = spawnCode$E.body(homeRoom,countRole).body;
			let thiefCost = spawnCode$E.body(homeRoom,countRole).cost;
			let tripsPerCreep = Math.floor(1500/(roomDistance*2));
			//using historical cpu logging: 18 energy/cpu -> 5.4 energy, include this cost -> time by distance we need to travel*2
			let costPerTrip = (thiefCost/tripsPerCreep)+(roomDistance*50*5.4*2);
			let capacity = (thiefBody.length/2)*50;
			let energyCostPerResourcePerTrip = costPerTrip/capacity;
			let minValueInCreds = energyCostPerResourcePerTrip*Memory.market.resources['energy'].w;
			let structuresToLoot = [];
			let resourcesToLoot = {};
			let structures = room.findStructures(['lab','factory']);
			structures.push(room.storage,room.terminal);
			for (let s in structures){
					let structure = structures[s];
					if (!structure){
							continue
					}
					let rampart = structure.pos.lookAround(LOOK_STRUCTURES,0,{filter:(s)=>s.structureType === 'rampart' && !s.my && !s.isPublic})[0];
					let value = 0;
					for (let i in structure.store){
							if (!Memory.market.resources[i]){
									continue
							}
							let price = Memory.market.resources[i].w;
							if (price > minValueInCreds){
									value += (price*structure.store[i]);
									resourcesToLoot[i] = true;
							}
					}
					if (rampart){
							let hitsInCreepLifeTimePerWorkPart = 50*(1500-(roomDistance*50));
							//cost includes move part
							let costPerWorkPart = 150;
							let energyCostPerRampartHit = hitsInCreepLifeTimePerWorkPart/costPerWorkPart;
							let creditCostForRamp = rampart.hits*energyCostPerRampartHit*Memory.market.resources['energy'].w;
							if (value < creditCostForRamp){
									continue
							}
					}
					structuresToLoot.push(structure.id);
			}
			if (structuresToLoot && structuresToLoot.length > 0){
					let obj = {
							structures : structuresToLoot,
							resources : resourcesToLoot
					};
					playerHeap.roomsAssessedForLooting[room.name] = obj;
			} else {
					playerHeap.roomsAssessedForLooting[room.name] = true;
			}
	}
	function getIntel(room,core){
			if (room.controller && !room.controller.my && room.controller.owner && Memory.ownedRooms[room.name]
					&& (!Memory.ownedRooms[room.name].lastAssessed || Game.time - Memory.ownedRooms[room.name].lastAssessed > 1000)){
					Memory.ownedRooms[room.name].lastAssessed = Game.time;
					Memory.ownedRooms[room.name].towers = room.findStructures(STRUCTURE_TOWER).length;
					Memory.ownedRooms[room.name].spawns = room.findStructures(STRUCTURE_SPAWN).length;
					let ramparts = room.findStructures(['rampart','constructedWall']);
					let totalHits = 0;
					let count = 0;
					let interval = 1;
					if (Game.cpu.bucket < 9000){
							interval = 10;
					}
					for (let i = 0; i < ramparts.length;i += interval){
							totalHits += ramparts[i].hits;
							count ++;
					}
					Memory.ownedRooms[room.name].rampartHealth = totalHits/count;
					//boost access
					for (let i in config$1.warboosts){
							if (room.storage && room.storage.store[i] && room.storage.store[i] > 1000){
									recordBoostAccess(room.controller.owner.username,i);
							}
					}
			}
			if (Game.cpu.bucket < 50){
					return
			}
			if (room && ((room.controller && room.controller.owner && room.controller.owner.username.isEnemy)|| core)){
					if (!Memory.quadEntryPoints){
							Memory.quadEntryPoints = {};
					}
					if (!Memory.quadEntryPoints[room.name] || Memory.quadEntryPoints[room.name].expiry < Game.time){
							let quadPos;
							let spawn = room.findStructures('spawn')[0];
							if (!spawn){
									spawn = room.findStructures('invaderCore')[0];
							}
							if (!spawn){
									spawn = room.controller;
							}
							if (spawn){
									for (let i = 2;i < 8;i+=2){
											let pos = spawn.pos.movePos(i);
											if (pos.isWalkable()){
													quadPos = new QuadPosition(pos,spawn.pos);
											}
									}
							}
							if (quadPos){
									Memory.quadEntryPoints[room.name] = {
											positions: getReachableExits(quadPos,room),
											expiry: Game.time + 10000
									};
							}
					}
			}
	}

	function run$15(creep){
			//claim-homeRoomName-chain
			Game.map.visual.text('Sc',creep.pos);
			var homeRoom = Game.rooms[creep.name.split(' ')[2]];
			homeRoom.name;
			let list = homeRoom.memory.nearRoomList;
			let canProgress = false;
			if (!creep.home.memory.scout){
					creep.suicide();
			}
			if (!homeRoom.memory.sourcelist){
					homeRoom.memory.sourcelist = {};
					delete creep.memory.sourcelist;
			}
			if (!creep.memory.sourcelist){
					creep.memory.sourcelist = {};
			}
			if (list){
					for (let i in list){
							if (list[i] == false && (!creep.home.memory.scoutTime || Game.time < creep.home.memory.scoutTime) &&
									(!creep.home.memory.scoutTarget || i == creep.home.memory.scoutTarget)){
									let room = Game.rooms[i];
									if (room){
											if (!creep.home.memory.scoutTarget || creep.home.memory.scoutTarget != room.name){
													creep.home.memory.scoutTime = Game.time + 300;
													creep.home.memory.scoutTarget = room.name;
											}
											canProgress = scoutSources(creep.home,room,creep);
											if (room.controller && (!room.controller.sign || room.controller.sign.username != Game.username) && room.controller && creep.pos.isNearTo(room.controller) && !room.controller.owner){
													creep.signController(room.controller, `${Game.username} territory`);
													creep.moveTo(room.controller);
											} else if (canProgress == true){
													room.assignTerritory(creep.home);
													list[room.name] = true;
											} else {
													creep.say(room.name);
													creep.moveTo(room);
											}
									} else {
											creep.goTo(i,{'SK':true});
									}
									break;
							} else if (creep.home.memory.scoutTarget && i === creep.home.memory.scoutTarget){
									list[i] = true;
									delete creep.home.memory.scoutTarget;
									delete creep.home.memory.scoutTime;
							}
					}
			}
			if (creep.ticksToLive < 2){
					delete creep.home.memory.scoutTarget;
					delete creep.home.memory.scoutTime;
			}
	}
	function getSourcePath(source,homeRoom){
			return PathFinder.search(source.pos, Game.spawns[homeRoom.memory.spawn], {
					range: 1,
					roomCallback: (roomName) => {
							if (Game.map.isCoreRoom(roomName)){
									return Infinity
							}
							if (Memory.ownedRooms[roomName]){
									return Infinity
							}
							if (Game.map.getRoomType(roomName) == 'SK'){
									return Game.map.getSKMatrix(roomName)
							}
					}
			})
	}
	function getDistance(path,SKAllowed,noRoads){
			let distance = 0;
			for (let p in path.path){
					let pos = path.path[p];
					if (pos){
							new RoomVisual(pos.roomName).circle(pos);
					}
					if (path.path[p].getTerrain() == 'swamp'){
							distance = distance + 1.25;
					} else {
							distance = distance + 1;
					}
					if (Game.rooms[pos.roomName] && !SKAllowed && (Game.rooms[pos.roomName].type == 'SK')){
							distance = 2000;
							break
					}
			}
			return Math.ceil(distance)
	}
	function scoutSources(homeRoom,room,creep){
			let roomType = Game.map.getRoomType(room.name);
			let list = homeRoom.memory.nearRoomList;
			if (list[room.name]){
					return
			}
			if (roomType === 'SK' && homeRoom.controller.level < 7){
					list[room.name] == true;
					return
			}
			console.log('scouting sources',room.name);
			let sources = room.find(FIND_SOURCES);
			if (room.controller && ((room.controller.owner && !room.controller.my)
					|| (room.controller.reservation && config.allies.includes(room.controller.reservation.username) && room.controller.reservation.username !== Game.username))){
					//not my room so don't try to gather
					for (let s in sources){
							let source = sources[s];
							if (Memory.sources && source.pos && Memory.sources[source.pos.toString()]){
									delete Memory.sources[source.pos.toString()];
							}
					}
					list[room.name] = true;
					return
			}
			let canProgress = true;
			let roomRoute = [];
			if (sources && sources.length > 0){
					let totalRoomDistance = 0,sourceList = [];
					for (let s in sources){
							let source = sources[s];
							if (!creep || !creep.memory.sourcelist[source.pos.toString()]){
									let sourceRoute = [];
									canProgress = false;
									let path = getSourcePath(source,homeRoom);
									if (path){
											let SKRoom = false;
											if (roomType == 'SK'){
													SKRoom = true;
											}
											if (!path.incomplete){
													if (roomType == 'SK' ){
															for (let p in path.path){
																	let pos = path.path[p];
																	if (!roomRoute.includes(pos.roomName)){
																			roomRoute.push(pos.roomName);
																	}
															}
													} else if (roomType === 'centre'){
															for (let p in path.path){
																	let pos = path.path[p];
																	if (!sourceRoute.includes(pos.roomName)){
																			sourceRoute.push(pos.roomName);
																	}
															}
													}
											}
											let distance = getDistance(path,SKRoom);
											if (creep && roomType !== 'SK'){
													creep.memory.sourcelist[source.pos.toString()] = distance;
											}
											if (!homeRoom.memory.sourceDistanceWithoutRoads){
													homeRoom.memory.sourceDistanceWithoutRoads = {};
											}
											if (roomType == 'SK'){
													totalRoomDistance += distance;
													sourceList.push(source.pos.toString());
											} else if (path.incomplete != true && distance && (distance < 150 ||
													(distance < 200 && roomType === 'centre'))){
													console.log('Scout: path complete from ' + room);
													homeRoom.memory.sourceDistanceWithoutRoads[source.pos.toString()] = getDistance(path,SKRoom);
													homeRoom.memory.sourcelist[source.pos.toString()] = distance;
													if (sourceRoute && sourceRoute.length > 0){
															if (!homeRoom.memory.centreSourceRoutes){
																	homeRoom.memory.centreSourceRoutes = {};
															}
															homeRoom.memory.centreSourceRoutes[source.pos.toString()] = sourceRoute;
													}
													if (!Memory.sources){
															Memory.sources = {};
													}
											} else {
													console.log('Scout: path incomplete from ' + room);
													distance = 1000;
											}
									} else {
											console.log('Scout: no path for ' + creep.room);
									}
							}
					}
					if (roomType == 'SK' && totalRoomDistance){
							if (!homeRoom.memory.possibleSKEnergyRooms){
									homeRoom.memory.possibleSKEnergyRooms = {};
							}
							if (creep){
									for (let i in sourceList){
											creep.memory.sourcelist[sourceList[i]] = totalRoomDistance/3;
									}
							}
							homeRoom.memory.possibleSKEnergyRooms[room.name] = totalRoomDistance;
							if (!room.memory.assignedEnergyHomeRoom || room.memory.assignedEnergyHomeRoomDistance > totalRoomDistance ||
									!room.memory.assignedEnergyHomeRoomRoute){
									room.memory.assignedEnergyHomeRoom = homeRoom.name;
									room.memory.assignedEnergyHomeRoomRoute = roomRoute;
									room.memory.assignedEnergyHomeRoomDistance = totalRoomDistance;
									room.memory.SKsources = sourceList;
							}
					}
			}
			if (!creep && canProgress == true){
					//creeps will sign controller before listing room as true
					room.assignTerritory();
					list[room.name] = true;
			}
			return canProgress
	}

	let spawnCode$A = {
			priority: (room, countFunction) => {
					let priority = 20;
					if (!room.memory.sourcelist){
							priority = 10;
					}
					return priority
			},
			isRequired: (room, countFunction) => {
					let numberRequired = 0;
					if (room.memory.scout && !room.memory.armedHostiles){
							numberRequired = room.memory.scout;
					}
					return countFunction('scout', room) < numberRequired;
			},
			spawn: (room, role, body) => {
					//decide if we need any other options
					if (body){
							//options -> TTL, creepnumber
							room.spawnCreep(role, body);
					}
			},
			body: (room, countFunction) => {
					if (room.memory.roadsDown === undefined){
							room.memory.roadsDown = false;
					}
					let bodyObject = {
							body: [MOVE],
							cost: 0
					};

					if (bodyObject.body && bodyObject.body.length > 0){
							bodyObject.cost += Game.getBodyCost(bodyObject.body);
					}
					return bodyObject
			}
	};

	var scout = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$15,
		scoutSources: scoutSources,
		spawnCode: spawnCode$A
	});

	function runScoutManager (room){
			if (!room.memory.nearRoomList || Object.keys(room.memory.nearRoomList).length === 0){
					let list = [];
					let visitedObj = {};
					findNearRooms(room.name, room.name, list, visitedObj, 0);
					list.sort((a,b)=>Game.map.getRoomLinearDistance(room.name,a) - Game.map.getRoomLinearDistance(room.name,b));
					let memObj = {};
					for (let i in list){
							memObj[list[i]] = false;
					}
					room.memory.nearRoomList = memObj;
			} else {
					let needScout = false;
					let observer = false;
					if (room.memory.observer && Game.getObjectById(room.memory.observer) && room.controller.level === 8){
							observer = true;
					}
					for (let i in room.memory.nearRoomList){
							if (room.memory.nearRoomList[i] == false){
									if (observer && Game.rooms[i]){
											scoutSources(room,Game.rooms[i]);
									}
									needScout = true;
									break;
							}
					}
					if (needScout == true && !observer){
							room.memory.scout = 1;
					} else {
							room.memory.scout = 0;
					}
			}
			let interval = 2000*room.controller.level;
			if (Game.time % interval == 0){
					delete room.memory.nearRoomList;
			}

			if (room.memory.sourcelist){
					for (let i in room.memory.sourcelist){
							saveSource(i.toPos(),room.memory.sourcelist[i],room);
					}
			}
	}
	function findNearRooms(spawnroom, room, arr, obj, step,distanceAway){
			let type = Game.map.getRoomType(room);
			if (type == 'normal' && config$1.highwayWalls){
					let homeSector = Game.map.getSector(spawnroom);
					let currentSector = Game.map.getSector(room);
					if (homeSector != currentSector){
							return
					}
			}
			if (!distanceAway){
					distanceAway = 4;
			}
			if (step < distanceAway && !obj[room] && type &&  (type !== 'highway' || config$1.remotesCanCrossHighways)){
					if (!Game.map.getRoomStatus(room) || Game.map.getRoomStatus(room).status === 'closed'){
							return
					}
					let newstep = step + 1;
					obj[room] = 1;
					let exits = Game.map.describeExits(room);
					if (room != spawnroom && (!Game.rooms[room] || type === 'SK'|| type =='centre' ||
							(Game.rooms[room].controller && (!Game.rooms[room].controller.owner ||
									(Game.rooms[room].controller.my && Game.rooms[room].class !== 'normal' && Game.rooms[room] !== 'bunker'))))){
							arr.push(room);
					}
					for (let e in exits){
							if (exits[e]){
									findNearRooms(spawnroom, exits[e], arr, obj, newstep,distanceAway);
							}
					}
			}
	}
	function saveSource(sourcePos,distance,home){
			let type = Game.map.getRoomType(sourcePos);
			let posString = sourcePos.toString();
			if (!Memory.sources[posString] || !Memory.sources[posString].rooms){
					Memory.sources[posString] = {rooms:[home.name]};
			} else if (Memory.sources[posString].rooms &&
					!Memory.sources[posString].rooms.includes(home.name)){
					Memory.sources[posString].rooms.push(home.name);
			}
			if (!Memory.sources[posString].closestRoom || distance < Memory.sources[posString].distance){
					Memory.sources[posString].closestRoom = home.name;
					Memory.sources[posString].distance = distance;
			}
			if (type == 'SK'){
					Memory.sources[posString].SK = true;
			} else if (type == 'centre'){
					Memory.sources[posString].centre = true;
			}
			Memory.sources[posString].expiry = Game.time+10000;
	}

	playerHeap.territoryManager = {};
	playerHeap.territoryManager.closestRanges = {};
	function contested(){
			if (!Memory.contestedTerritory){
					return
			}
			for (let i in Memory.contestedTerritory){
					if (Game.rooms[i] && isTolerated(Game.rooms[i])){
							delete Memory.contestedTerritory[i];
					}
			}
	}
	function tolerateRoom(roomName,owner){
			if (!Memory.toleratedRooms){
					Memory.toleratedRooms = {};
			}
			Memory.toleratedRooms[roomName] = owner;
	}

	//assignTerritory prototype -> if home is specified then assign to home else assign globally -> CHANGE SO NOT RELIANT ON ROOM OBJ
	function assignTerritory(home){
			if (!Memory.territory){
					Memory.territory = {};
			}
			//scan territory rooms and generate list if needed
			if (!home.memory.territoryAdded || Game.time > home.memory.territoryAdded+10000){
					let tRooms = [];
					//direct neighbours
					let exits = Game.map.describeExits(home.name);
					for (let i in exits){
							tRooms.push(exits[i]);
					}
					//nearbyRooms
					let nearRooms = [];
					let visitedObj = {};
					findNearRooms(home.name,home.name,nearRooms,visitedObj,0,6);
					if (nearRooms){
							for (let i in nearRooms){
									if (nearRooms[i]){
											tRooms.push(nearRooms[i]);
									}
							}
					} else {
							return
					}
					if (tRooms.length < 5){
							return
					}
					for (let i in tRooms){
							if ((Memory.toleratedRooms && Memory.toleratedRooms[tRooms[i]]) || (Memory.ownedRooms && Memory.ownedRooms[tRooms[i]] && config.allies && Memory.ownedRooms[tRooms[i]].owner
									&& config.allies.includes(Memory.ownedRooms[tRooms[i]].owner))){
									continue
							}
							Memory.territory[tRooms[i]] = true;
					}
					home.memory.territoryAdded = Game.time;
			}
	}
	function forceReserve(){
			if (Memory.forceReserveRooms){
					for (let i in Memory.forceReserveRooms){
							if (Memory.forceReserveRooms[i].expiry && Memory.forceReserveRooms[i].expiry<Game.time){
									delete Memory.forceReserveRooms[i];
									continue
							}
							if (Game.rooms[i]){
									let room = Game.rooms[i];
									if (Memory.forceReserveRooms[i].status === 'owned' && room.controller && !room.controller.owner){
											Memory.forceReserveRooms[i].status = 'reserve';
											Memory.forceReserveRooms[i].expiry = Game.time+25000;
											Memory.forceReserveRooms[i].start = Game.time+200;
									} else if (room.controller && (!room.controller.reservation || room.controller.reservation.ticksToEnd < 250) && !room.memory.armedHostiles
											&& Memory.forceReserveRooms[i].start && Game.time < Memory.forceReserveRooms[i].start){
											let closest,closestRange;
											Game.myRooms.forEach((myRoom)=>{
													if (myRoom.controller && myRoom.controller.level === 8){
															let range = Game.map.getRoomLinearDistance(i,myRoom.name);
															if (range && (!closest || closestRange > range)){
																	closestRange = range;
																	closest = myRoom;
															}
													}
											});
											if (closest){
													closest.sendRCA(i);
											}
									}
									if (room && Game.time % 30 === 0){
											let core = room.find(FIND_STRUCTURES, {filter: (s) => s.structureType == STRUCTURE_INVADER_CORE})[0];
											if (core){
													delete Memory.forceReserveRooms[i];
													continue
											}
									}
							}
					}
			}
	}
	function scanTerritory(){
			//scan
			if (!Memory.territory){
					return
			}
			// for (let i in Memory.territory){
			// 		let roomName = i
			// 		if (roomName.isRoomName()){
			// 				let homePos = new RoomPosition (0,0,roomName)
			// 				Game.map.visual.rect(homePos,50,50,{fill:'#00f0dc'})
			// 		}
			// }
			if (Game.shard.name === 'shard2'){
					tolerateRoom('E38S6','Blattlaus');
					tolerateRoom('E39S3','Blattlaus');
					tolerateRoom('E18S9','PlaidRabbit');
					tolerateRoom('E32N15','Christinayo');
					tolerateRoom('W2S7','shley92822212');
			}
			for (let i in Memory.ownedRooms){
					if (!Memory.ownedRooms[i].owner){
							delete Memory.ownedRooms[i];
					}
			}
			if (config.attackRooms){
					for (let i in config.attackRooms){
							let shard = config.attackRooms[i][0];
							if (shard && Game.shard.name === shard){
									let roomName = config.attackRooms[i][1];
									if (config.boostLevels[5] && Game.canBoost(config.boostLevels[5],0.7)){
											console.log(`announcement|${Game.shard.name}|planned attack ${roomName}`);
											let count = 2;
											if (Game.rooms[roomName] && Game.rooms[roomName].controller.level > 7){
													count = 4;
											}
											requestSquadsViaCombatManager(roomName,'Ca',{count:count});
									}
							}
					}
			}
			let roomsToClear = [];
			for (let i in Memory.contestedTerritory){
					let owner = Memory.contestedTerritory[i];
					if (Game.rooms[i] && Game.rooms[i].controller && !Game.rooms[i].controller.owner && !Game.rooms[i].controller.reservation){
							delete Memory.contestedTerritory[i];
							continue
					}
					if (Game.rooms[i] && Game.rooms[i].controller && Game.rooms[i].controller.reservation && Game.rooms[i].controller.reservation.username === Game.username){
							delete Memory.contestedTerritory[i];
							continue
					}
					if (owner === 'Invader' || config.allies.includes(owner)){
							delete Memory.contestedTerritory[i];
					}
					if (Game.rooms[i] && Game.rooms[i].controller && Game.rooms[i].controller.owner){
							let exits = Game.map.describeExits(i);
							let faceClaim = false;
							for (let j in exits){
									if (Memory.myRooms.includes(exits[j])){
											if (Game.rooms[i].controller.level > 7 || (Game.rooms[i].controller.level > 5 && !config.official)){
													tolerateRoom(i,owner);
													break
											} else {
													//this room is face claiming us;
													console.log(`announcement|${Game.shard.name}|faceclaim ${i} ${owner}, level ${room.controller.level}`);
													let maxLevel = 5;
													if (!Game.canBoost(config.boostLevels[5],1.1)){
															maxLevel = 1;
													}
													//face claim so we force a squad rather than deciding whether to send via roomsToClear object
													requestSquadsViaCombatManager(i,'Ca',{count:2,maxLevel:maxLevel});
													logFaceClaim(Game.rooms[exits[j]],i);
													faceClaim = true;
													break
											}
									}
							}
							if (isTolerated(Game.rooms[i])){
									delete Memory.contestedTerritory[i];
									continue
							}
							if (!faceClaim && config.official && Game.shard.name !== 'shard2'){
									//avoid conflict on other shards
									continue
							}
							if (!faceClaim && Game.rooms[i].controller.level < 8 && config.autoClear && (config.autoClear === true || config.autoClear >= Game.rooms[i].controller.level)){
									console.log(`announcement|${Game.shard.name}|territory (low level) ${i} ${owner}`);
									let closestRange = playerHeap.territoryManager.closestRanges[i];
									if (!closestRange){
											for (let r in Memory.myRooms){
													let roomName = Memory.myRooms[r];
													let range = Game.map.getRoomLinearDistance(roomName,i);
													if (range > 10){
															continue
													}
													range = getDist(roomName,i,true);
													if (!closestRange || range < closestRange){
															closestRange = range;
													}
											}
											if (!closestRange){
													continue
											} else {
													playerHeap.territoryManager.closestRanges[i] = closestRange;
											}
									}
									if (config.allowedProximity && config.allowedProximity[owner]){
											//this player is allowed to settle closer
											let allowedRange = 3;
											if (config.allowedProximity && config.allowedProximity[owner]){
													allowedRange = config.allowedProximity[owner];
											}
											if (closestRange && closestRange >= allowedRange){
													tolerateRoom(i,owner);
													continue
											}
									}
									let attackType = 'Ca',count = 2;
									if (config.lootPlayer && config.lootPlayer.includes(owner)){
											attackType = 'L';
											count = 1;
									} else if (Memory.myRooms.length < 10 || Memory.excessEnergy < 10000){
											//send R squad only if we can't afford Ca
											attackType = 'R';
									}
									let level = 8;
									if (Memory.ownedRooms[i].level){
											level = Memory.ownedRooms[i].level;
									}
									let score = closestRange+(level*2)+count;
									if (Memory.combatLog && Memory.combatLog[i]){
											score -= 3;
									}
									if (owner === 'TgDgNU'){
											score += 50;
											if (level > 6){
													continue
											}
									}
									roomsToClear.push({
											targetRoom:i,
											type:attackType,
											count:count,
											score:score,
											closestRange:closestRange
									});
							} else if (!faceClaim && owner !== 'TgDgNU' && owner !== 'Tigga' && config.autoClear){
									tolerateRoom(i,owner);
							}
					}
			}
			roomsToClear.sort((a,b)=>a.score-b.score);
			let maxRoomsToAttack = 1;
			if (roomsToClear.length > 0){
					maxRoomsToAttack = Math.ceil(Memory.myRooms.length/10);
					let targetRooms = roomsToClear.slice(0,maxRoomsToAttack);
					for (let i in targetRooms){
							requestSquadsViaCombatManager(targetRooms[i].targetRoom,targetRooms[i].type,{count:targetRooms[i].count});
					}
			}
			for (let i in Memory.territory){
					let tRoom = Game.rooms[i];
					if (tRoom && tRoom.controller && ((tRoom.controller.owner && tRoom.controller.owner.username !== Game.username) || (tRoom.controller.reservation && tRoom.controller.reservation.username !== Game.username))){
							let owner;
							if (tRoom.controller.owner){
									owner = tRoom.controller.owner.username;
							} else if (tRoom.controller.reservation){
									owner = tRoom.controller.reservation.username;
							}
							if (owner === 'Invader' || config.allies.includes(owner) || (Memory.toleratedRooms && Memory.toleratedRooms[i])){
									delete Memory.contestedTerritory[tRoom.name];
									continue
							}
							if (!Memory.contestedTerritory){
									Memory.contestedTerritory = {};
							}
							Memory.contestedTerritory[tRoom.name] = owner;
					} else if (Game.time % 1000 === 0){
							let sign = '👻 ghost territory - auto clearing is active 👻';
							let tRoom = Game.rooms[i];
							if (tRoom && tRoom.controller && !tRoom.controller.owner && (!tRoom.controller.sign || tRoom.controller.sign.text !== sign)){
									let closest,closestRange;
									for (let r in Memory.myRooms){
											let roomName = Memory.myRooms[r];
											let range = Game.map.getRoomLinearDistance(roomName,tRoom.name);
											if (!closest || range < closestRange){
													closest = roomName;
													closestRange = range;
											}
									}
									let allowedRange = 4;
									if (closest && closestRange && closestRange < allowedRange){
											Game.rooms[closest].sendSigner(tRoom.name);
									} else if (closestRange && closestRange >= allowedRange){
											//not near our rooms anymore
											delete Memory.territory[i];
									}
							}
					}
			}
	}
	function isTolerated(room){
			if (!Memory.toleratedRooms || !room || !room.controller || !room.controller.owner){
					return false
			}
			if (Memory.toleratedRooms[room.name] && Memory.toleratedRooms[room.name] === room.controller.owner.username){
					return true
			}
	}
	function logFaceClaim(myRoom,theirRoomName){
			if (!myRoom.memory.faceClaims){
					myRoom.memory.faceClaims = [];
			}
			if (!myRoom.memory.faceClaims.includes(theirRoomName)){
					myRoom.memory.faceClaims.push(theirRoomName);
			}
	}

	playerHeap.squadManager = {};
	const powerSquadCap = Math.ceil(Game.cpu.limit / 15);
	const powerSquadRoomCap = 2;
	let powerSquadsCount = 0;
	playerHeap.squadManager.powerSquadRoomCount = {};
	let time$2 = Game.time;
	playerHeap.squadManager.targets = {};
	playerHeap.squadManager.harassSquadList = {};
	playerHeap.squadManager.currentTarget = {};
	//for auto squads
	function runSquadManager(){
			if (!Memory.squads){
					Memory.squads = {};
			}
			if (time$2 != Game.time){
					time$2 = Game.time;
					powerSquadsCount = 0;
					playerHeap.squadManager.powerSquadRoomCount = {};
			}
			let boostingRequiredAll = {};
			let currentlySpawning = [];
			let activeSiege = {};
			let cpuLog = {};
			let cpuSpawnLog = {};
			for (let s in Memory.squads){
					//console.log(JSON.stringify(homeRoom.memory.squads[s]))
					/*
							{
											//options
											targetRoom:roomName,
											dozers:doz,
											attackers:att,
											snipers:snip,
											medics:medic,
											boosted:boolean,
											type: R/L/D,
											//live data
											members: [],
											state: spawning,
											nextWaveTime: time
							}
							*/
					// rather than using waves -> request a new squad in good time so no off period
					//delete the squad memory when squad dies
					let squad = Memory.squads[s];
					let cpu = Game.cpu.getUsed();
					let homeRoom = Game.rooms[squad.homeRoom];
					if (!homeRoom){
							delete Memory.squads[s];
							continue
					}
					if (squad.type === 'swc'){
							squad.type = 'R';
					}
					if (!homeRoom && squad.homeShard && squad.homeShard !== Game.shard.name && squad.shard){
							runSquad(squad);
							continue
					} else if (squad.homeShard && squad.homeShard !== Game.shard.name && squad.state === 'spawning'){
							delete Memory.squads[s];
							continue
					}
					let rally = Game.flags['rally' + homeRoom.name];
					if (squad.state !== 'moving' && homeRoom.memory.defcon === 5 && squad.type !== 'G' && squad.targetRoom !== homeRoom.name){
							if (squad.rally){
									rally = squad.rally.toPos();
									rally.highlight();
							} else if (squad.rally === undefined && homeRoom.storage){
									//find a point on the way to the target destination to rally at
									let pos = new RoomPosition(25,25,squad.targetRoom);
									let startPos = homeRoom.storage.pos.movePos(5);
									let path = PathFinder.search(startPos,{pos:pos,range:20},{maxOps:10000,maxRooms:64,roomCallback: function(roomName) {
													if (roomName === squad.targetRoom){
															return
													}
													let room = Game.rooms[roomName];
													if (room && room.structureMatrix){
															let matrix = room.structureMatrix;
															if (matrix){
																	return  matrix
															}
													}
													if ((Memory.avoidRooms && Memory.avoidRooms[roomName]) || (Memory.ownedRooms && Memory.ownedRooms[roomName])){
															return false
													}
											}});
									if (path && !path.incomplete){
											console.log(homeRoom.name,'rally path found',squad.targetRoom);
											for (let p in path.path){
													path.path[p].highlight('blue');
													let range = 0;
													if (path.path[p].roomName === homeRoom.name && homeRoom.storage){
															range = path.path[p].getRangeTo(homeRoom.storage);
													}
													if (path.path[p].nearEdge() || range > 15){
															console.log('rally:', path.path[p].toString());
															squad.rally = path.path[p].toString();
															break
													}
											}
									} else {
											squad.rally = false;
									}
							}
					}
					if (homeRoom.memory.boostflag){
							var boostflag = homeRoom.memory.boostflag.toPos();
					}

					if (squad && squad.type == 'P'){
							powerSquadsCount++;
							if (!playerHeap.squadManager.powerSquadRoomCount[squad.homeRoom]){
									playerHeap.squadManager.powerSquadRoomCount[squad.homeRoom] = 0;
							}
							playerHeap.squadManager.powerSquadRoomCount[squad.homeRoom]++;
							//console.log(JSON.stringify(squad))
					}
					//console.log(JSON.stringify(squad),i, homeRoom.name)
					//console.log(JSON.stringify(homeRoom.memory.spawnCounters))
					squad.targetRoom;
					let squadSize = Number.parseInt(squad.dozers) + Number.parseInt(squad.attackers) + Number.parseInt(squad.snipers) + Number.parseInt(squad.medics) + Number.parseInt(squad.hybrids);
					//deleting dead creeps from list
					if (!squad.members){
							squad.members = [];
					}
					if (squad.type === 'H'){
							homeRoom.memory.lastHarass = Game.time;
							playerHeap.squadManager.harassSquadList[homeRoom.name]=squad.id;
					}
					if (squad.type != 'C' && squad.type != 'DC'&& squad.type != 'P' && squad.type !== 'SKM' && squad.type != 'T'){
							activeSiege[homeRoom.name] = true;
					}
					if (squad.state != 'spawning'){
							//think if state is spawning we keep spawning creeps and then removing them from the squad before the next tick
							for (let i in squad.members){
									if (!Game.creeps[squad.members[i]] && squad.homeShard === Game.shard.name){
											squad.members.splice(i, 1);
									}
							}
					}
					// if (squad.state === 'moving' && squad.boosted && squad.boosted !== 'N' && squad.members){
					// 		for (let i in squad.members){
					// 				let member = Game.getObjectById(squad.members[i])
					// 				if (member && !checkCreepIsBoostedAsRequired(member,squad.boosted) && member.ticksToLive &&
					// 				member.ticksToLive > 700){
					// 						squad.state = 'moving'
					// 						member.say('bErr',true)
					// 						break
					// 				}
					// 		}
					// }
					if (squad.state && squad.state == undefined || !squad.state){
							squad.state = 'spawning';
					}
					if ((!squad.homeShard || squad.homeShard === Game.shard.name) && ((squad.members && squad.members.length === 0 && squad.state != 'spawning')
							|| (squad.members.length == 0 && squad.expiry && squad.expiry < Game.time))){
							if (squad.type === 'Ca' || squad.type === 'D' || squad.type === 'L' || squad.type === 'C'){
									let deathObj = {
											id:squad.id,
											size:squadSize,
											level:squad.boosted,
											deathEarly:false
									};
									//squad has died prematurely - increase or block next squad
									if (squad.firstTTL && Game.time < squad.firstTTL){
											deathObj.deathEarly = true;
									}
									if (!Memory.combatLog[squad.targetRoom]){
											Memory.combatLog[squad.targetRoom] = {
													expiry:Game.time+5000,
													squadLog:[]
											};
									} else {
											Memory.combatLog[squad.targetRoom].expiry = Game.time+5000;
											if (!deathObj.deathEarly){
													delete Memory.combatLog[squad.targetRoom].block;
											}
									}
									if (!Memory.combatLog[squad.targetRoom].squadLog.includes(deathObj)){
											Memory.combatLog[squad.targetRoom].squadLog.push(deathObj);
									}
							}
							if (squad.type === 'edgeDrain'){
									if (!Memory.edgeDrainBlock){
											Memory.edgeDrainBlock = {};
									}
									Memory.edgeDrainBlock[squad.targetRoom] = Game.time + 1500;
									for (let r in squad.secondaryRooms){
											Memory.edgeDrainBlock[squad.secondaryRooms[r]] = Game.time + 1500;
									}
							}
							if (squad.type === 'G'){
									if (homeRoom.memory.remoteRooms && homeRoom.memory.remoteRooms[squad.targetRoom]){
											homeRoom.memory.remoteRooms[squad.targetRoom].blockGuardSquad = Game.time + 3000;
									}
							}
							if (squad.type === 'SKM'){
									if (!homeRoom.memory.avoidSKMineral){
											homeRoom.memory.avoidSKMineral = {};
									}
									homeRoom.memory.avoidSKMineral[squad.targetRoom] = Game.time + 3000;
							}
							console.log('deleting',squad.id,squad.type,squad.homeRoom);
							delete Memory.squads[s];
							continue
					}
					if (squad.state === 'spawning'){
							//move to rally and move off if enough creeps
							//move to rally point
							if (homeRoom.memory.alert && homeRoom.memory.alert == 'high' && squad.type == 'C'){
									delete Memory.squads[s];
									continue
							}
							let members = [];
							for (let i = squad.members.length - 1; i > -1; i--){
									if (!squad.members[i] || !Game.creeps[squad.members[i]]){
											squad.members.splice(i, 1);
									}
							}
							for (let i in squad.members){
									let creep = Game.creeps[squad.members[i]];
									members.push(creep);
							}
							if (homeRoom.memory.siegeBlock && homeRoom.memory.siegeBlock[squad.targetRoom] && homeRoom.memory.siegeBlock[squad.targetRoom] > Game.time){
									delete Memory.squads[s];
									console.log(`spawning blocked: ${squad.id} ${squad.targetRoom} ${squad.type}, home: ${homeRoom.name}, name:${s}`);
									if (Memory.combatLog[squad.targetRoom] && !Memory.combatLog[squad.targetRoom].safeMode){
											Memory.combatLog[squad.targetRoom].safeMode = homeRoom.memory.siegeBlock[squad.targetRoom];
									}
									continue
							} else if (homeRoom.spawnFree){
									if (homeRoom.memory.siegeBlock && homeRoom.memory.siegeBlock[squad.targetRoom]){
											delete homeRoom.memory.siegeBlock[squad.targetRoom];
									}
									let canBoost = (!squad.boosted || squad.members.length > 0 || squad.boosted === 'N' || (homeRoom.memory.blabsFull && homeRoom.memory.boostingRequired === squad.boosted));
									if (squadSize && canBoost && squad.members && squad.members.length < squadSize && !currentlySpawning.includes(homeRoom.name)){
											currentlySpawning.push(homeRoom.name);
											spawnSquad(homeRoom,squad,s);
									}
									homeRoom.display(`spawning squad: ${squad.id} ${squad.targetRoom} ${squad.type}, home: ${homeRoom.name}, name:${s}, boosted:${squad.boosted}`);
									//homeRoom.display(` can boost : ${canBoost}`)
							}
							if (squad.boosted && !boostingRequiredAll[homeRoom.name]){
									//console.log('boost needed',squad.boosted,homeRoom.name)
									boostingRequiredAll[homeRoom.name] = squad.boosted;
							}
							let boosted = boost(members);
							if ((squadSize && squad.members && members && members.length === squadSize && boosted) ||
									(squad.members.length > 0 && squad.members[0] && Game.getObjectById(squad.members[0]) && Game.getObjectById(squad.members[0]).ticksToLive < 700 && !Game.getObjectById(squad.members[0]).spawning)){
									if (config.private){
											homeRoom.display(`boost: ${boosted}`);
									}
									squad.state = 'moving';
									for (let i in squad.members){
											if (Game.getObjectById(squad.members[i])){
													Game.getObjectById(squad.members[i]).say(`b ${boosted}`,true);
											}
									}
							}
							if (squadSize === 0){
									delete Memory.squads[s];
							}
							let usedCPU = Game.cpu.getUsed() - cpu;
							let statID = squad.type+'.'+squadSize+'.'+squad.boosted;
							if (!cpuSpawnLog[statID]){
									cpuSpawnLog[statID] = usedCPU;
							} else {
									cpuSpawnLog[statID] += usedCPU;
							}
							if (!Memory.stats.squadsSpawning.number[statID]){
									Memory.stats.squadsSpawning.number[statID] = 1;
							} else {
									Memory.stats.squadsSpawning.number[statID] ++;
							}
							function boost(members){
									let ret = true;
									if (squad.boosted == 0 || squad.boosted == 'N'){
											if (rally){
													for (let i in members){
															if (members[i] && !members[i].spawning && members[i].pos.getRangeTo(rally)>1){
																	members[i].moveTo(rally, {range: 1});
															}
													}
											}
											return true
									} else if (squad.targetRoom === homeRoom.name && (!homeRoom.memory.armedHostiles || (homeRoom.hostileList && homeRoom.hostileList.length === 1
													&& homeRoom.memory.hostiles && Game.getObjectById(homeRoom.memory.hostiles) && !Game.getObjectById(homeRoom.memory.hostiles).isBoosted()))
											&& squad.type == 'D'){
											if (rally){
													for (let i in members){
															if (members[i] && !members[i].spawning && members[i].pos.getRangeTo(rally)>1){
																	members[i].moveTo(rally, {range: 1});
															}
													}
											}
											return false
									}
									for (let i in members){
											let creep = members[i];
											if (!creep){
													return false
											}
											if (creep.spawning){
													ret = false;
													continue
											}
											let bLabsFull = false;
											if (homeRoom.memory.blabsFull || creep.memory.boosted){
													bLabsFull = true;
											} else {
													let boostsNeeded = boostsNeededByCreep(creep,squad.boosted);
													if (homeRoom.memory.boostLabs){
															let canBoost = true;
															for (let i in boostsNeeded){
																	let boostNeeded = boostsNeeded[i];
																	let canBoostThisBoost = false;
																	for (let min in homeRoom.memory.boostLabs){
																			if (min === 'list'){
																					continue
																			}
																			let lab = Game.getObjectById(homeRoom.memory.boostLabs[min]);
																			if (min === boostNeeded && lab && lab.store[boostNeeded] && lab.store[boostNeeded] >= 500
																					&& lab.store['energy'] > 700){
																					canBoostThisBoost = true;
																					break
																			}
																	}
																	if (!canBoostThisBoost){
																			canBoost = false;
																			break
																	}
															}
															if (canBoost){
																	bLabsFull = true;
															}
													}
											}
											if (!config.squadBoostTypes && creep.isBoosted(true)){
													if (rally){
															creep.moveTo(rally, {range: 1});
													}
											} else if (checkCreepIsBoostedAsRequired(creep,squad.boosted)){
													creep.memory.boosted = true;
													if (rally && creep.pos.getRangeTo(rally)>1){
															creep.moveTo(rally, {range: 1});
													}
											} else if (bLabsFull && homeRoom.memory.boostingRequired == squad.boosted && homeRoom.memory.boostLabs){
													ret = false;
													if (boostflag){
															if (creep.pos.isEqualTo(boostflag)){
																	for (let j in homeRoom.memory.boostLabs){
																			if (j === 'list'){
																					continue
																			}
																			let lab = Game.getObjectById(homeRoom.memory.boostLabs[j]);
																			lab.boostCreep(creep);
																	}
															} else {
																	creep.moveTo(boostflag,{range:0});
															}
													}
											} else {
													ret = false;
											}
									}
									return ret
							}
					} else if (squad.state === 'moving'){
							if (squad.shard && squad.shard != Game.shard.name){
									if (!squad.nextWaveTime){
											squad.nextWaveTime = Game.time+700;
									}
									let interMem = JSON.parse(InterShardMemory.getLocal());
									if (!interMem.squads){
											interMem.squads = {};
									}
									if (!interMem.squads[squad.shard]){
											interMem.squads[squad.shard] = {};
									}
									if (!interMem.squads[squad.shard][squad.id] && squad.homeShard && squad.homeShard === Game.shard.name){
											interMem.squads[squad.shard][squad.id] = squad;
											InterShardMemory.setLocal(JSON.stringify(interMem));
									}
							}
							let members = [];
							for (let i in squad.members){
									let creep = Game.creeps[squad.members[i]];
									if (creep && squad && squad.id){
											creep.memory.squad = squad.id;
											members.push(creep);
									}
							}
							if (squad.homeRoom && Game.flags['hold'+squad.homeRoom] && !squad.release){
									for (let i in members){
											members[i].rally(3);
									}
									if (members[0].ticksToLive < 800 || Game.time %500 === 0){
											squad.release = true;
											members[0].say('release',true);
									}
									continue
							} else {
									squad.release = true;
							}
							if (squad.type === 'chase'){
									console.log('chase',members[0],checkCreepIsBoostedAsRequired(members[0],5));
							}
							if (squad.type === 'Bow' && (members[0].room.name === squad.targetRoom || members[0].room.name === squad.entryRoom)){
									console.log('running bow');
									runBow(squad,homeRoom);
							} else {
									runSquad(squad, homeRoom);
							}
							let usedCPU = Game.cpu.getUsed() - cpu;
							if (members.length > 0){
									let room = members[0].room;
									room.display(`squad: ${s} ${squad.id} ${squad.targetRoom} ${squad.type}, home: ${homeRoom.name}, boosted:  ${squad.boosted}, ${squadSize}, cpu: ${usedCPU}`);
									if (usedCPU>5 ){
											console.log('high cpu',usedCPU,squad.id,members[0].pos.hyperlink,squad.type,members.length,'home:',homeRoom.name,'target:',squad.targetRoom);
											squad.debugCPU = true;
									}
							}
							let statID = squad.type+'.'+squadSize+'.'+squad.boosted;
							if (!cpuLog[statID]){
									cpuLog[statID] = usedCPU;
							} else {
									cpuLog[statID] += usedCPU;
							}
							if (!Memory.stats.squads.number[statID]){
									Memory.stats.squads.number[statID] = 1;
							} else {
									Memory.stats.squads.number[statID] ++;
							}
					}
			}
			for (let i in cpuLog){
					Memory.stats.squads.cpu[i] = cpuLog[i] / Memory.stats.squads.number[i];
			}
			for (let i in cpuSpawnLog){
					Memory.stats.squadsSpawning.cpu[i] = cpuSpawnLog[i] / Memory.stats.squadsSpawning.number[i];
			}
			for (let i in Game.myRooms){
					let homeRoom = Game.myRooms[i];
					if (activeSiege[homeRoom.name]){
							homeRoom.memory.activeSiege = true;
					} else {
							homeRoom.memory.activeSiege = false;
					}
					let boostingRequired = boostingRequiredAll[homeRoom.name];
					if (boostingRequired && boostingRequired != 0){
							homeRoom.memory.boostingRequired = boostingRequired;
					} else if (!homeRoom.memory.faceClaimed){
							//don't delete if faceclaimed - need mega fast squad spawning
							delete homeRoom.memory.boostingRequired;
					}
			}
	}

	function findTarget(pos, squad, healPower,toughPower, needPowerMatrix){
			let room = Game.rooms[pos.roomName];
			let type = squad.type;
			let dict = squadDict[type];
			let defendPoint;
			if (!pos){
					console.log('no pos',squad.id,squad.homeRoom);
					return
			}
			if (playerHeap.squadManager.currentTarget && playerHeap.squadManager.currentTarget[squad.id]){
					let cachedTarget = Game.getObjectById(playerHeap.squadManager.currentTarget[squad.id].target);
					if (cachedTarget && cachedTarget.pos && cachedTarget.pos.roomName === pos.roomName && (cachedTarget.pos.isNearTo(pos) || playerHeap.squadManager.currentTarget[squad.id].expiry > Game.time)){
							console.log('cached target found',pos,squad.id,squad.type,pos.hyperlink);
							return cachedTarget
					} else {
							console.log('deleting cached target',JSON.stringify(playerHeap.squadManager.currentTarget[squad.id]),pos.hyperlink);
							delete playerHeap.squadManager.currentTarget[squad.id];
					}
			}
			if (type === 'D' && Game.flags['defendPoint'+room.name] && Game.flags['defendPoint'+room.name].pos && Game.flags['defendPoint'+room.name].pos.roomName === room.name){
					defendPoint = Game.flags['defendPoint'+room.name].pos;
			}
			if (dict && !dict.structures && !dict.cons && dict.hostiles && !room.memory.hostiles && type !== 'SKE'){
					return
			}
			if (!dict){
					console.log('no dict',type);
					return
			}
			if (healPower){
					healPower = healPower / 100;
			}
			if (!dict){
					console.log('no dict!', pos, type);
			}
			if (!room){
					console.log('find target no room SM');
			}
			let matrix;
			if (needPowerMatrix){
					matrix = room.getTowerPowerMatrix();
			}
			//todo allow targeting hostiles first in some situations - eg harassers
			if (dict.structures && dict.sFilter && (!room.controller || !room.controller.my)){
					for (let i in dict.sFilter){
							if (type === 'L' && room.controller && !room.controller.owner && room.memory.hostiles){
									continue
							}
							let t;
							let findConst = FIND_HOSTILE_STRUCTURES;
							if (type === 'H' && room && (!room.controller || !room.controller.owner || room.controller.owner.username.isEnemy) &&
									(!room.controller || !room.controller.reservation || (room.controller.reservation.username !== Game.username && !config.allies.includes(room.controller.reservation.username)))){
									findConst = FIND_STRUCTURES;
							}
							if (type === 'C'){
									let core = room.findStructures('invaderCore')[0];
									if (core && core.level <= 3){
											cacheTarget(core);
											return core
									}
							}
							if (!needPowerMatrix || !matrix){
									t = pos.findClosestByRange(findConst, dict.sFilter[i]);
							} else {
									let list = room.find(findConst, dict.sFilter[i]);
									let newList = list.filter((item) => {
											let score = matrix.get(item.pos.x, item.pos.y);
											if (room && room.controller && room.controller.level < 5 && score === 2){
													score = 1.5;
											}
											if (toughPower){
													score *= toughPower;
											}
											if (score < healPower){
													return true
											} else {
													return false
											}
									});
									if (newList && newList.length > 0){
											if (newList.length == 1){
													return newList[0]
											} else {
													t = pos.findClosestByRange(newList);
											}
									}
							}
							if (!t && (type === 'R' || type === 'L' || type === 'Ca' || type === 'W')){
									if (!needPowerMatrix || !matrix){
											t = pos.findClosestByRange(FIND_STRUCTURES, dict.sFilter[i]);
									} else {
											let list = room.find(FIND_STRUCTURES, dict.sFilter[i]);
											let newList = list.filter((item) => {
													let score = matrix.get(item.pos.x, item.pos.y);
													if (toughPower){
															score *= toughPower;
													}
													if (score < healPower){
															return true
													} else {
															return false
													}
											});
											if (newList && newList.length > 0){
													if (newList.length == 1){
															t = newList[0];
													} else {
															t = pos.findClosestByRange(newList);
													}
											}
									}
							}
							if (t){
									cacheTarget(t);
									return t
							}
					}
			}
			if (dict.hostiles && dict.hFilter){
					let t;
					if (!needPowerMatrix || !matrix){
							let allHostiles = room.find(FIND_HOSTILE_CREEPS, dict.hFilter);
							if (defendPoint){
									allHostiles = allHostiles.filter((h)=>h.pos && h.pos.getRangeTo(defendPoint)<5);
							}
							t = pos.findClosestByRange(allHostiles);
					} else {
							let list = room.find(FIND_HOSTILE_CREEPS, dict.hFilter);
							let newList = list.filter((item) => {
									let score = matrix.get(item.pos.x, item.pos.y);
									if (score < healPower){
											return true
									} else {
											return false
									}
							});
							if (newList && newList.length > 0){
									if (newList.length == 1){
											return newList[0]
									} else {
											t = pos.findClosestByRange(newList);
									}
							}
					}

					if (t){
							cacheTarget(t);
							return t
					}
			}
			if (dict.cons && dict.cFilter){
					let t;
					if (!needPowerMatrix || !matrix){
							t = pos.findClosestByRange(FIND_HOSTILE_CONSTRUCTION_SITES, dict.cFilter);
					} else {
							let list = room.find(FIND_HOSTILE_CONSTRUCTION_SITES, dict.cFilter);
							let newList = list.filter((item) => {
									let score = matrix.get(item.pos.x, item.pos.y);
									if (score < healPower){
											return true
									} else {
											return false
									}
							});
							if (newList && newList.length > 0){
									if (newList.length == 1){
											return newList[0]
									} else {
											t = pos.findClosestByRange(newList);
									}
							}
					}
					if (t){
							cacheTarget(t);
							return t
					}
			}
			function cacheTarget(target){
					let expireIn = 10;
					if (target.structureType){
							expireIn = 30;
					}
					if (squad.type === 'SKE' && target.ticksToSpawn){
							expireIn = target.ticksToSpawn-5;
					}
					if (expireIn < 0){
							expireIn = 0;
					}
					playerHeap.squadManager.currentTarget[squad.id] = {
							target: target.id,
							expiry: Game.time + expireIn
					};
			}
	}

	function runSquad(squad, homeRoom){
			let targetRoom = squad.targetRoom;
			if (squad.type === 'Bow'){
					targetRoom = squad.entryRoom;
			}
			Game.cpu.getUsed();
			//if in room move towards target
			// if defenders draw them out of ramparts?
			let members = [];
			for (let i in squad.members){
					let creep = Game.creeps[squad.members[i]];
					if (creep && squad && squad.id){
							creep.memory.squad = squad.id;
							members.push(creep);
					}
			}
			if (!homeRoom && members[0]){
					members[0].room.display(`squad: ${squad.id} ${targetRoom} ${squad.type}`);
			}
			if (squad.escortId && Game.getObjectById(squad.escortId)){
					members.push(Game.getObjectById(squad.escortId));
					Game.getObjectById(squad.escortId).memory.squad = squad.id;
			} else if (squad.escortId){
					console.log('no escort target');
					delete Memory.squads[squad.id];
					return
			} else if (squad.type === 'E'){
					squad.type = 'D';
			}
			if (members.length == 0){
					return
			}
			let currentRoom = members[0].room;

			if (!squad.firstTTL){
					//the time when the first squad member dies of old age, if the squad doesn't make it past this we block spawning
					let lowest = 1500;
					for (let i in members){
							if (members[i].ticksToLive < lowest){
									lowest = members[i].ticksToLive;
							}
					}
					squad.firstTTL = Game.time + lowest;
			}

			//put medics last so a damage dealer is the leader
			members = alternate(members, squad.leaderRole);
			let room = members[0].room;
			if (room.memory.hostiles){
					Game.map.visual.text('\u{2694}', new RoomPosition(10, 40, room.name, {fontSize: 20}));
			}
			if (squad.shard != Game.shard.name && members && members[0]){
					let portal;
					let goalNum = Number.parseInt(squad.shard.slice(5));
					let currentNum = Number.parseInt(Game.shard.name.slice(5));
					let targetPortalNum = Number.parseInt(Game.shard.name.slice(5));
					goalNum > currentNum ? targetPortalNum++ : targetPortalNum--;
					let targetShard ='shard' + targetPortalNum;
					let currentRange;
					if (Memory.portals && targetShard && Memory.portals[targetShard]){
							for (let i in Memory.portals[targetShard]){
									let range = Game.map.getRoomLinearDistance(members[0].room.name, i);
									// if (range <= 6 && Game.flags['PortalRoom']&& Game.flags['PortalRoom'].pos.roomName === i){
									// 		portal = Memory.portals[targetShard][i]
									// 		break
									// }
									if (i === members[0].room.name){
											portal = Memory.portals[targetShard][i];
											break
									}
									if (!currentRange || range < currentRange){
											portal = Memory.portals[targetShard][i];
											currentRange = range;
									}
							}
					}
					if (members[0] && Game.map.getRoomType(members[0].room.name) === 'highway'){
							let COs = toCoOrds(members[0].room.name);
							if (COs[0] !== undefined && COs[1] !== undefined && COs[0].toString().slice(-1)==='0' && COs[1].toString().slice(-1)==='0'){
									let portals = room.find(FIND_STRUCTURES, {filter: (s) => s.structureType == STRUCTURE_PORTAL});
									addPortals(portals);
							}
					}
					if (portal){
							let portalPos = portal.toPos();
							if (targetShard && targetShard === 'shard0' && portalPos && portalPos.roomName && Game.rooms[portalPos.roomName]){
									let portals = Game.rooms[portalPos.roomName].findStructures('portal',(p)=>p.destination &&
											p.destination.shard && p.destination.shard === 'shard0');
									if (portals){
											let currentRange;
											for (let i in portals){
													let thisPortal = portals[i];
													let landingRoom = targetRoom;
													if (squad.portalLandingRoom){
															landingRoom = squad.portalLandingRoom;
													}
													let range = Game.map.getRoomLinearDistance(thisPortal.destination.room,landingRoom);
													if (thisPortal.destination.room === landingRoom){
															portalPos = thisPortal.pos;
															break
													}
													if (range === undefined || range > currentRange){
															portalPos = thisPortal.pos;
															currentRange = range;
													}
											}
									}
							}
							for (let i in members){
									members[i].goTo(portalPos,{range:0});
							}
					}
					return
			}
			//if not in room move to room
			let target = undefined;
			let towerPowerMatrix;
			if (squad.type === 'H' && !targetRoom){
					assignHarassTarget();
			}
			if (squad.type === 'edgeDrain'){
					if (members[0]){
							if (members[0].room.name === targetRoom && ((members[0].room.controller && members[0].room.controller.owner) || members[0].hits === members[0].hitsMax)){
									let originalTarget = targetRoom;
									squad.targetRoom = squad.secondaryRooms[0];
									squad.secondaryRooms = [originalTarget];
							}
					}
			}
			if ((squad.type == 'C' || squad.type == 'P') && Game.time % 20 === 0 && homeRoom && homeRoom.memory.armedHostiles){
					let hosList = homeRoom.hostileList;
					let goHome = false;
					for (let i in hosList){
							let hos = hosList[i];
							if (hos && hos.owner && hos.owner.username && hos.owner.username !== 'Invader'){
									let stats = hos.stats();
									if (stats.attack || stats.ranged_attack || stats.heal){
											goHome = true;
									}
							}
					}
					if (goHome){
							squad.type = 'D';
							squad.targetRoom = homeRoom.name;
					}
			}
			if (members[0]){
					new RoomVisual(members[0].room.name).text(squad.type, members[0].pos);
			}
			if (Game.time % 25 === 0){
					let nukes = members[0].room.find(FIND_NUKES);
					let nextLanding;
					for (let i in nukes){
							let nuke = nukes[i];
							if (nuke && (!nextLanding || nuke.timeToLand < nextLanding)){
									nextLanding = nuke.timeToLand;
							}
					}
					if (nextLanding){
							squad.nukeLandingTime  = Game.time + nextLanding;
					}
			}
			if (squad.nukeLandingTime && squad.nukeLandingTime > Game.time &&
					squad.nukeLandingTime-Game.time < 100){
					runLineSquad(members, undefined, squad.homeRoom, squad);
					return
			} else if (squad.nukeLandingTime && squad.nukeLandingTime > Game.time){
					members[0].say(squad.nukeLandingTime-Game.time);
			}
			if (members[0] && members[0].room.name !== targetRoom){
					if (members[0].room.memory.hostiles && Game.getObjectById(members[0].room.memory.hostiles) &&
							squad.type == 'G' && homeRoom.memory.remoteRooms[members[0].room.name]){
							squad.targetRoom = members[0].room.name;
							target = Game.getObjectById(members[0].room.memory.hostiles);
							if (target && members[0].pos.onEdge()){
									members[0].move(members[0].pos.getDirectionTo(target));
							}
					}
					let room = members[0].room;
					if (squad.type == 'D' && (!squad.noDiversion || (squad.secondaryRooms && squad.secondaryRooms.includes(room.name)))
							&& room && (!room.controller || !room.controller.owner || room.controller.my) && room.memory.hostiles && room.hostileList){
							for (let h in room.hostileList){
									let hos = room.hostileList[h];
									if (hos && hos.body.length > 15 && hos.owner && hos.owner.username && hos.owner.username.isEnemy){
											//divert defensive squad to attack the hostile in the same room
											if (!squad.secondaryRooms){
													squad.secondaryRooms = [];
											}
											squad.secondaryRooms.splice(0, 0, targetRoom);
											squad.targetRoom = room.name;
									}
							}
					}
					let leader = members[0];
					if (leader.memory.exit && leader.room.controller && leader.room.controller.owner && leader.room.controller.owner.username.isEnemy){
							target = findWallsInWay(leader,leader.memory.exit.toPos());
					}

					//console.log(members[0])
					if (room.memory.hostiles){
							for (let i in members){
									engage(members[i],undefined,members,undefined,false);
							}
					}
			} else {
					if (homeRoom && members[0].room.controller && members[0].room.controller.safeMode && !members[0].room.controller.my){
							if (!homeRoom.memory.siegeBlock){
									homeRoom.memory.siegeBlock = {};
							}
							homeRoom.memory.siegeBlock[targetRoom] = Game.time + members[0].room.controller.safeMode;
					}
					let needPowerMatrix,towersDown;
					if (room && (((!room.controller && squad.type == 'C' && room.findStructures('invaderCore').length > 0) || (room.controller && room.controller.owner && !room.controller.my)))){
							let towers = room.find(FIND_HOSTILE_STRUCTURES, {filter: (s) => s.structureType == STRUCTURE_TOWER});
							let energy = false;
							if (towers && towers.length > 0){
									for (let i in towers){
											if (towers[i].store['energy'] >= 10){
													energy = true;
													needPowerMatrix = true;
													break
											}
									}
							} else {
									towersDown = true;
									room.towersDown = true;
							}
							if ((!energy || (room.controller && room.controller.owner && config.botIsDead && config.botIsDead.includes(room.controller.owner.username)))
									&& !room.memory.hostiles){
									//no energy in towers and no hostiles
									needPowerMatrix = false;
									towersDown = true;
									room.towersDown = true;
							}
					}
					let healPower = 0,toughPower = 0;
					if (needPowerMatrix){
							let matrix = room.getTowerPowerMatrix();
							if (matrix){
									towerPowerMatrix = matrix;
							}
							for (let i in members){
									let member = members[i];
									if (member && member.id){
											let heal = 0;
											if (member.stats().heal && member.stats().heal > 0){
													heal = Number.parseInt(member.stats().heal);
											}
											if (member.stats().toughPower && !toughPower){
													toughPower = member.stats().toughPower;
											}
											healPower += heal;
									}
							}
					}
					if (target == undefined){
							target = findTarget(members[0].pos, squad, healPower,toughPower, needPowerMatrix);
							if (target && !members[0].pos.isNearTo(target) && (members.length !== 4) && squad.type !== 'C' && squad.type !== 'P' &&
									(!target.room.controller || !target.room.controller.isWhiteListed)){
									target = findWallsInWay(members[0], target);
							}
					}
					if (squad.type === 'SKE' && members[0] && members[0].hits < members[0].hitsMax){
							for (let i in members){
									engage(members[i], undefined, members);
							}
					}
					if (target == undefined && members[0] && (squad.type == 'DC' || squad.type == 'SKE')){
							if (!target && members[0].room.memory.lair){
									target = Game.getObjectById(members[0].room.memory.lair);
									let site;
									if (target && room.memory.sites){
											site = target.pos.lookAround(LOOK_CONSTRUCTION_SITES,8)[0];
									}
									if (site); else if (squad.type === 'SKE' && members[0].pos.getRangeTo(target) < 8){
											target = undefined;
											members[0].say('1',true);
											return
									}
							}
					} else if (squad.type === 'SKE' && members[0]){
							if (target.ticksToLive > 1485 && !target.pos.inRangeTo(members[0].pos,2) && !target.pos.lookAround(LOOK_STRUCTURES,0,{filter:(s)=>s.structureType === 'container'})[0]){
									target = undefined;
									members[0].say('2',true);
									return
							}
					}
					if (target === undefined && members[0].hits < members[0].hitsMax*0.85 &&(!room.controller || !room.controller.owner) && squad.type === 'edgeDrain'){
							target = new RoomPosition(25,25,targetRoom);
							for (let i in members){
									members[i].moveTo(target,{range:20});
							}
					} else if (target === undefined && squad.type === 'edgeDrain' &&
							(members[0].room.name === targetRoom ||
									(members[0].pos.onEdge() && members[0].pos.oppositeEdge().roomName === targetRoom))){
							for (let i in members){
									engage(members[i],undefined,members,'edgeDrain');
							}
							return
					}
					if (squad.type == 'DC'){
							let creep = members[0];
							if (config.mapVisual){
									Game.map.visual.text('DC', creep.pos);
							}
							console.log('DC',creep.pos.hyperlink);
							homeRoom.sendCoreHauler(targetRoom);
					}
					let rampsUpCa = false;
					if (squad.type === 'Ca' || squad.type === 'L' || squad.type === 'R'){
							if (Game.rooms[targetRoom] && isTolerated(Game.rooms[targetRoom])){
									squad.type = 'G';
									squad.targetRoom = squad.homeRoom;
									return
							}
							//no hostiles or towers - request wall killers
							let ramps = Game.rooms[targetRoom].find(FIND_STRUCTURES,{filter:(s)=>s.structureType === STRUCTURE_RAMPART && !s.my});
							if (ramps && ramps[0]){
									if (!target){
											target = ramps[0];
									}
									rampsUpCa = true;
							} else if (!Game.rooms[targetRoom].controller || !Game.rooms[targetRoom].controller.my){
									let walls = Game.rooms[targetRoom].find(FIND_STRUCTURES,{filter:(s)=>s.structureType === STRUCTURE_WALL});
									if (walls && walls[0]){
											if (!target){
													target = walls[0];
											}
											rampsUpCa = true;
									}
							}
					}
					if (homeRoom && squad.type !== 'W' && (towersDown || (!Game.rooms[targetRoom].memory.hostiles && !towerPowerMatrix)) && rampsUpCa && Game.rooms[targetRoom] && !Game.rooms[targetRoom].memory.armedHostiles
							&& (!Game.rooms[targetRoom].controller || !Game.rooms[targetRoom].controller.my)){
							requestSquad(homeRoom,targetRoom,{dozers:1,medics:0,type:'W',numberOfSquads:3});
							members[0].room.display('request W squad');
					}
					if (squad.type === 'D' && Memory.combatLog && Memory.combatLog[targetRoom] && Memory.combatLog[targetRoom].secondary && members[0].room.name === targetRoom){
							if (members[0].room.memory.hostiles){
									squad.hostilesSeen = true;
							}
							if (members[0].ticksToLive < 10 && !squad.hostilesSeen){
									//don't keep blocking this room
									Memory.combatLog[targetRoom].delete = true;
							}
					}
					try {
							if (squad.type === 'Ca' && Memory.contestedTerritory && Memory.contestedTerritory[members[0].room.name]){
									if (towersDown && Memory.combatLog[members[0].room.name] && Memory.combatLog[members[0].room.name].squadLog &&
											Memory.combatLog[members[0].room.name].squadLog.length > 10 && Game.rooms[targetRoom].memory.hostiles){
											//looks like they are reinforcing the room -> block it
											Memory.combatLog[members[0].room.name].reinforcing = Game.time + 5000;
									}
							}
					} catch (err){
							console.log(err);
					}
					if ((squad.type == 'D' || squad.type == 'G') && members[0].hits < members[0].hitsMax * 0.5 && homeRoom && members[0].room.name == homeRoom.name){
							homeRoom.memory.defenceSquadBlock = Game.time + 1000;
					}
					if (squad.type == 'P' && members[0] && homeRoom){
							let creep = members[0];
							if (config.mapVisual){
									Game.map.visual.text('\u{1F6D1}', creep.pos);
							}
							let PB;
							if (!squad.PB){
									PB = creep.room.find(FIND_STRUCTURES, {filter: (s) => s.structureType == STRUCTURE_POWER_BANK})[0];
									if (PB){
											squad.PB = PB.id;
									}
							} else {
									PB = Game.getObjectById(squad.PB);
							}
							if (PB){
									if (creep.hits > 700 || (config.season && config.season === 'power')){
											target = PB;
									}
									if (members[0].room.memory.hostiles){
											let nearest = members[0].pos.findClosestByRange(FIND_HOSTILE_CREEPS, squadDict['P'].hFilter);
											if (nearest && nearest.pos.getRangeTo(PB) < 15){
													target = nearest;
											}
									}
									if ((!squad.holdRequests || squad.holdRequests < Game.time) && squad.homeShard === Game.shard.name &&(creep.ticksToLive < 10 || (squad.nextWaveTime && Game.time > squad.nextWaveTime))){
											let ret = reRequest(homeRoom, squad);
											members[0].say('request');
											members[0].room.display('rerequest',squad.id);
											if (ret === -6 || ret === -8){
													//either can't afford or there is already a squad requested -> delay further requests
													squad.holdRequests = Game.time+100;
											}
									}
									if (members[0].room.memory.armedHostiles){
											saveConflictStatus(members[0].room);
									}
									let PMFlagNeeded = false;
									if (!squad.timeToArrival && squad.timeRequested){
											squad.timeToArrival = Game.time-squad.timeRequested;
									}
									if (squad.timeToArrival){
											if (squad.PBLastHits){
													let hitsPerTick = squad.PBLastHits - PB.hits;
													let ticksToKill = PB.hits / hitsPerTick;
													if (members[0].ticksToLive > ticksToKill && squad.timeToArrival + 100 > ticksToKill){
															PMFlagNeeded = true;
													}
											}
											squad.PBLastHits = PB.hits;
									}
									if (PMFlagNeeded || (PB.hits < 50000 && !Game.flags['PM' + homeRoom.name])){
											creep.pos.createFlag('PM' + homeRoom.name);
									}
									if (PB.hits < 10000){
											if (Memory.powerBanks[PB.id] && !Memory.powerBanks[PB.id].complete){
													Memory.powerBanks[PB.id].complete = "https://screeps.com/a/#!/history/" + Game.shard.name + "/" + PB.room.name + "?t=" + Game.time;
											}
									}
							} else if (creep.room.name === targetRoom && !creep.room.memory.armedHostiles){
									creep.suicide();
							}
					}
					if (squad.type == 'C' && homeRoom){
							//console.log('removing core: ',targetRoom,squad.boosted)
							if (target == undefined){
									target = members[0].pos.findClosestByRange(FIND_HOSTILE_STRUCTURES, {
											filter: (s) => s.structureType == STRUCTURE_RAMPART
													&& s.pos.lookAround(LOOK_STRUCTURES, 0, {filter: (s) => s.structureType == STRUCTURE_CONTAINER})
									});
							}
					}
					//destroy any structs under targetflag
					if ((target == undefined || squad.type === 'W' || members[0].role === 'dozer') && (squad.type == 'R' || squad.type === 'Ca' || squad.type == 'L' || squad.type === 'W')){
							let flags = members[0].room.find(FIND_FLAGS, {filter: (f) => f.name != squad.flag || squad.type  ==='W'});
							if ((!members[0].room.controller || !members[0].room.controller.my) && flags && flags.length > 0){
									for (let i in flags){
											let flag = flags[i];
											let obj = flag.pos.lookAround(LOOK_STRUCTURES, 0, {filter: (s) => s.structureType != STRUCTURE_CONTROLLER && s.structureType != STRUCTURE_POWER_BANK && !s.my})[0];
											let myCreeps = flag.pos.lookAround(LOOK_CREEPS,1,{filter:(c)=>c.my});
											if (obj && (members[0].pos.isNearTo(flag.pos) || (myCreeps && myCreeps.length < 3))){
													target = obj;
											}
									}
							}
					}
					//sign controller
					if (!target && squad.type !== 'D' && squad.type !== 'G' && (!towerPowerMatrix || members[0].pos.onEdge() || members[0].pos.nearEdge()) && squad.type != 'C' && members[0].room && members[0].room.name === targetRoom && members[0].room.controller && !members[0].room.controller.my
							&& (!members[0].room.controller.sign || (members[0].room.controller.sign.username != Game.username && members[0].room.controller.sign.username != 'Screeps'))){
							target = members[0].room.controller;
					}
					if (squad.type === 'H' && Game.rooms[targetRoom].armedHostileList){
							let power = Game.rooms[targetRoom].assessTotalHostileCreepPower();
							if (power > (members[0].stats().attack+members[0].stats().ranged_attack)){
									assignHarassTarget(true);
									return
							}
					}
					if (squad.type === 'H' && target && members[0].room.controller && members[0].room.controller.reservation && config.allies &&
							config.allies.includes(members[0].room.controller.reservation)){
							target = undefined;
							delete creep.home.memory.hostileRemotes[members[0].room.name];
							assignHarassTarget();
					}
					if (!target && squad.type === 'H' && !squad.secondaryRooms){
							if (!config.autoHarassEnemies || !homeRoom.memory.hostileRemotes){
									squad.type = 'G';
									return
							}
							assignHarassTarget();
					}
					//remove siege flag if there is a no targets left
					if ((squad.type === 'L' || squad.type === 'R') && !towerPowerMatrix){
							//why isnt this working?
							if (squad.flag && !target && Game.flags[squad.flag]){
									Game.flags[squad.flag].remove();
							}
					}
					if ((squad.type === 'Ca' || squad.type === 'R') && targetRoom && Game.rooms[targetRoom] &&
							Game.rooms[targetRoom].controller && !Game.rooms[targetRoom].controller.owner){
							if (squad.flag && !target && Game.flags[squad.flag]){
									Game.flags[squad.flag].remove();
							}
					}
					if (members[0].hits < members[0].hitsMax * 0.4 && squad.type == 'G' && !squad.boosted && homeRoom.canBoost(['ZH', 'LO', 'UH', 'KO', 'ZO'])){
							requestSquad(homeRoom, targetRoom, {
									type: 'G',
									medics: squad.medics,
									snipers: squad.snipers,
									leaderRole: squad.leaderRole,
									boosted: 1
							});
					}
					if (!target && squad.type == 'SKM'){
							if (members[0].room.name === targetRoom){
									let mineral = members[0].room.mineral;
									let hostile = mineral.pos.lookAround(LOOK_CREEPS, 6, {filter: (c) => !c.my && !c.isWhiteListed})[0];
									if (hostile){
											target = hostile;
									}
									if (!hostile){
											if (members[0].room && members[0].room.cache && !members[0].room.cache.SKMSquadPos &&
													Game.map.getSKMatrix(members[0].room.name)){
													let neighbours = mineral.pos.neighbours(6);
													let SKMatrix = Game.map.getSKMatrix(members[0].room.name);
													if (SKMatrix){
															for (let i in neighbours){
																	let neighbour = neighbours[i];
																	if (neighbour && neighbour.getTerrain() != 'wall' && !neighbour.onEdge() && !neighbour.nearEdge() && members[0].room.cache && SKMatrix.get(neighbour.x, neighbour.y) < 20){
																			members[0].room.cache.SKMSquadPos = neighbour.toString();
																			break
																	}
															}
													}
											} else if (members[0] && members[1] && (members[0].hits < (members[0].hitsMax * 0.8) || members[1].hits < (members[1].hitsMax - 100))){
													engage(members[1],undefined,members);
											} else if (members[0] && (members[0].hits < members[0].hitsMax)){
													engage(members[0],undefined,members);
											} else if (members[0].room.cache && members[0].room.cache.SKMSquadPos && members[0].room.cache.SKMSquadPos.toPos()){
													members[0].room.cache.SKMSquadPos.toPos().highlight();
													let spot = members[0].room.cache.SKMSquadPos.toPos();
													for (let i in members){
															members[i].moveTo(spot, {range: 1});
													}
													for (let i in members){
															engage(members[i], undefined, members);
													}
													return
											}
									}
							}
					}
					if (!target && squad.type == 'G'){
							if (homeRoom.memory.remoteRooms){
									if (members[0].room.name && homeRoom.memory.remoteRooms[members[0].room.name]){
											homeRoom.memory.remoteRooms[members[0].room.name].guardNeeded = false;
									}
									let found = false;
									for (let i in homeRoom.memory.remoteRooms){
											if (homeRoom.memory.remoteRooms[i].guardNeeded &&
													(!homeRoom.memory.remoteRooms[i].blockGuardSquad || Game.time > homeRoom.memory.remoteRooms[i].blockGuardSquad)){
													delete homeRoom.memory.remoteRooms[i].blockGuardSquad;
													squad.targetRoom = i;
													found = true;
													break
											}
									}
									if (!found && homeRoom.total('energy') > homeRoom.memory.reserve*1.1 && homeRoom.memory.hostileRemotes &&
											(!playerHeap.squadManager.harassSquadList[homeRoom.name] || !Memory.squads[playerHeap.squadManager.harassSquadList[homeRoom.name]])){
											//check there isnt already a squad out harassing
											assignHarassTarget(true);
									}
							}
					}
					if (squad.type == 'P' && members.length < 3){
							let attacker = false;
							for (let m in members){
									if (members[m].role == 'attacker'){
											attacker = true;
									}
							}
							if (!attacker){
									for (let m in members){
											members[m].suicide();
									}
							}
					}
					if (!target && (squad.type === 'D' || squad.type === 'chase')  && !squad.secondaryRooms && Memory.combatLog && Memory.combatLog[targetRoom] && Memory.combatLog[targetRoom].lastHostilePosition){
							let lastPos = Memory.combatLog[targetRoom].lastHostilePosition.toPos();
							if (Game.flags['defendPoint'+members[0].room.name] && Game.flags['defendPoint'+members[0].room.name].pos && Game.flags['defendPoint'+members[0].room.name].pos.roomName === members[0].room.name){
									lastPos = Game.flags['defendPoint'+members[0].room.name].pos;
							}
							if (lastPos && members[0].pos.getRangeTo(lastPos) > 2){
									lastPos.highlight();
									target = lastPos;
							} else {
									let allHealed = true;
									if (!members[0].room.memory.armedHostiles){
											for (let i in members){
													if (members[i].hits !== members[i].hitsMax){
															allHealed = false;
													}
											}
									}
									if (allHealed){
											//no target and no healing needed - return to save cpu
											return
									}
							}
					}
					if (!target && !needPowerMatrix && squad.type !== 'Co' && squad.type !== 'H' && squad.type != 'G' && squad.type != 'Ca' && (squad.type != 'D' || (homeRoom && targetRoom == homeRoom.name))){
							squad.idle = true;
							if (squad.type === 'C'){
									if (members[0].pos.onEdge() || members[0].pos.nearEdge()){
											target = members[0].room.controller;
									} else if (room.controller){
											return
									} else {
											squad.type = 'DC';
									}
							}
							if (squad.members.length < 2 && squad.type !== 'E' && squad.medics > 1){
									for (let m in members){
											members[m].suicide();
									}
							}
					} else if (squad.type != 'Ca'){
							delete squad.idle;
					}
					members[0].room.display(`squad ${squad.id} ${target}`);
					if ((!target || (members[0].room.controller && members[0].room.controller.safeMode)) && (squad.type === 'D' || squad.type === 'H' || squad.type === 'R') && Game.time % 5 === 0
							&& members[0].room.name === targetRoom && squad.secondaryRooms){
							for (let r in squad.secondaryRooms){
									let roomName = squad.secondaryRooms[r];
									if (roomName && roomName != targetRoom){
											if (!members[0].room.controller || !members[0].room.controller.safeMode){
													squad.secondaryRooms.push(targetRoom);
											}
											squad.targetRoom = roomName;
											squad.secondaryRooms.splice(r, 1);
											break
									}
							}
					}
					if (target && members[0]){
							new RoomVisual(members[0].room.name).line(members[0].pos, target.pos, {color: 'red'});
					}
			}
			if (members){
					for (let i in members){
							let member = members[i];
							if (member.attackTarget && member.attackTarget.body){
									let attackPower = member.attackTarget.stats().attack;
									let cancelled = false;
									if (attackPower > 200){
											if (member.nextHits <= member.hitsMax){
													//avoid attacking if risk of hit back and not being healed
													member.cancelOrder('attack');
													console.log(member,'cancel attack on',member.attackTarget,member.pos.hyperlink);
													cancelled = true;
											}
									}
									if (!cancelled){
											member.guessNextHits(attackPower);
									}
							}
					}
			}
			function assignHarassTarget(flee){
					if (!homeRoom.memory.hostileRemotes){
							return
					}
					squad.type = 'H';
					let hostileRemotes = Object.keys(homeRoom.memory.hostileRemotes);
					if (hostileRemotes){
							let remotes = [];
							for (let i in hostileRemotes){
									if (Memory.dangerRooms && Memory.dangerRooms[hostileRemotes[i]] && Memory.dangerRooms[hostileRemotes[i]].expiry > Game.time ){
											continue
									}
									let start = targetRoom;
									if (!start){
											start = homeRoom.name;
									}
									let distance = Game.map.getRoomLinearDistance(start, hostileRemotes[i]);
									if (flee && distance < 3){
											continue
									}
									if (distance <= 10){
											let val = 11 - distance;
											while (val > 0){
													remotes.push(hostileRemotes[i]);
													val--;
											}
									}
							}
							console.log('assign remote for harass squad');
							let random = Math.floor(Math.random() * remotes.length);
							console.log('assign remote for harass squad',remotes[random]);
							squad.targetRoom = remotes[random];
					}
			}
			if (squad.flag && Game.flags[squad.flag] && Game.flags[squad.flag].room && (squad.type == 'T' || !target) && !Game.flags[squad.flag].pos.lookFor(LOOK_STRUCTURES)[0]){
					target = Game.flags[squad.flag];
			}
			if (squad.id && playerHeap.squadManager.targets[squad.id] && playerHeap.squadManager.targets[squad.id].expiry > Game.time && Game.getObjectById(playerHeap.squadManager.targets[squad.id].id)){
					target = Game.getObjectById(playerHeap.squadManager.targets[squad.id].id);
			}
			if (target && target.id && (!playerHeap.squadManager.targets[squad.id] || playerHeap.squadManager.targets[squad.id].expiry < Game.time)){
					playerHeap.squadManager.targets[squad.id] =
							{
									id: target.id,
									expiry: Game.time + 20
							};
			}
			let rangedSquad = false;
			if (members[0].role !== 'attacker' && members[0].role !== 'dozer'){
					rangedSquad = true;
			}
			if (squad.type === 'C' && Game.rooms[targetRoom]){
					let core = Game.rooms[targetRoom].find(FIND_STRUCTURES,{filter:(s)=>s.structureType === STRUCTURE_INVADER_CORE})[0];
					if (!core){
							rangedSquad = false;
					}
					if (core && core.level === 4){
							let towers = Game.rooms[targetRoom].find(FIND_STRUCTURES,{filter:(s)=>s.structureType === STRUCTURE_TOWER});
							if (!towers){
									rangedSquad = false;
							}
					}
			}
			if (squad.type === 'Cl' && members[0] && members[0].room.name=== targetRoom && members[0].room.controller && !members[0].room.controller.upgradeBlocked){
					target = members[0].room.controller;
					if (members[0].pos.isNearTo(target)){
							members[0].attackController(target);
					}
			}
			let lineFlag;
			if (Game.flags['line'] && Game.flags['line'].pos.roomName === targetRoom){
					lineFlag = true;
			}
			if (members.length >= 4 && !lineFlag){
					//todo getting stuck on edge if no target
					let extraMembers = members.slice(4);
					let firstMembers = members.slice(0,4);
					let f = getFormation(squad, firstMembers,extraMembers);
					let hosWeak = false;
					let healPower = 0;
					for (let i in firstMembers){
							let member = members[i];
							if (member && member.id){
									let heal = 0;
									if (member.stats().heal && member.stats().heal > 0){
											heal = Number.parseInt(member.stats().heal);
									}
									healPower += heal;
							}
					}
					if (Game.rooms[targetRoom] && ((Game.rooms[targetRoom].controller && Game.rooms[targetRoom].controller.my) || !towerPowerMatrix) && healPower){
							let totalDamage = 0;
							for (let i in Game.rooms[targetRoom].hostileList){
									let hostile = Game.rooms[targetRoom].hostileList[i];
									if (hostile){
											let stats = hostile.stats();
											if (stats.attack){
													totalDamage += Number.parseInt(stats.attack);
											}
											if (stats.ranged_attack){
													totalDamage += Number.parseInt(stats.ranged_attack);
											}
											if (totalDamage > healPower / 2){
													break
											}
									}
							}
							if (totalDamage <= healPower / 4 || (Game.rooms[targetRoom].findStructures('tower').length === 0 &&
									(Game.rooms[targetRoom].armedHostileList.length === 0 || totalDamage <= healPower / 2 || Game.rooms[targetRoom].armedHostileList.length < 3))){
									hosWeak = true;
							}
					}
					let retreatPos;
					if (targetRoom === members[0].pos.roomName && !members[0].pos.onEdge() && !members[0].pos.nearEdge()){
							//todo improve how you find retreat point
							if (squad.retreatPos){
									retreatPos = squad.retreatPos.toPos();
							}
							if (!retreatPos || (retreatPos && retreatPos.roomName != targetRoom)){
									squad.retreatPos = members[0].pos.toString();
							}
							if (Game.flags['rally' + members[0].pos.roomName] && Game.flags['rally' + members[0].pos.roomName].pos){
									squad.retreatPos = Game.flags['rally' + members[0].pos.roomName].pos.toString();
							}
					}
					let retreatNeeded = checkForRetreat(squad, firstMembers, targetRoom);
					//work out the closest hostile distance to determine if retreat indicated
					let nearestHostileDistance = 25;
					if (currentRoom.armedHostileList.length > 0 && rangedSquad && (squad.type === 'Ca' || squad.type === 'R' || squad.type === 'L' || squad.type === 'C') && f && f.quadPosition){
							for (let a in currentRoom.armedHostileList){
									let range = f.quadPosition.getQuadRangeTo(currentRoom.armedHostileList[a].pos);
									if (range < nearestHostileDistance){
											nearestHostileDistance = range;
									}
							}
					}
					//retreat if ranged squad and tooClose to a hostile
					if ((nearestHostileDistance < 3 && squad.type !== 'C') || nearestHostileDistance === 1){
							retreatNeeded = true;
					}
					if (squad.noRetreat){
							retreatNeeded = false;
					}
					let retreatLocations = [];
					if (retreatNeeded && squad.type !== 'P'){
							members[0].say('scree!', {public: true});
							if (retreatPos){
									retreatLocations.push(retreatPos);
							}
					}
					if (retreatPos){
							retreatPos.highlight();
					}
					if (squad.flag && Game.flags[squad.flag] && members.length >= 4 && !target){
							target = Game.flags[squad.flag];
					}
					currentRoom.display(`target  ${target}`);
					if ((!target || target.structureType === 'road') && members[0].role === 'medic' && !retreatNeeded&& Game.flags['drainflag'] && Game.flags['drainflag'].pos.roomName && Game.flags['drainflag'].pos.roomName === targetRoom){
							target = Game.flags['drainflag'];
					}
					if ((target || (!target && members.length >= 4)) && retreatNeeded && retreatLocations.length > 0 && squad.type !== 'P'){
							for (let i in members){
									if (members[i].pos){
											engage(members[i], target, members, squad.type,undefined,f);
									}
							}
							f.qMove(retreatLocations[0],{noTurn:true},squad);
					} else if (!target || targetRoom != members[0].room.name){
							if (Game.flags['rally'+targetRoom] && Game.flags['rally'+targetRoom].pos &&
									Game.flags['rally'+targetRoom].pos.roomName === targetRoom){
									target = Game.flags['rally'+targetRoom];
							} else if (!target && members[0].room.name === targetRoom && members[0].room.controller && (members[0].pos.getRangeTo(members[0].room.controller.pos)>5)){
									target = members[0].room.controller;
							} else {
									target = undefined;
							}
							let allHealed = true;
							for (let i in members){
									if (members[i].hits < members[i].hitsMax*0.9){
											allHealed = false;
											break
									}
							}
							if (!allHealed){
									for (let i in members){
											engage(members[i], undefined, members, squad.type,undefined,f);
									}
							}
							if (squad.type === 'Ca' && retreatPos){
									target = retreatPos;
							}
							if (squad.entryRoom && members[0].room.name !== squad.entryRoom){
									console.log('squad going to entry room',squad.entryRoom);
									targetRoom = squad.entryRoom;
							}
							runLineSquad(members, target, targetRoom, squad);
					} else if ((hosWeak || !members[0].room.memory.armedHostiles) && (!members[0].room.controller || !members[0].room.controller.my || !members[0].room.controller.owner) && squad.type !== 'T' && !towerPowerMatrix
							&& (!members[0].room.controller || !members[0].room.controller.isWhiteListed) && (squad.type !== 'C' || !towerPowerMatrix)){
							target = findWallsInWay(members[0], target);
							runLineSquad(members, target, targetRoom, squad);
					} else if (rangedSquad && members[0].pos.getRangeTo(target) < 4 && !target.structureType){
							for (let i in members){
									if (members[i].pos){
											engage(members[i], target, members, squad.type,undefined,f);
									}
							}
					} else if (target && target.pos && !target.pos.onEdge()){
							let noTurn,fixTurn,avoidRamps,freeze;
							if (target && members[0]){
									let range = members[0].pos.getRangeTo(target);
									if ((range>10 && !target.structureType) || range > 15){
											noTurn = true;
									} else if (range < 3){
											fixTurn = members[0].pos.getDirectionTo(target);
											for (let i in extraMembers){
															if (extraMembers[i].role === 'attacker'){
																	extraMembers[i].moveTo(target,{range:1});
															} else if (extraMembers[i].role === 'medic' && extraMembers[i-1] && extraMembers[i-1].role !== 'medic'){
																	if (extraMembers[i].pos.isNearTo(extraMembers[i-1])){
																			extraMembers[i].move(extraMembers[i].pos.getDirectionTo(extraMembers[i-1]));
																	} else {
																			extraMembers[i].moveTo(extraMembers[i-1],{range:1});
																	}
															}
													}
									}
							}
							if (nearestHostileDistance && nearestHostileDistance < 3 && squad.type !== 'C'){
									freeze = true;
									avoidRamps = true;
							} else if (nearestHostileDistance && nearestHostileDistance < 10){
									avoidRamps = true;
							}
							let targetList;
							if (squad.type === 'Ca' && false){
									targetList = Game.rooms[targetRoom].find(FIND_STRUCTURES,{filter:(s)=>s.structureType !== 'rampart' && s.owner && !s.my &&
													s.structureType !== 'controller' && s.structureType !== STRUCTURE_KEEPER_LAIR});
							}
							if (squad.type === 'C' && targetRoom && Game.rooms[targetRoom]){
									let core = Game.rooms[targetRoom].find(FIND_STRUCTURES,{filter:(s)=>s.structureType === STRUCTURE_INVADER_CORE})[0];
									let chosen,chosenX,chosenY;
									for (let i in members){
											if (!chosen || members[i].pos.x < chosenX || members[i].pos.y < chosenY){
													chosen = members[i];
													chosenX = members[i].pos.x;
													chosenY = members[i].pos.y;
											}
									}
									if (chosen){
											let dir = chosen.pos.getDirectionTo(core);
											fixTurn = dir;
									}
							}
							let q;
							if (targetList && targetList.length > 0){
									q = f.qMove(targetList,{rangedSquad:rangedSquad,noTurn:noTurn,fixTurn:fixTurn,avoidRamps:avoidRamps,freeze:freeze},squad);
							} else {
									q = f.qMove(target,{rangedSquad:rangedSquad,noTurn:noTurn,fixTurn:fixTurn,avoidRamps:avoidRamps,freeze:freeze},squad);
							}
							console.log('q',q,targetRoom,target);
							let dict = squadDict[squad.type];
							if (q !== 0 && q && !q.id && !target.structureType && dict && dict.hostiles && dict.hFilter){
									let hostiles = members[0].room.find(FIND_HOSTILE_CREEPS, dict.hFilter).sort((a, b) => a.pos.getRangeTo(members[0]) - b.pos.getRangeTo(members[0]));
									let count = 0;
									let hostile;
									if (hostiles.length > 0){
											hostile = hostiles[0];
											if (!squad.fixedTarget || Game.time % 5 == 0){
													squad.fixedTarget = hostiles[0].id;
											} else {
													hostile = Game.getObjectById(squad.fixedTarget);
													if (!hostile){
															hostile = hostiles[0];
													}
											}
									}
									while (!q && count < 7){
											count++;
											q = f.qMove(hostile,undefined,squad);
											if (q === 0){
													target = hostile;
											}
									}
							}
							if ((q !== 0 && q && !q.id) || members[0].pos.onEdge() || q===-2){
									if ((!members[0].room.controller || (members[0].room.controller.owner && !members[0].room.controller.isWhiteListed)) && squad.type !== 'C'){
											target = findWallsInWay(members[0], target);
									}
									runLineSquad(members, target, targetRoom, squad);
							}
							let rangeToTarget;
							if ((squad.type === 'C' || squad.type === 'T' ||  squad.type === 'R')&& f && f.quadPosition){
									rangeToTarget = f.quadPosition.getQuadRangeTo(target);
									console.log('quad range to target',rangeToTarget,targetRoom);
							}
							for (let i in members){
									if (members[i].pos){
											if (q && q.id && (!rangeToTarget || rangeToTarget > 3 || (!rangedSquad && rangeToTarget < 2))){
													target = q;
											}
											engage(members[i], target, members, squad.type,undefined,f);
									}
							}
					}
			} else {
					let cpu1 = Game.cpu.getUsed();
					if (squad.entryRoom && members[0].room.name !== targetRoom && members[0].room.name !== squad.entryRoom){
							targetRoom = squad.entryRoom;
					} else {
							targetRoom = squad.targetRoom;
					}
					runLineSquad(members, target, targetRoom, squad);
					let listTarget = target;
					if (!target && members[0] && members[0].room.name !== targetRoom){
							listTarget = targetRoom;
					}
					//console.log(`cpu movesquad: ${Game.cpu.getUsed()-cpu1}, target: ${listTarget}, ${members[0].pos.hyperlink}, size: ${members.length}`)
					members[0].room.display(`cpu movesquad: ${Game.cpu.getUsed()-cpu1}, target: ${listTarget}`);
			}
			function checkForRetreat(squad, members, targetRoom){
					let allHealed = true;
					for (let i in members){
							if (!members[i] || members[i].pos.roomName != targetRoom){
									continue
							}
							let cutOff = 0.85;
							if (targetRoom && Game.rooms[targetRoom] && (!Game.rooms[targetRoom].controller || !Game.rooms[targetRoom].controller.owner
									|| Game.rooms[targetRoom].controller.isWhiteListed)){
									cutOff = 0.5;
							}
							if (members[i].hits < members[i].hitsMax * cutOff){
									squad.retreat = true;
									return true
							} else if (members[i].hits < members[i].hitsMax * 0.95){
									allHealed = false;
							}
					}
					if (squad.retreat && !allHealed){
							return true
					}
					delete squad.retreat;
					return false
			}

			function alternate(arr, leaderRole){
					let newArr = [];
					let count = 0;
					if (arr.length === 1){
							return arr
					}
					let sortValues = {
							'attacker':1,
							'dozer':1,
							'sniper':2,
							'hybrid':2,
					};
					arr.sort((a, b) => {
							let valA = 1;
							let valB = 1;
							if (sortValues[a.role]){
									valA = sortValues[a.role];
							}
							if (sortValues[b.role]){
									valB = sortValues[b.role];
							}
							return valA - valB
					});
					while (arr.length > 0 && count < 20){
							count += 1;
							if (newArr.length == 0 && leaderRole){
									let creep = arr[arr.findIndex((c) => c && c.role === leaderRole)];
									if (!creep){
											creep = arr[arr.findIndex((c) => c && c.role !== 'medic' && c.role !== 'hybrid')];
									}
									if (creep){
											newArr.push(creep);
											arr.splice(arr.findIndex((c) => c && c.id === creep.id), 1);
									} else {
											newArr.push(arr[0]);
											arr.shift();
									}
							} else if (newArr.length == 0 || newArr[newArr.length - 1].role == 'medic'){
									let creep = arr[arr.findIndex((c) => c && c.role !== 'medic')];
									if (creep){
											newArr.push(creep);
											arr.splice(arr.findIndex((c) => c && c.id === creep.id), 1);
									} else {
											newArr.push(arr[0]);
											arr.shift();
									}
							} else {
									let creep = arr[arr.findIndex((c) => c && c.role === 'medic')];
									if (creep){
											newArr.push(creep);
											arr.splice(arr.findIndex((c) => c && c.id === creep.id), 1);
									} else {
											newArr.push(arr[0]);
											arr.shift();
									}
							}
					}
					return newArr
			}

			function findWallsInWay(creep, target){
					if ((creep.room.controller && creep.room.controller.my)|| (!creep.room.controller && Game.map.getRoomType(creep.room.name) === 'highway')){
							return target
					}
					if (!creep.room.memory.optimalWallMatrix || (creep.room.memory.optimalWallMatrixExp < Game.time)){
							let matrix = creep.room.wallMatrix();
							creep.room.memory.optimalWallMatrix = matrix.serialize();
							creep.room.memory.optimalWallMatrixExp = Game.time + 10;
					}
					if (!creep || creep.pos.isNearTo(target)){
							return target
					}
					var matrix = PathFinder.CostMatrix.deserialize(creep.room.memory.optimalWallMatrix);
					//finding a path through ramparts and walls to the target
					creep.room.findStructures('road',(s)=>s.pos.getTerrain() === 'wall' && s.pos.lookAround(LOOK_STRUCTURES,0,{filter:(s)=>s.owner}).length === 0);
					creep.room.find(FIND_MY_CREEPS);
					var path = PathFinder.search(creep.pos, target, {
							maxRooms: 1,
							swampCost:3,
							plainCost:1,
							roomCallback: function (){
									return matrix
							}
					}).path;
					new RoomVisual(creep.room.name).poly(path);
					if (path && path.length > 0){
							for (var p = 0; p < path.length; p++){
									var posStructures = path[p].lookFor(LOOK_STRUCTURES);
									if (posStructures.length > 0){
											for (var s in posStructures){
													if (posStructures[s].structureType == STRUCTURE_WALL || posStructures[s].structureType == STRUCTURE_RAMPART){
															return posStructures[s]
													}
											}
									}
							}
					}
					return target
			}
	}
	function checkCreepIsBoostedAsRequired(creep, boostLevel){
			if (creep.memory.boosted){
					return true
			}
			if (creep.spawning){
					return false
			}
			let boostsNeeded = config.boostLevels[boostLevel];
			let ret = true;
			for (let i in creep.body){
					let part = creep.body[i];
					if (!part.boost){
							let possibleBoosts = config.squadBoostTypes[part.type];
							if (possibleBoosts){
									for (let b in possibleBoosts){
											if (boostsNeeded.includes(possibleBoosts[b])){
													//this part does need boosting and is not boosted
													return false
											}
									}
							}
					}
			}
			creep.say('boosted',true);
			return ret
	}

	function boostsNeededByCreep(creep,boostLevel){
			if (!boostLevel || !config.boostLevels || !config.squadBoostTypes){
					console.log('broken boost picking');
					return
			}
			let boostsNeeded = config.boostLevels[boostLevel];
			let partTypes = config.squadBoostTypes;
			let ret = [];
			let done = {};
			for (let i in creep.body){
					let part = creep.body[i];
					if (part && part.type && partTypes[part.type] && !done[part.type]){
							for (let b in boostsNeeded){
									if (partTypes[part.type].includes(boostsNeeded[b])){
											ret.push(boostsNeeded[b]);
											done[part.type] = true;
									}
							}
					}
			}
			return ret
	}
	function reRequest(homeRoom, squad){
			return requestSquad(homeRoom, squad.targetRoom, {
					dozers: squad.dozers,
					attackers: squad.attackers,
					snipers: squad.snipers,
					medics: squad.medics,
					hybrids:squad.hybrids,
					boosted: squad.boosted,
					type: squad.type,
					flag: squad.flag,
					leaderRole: squad.leaderRole,
					secondaryRooms: squad.secondaryRooms,
					reRequest:true,
			})
	}

	function requestSquad(homeRoom, targetRoomName, options){
			//targetRoom is a room.name
			//reuse idle squads
			if (homeRoom.energyCapacityAvailable < 1000 && (Memory.myRooms.length > 1 && options.type && options.type !== 'D' && options.type !== 'G')){
					return
			}
			let cpu = Game.cpu.getUsed();
			if (!Memory.squads){
					Memory.squads = {};
			}
			if (!homeRoom || (homeRoom.memory.armedHostiles || homeRoom.memory.defcon < 5) && (!options || !options.type || options.type != 'D')){
					console.log('cant request squad while under siege', homeRoom.name);
					return
			}
			if (homeRoom.class === 'bunker' && (!options.type || options.type !== 'C')){
					console.log(`bunker room ${homeRoom.name} cannot make squad`);
					return
			}
			if (options.type === 'edgeDrainBlock' && Memory.edgeDrainBlock && Memory.edgeDrainBlock[targetRoomName] && Memory.edgeDrainBlock[targetRoomName]> Game.time){
					return
			}
			if (options.type === 'G' && homeRoom.memory.remoteRooms && homeRoom.memory.remoteRooms[targetRoomName] &&
					homeRoom.memory.remoteRooms[targetRoomName].blockGuardSquad && Game.time < homeRoom.memory.remoteRooms[targetRoomName].blockGuardSquad){
					console.log('guard squad blocked to',targetRoomName);
			} else if (homeRoom.memory.remoteRooms && homeRoom.memory.remoteRooms[targetRoomName] &&
					homeRoom.memory.remoteRooms[targetRoomName].blockGuardSquad && Game.time > homeRoom.memory.remoteRooms[targetRoomName].blockGuardSquad){
					delete homeRoom.memory.remoteRooms[targetRoomName].blockGuardSquad;
			}
			if (options.type && options.type !== 'D' && options.type !== 'Ca' && options.type !== 'G' && homeRoom.memory.faceClaimed){
					console.log('cant send face claimed',homeRoom);
					return
			}
			if (!homeRoom || !homeRoom.controller || typeof targetRoomName != 'string'){
					console.log('requestSquad input error', homeRoom, targetRoomName);
					return
			}
			let energyThreshold = 0.5;
			if (options.type && squadDict[options.type] && squadDict[options.type].energyThreshold){
					energyThreshold = squadDict[options.type].energyThreshold;
			}
			if (options && options.energyThreshold){
					energyThreshold = options.energyThreshold;
			}
			if (!homeRoom.memory.hostile && homeRoom.memory.reserve && homeRoom.total('energy') < homeRoom.memory.reserve * energyThreshold){
					console.log('eco not stable cannot request squad', homeRoom,'to',targetRoomName);
					return
			}
			if (options.type === 'Cl' && (!Game.rooms[targetRoomName] || !Game.rooms[targetRoomName].controller ||
					(Game.rooms[targetRoomName].controller.upgradeBlocked && Game.rooms[targetRoomName].controller.upgradeBlocked > 400))){
					return -4
			}
			// let currentSquads = Memory.squads
			// for (let i in currentSquads){
			// 		let cur = currentSquads[i]
			// 		if (cur.idle && cur.targetRoom !== targetRoomName && options && options.type == cur.type && (!options.boosted || cur.boosted === options.boosted)){
			// 				cur.targetRoom = targetRoomName
			// 				console.log('reassigning squad', cur.id, 'to', targetRoomName)
			// 				delete cur.idle
			// 				return
			// 		}
			// }
			if (options && options.idleOnly){
					return
			}
			try {
					if (options && options.startTime){
							let date = new Date();
							let startTime = new Date(options.startTime);
							if (date && startTime && date.getTime() > startTime.getTime()){
									return
							}
					}
			} catch (err){
					console.log(err);
			}
			/*
								{
												//options
												targetRoom:roomName,
												dozers:doz,
												attackers:att,
												snipers:snip,
												medics:medic,
												boosted:0||1||2||3,
												type: R/L/D,
												//live data
												members: [],
												state: spawning,
												nextWaveTime: time
								}
								*/
			let dozers, attackers, snipers, medics, hybrids,claimMedics, boosted, type, portalLandingRoom,numberOfSquads, flag, shard, secondaryRooms,leaderRole,entryRoom;
			options && options.attackers ? attackers = options.attackers : attackers = 0;
			options && options.dozers ? dozers = options.dozers : dozers = 0;
			options && options.snipers ? snipers = options.snipers : snipers = 0;
			options && options.hybrids ? hybrids = options.hybrids : hybrids = 0;
			options && options.claimMedics ? claimMedics = options.claimMedics : claimMedics = 0;
			options && options.medics != undefined ? medics = options.medics : medics = attackers + dozers + snipers;
			options && options.boosted ? boosted = options.boosted : boosted = 0;
			options && options.flag ? flag = options.flag : flag = undefined;
			options && options.leaderRole ? leaderRole = options.leaderRole : leaderRole = undefined;
			options && options.shard ? shard = options.shard : shard = Game.shard.name;
			options && options.secondaryRooms ? secondaryRooms = options.secondaryRooms : secondaryRooms = undefined;
			options && options.entryRoom ? entryRoom = options.entryRoom : entryRoom = undefined;
			options && options.portalLandingRoom ? portalLandingRoom = options.portalLandingRoom : portalLandingRoom = undefined;
			let originalTargetRoom;
			let noDiversion = false;
			if (options && options.noDiversion){
					noDiversion = options.noDiversion;
			}
			if (secondaryRooms){
					originalTargetRoom = targetRoomName;
			}
			if (options && options.type){
					type = options.type;
			} else {
					console.log('squad has no type', homeRoom, targetRoomName);
					return -10
			}
			if (type === 'Bow'){
					medics = 1;
					hybrids = 2;
			}
			if (attackers + dozers + snipers + medics + hybrids == 0){
					attackers = 1;
					medics = 1;
			}
			if (options && !options.boosted && options.level){
					boosted = options.level;
			}

			if ((type === 'P' || type === 'C') && checkBlockLowPrioritySquads()){
					console.log('blocking low prio squads');
					return
			}
			if (type == 'P' && powerSquadCap && powerSquadsCount && powerSquadsCount >= powerSquadCap){
					console.log('current power squads over cap:', powerSquadCap, 'squadCount:', powerSquadsCount);
					return
			}
			if (type === 'P' && playerHeap.squadManager.powerSquadRoomCount && playerHeap.squadManager.powerSquadRoomCount[homeRoom.name] && (!options || !options.reRequest) && playerHeap.squadManager.powerSquadRoomCount[homeRoom.name] > powerSquadRoomCap){
					console.log('current power squads over room cap:', powerSquadRoomCap, 'squadCount:', playerHeap.squadManager.powerSquadRoomCount[homeRoom.name]);
					return
			}
			if (type === 'Ca' && homeRoom.memory.siegeBlock[targetRoomName] && homeRoom.memory.siegeBlock[targetRoomName]> Game.time){
					return
			}
			if (homeRoom.memory.defenceSquadBlock && homeRoom.memory.defenceSquadBlock > Game.time){
					console.log('squad blocked, inadequate defence');
					return
			}
			if (options.type == 'D' && targetRoomName && Game.rooms[targetRoomName] && Game.rooms[targetRoomName].controller
					&& Game.rooms[targetRoomName].controller.safeMode && Game.rooms[targetRoomName].controller.safeMode > 500){
					return
			}
			options && options.numberOfSquads ? numberOfSquads = options.numberOfSquads : options && options.count ? numberOfSquads = options.count : numberOfSquads = 1;
			let escortId;
			if (options && options.escortId){
					escortId = options.escortId;
			}
			let interval;
			if (options && options.interval){
					interval = options.interval;
					if (Memory.squadIntervals && Memory.squadIntervals[targetRoomName] &&
							Memory.squadIntervals[targetRoomName][type] && Memory.squadIntervals[targetRoomName][type] > Game.time){
							console.log('requesting squad too soon based on interval');
							return -8
					}
			}
			if (type === 'Bow' && !entryRoom){
					console.log('bow no entry rooms');
					return -10
			}
			let currentActiveSquads = 0;
			for (let i in Memory.squads){
					let squad = Memory.squads[i];
					if (squad.homeShard && squad.homeShard !== Game.shard.name){
							continue
					}
					if (((squad.targetRoom == targetRoomName || (squad.originalTargetRoom && squad.originalTargetRoom === targetRoomName)) && type === squad.type) || (type == 'G' && squad.type == 'G' && squad.homeRoom === homeRoom.name) ||
							(type == 'edgeDrain' && squad.type == 'edgeDrain' && squad.homeRoom === homeRoom.name)){
							if (squad.boosted && boosted && squad.boosted !== boosted){
									continue
							}
							if (!squad.nextWaveTime || squad.nextWaveTime > Game.time){
									currentActiveSquads++;
							}
					}
			}
			if (boosted && boosted != 0 && config.boostLevels[boosted]){
					let canBoost = homeRoom.canBoost(config.boostLevels[boosted]);
					let boostsStocked;
					if (type && (type === 'D' || type === 'Ca' || (config.swc))){
							boostsStocked = Game.canBoost(config.boostLevels[boosted],1500);
					} else {
							boostsStocked = Game.canBoost(config.boostLevels[boosted]);
					}
					if ((!canBoost && (!boostsStocked || !homeRoom.terminal)) || homeRoom.controller.level < 6){
							console.log('unable to boost squad', homeRoom, 'to', targetRoomName, options.type);
							if (!homeRoom.memory.boostingRequired){
									homeRoom.memory.boostingRequired = boosted;
							}
							return -6
					}
			}
			if (currentActiveSquads < numberOfSquads){
					let id = Game.generateId();
					console.log(homeRoom.name, 'creating squad - targetRoom:', targetRoomName, 'type:', type);
					Memory.squads[id] = {
							targetRoom: targetRoomName,
							homeRoom: homeRoom.name,
							dozers: Number.parseInt(dozers),
							attackers: Number.parseInt(attackers),
							snipers: Number.parseInt(snipers),
							medics: Number.parseInt(medics),
							hybrids : Number.parseInt(hybrids),
							claimMedics : Number.parseInt(claimMedics),
							boosted: Number.parseInt(boosted),
							noDiversion:noDiversion,
							type: type,
							expiry: Game.time + 3000,
							shard: shard,
							flag: flag,
							formationID: undefined,
							leaderRole: leaderRole,
							secondaryRooms: secondaryRooms,
							originalTargetRoom: originalTargetRoom,
							timeRequested: Game.time,
							escortId : escortId,
							entryRoom : entryRoom,
							homeShard:Game.shard.name,
							portalLandingRoom:portalLandingRoom,
							id: id
					};
					if (interval){
							if (!Memory.squadIntervals){
									Memory.squadIntervals = {};
							}
							if (!Memory.squadIntervals[targetRoomName]){
									Memory.squadIntervals[targetRoomName] = {};
							}
							Memory.squadIntervals[targetRoomName][type] = Game.time+interval;
					}
					return 'OK'
			} else {
					console.log('already enough squads',homeRoom.name,targetRoomName,options.type,Game.cpu.getUsed() - cpu);
					return -8
			}
	}
	let bowPositions = {};
	function runBow(squad,homeRoom){
			if (!bowPositions[squad.entryRoom]){
					bowPositions[squad.entryRoom] = {};
			}
			if (!bowPositions[squad.entryRoom][squad.targetRoom]){
					bowPositions[squad.entryRoom][squad.targetRoom] = {};
			}
			let positionList = bowPositions[squad.entryRoom][squad.targetRoom];
			let members = [];
			let room = Game.rooms[squad.entryRoom];
			if (room && room.armedHostileList && room.armedHostileList.length > 0){
					runSquad(squad,homeRoom);
					return
			}
			for (let i = squad.members.length - 1; i > -1; i--){
					if (!squad.members[i] || !Game.creeps[squad.members[i]]){
							squad.members.splice(i, 1);
					}
			}
			for (let i in squad.members){
					let creep = Game.creeps[squad.members[i]];
					if (creep){
							members.push(creep);
					}
			}
			if (!squad.bowPosition){
					let exitDir;
					let exits = Game.map.describeExits(squad.entryRoom);
					for (let i in exits){
							if (exits[i] === squad.targetRoom){
									exitDir = i;
									break
							}
					}
					console.log('exit dir',exitDir);
					if (exitDir && Game.rooms[squad.entryRoom]){
							let exits = Game.rooms[squad.entryRoom].find(Number.parseInt(exitDir));
							console.log(exits);
							for (let i in exits){
									let exitPos = exits[i];
									if (!positionList[exitPos.toString()] || !Memory.squads[positionList[exitPos.toString()]]){
											squad.bowPosition = exitPos.toString();
											squad.bowDirection = exitDir;
											positionList[exitPos.toString()] = squad.id;
											break
									}
							}
					}
			} else {
					positionList[squad.bowPosition] = squad.id;
					let bowPos = squad.bowPosition.toPos();
					let healPos = bowPos.movePos(Number.parseInt(squad.bowDirection).map8(4));
					console.log('bowpos',healPos);
					let retreatPoint = new RoomPosition(25,25,squad.entryRoom);
					let retreat = false;
					for (let i in members){
							let creep = members[i];
							if (creep.hits < creep.hitsMax*0.7){
									retreat = true;
							}
					}
					for (let i in members){
							let creep = members[i];
							engage(creep,undefined,members,squad.type);
							if (retreat) {
									if (creep.room.name === squad.entryRoom){
											creep.moveTo(retreatPoint,{range:15,maxRooms:1});
									} else {
											creep.move(Number.parseInt(squad.bowDirection).map8(4));
									}
							} else if (creep.role === 'hybrid'){
									creep.rangedMassAttack();
									if (!creep.pos.onEdge() || (!creep.pos.isEqualTo(bowPos) && !creep.pos.isEqualTo(bowPos.oppositeEdge()))){
											let maxRooms = undefined;
											if (creep.room.name === squad.entryRoom){
													maxRooms = 1;
											}
											creep.moveTo(bowPos,{range:0,maxRooms:maxRooms});
									}
							}  else  {
									let maxRooms = undefined;
									if (creep.room.name === squad.entryRoom){
											maxRooms = 1;
									}
									creep.moveTo(healPos,{range:0,maxRooms:maxRooms});
							}
					}
			}
	}

	//overarching controller for combat
	playerHeap.combatManager = {};
	let blockLowPrioritySquads = false;
	const forceHigherLevel = [];
	let roomStats = {
			time:Game.time
	};
	playerHeap.combatManager.chosenSquads = {};
	function chooseSquad(homeRoom,targetRoom,type,options){
			//only do this processing if you havent got a squad on route
			let optionsStr = undefined;
			if (options){
					optionsStr = JSON.stringify(options);
			}
			let key = targetRoom+type+optionsStr+','+homeRoom.energyCapacityAvailable;
			if (playerHeap.combatManager.chosenSquads[key] && playerHeap.combatManager.chosenSquads[key].expiry > Game.time){
					return playerHeap.combatManager.chosenSquads.squadInfo
			}
			let hostileRoom = false;
			if (targetRoom && targetRoom.controller && targetRoom.controller.owner && !targetRoom.controller.my){
					hostileRoom = true;
			}
			let healLevelNeeded = 0;
			let rangedNeeded = false;
			let towersUp = false;
			if (options && options.rangedNeeded){
					rangedNeeded = true;
			}
			if (Memory.coreRooms && Memory.coreRooms[targetRoom.name]){
					let core = targetRoom.findStructures('invaderCore')[0];
					if (core){
							hostileRoom = true;
					} else {
							rangedNeeded = false;
					}
			}
			//switch to dozer if first attack and hostileRoom
			let mainType = 'attacker';
			if (options && options.dozer){
					mainType = 'dozer';
			}
			if (roomStats.time != Game.time){
					roomStats = {
							time:Game.time
					};
			}
			if (roomStats && roomStats[targetRoom.name]){
					healLevelNeeded = roomStats[targetRoom.name].healLevelNeeded;
					rangedNeeded = roomStats[targetRoom.name].rangedNeeded;
					towersUp = roomStats[targetRoom.name].towersUp;
			}
			if (!healLevelNeeded){
					if (hostileRoom){
							let towers = targetRoom.find(FIND_STRUCTURES,{filter:(s)=>s.structureType === STRUCTURE_TOWER});
							if (targetRoom.controller && towers.length > CONTROLLER_STRUCTURES['tower'][targetRoom.controller.level]){
									towers = towers.filter((s)=>s.structureType === STRUCTURE_TOWER && !s.isWhiteListed && s.store['energy']>=10 && s.isActive());
							}
							towers = towers.filter((s)=>s.structureType === STRUCTURE_TOWER && !s.isWhiteListed && s.store['energy']>=10);
							if (towers[0]){
									healLevelNeeded = towers.length * TOWER_POWER_ATTACK;
									towersUp = true;
							}
					}
					if (targetRoom.hostileList && targetRoom.hostileList.length > 0){
							let maxStats = {};
							for (let i in targetRoom.hostileList){
									let hos = targetRoom.hostileList[i];
									let stats = hos.stats();
									for (let s in stats){
											if (!maxStats[s] || maxStats[s]<stats[s]){
													maxStats[s] = stats[s];
											}
									}
							}
							if (maxStats['ranged_attack']){
									if (maxStats['ranged_attack'] > 200 || towersUp){
											rangedNeeded = true;
									}
									healLevelNeeded += maxStats['ranged_attack'];
							}
							if (maxStats['attack']){
									if (towersUp){
											rangedNeeded = true;
									} else {
											rangedNeeded = false;
									}
									healLevelNeeded += maxStats['attack'];
							}
					} else if (config.botIsDead && targetRoom && targetRoom.controller && targetRoom.controller.owner && config.botIsDead.includes(targetRoom.controller.owner.username)){
							towersUp = false;
							healLevelNeeded = 1;
							rangedNeeded = false;
					}
					roomStats[targetRoom.name] = {
							rangedNeeded : rangedNeeded,
							healLevelNeeded:healLevelNeeded,
							towersUp:towersUp
					};
			}
			let startingBoost = 0;
			if (options && options.minLevel){
					startingBoost = options.minLevel;
			}
			let squadSize = 2;
			let activeCreeps = 1;
			let finalBoost = 0;
			let canSpawn = false;
			console.log('boost level length',Object.keys(config.boostLevels).length);
			for (let i = startingBoost;i<= Object.keys(config.boostLevels).length;i++){
					if ((i === 2 || i === 3) && Game.canBoost(config.boostLevels[4],0.7) && config.official){
							//skip low stocked mid level boosts
							continue
					}
					let boostLevel = i;
					if (options && options.maxLevel !== undefined && i > options.maxLevel){
							continue
					}
					if (boostLevel && config.boostLevels[boostLevel]){
							if (!homeRoom.canBoost(config.boostLevels[boostLevel]) && !Game.canBoost(config.boostLevels[boostLevel],4000)){
									//console.log('boost blocked',homeRoom,targetRoom,boostLevel)
									continue
							}
					}
					let healBoost = undefined,toughBoost = undefined;
					if (config.boostLevels[boostLevel]){
							for (let b in config.boostLevels[boostLevel]){
									let boost = config.boostLevels[boostLevel][b];
									if (boost === 'LO' || boost === 'LHO2' || boost === 'XLHO2'){
											healBoost = boost;
											break
									}
									if (boost === 'GO' || boost === 'GHO2' || boost === 'XGHO2'){
											toughBoost = boost;
											break
									}
							}
					}

					let medicBody = getBody$2(homeRoom,boostLevel,type);
					let healCount = 0;
					for (let p in medicBody){
							if (medicBody[p] === HEAL || medicBody[p]==='heal'){
									healCount++;
							}
							if (medicBody[p] === TOUGH || medicBody[p]==='tough');
					}
					let healPower = healCount*HEAL_POWER;
					if (healBoost){
							healPower = healPower*BOOSTS['heal'][healBoost]['heal'];
					}
					if (toughBoost){
							healLevelNeeded = healLevelNeeded*BOOSTS['tough'][toughBoost]['damage'];
					}
					//duo
					if (healPower > healLevelNeeded && (!options || !options.quad)){
							finalBoost = boostLevel;
							canSpawn = true;
							squadSize = 2;
							activeCreeps = 1;
							break
					}
					//quad
					if (healPower*2 > healLevelNeeded && boostLevel !== 5){
							finalBoost = boostLevel;
							canSpawn = true;
							squadSize = 4;
							activeCreeps = 2;
							break
					}
					//quad 3 medics
					if (healPower*3 > healLevelNeeded || (options && options.forceBoost===boostLevel) ||
							(type === 'D' && boostLevel === 5 && !towersUp)){
							finalBoost = boostLevel;
							canSpawn = true;
							squadSize = 4;
							activeCreeps = 1;
							break
					}
			}

			if (canSpawn){
					let obj = {
							level:finalBoost
					};
					if (!towersUp && type !== 'D'){
							rangedNeeded = true;
					}
					if (type === 'D' && (!targetRoom.controller || targetRoom.controller.my || !targetRoom.controller.owner)){
							rangedNeeded = false;
							if (activeCreeps < 1){
									activeCreeps = 1;
							}
					}
					let medicsNotNeeded = false;
					if (type === 'chase'){
							obj['hybrids'] = 2;
							medicsNotNeeded = true;
					} else if (mainType === 'attacker'){
							if (type === 'L' && healLevelNeeded === 1){
									obj['dozers'] = activeCreeps;
									//toStopMedics
									medicsNotNeeded = true;
							} else if (type === 'G'){
									obj['attackers'] = activeCreeps;
							} else if (rangedNeeded && !towersUp && squadSize === 4){
									obj['hybrids'] = 4;
									medicsNotNeeded = true;
							} else if (rangedNeeded && !towersUp){
									obj['hybrids'] = 2;
									medicsNotNeeded = true;
							} else if (rangedNeeded){
									obj['snipers'] = activeCreeps;
							} else {
									obj['attackers'] = activeCreeps;
							}
					} else {
							if (rangedNeeded && !towersUp){
									obj['hybrids'] = 4;
									medicsNotNeeded = true;
							} else if (rangedNeeded){
									obj['snipers'] = activeCreeps;
							} else {
									obj['dozers'] = activeCreeps;
							}
					}
					if (medicsNotNeeded){
							//hybrids self heal
							obj['medics'] = 0;
					} else if (type === 'G'){
							obj['medics'] = 0;
							obj['hybrids'] = squadSize-activeCreeps;
					} else {
							obj['medics'] = squadSize-activeCreeps;
					}
					obj['squadSize'] = squadSize;
					playerHeap.combatManager.chosenSquads[key] = {
							expiry: Game.time + 300,
							squadInfo: obj
					};
					return obj
			} else {
					console.log('cant spawn squad for',targetRoom,homeRoom);
			}
	}

	function requestSquadsViaCombatManager(targetRoom, type, options){
			let count;
			if (!options){
					options = {};
			}
			if (!options.count){
					count = 1;
			} else {
					count = options.count;
			}
			if (!Memory.combatLog){
					Memory.combatLog = {};
			}
			if (!Memory.combatLog[targetRoom]){
					if (options && options.expiryTime){
							options.expiryTime;
					}
					Memory.combatLog[targetRoom] = {
							expiry:Game.time+5000,
							squadLog:[]
					};
			}
			if (type === 'C'){
					if (!Game.rooms[targetRoom]){
							console.log('core room no vision',targetRoom);
							if (!config.official){
									sendVisionCreep(targetRoom);
							}
							return
					}
					if (!Memory.quadEntryPoints || !Memory.quadEntryPoints[targetRoom] || !Memory.quadEntryPoints[targetRoom].positions){
							console.log('core room blocked',targetRoom);
							getIntel(Game.rooms[targetRoom],true);
							return false
					}
			}
			if (options && options.secondary){
					Memory.combatLog[targetRoom].secondary = true;
			}
			if (Memory.combatLog[targetRoom].safeMode && Game.rooms[targetRoom] && Game.rooms[targetRoom].controller && (!Game.rooms[targetRoom].controller.safeMode
			|| Game.rooms[targetRoom].controller.safeMode < 300)){
					delete Memory.combatLog[targetRoom].safeMode;
					if (Memory.combatLog[targetRoom].closeRooms){
							for (let r in Memory.combatLog[targetRoom].closeRooms){
									let homeRoomName = Memory.combatLog[targetRoom].closeRooms[r];
									if (homeRoomName && Memory.rooms && Memory.rooms[homeRoomName] && Memory.rooms[homeRoomName].siegeBlock && Memory.rooms[homeRoomName].siegeBlock[targetRoom]){
											delete Memory.rooms[homeRoomName].siegeBlock[targetRoom];
									}
							}
					}
			}
			if (((Memory.combatLog[targetRoom].safeMode && Memory.combatLog[targetRoom].safeMode > Game.time) ||
							(Memory.combatLog[targetRoom].reinforcing && Memory.combatLog[targetRoom].reinforcing > Game.time && Memory.combatLog[targetRoom].block)) &&
					!Memory.combatLog[targetRoom].secondary && (!config.operations || !config.operations[targetRoom])){
					//block the room exits if we can't hold the room itself
					Memory.combatLog[targetRoom].expiry = Game.time + 2000;
					if (Memory.combatLog[targetRoom].reinforcementDir){
							for (let r in Memory.combatLog[targetRoom].reinforcementDir){
									if (Memory.combatLog[r] && Memory.combatLog[r].delete){
											delete Memory.combatLog[targetRoom].reinforcementDir[r];
											continue
									}
									//requestSquadsViaCombatManager(r,'D',{count:1,maxLevel:1,expiryTime:2000,secondary:true})
							}
					}
			}
			if (!Game.rooms[targetRoom] || (type === 'Ca' && Game.rooms[targetRoom].controller && !Game.rooms[targetRoom].controller.owner)){
					if (!config.official){
							sendVisionCreep(targetRoom);
					}
					if (type !== 'D' || (Memory.combatLog[targetRoom] && Memory.combatLog[targetRoom].block)){
							console.log('no vision',targetRoom,'to request squad');
							return
					}
			}
			if (type === 'R'){
					let spawns = Game.rooms[targetRoom].findStructures('spawn');
					if (!spawns || spawns.length === 0){
							console.log('no spawn',targetRoom,'R squad not needed');
							return
					}
			}
			if (type === 'response' && Game.rooms[targetRoom]){
					if (Game.map.isCoreRoom(targetRoom)){
							return
					}
					//send a D squad if enemy creeps
					let room = Game.rooms[targetRoom];
					if (room.controller && room.controller.my && room.controller.safeMode && room.controller.safeMode > 300){
							return
					}
					if (room.hostileList){
							let nonScout = false;
							for (let i in room.hostileList){
									let hos = room.hostileList[i];
									for (let i in hos.body){
											if (hos.body[i].type !== 'move' && hos.owner && hos.owner.username !== 'Source Keeper'){
													nonScout = true;
													break
											}
									}
							}
							if (!nonScout){
									return
							}
							//there are enemies so we organise a defence squad
							type = 'D';
					} else {
							return
					}
			}
			//get close rooms
			let closeRooms = [];
			if (Memory.combatLog[targetRoom].closeRooms){
					closeRooms = Memory.combatLog[targetRoom].closeRooms;
			} else {
					let maxLevel = 3;
					for (let i in Game.myRooms){
							let myRoom = Game.myRooms[i];
							let range = getDist(targetRoom,myRoom.name);
							if (myRoom && range < 15 && myRoom.memory.defcon === 5 && myRoom.class === 'normal'){
									if (myRoom.controller.level > maxLevel){
											maxLevel = myRoom.controller.level;
									} else if (myRoom.controller.level < (maxLevel)){
											continue
									}
									closeRooms.push(myRoom.name);
							}
					}
					if (Game.rooms[targetRoom] && Game.rooms[targetRoom] < 6 && maxLevel === 8){
						maxLevel = 7;
					}
					closeRooms = closeRooms.filter((r)=>Game.rooms[r].controller.level >= (maxLevel));
					closeRooms = closeRooms.sort((a,b)=>{return getDist(targetRoom,a)-getDist(targetRoom,b)});
					Memory.combatLog[targetRoom].closeRooms = closeRooms;
			}
			console.log('requesting combat squads to',targetRoom,type, 'from',closeRooms);
			if (!Game.rooms[targetRoom] && type === 'D' && closeRooms && closeRooms[0]){
					//ensure defence squad on way even if no room vision
					requestSquad(Game.rooms[closeRooms[0]],targetRoom,{type:'D',attackers:1,medics:1,numberOfSquads:1});
					return
			} else if (type === 'D' && !Game.rooms[targetRoom]) {
					return
			}
			if (type === 'Ca' && !Memory.forceReserveRooms[targetRoom]){
					Memory.forceReserveRooms[targetRoom] = {
							status:'owned'
					};
			}
			let owner;
			if (Game.rooms[targetRoom].controller && Game.rooms[targetRoom].controller.owner && Game.rooms[targetRoom].controller.owner.username){
					owner = Game.rooms[targetRoom].controller.owner.username;
			}
			let squadOptions = {};
			if (options && options.maxLevel !== undefined){
					squadOptions.maxLevel = options.maxLevel;
			}
			if (Memory.combatLog[targetRoom].rangedNeeded){
					squadOptions.rangedNeeded = true;
					if (type === 'D' && Game.rooms[targetRoom] && (!Game.rooms[targetRoom].controller || !Game.rooms[targetRoom].controller.owner)){
							squadOptions.rangedNeeded = false;
					}
			} else if (options && options.rangedNeeded){
					squadOptions.rangedNeeded = options.rangedNeeded;
			}
			let fcRoom;
			for (let i = closeRooms.length-1;i> -1;i--){
					if (Game.rooms[closeRooms[i]] && Game.rooms[closeRooms[i]].memory.faceClaimed &&  Game.rooms[closeRooms[i]].memory.faceClaims &&
							Game.rooms[closeRooms[i]].memory.faceClaims.length > 0 && Game.rooms[closeRooms[i]].memory.faceClaims.includes(targetRoom)){
							fcRoom = closeRooms[i];
					} else if (Game.rooms[closeRooms[i]] && Game.rooms[closeRooms[i]].memory.faceClaimed &&  Game.rooms[closeRooms[i]].memory.faceClaims &&
							Game.rooms[closeRooms[i]].memory.faceClaims.length > 0){
							closeRooms.splice(i,1);
					}
			}
			if (Memory.combatLog[targetRoom].block && !config.private){
					if (!options.force){
							console.log(`max squad tried for ${targetRoom},${type}`);
							return
					}
			}
			if (Game.rooms[targetRoom].controller && Game.rooms[targetRoom].controller.safeMode && !Memory.combatLog[targetRoom].secondary){
					Memory.combatLog[targetRoom].safeMode = Game.time + Game.rooms[targetRoom].controller.safeMode;
					Memory.combatLog[targetRoom].expiry = Game.time + 1000;
					return
			}
			let lastSquad = Memory.combatLog[targetRoom].squadLog[Memory.combatLog[targetRoom].squadLog.length-1];
			if (options && options.minLevel){
					squadOptions.minLevel = options.minLevel;
			}
			if (lastSquad && lastSquad.deathEarly && (lastSquad.level < 5 || lastSquad.size == 2) && (!options || !options.minLevel || lastSquad.level < options.minLevel)){
					if (lastSquad.size == 2){
							squadOptions.quad = true;
							squadOptions.minLevel = lastSquad.level;
					} else {
							squadOptions.minLevel = lastSquad.level+1;
					}
			} else if (lastSquad && lastSquad.deathEarly && !squadOptions.rangedNeeded){
					//have not tried a ranged squad
					Memory.combatLog[targetRoom].rangedNeeded = Game.time + 2000;
					squadOptions.rangedNeeded = true;
					squadOptions.quad = true;
					if (lastSquad && lastSquad.level){
							squadOptions.minLevel = lastSquad.level;
					}
			} else if (lastSquad && lastSquad.deathEarly && (lastSquad.level || options.maxLevel === 0) && !options.force){
					//can't get a bigger squad - try later
					Memory.combatLog[targetRoom].block = true;
					Memory.combatLog[targetRoom].expiry = Game.time + 5000;
			}
			if (squadOptions.minLevel){
					Memory.combatLog[targetRoom].minLevel = squadOptions.minLevel;
					Memory.combatLog[targetRoom].minLevelExpiry = Game.time + 3000;
			} else if (Memory.combatLog[targetRoom].minLevel && Memory.combatLog[targetRoom].minLevelExpiry > Game.time){
					squadOptions.minLevel = Memory.combatLog[targetRoom].minLevel;
			} else if (Memory.combatLog[targetRoom].minLevel && (Memory.combatLog[targetRoom].minLevel>1|| (Memory.combatLog[targetRoom].minLevel>0 &&
					(type !== 'Ca' || !Game.canBoost(config.boostLevels[1]))))){
					Memory.combatLog[targetRoom].minLevel--;
					Memory.combatLog[targetRoom].minLevelExpiry = Game.time + 1000;
					squadOptions.minLevel = Memory.combatLog[targetRoom].minLevel;
			}
			let earlyDeath = false;
			if (Memory.combatLog && Memory.combatLog[targetRoom] && Memory.combatLog[targetRoom].squadLog){
					for (let s in Memory.combatLog[targetRoom].squadLog){
							if (Memory.combatLog[targetRoom].squadLog[s].deathEarly){
									earlyDeath = true;
									break
							}
					}
			}
			if (owner && earlyDeath && forceHigherLevel.includes(owner) && (!squadOptions.minLevel || squadOptions.minLevel < 5) && Game.canBoost(config.boostLevels[5],4000)){
					squadOptions.minLevel = 5;
			}
			if (owner && earlyDeath && forceHigherLevel.includes(owner)){
					squadOptions.quad = true;
			}
			if (options && options.quad){
					squadOptions.quad = true;
			}
			if (!lastSquad && type == 'Ca' && Game.rooms[targetRoom].controller && Game.rooms[targetRoom].controller.level > 5){
					squadOptions.quad = true;
					squadOptions.dozer = true;
			}
			//choose squad
			let minLevel;
			if (squadOptions.minLevel){
					minLevel = squadOptions.minLevel;
			}
			//active attack - if type === 'Ca' || 'L' - block other squads to save cpu
			if (Game.cpu.bucket < 3000 && type !== 'C' && type !== 'P' && (!config.official || minLevel > 1)){
					blockLowPrioritySquads = Game.time+5;
			}
			let currentSquads = getSquads(targetRoom,type,minLevel);
			let sendingRooms = {};
			for (let s in currentSquads){
					if (!sendingRooms[currentSquads[s].homeRoom]){
							sendingRooms[currentSquads[s].homeRoom] = 0;
					}
					sendingRooms[currentSquads[s].homeRoom]++;
			}
			let sent = currentSquads.length;
			if (Memory.combatLog[targetRoom].minLevel === 4 && !options.force  && type === 'Ca' && fcRoom && Game.rooms[fcRoom] && Game.rooms[fcRoom].controller.level > 7){
					//save high level boosts - can use at level 5 if need be
					count = 1;
			}
			if (Game.rooms[targetRoom] && Memory.rooms[targetRoom] && !Memory.rooms[targetRoom].hostiles && count > 2 && !options.force){
					count = 2;
			}
			let sendRCA = false;
			if (Game.rooms[targetRoom]){
					let spawnAndTowers = Game.rooms[targetRoom].find(FIND_STRUCTURES,{filter:(s)=>!s.my && (s.structureType === STRUCTURE_SPAWN || (s.structureType === STRUCTURE_TOWER && s.store['energy']>0))});
					if (spawnAndTowers && spawnAndTowers.length === 0){
							if (count > 2 && !options.force){
									count = 2;
							}
							if ((!Game.rooms[targetRoom].memory.armedHostiles || (Game.flags['RCA'] && Game.flags['RCA'].pos.roomName === targetRoom)) && (type === 'Ca' || type === 'RCA') && Game.rooms[targetRoom].controller && Game.rooms[targetRoom].controller.owner && !Game.rooms[targetRoom].controller.owner.my){
									sendRCA = true;
							}
					}
			}
			closeRooms = closeRooms.filter((r)=> Game.rooms[r] && (!Game.rooms[r].memory.faceClaimed || !fcRoom || r !== fcRoom));
			if (closeRooms[0] && Game.rooms[closeRooms[0]]){
					Game.rooms[closeRooms[0]].memory.blockPowerSquads = Game.time+3000;
			}
			if (sendRCA){
					//send an RCA from nearbyRooms
					if (!Memory.combatLog[targetRoom].controllerSpots || Game.time > Memory.combatLog[targetRoom].controllerSpots.expiry){
							let controller = Game.rooms[targetRoom].controller;
							let neighbours = controller.pos.neighbours();
							let spots = 0;
							for (let n in neighbours){
									if (neighbours[n].isWalkable()){
											spots++;
									}
							}
							Memory.combatLog[targetRoom].controllerSpots = {
									spots:spots,expiry:Game.time+1000
							};
					}
					if (Memory.combatLog[targetRoom].controllerSpots && Memory.combatLog[targetRoom].controllerSpots.spots){
							let RCAsSent = 0;
							for (let c in closeRooms){
									let distance = getDist(targetRoom,closeRooms[c]);
									if (distance > 5 || RCAsSent >= Memory.combatLog[targetRoom].controllerSpots.spots){
											break
									}
									RCAsSent++;
									Game.rooms[closeRooms[c]].sendRCA(targetRoom);
							}
					}
			}
			if ((type === 'Ca' || type === 'RCA') && Game.rooms[targetRoom].controller && !Game.rooms[targetRoom].controller.my && Game.rooms[targetRoom].controller.owner && Memory.combatLog[targetRoom].controllerSpots && Memory.combatLog[targetRoom].controllerSpots.spots){
					attackRoomController(targetRoom,Memory.combatLog[targetRoom].controllerSpots.spots);
			}
			if (type === 'RCA'){
					//just a combat manager for sending RCA to attack controller - dont send squads
					return
			}
			if (sent < count){
					console.log('current squads on route to ',targetRoom,sent,' target number:',count);
					for (let c in closeRooms){
							let closeRoom = closeRooms[c];
							let range = Game.map.getRoomLinearDistance(closeRoom,targetRoom);
							let suggestedCount = 1;
							if (range < 3){
									suggestedCount = 3;
							} else if (range < 6){
									suggestedCount = 2;
							}
							if (closeRooms.length > 5 && suggestedCount > count/3){
									suggestedCount = Math.round(count/3);
							}
							if (sendingRooms[closeRoom] && sendingRooms[closeRoom]>=suggestedCount){
									//use different rooms if needed
									continue
							}
							if (options && options.forceBoost){
									squadOptions.forceBoost = options.forceBoost;
							}
							let entryRoom;
							let chosenSquad = chooseSquad(Game.rooms[closeRoom],Game.rooms[targetRoom],type,squadOptions);
							console.log('chosenSquad',closeRoom,chosenSquad);
							if (options && options.entryRoom){
									entryRoom = options.entryRoom;
							}
							if (options && options.noMedic && chosenSquad){
									chosenSquad.medics = 0;
									if (type === 'C'){
											chosenSquad.attackers = 1;
											chosenSquad.hybrids = 0;
											chosenSquad.dozers = 0;
											chosenSquad.snipers = 0;
									}
							}
							if (chosenSquad){
									let res = requestSquad(Game.rooms[closeRoom],targetRoom,{
											type:type,
											boosted:chosenSquad.level,
											attackers:chosenSquad.attackers,
											dozers:chosenSquad.dozers,
											medics:chosenSquad.medics,
											snipers:chosenSquad.snipers,
											hybrids:chosenSquad.hybrids,
											numberOfSquads:count,
											entryRoom:entryRoom
									});
									if (res && res === 'OK' && type !== 'C'){
											console.log(`announcement|${Game.shard.name}|sending ${type} squad to ${targetRoom} from ${closeRoom} ${JSON.stringify(chosenSquad)}`);
											sent++;
									} else {
											console.log(`failed to send squad to ${targetRoom} from ${closeRoom} ${res}`);
									}
									if (sent >= count || (res && res === -8)){
											break
									}
							}
					}
			} else {
					console.log(sent,'squads on route to',targetRoom,);
			}
			if (fcRoom && !sendingRooms[fcRoom]){
					console.log(fcRoom,'need to send',targetRoom);
					squadOptions.minLevel = 4;
					//constant send from fcroom
					let chosenSquad = chooseSquad(Game.rooms[fcRoom], Game.rooms[targetRoom], type, squadOptions);
					if (chosenSquad){
							let res = requestSquad(Game.rooms[fcRoom], targetRoom, {
									type: type,
									boosted: chosenSquad.level,
									attackers: chosenSquad.attackers,
									dozers: chosenSquad.dozers,
									medics: chosenSquad.medics,
									snipers: chosenSquad.snipers,
									hybrids: chosenSquad.hybrids,
									numberOfSquads: count+1
							});
							if (res && res === 'OK'){
									console.log(`announcement|${Game.shard.name}|sending squad to ${targetRoom} from ${fcRoom} ${JSON.stringify(chosenSquad)} - room is empty`);
							} else {
									console.log(`failed to send squad to ${targetRoom} from ${fcRoom} ${res}`);
							}
					}
			}
	}
	function getSquads(targetRoom,type,minLevel){
			let squads = [];
			for (let i in Memory.squads){
					let squad = Memory.squads[i];
					if (minLevel && (!squad.boosted || squad.boosted < minLevel)){
							continue
					}
					if (squad.targetRoom === targetRoom && squad.type === type && (!squad.nextWaveTime || Game.time < squad.nextWaveTime)){
							squads.push(squad);
					}
			}
			return squads
	}
	function tidy(){
			if (!Memory.combatLog){
					Memory.combatLog = {};
			}
			for (let i in Memory.combatLog){
					if (Memory.combatLog[i].expiry < Game.time){
							delete Memory.combatLog[i];
					}
			}
	}
	function checkBlockLowPrioritySquads(){
			if (blockLowPrioritySquads && Game.time < blockLowPrioritySquads){
					return true;
			}
			return false
	}

	playerHeap.segments = {};
	playerHeap.segments.segmentRawMemoryCache = {};
	playerHeap.segments.segmentDataObjectCache = {};
	let segmentsLoaded = false;
	playerHeap.segments.dataSectionsToSave = [];
	playerHeap.segments.saveQueue = [];
	playerHeap.segments.save10 = [9];
	playerHeap.segments.foreignSegments = {};
	playerHeap.segments.segLastTry = {};
	playerHeap.segments.lastRequestedByMe = {};
	playerHeap.segments.lastPriorityShareRequest = {};
	let foreignSegmentActive = config$1.segmentId && config$1.alliedSegments && config$1.alliedSegments.length > 0;
	function run$14(){
			if (!Memory.segments){
					Memory.segments = {};
					Memory.segmentTracker = [];
					while (Memory.segmentTracker.length < 100){
							Memory.segmentTracker.push(0);
					}
			}
			for (let i in Memory.segments){
					if (!Array.isArray(Memory.segments[i])){
							Memory.segments[i] = [Memory.segments[i]];
					}
			}
			if (config$1.segmentId){
					RawMemory.setDefaultPublicSegment(config$1.segmentId);
					RawMemory.setPublicSegments([config$1.segmentId]);
			}
			if (Memory.defenceRequestExpiries){
					for (let i in Memory.defenceRequestExpiries){
							if (Memory.defenceRequestExpiries[i] < Game.time){
									removeDefenceRequest(i);
							}
					}
			}
			clearSegments();
			let segmentQueue = [];
			if (!foreignSegmentActive && access('public')){
					let data = access('public');
					if (!Array.isArray(data) || data.length > 0){
							save('public',undefined,[]);
					}
			}
			for (let i in Game.rooms){
					let room = Game.rooms[i];
					if (room.controller && room.controller.my){
							let assigned = checkAssignedSegmentsForDataName(i);
							if (assigned === false){
									assignSegment(i);
							}
					}
			}
			let activeSegments = [];
			for (let i in Memory.segmentTracker){
					if (Memory.segmentTracker[i] === 1){
							activeSegments.push(i);
					}
			}
			cacheSegments(activeSegments);
			if (!playerHeap.segments.save10){
					playerHeap.segments.save10 = [];
			}
			if (!playerHeap.segments.save10 || !segmentQueue){
					console.log('no segment queue error');
					return
			}
			if (playerHeap.segments.save10 && playerHeap.segments.save10.length > 0 && !segmentsLoaded){
					for (let i in playerHeap.segments.save10){
							let current = playerHeap.segments.save10[i];
							if (RawMemory.segments[current] != undefined){
									playerHeap.segments.save10[i] = "";
							}
					}
					playerHeap.segments.save10 = playerHeap.segments.save10.filter((a) => {
							return a !== ""
					});
			}
			while (playerHeap.segments.save10.length < 10 && segmentQueue.length > 0){
					playerHeap.segments.save10.push(segmentQueue.pop());
			}
			while (playerHeap.segments.save10.length < 10 && playerHeap.segments.saveQueue.length > 0){
					playerHeap.segments.save10.push(playerHeap.segments.saveQueue.pop());
			}
			if (playerHeap.segments.save10.length > 0 && playerHeap.segments.save10.length <= 10){
					console.log('s10',playerHeap.segments.save10,'loaded',segmentsLoaded);
					try {
							RawMemory.setActiveSegments(playerHeap.segments.save10);
					} catch (err){
							console.log('segments', err);
					}
					if (segmentsLoaded){
							let ret = uploadCache(playerHeap.segments.save10);
							playerHeap.segments.save10 = ret;
					}
			} else if (playerHeap.segments.save10.length > 10){
					console.log('playerHeap.segments.save10 too large', playerHeap.segments.save10);
			}
			if (playerHeap.segments.save10 && playerHeap.segments.save10.length == 0){
					segmentsLoaded = true;
			}
			if (config$1.alliedSegments && config$1.alliedSegments.length > 0 && playerHeap.segments.foreignSegments
					&& Object.keys(playerHeap.segments.foreignSegments).length < config$1.alliedSegments.length && Memory.myRooms.length > 1){
					if (RawMemory.foreignSegment){
							try {
									let user = RawMemory.foreignSegment.username;
									console.log('seg', user);
									if (!user || playerHeap.segments.foreignSegments[user]){
											RawMemory.setActiveForeignSegment(null);
									} else if (RawMemory.foreignSegment.data){
											playerHeap.segments.foreignSegments[user] = JSON.parse(RawMemory.foreignSegment.data);
									}
							} catch (err){
									console.log('seg ally 1',err);
							}
					} else {
							for (let i in config$1.alliedSegments){
									let user = config$1.alliedSegments[i];
									try {
											if (!playerHeap.segments.foreignSegments[user] && (!playerHeap.segments.segLastTry[user] || Game.time > playerHeap.segments.segLastTry[user])){
													console.log('set seg', user);
													let id;
													if (config$1.segmentId){
															id = config$1.segmentId;
													}
													RawMemory.setActiveForeignSegment(user, id);
													playerHeap.segments.segLastTry[user] = Game.time + 200;
													break
											}
									} catch (err){
											console.log(`segments ally ${user}`, err);
									}
							}
					}
			}

			for (let i in playerHeap.segments.foreignSegments){
					try {
							if (!Memory.closestAllyRooms){
									Memory.closestAllyRooms = {};
							}
							if ((!Memory.closestAllyRooms[i] || Memory.closestAllyRooms[i].expiry < Game.time) && (Game.time % 10 === 0 && Game.cpu.bucket > 1000)){
									findClosestRoom(i);
							}
							if (Game.time % 10 == 0){
									let requests = playerHeap.segments.foreignSegments[i];
									for (let j in requests){
											let request = requests[j];
											if (request && request.requestType != undefined){
													processRequest(i, request);
											}
									}
							}
					} catch (err){
							console.log(`segments ally 2 ${i}`, err);
					}
			}
			function cacheSegments(assignedSegmentIds){
					for ( let i in assignedSegmentIds){
							let segmentId = assignedSegmentIds[i];
							if (playerHeap.segments.segmentRawMemoryCache[segmentId] !== undefined); else {
									//cache this segment in segmentMemory so it can be accessed
									if (RawMemory.segments[segmentId] !== undefined){
											console.log(`segment ${segmentId} size: ${RawMemory.segments[segmentId].length/1024} kb`);
											playerHeap.segments.segmentRawMemoryCache[segmentId] = RawMemory.segments[segmentId];
									} else if (segmentId) {
											segmentQueue.push(segmentId);
									}
							}
					}
			}
			function processRequest(user, request){
					//    RESOURCE: 0,
					//     DEFENSE: 1,
					//     ATTACK: 2,
					//     EXECUTE: 3,
					//     HATE: 4,
					//     REMOTE_DEF: 5,
					//{"requestType":0,"resourceType":"X","maxAmount":29090,"roomName":"E16N8","priority":0.25}
					if ((request.requestType === 0||request.requestType === '0')  && request.priority){
							//resource request
							let type = request.resourceType;
							let priority = request.priority;
							if (priority > 1){
									priority = 1;
							}
							if (playerHeap.segments.lastPriorityShareRequest && priority > 0.8){
									playerHeap.segments.lastPriorityShareRequest[type] = Game.time;
							}
							if (type === 'energy' || true){
									console.log(`${user} requesting resource ${type} ${priority}`);
							}
							if (playerHeap.segments.lastRequestedByMe && playerHeap.segments.lastRequestedByMe[type]){
									let delay = 5000;
									if (type === 'energy'){
											delay = 3000;
											if (priority > 0.8){
													delay = 1000;
											}
									}
									if (Game.time < playerHeap.segments.lastRequestedByMe[type]+delay){
											console.log('block recently requested resource',type);
											return
									}
							}
							let myRequests = access('public');
							if (myRequests){
									for (let i in myRequests){
											let myRequest = myRequests[i];
											if (myRequest.resourceType && myRequest.resourceType === type &&
													(myRequest.priority >= priority - 0.3 || type !== 'energy')){
													//we need this resource - don't give away unless other player has more urgent need
													console.log(`block sharing of ${myRequest.resourceType}:`);
													console.log(JSON.stringify(myRequest));
													return
											}
									}
							}
							if (type && config$1.shareList.includes(type) && Memory.closestAllyRooms[user]){
									let myAmount = Game.getResourceTotal(type);
									let resourceTarget;
									if (config$1.warboosts && config$1.warboosts[type]){
											resourceTarget = config$1.warboosts[type] * Memory.myRooms.length;
									} else {
											resourceTarget = config$1.mineralTarget * Memory.myRooms.length;
									}
									let energyPriorityAdjust = 30000 - (priority*32000);
									if (type === 'energy' && priority < 0.7 && Memory.priorityEnergyRoomName){
											energyPriorityAdjust *= 2;
									} else if (type === 'energy' && priority < 0.8 && Memory.priorityEnergyRoomName){
											energyPriorityAdjust *= 1.5;
									}
									energyPriorityAdjust*=Memory.myRooms.length;
									console.log('energy prio',energyPriorityAdjust,);
									if ((myAmount > resourceTarget && type !== 'energy') || (type === 'energy' && Memory.excessEnergy > energyPriorityAdjust)){
											let dif = myAmount - resourceTarget;
											if (dif > 5000 || (type === 'energy' && Memory.excessEnergy > 0 && Memory.excessEnergy > energyPriorityAdjust)){
													let targetRoom = Memory.closestAllyRooms[user].roomName;
													let myRoom = Memory.closestAllyRooms[user].myNearRoom;
													if (type === 'energy'){
															if (Game.rooms[myRoom] && Game.rooms[myRoom].total(type) > Game.rooms[myRoom].memory.reserve){
																	Game.supplyResource(type, 5000, myRoom, targetRoom);
															}
													} else if (Game.rooms[myRoom] && Game.rooms[myRoom].total(type) > 8000){
															Game.supplyResource(type, 5000, myRoom, targetRoom);
													}
											}
									}
							}
					}
					if ((request.requestType === 1||request.requestType === '1') && request.roomName){
							let maxLevel = 0;
							let count = 1;
							// if (request.priority && request.priority ===1 && Game.canBoost(config.boostLevels[1],1.5)){
							// 		maxLevel = 1
							// }
							console.log('defence request for',user,request.roomName);
							requestSquadsViaCombatManager(request.roomName,'D',{
									maxLevel:maxLevel,
									count:count,
							});
					}
			}

			function findClosestRoom(user){
					console.log('finding closest room', user);
					let closestTheirs;
					let closestMine;
					let range;
					for (let i in Game.myRooms){
							if (Game.myRooms[i] && Game.myRooms[i].terminal){
									let myRoom = Game.myRooms[i];
									for (let roomName in Memory.ownedRooms){
											let owner = Memory.ownedRooms[roomName].owner;
											let level = Memory.ownedRooms[roomName].level;
											if (owner && owner == user && level && level >= 6){
													let thisRange = Game.map.getRoomLinearDistance(myRoom.name, roomName);
													if (!closestTheirs || range > thisRange){
															closestTheirs = roomName;
															closestMine = myRoom.name;
															range = thisRange;
													}
											}
									}
							}
					}
					if (closestTheirs){
							Memory.closestAllyRooms[user] = {
									roomName: closestTheirs,
									myNearRoom: closestMine,
									range: range,
									expiry: Game.time + 5000
							};
					}
			}

			function uploadCache(arr){
					for (let i in arr){
							let current = arr[i];
							if (RawMemory.segments[current] === undefined){
									console.log('segment undefined:',current);
									// RawMemory.segments[current] = ""
									// segments.segmentRawMemoryCache[current] = ""
									// arr[i] = ""
									continue
							}
							if (playerHeap.segments.segmentRawMemoryCache[current] === "clear"){
									RawMemory.segments[current] = "";
									playerHeap.segments.segmentRawMemoryCache[current] = "";
									arr[i] = "";
									for (let i in Memory.segments){
											if (Memory.segments[i] == current || Memory.segments[i].includes(current)){
													delete Memory.segments[i];
											}
									}
									Memory.segmentTracker[current] = 0;
									console.log('clearing', current);
									return
							}
							RawMemory.segments[current] = playerHeap.segments.segmentRawMemoryCache[current];
							arr[i] = "";
							console.log(`saving ${current}`);
					}
					return arr.filter((a) => {
							return a !== ""
					})
			}
	}


	function assignSegment(name){
			if (Memory.segmentTracker){
					console.log('assigning segment for', name);
					let index = Memory.segmentTracker.findIndex((j) => {
							return j === 0
					});
					if (name === 'public' && config$1.segmentId){
							index = config$1.segmentId;
					}
					if (index >= 0){
							if (!Memory.segments[name]){
									Memory.segments[name] = [];
							}
							Memory.segments[name].push(index);
							Memory.segmentTracker[index] = 1;
							playerHeap.segments.segmentRawMemoryCache[index] = '';
					} else {
							console.log('need to develop segment clearing now');
					}
			}
	}

	function clearSegments(){
			if (segmentsLoaded){
					for (let i in Memory.segments){
							if (!Game.rooms[i] && i.isRoomName()){
									let assigned = checkAssignedSegmentsForDataName(i);
									if (assigned == false){
											console.log(`segment ${i} does not exist`);
											return
									}
									for (let i in assigned){
											let seg = assigned[i];
											playerHeap.segments.segmentRawMemoryCache[seg] = "clear";
											playerHeap.segments.saveQueue.push(seg);
											//Memory edited when saved to ensure that only cleared segments are altered in the segmentTracker memory location
									}
							}
					}
			}
	}

	function ready(){
			return segmentsLoaded
	}

	function access(dataName){
			if (!dataName || !segmentsLoaded){
					return false
			}
			if (playerHeap.segments.segmentDataObjectCache[dataName] !== undefined){
					//console.log('returning seg,',dataName,JSON.stringify(playerHeap.segments.segmentDataObjectCache[dataName]))
					return playerHeap.segments.segmentDataObjectCache[dataName]
			}
			let segmentIDs = checkAssignedSegmentsForDataName(dataName);
			try {
					if (segmentIDs && Array.isArray(segmentIDs) && segmentIDs.length > 0){
							let dataStr;
							for (let i in segmentIDs){
									let dataChunk = getRawSegmentData(segmentIDs[i]);
									if (segmentIDs.length > 1){
											console.log(i,segmentIDs[i],dataChunk);
									}
									if (dataChunk !== undefined && (dataChunk !== "" || i === '0')){
											if (dataStr === undefined){
													dataStr = dataChunk;
											} else {
													dataStr = dataStr.concat(dataChunk);
											}
									}
							}
							if (dataStr !== undefined){
									if (dataStr === ""){
											dataStr = "{}";
									}
									let obj = JSON.parse(dataStr);
									if (obj){
											playerHeap.segments.segmentDataObjectCache[dataName] = obj;
											return obj
									}
							}
					} else {
							console.log(`segment ${dataName} does not exist`);
							return false
					}
			} catch (err){
					console.log('data err with segment',dataName,err);
					if (segmentIDs.length > 1){
							playerHeap.segments.segmentDataObjectCache[dataName] = {};
					}
					let canWipe = ['SKMatrices'];
					try {
							let dataStr;
							let finishedSegment;
							for (let i in segmentIDs){
									if (canWipe.includes(dataName)){
											playerHeap.segments.segmentRawMemoryCache[segmentIDs[i]] = "clear";
											playerHeap.segments.saveQueue.push(segmentIDs[i]);
											continue
									}
									let dataChunk = getRawSegmentData(segmentIDs[i]);
									if (segmentIDs.length > 1 || true){
											console.log(i,segmentIDs[i],dataChunk);
									}
									if (dataChunk !== undefined && (dataChunk !== "" || i === '0')){
											if (finishedSegment){
													playerHeap.segments.segmentRawMemoryCache[segmentIDs[i]] = "clear";
													playerHeap.segments.saveQueue.push(segmentIDs[i]);
											}
											if (dataStr === undefined){
													dataStr = dataChunk;
											} else {
													dataStr = dataStr.concat(dataChunk);
											}
											if (dataChunk.length < 100000){
													//likely next segment not required as data is short enough to fit on segments up to this point
													finishedSegment = true;
											}
									}
							}
					} catch (err){
							console.log('unable to correct error',dataName,err);
					}
			}
	}
	function getRawSegmentData(segmentNumber){
			return playerHeap.segments.segmentRawMemoryCache[segmentNumber]
	}
	function save(dataBlockName, dataSubSectionName, data){
			//only operate if cache complete
			//todo remove save block
			if (!dataBlockName){
					return
			}
			let assigned = checkAssignedSegmentsForDataName(dataBlockName);
			if (assigned === false){
					console.log(`segment ${dataBlockName} does not exist`);
					return
			}
			if (segmentsLoaded && playerHeap.segments.segmentDataObjectCache && playerHeap.segments.segmentDataObjectCache[dataBlockName] !== undefined){
					access(dataBlockName);
			}
			if (segmentsLoaded && playerHeap.segments.segmentDataObjectCache && playerHeap.segments.segmentDataObjectCache[dataBlockName] !== undefined){
					let saveObj = playerHeap.segments.segmentDataObjectCache[dataBlockName];
					if (!dataSubSectionName){
							saveObj = data;
					} else {
							saveObj[dataSubSectionName] = data;
					}
					playerHeap.segments.segmentDataObjectCache[dataBlockName] = saveObj;
					console.log('submitting segment save request', dataBlockName, dataSubSectionName);
					playerHeap.segments.dataSectionsToSave[dataBlockName] = true;
			}
	}
	function saveAllPendingSegmentData(){
			if (!segmentsLoaded || !playerHeap.segments.segmentDataObjectCache){
					return
			}
			for (let i in playerHeap.segments.dataSectionsToSave){
					let dataBlockName = i;
					let assigned = checkAssignedSegmentsForDataName(dataBlockName);
					if (playerHeap.segments.segmentDataObjectCache[dataBlockName]){
							let str = JSON.stringify(playerHeap.segments.segmentDataObjectCache[dataBlockName]);
							let length = str.length;
							let segmentSize = 100000;
							let segmentsNeeded = Math.ceil(length/segmentSize);
							let count = 10;
							if (dataBlockName == 'public'){
									playerHeap.segments.saveQueue = playerHeap.segments.saveQueue.concat([assigned[0]]);
									playerHeap.segments.segmentRawMemoryCache[assigned[0]] = str;
									delete playerHeap.segments.dataSectionsToSave[dataBlockName];
									continue
							}
							while (assigned.length < segmentsNeeded && count > 0){
									count--;
									assignSegment(dataBlockName);
									assigned = checkAssignedSegmentsForDataName(dataBlockName);
							}
							while (assigned.length > segmentsNeeded){
									let lastSeg = assigned.pop();
									playerHeap.segments.segmentRawMemoryCache[lastSeg] = 'clear';
									playerHeap.segments.saveQueue = playerHeap.segments.saveQueue.push(lastSeg);
							}
							if (count === 0){
									console.log('data too large:',dataBlockName);
									continue
							}
							let currentByte = 0;
							let currentSegmentIndex = 0;
							while (segmentsNeeded > 0){
									playerHeap.segments.segmentRawMemoryCache[assigned[currentSegmentIndex]] = str.slice(currentByte,currentByte+segmentSize);
									currentByte += segmentSize;
									currentSegmentIndex++;
									segmentsNeeded--;
							}
							playerHeap.segments.saveQueue = playerHeap.segments.saveQueue.concat(assigned);
							delete playerHeap.segments.dataSectionsToSave[dataBlockName];
					}
			}
	}
	function checkAssignedSegmentsForDataName(dataName){
			if (Memory.segments[dataName]){
					return Memory.segments[dataName]
			} else {
					if (!dataName.isRoomName()){
							assignSegment(dataName);
					}
					return false
			}
	}
	function requestDefence(room,priority){
			let requests = access('public');
			//console.log('requesting defence to',room.name,'from allies')
			let canPlace = true;
			if (!Array.isArray(requests)){
					save('public',undefined,[]);
					return;
			}
			if (!requests || !foreignSegmentActive){
					return
			} else {
					if (requests){
							for (let i in requests){
									let request = requests[i];
									if (request.requestType !== 1){
											continue
									}
									if (request.roomName && request.roomName === room.name){
											request.priority = priority;
											canPlace = false;
									}
							}
					}
			}
			if (!requests || !Array.isArray(requests)){
					return
			}
			if (canPlace){
					let obj = {
							requestType: 1,
							roomName: room.name,
							priority: priority
					};
					requests.push(obj);
			}
			if (!Memory.defenceRequestExpiries){
					Memory.defenceRequestExpiries = {};
			}
			Memory.defenceRequestExpiries[room.name] = Game.time+250;
			if (requests){
					save('public', undefined, requests);
			}
	}
	function requestResource(room, resource, priority, amount){
	// 		requestType: 0;
	// 		resourceType: ResourceConstant;
	// 		maxAmount?: number;
	// 		roomName: string;
	// 		priority?: number;
	// }
			if (!amount){
					amount = 5000;
			}
			let requests = access('public');
			let canPlace = true;
			if (!Array.isArray(requests)){
					save('public',undefined,[]);
					return;
			}
			let count = 0;
			if (!requests || !foreignSegmentActive){
					return
			} else {
					if (requests){
							for (let i in requests){
									let request = requests[i];
									if (request.requestType !== 0){
											continue
									}
									if (request.resourceType && request.resourceType === 'energy' && Game.time % 15 === 0);
									if (request.resourceType && request.resourceType === resource && request.roomName && request.roomName === room.name){
											request.priority = priority;
											request.maxAmount = amount;
											canPlace = false;
											//remove duplicate
											if (count > 0){
													console.log('removing request duplicates');
													removeResourceRequest(room,resource);
													return
											}
											count++;
									}
							}
					}
			}
			if (!requests || !Array.isArray(requests)){
					return
			}
			if (priority < 0.8 && playerHeap.segments.lastPriorityShareRequest && playerHeap.segments.lastPriorityShareRequest[resource]
					&& Game.time < playerHeap.segments.lastPriorityShareRequest[resource]+3000){
					console.log('block resource request due to recent ally high prio',resource);
					return
			}
			playerHeap.segments.lastRequestedByMe[resource] = Game.time;
			if (canPlace){
					let obj = {
							requestType: 0,
							resourceType: resource,
							maxAmount: amount,
							roomName: room.name,
							priority: priority
					};
					requests.push(obj);
			}
			if (requests){
					save('public', undefined, requests);
			}
	}

	function removeResourceRequest(room, resource){
			let requests = access('public');
			let needSave = false;
			if (!requests){
					console.log('block remove request',requests,foreignSegmentActive);
					return
			} else {
					if (requests){
							for (let i = requests.length - 1; i > -1; i--){
									let request = requests[i];
									if (request.requestType !== 0){
											//console.log('unexpected request type,',typeof request.requestType)
											continue
									}
									if (!request.roomName){
											console.log('borked request removed');
											requests.splice(i, 1);
											needSave = true;
									}
									if (request.resourceType && request.resourceType === resource && request.roomName && request.roomName === room.name){
											console.log('remove request',JSON.stringify(request));
											requests.splice(i, 1);
											needSave = true;
									}
							}
					}
			}
			if (needSave){
					save('public', undefined, requests);
			}
	}
	function removeDefenceRequest(roomName){
			let requests = access('public');
			let needSave = false;
			if (!requests){
					return
			} else {
					if (requests){
							for (let i = requests.length - 1; i > -1; i--){
									let request = requests[i];
									if (request.requestType !== 1){
											continue
									}
									if (request.roomName && request.roomName === roomName){
											requests.splice(i, 1);
											needSave = true;
									}
							}
					}
			}
			if (needSave){
					if (Memory.defenceRequestExpiries && Memory.defenceRequestExpiries[roomName]){
							delete Memory.defenceRequestExpiries[roomName];
					}
					save('public', undefined, requests);
			}
	}
	function getRoadPositions(homeRoomName,targetRoomName){
			if (ready()){
					let seg = access(homeRoomName);
					if (seg && seg.roadPositions){
							if (!seg.roadPositions[homeRoomName]){
									let obj = {};
									obj[homeRoomName] = [];
									save(homeRoomName, 'roadPositions',obj);
									return
							}
							if (seg.roadPositions[targetRoomName]){
									let arr = [];
									for (let i in seg.roadPositions[targetRoomName]){
											let split = seg.roadPositions[targetRoomName][i].split(',');
											let pos = new RoomPosition(split[0],split[1],targetRoomName);
											if (pos.getTerrain() !== 'wall'){
													arr.push();
											}
									}
									return arr
							}
					}
			}
	}

	function setRoadPositions(homeRoomName,targetRoomName,positions){
			if (ready()){
					let seg = access(homeRoomName);
					if (seg){
							let currentData;
							if (!seg.roadPositions || !seg.roadPositions[homeRoomName]){
									currentData = {};
									currentData[homeRoomName] = [];
							} else {
									currentData = seg.roadPositions;
							}
							if (!currentData[targetRoomName]){
									currentData[targetRoomName] = [];
							}
							for (let i in positions){
									let key = positions[i].x+','+positions[i].y;
									if (!currentData[targetRoomName].includes(key)){
											currentData[targetRoomName].push(key);
									}
							}
							save(homeRoomName,'roadPositions',currentData);
					}
			}
	}

	let creepStuckCache = {},blockCreep = {};
	let lastCleared;
	function flowPath(creep,destination,range,options){
			if (!lastCleared || Game.time-lastCleared>1000){
					for (let i in creepStuckCache){
							if (!Game.getObjectById(i)){
									delete creepStuckCache[i];
							}
					}
					for (let i in blockCreep){
							if (!Game.getObjectById(i)){
									delete blockCreep[i];
							}
					}
					lastCleared = Game.time;
			}
			//let cpu = Game.cpu.getUsed()
			let tempDest = destination;
			if (tempDest.pos){
					tempDest = tempDest.pos;
			}
			let destinationKey = tempDest.x+','+tempDest.y;
			if (tempDest.roomName !== creep.pos.roomName){
					destinationKey = tempDest.roomName;
			}
			if ((blockCreep && blockCreep[creep.id] && blockCreep[creep.id]===destinationKey) || (creep.memory.onEdge && creep.memory.onEdge > 4) ){
					creep.say('blocked',true);
					creep.moveTo(destination,{range:range});
					//console.log('flowM',Game.cpu.getUsed()-cpu)
					return
			} else if (blockCreep && blockCreep[creep.id]) {
					delete blockCreep[creep.id];
			}
			creep.say(destinationKey,true);
			if (creep.pos.onEdge()){
					if (creep.memory.onEdge){
							creep.memory.onEdge++;
					} else {
							creep.memory.onEdge = 1;
					}
			} else {
					delete creep.memory.onEdge;
			}
			_flowPath(creep,destination,range,options);
			//console.log('flow',Game.cpu.getUsed()-cpu)
	}
	function _flowPath(creep,destination,range,options){
			//pathing for local economy
			if (!destination || !creep){
					console.log('flow err',creep,destination);
					return
			}
			if (destination.pos){
					destination = destination.pos;
			}
			let addToMatrix = false;
			if ((options && options.addToMatrix) || (destination && destination.structureType && destination.structureType !== 'road')
					|| (destination && destination.energy)){
					//if energy then likely a source
					addToMatrix = true;
			}
			let destinationKey = destination.x+','+destination.y;
			if (destination.roomName !==creep.pos.roomName){
					destinationKey = destination.roomName;
			}
			//use moveTo
			if (creep.room.memory.armedHostiles || (creep.home.memory.dangerousHostileInRemotes && Game.time-creep.home.memory.dangerousHostileInRemotes<5000)){
					creep.moveTo(destination,{range:range});
					return
			}

			if (!addToMatrix && destination.roomName && destination.roomName === creep.home.name){
					if (creep.home.memory.sources){
							for (let s in creep.home.memory.sources){
									let source = Game.getObjectById(creep.home.memory.sources[s]);
									if (source.pos.isNearTo(destination)){
											addToMatrix = true;
									}
							}
					}
					if (!addToMatrix && creep.home.memory.storeContPosition){
							if (creep.memory.storeContPosition === destination.toString()){
									addToMatrix = true;
							}
					}
			}
			if (range === undefined || range === false){
					range = 1;
			}
			let map = getMap(creep.home);
			let positionKey = creep.pos.x+','+creep.pos.y;
			if (destination.roomName && destination.roomName === creep.home.name){
					let rangeTo = creep.pos.getRangeTo(destination);
					if (range && rangeTo <= range) {
							creep.pos.highlight('blue');
							return
					} else if (range === 0 && rangeTo === 1){
							creep.move(creep.pos.getDirectionTo(destination));
							return
					}
			}

			if (map && map[creep.pos.roomName]){
					let localMap = map[creep.pos.roomName];
					if (localMap[positionKey] && localMap[positionKey][destinationKey]){
							//on the correct path - flow in the desired direction
							moveDir(creep,localMap[positionKey][destinationKey],destinationKey);
					} else {
							let neighbours = creep.pos.neighbours();
							for (let i in neighbours){
									let neighbourKey = neighbours[i].x+','+neighbours[i].y;
									if (localMap[neighbourKey] && localMap[neighbourKey][destinationKey]){
											moveDir(creep,localMap[neighbourKey][destinationKey],destinationKey);
											return
									}
							}
							//if neighbour not found then either normal moveTo or gen a path to target and update the map
							if (addToMatrix){
									let pathObj = getPath(creep,destination,range,map);
									if (pathObj && !pathObj.incomplete && pathObj.path){
											pathObj.path.splice(0,0,creep.pos);
											for (let i in pathObj.path){
													let pos = pathObj.path[i];
													pos.highlight('purple');
													if (pos.getTerrain() === 'wall'){
															console.log('flow path borked',creep.name,creep.pos,pos);
															creep.moveTo(destination,{range:range});
															saveMap(creep.home,{});
															return
													}
											}
											savePathToMap(destinationKey,pathObj.path,map);
											saveMap(creep.home,map);
									} else {
											console.log('fp err',JSON.stringify(pathObj));
											blockCreep[creep.id] = destinationKey;
									}
							} else {
									creep.moveTo(destination,{range:range});
							}
					}
			} else if (map){
					map[creep.pos.roomName] = {};
					saveMap(creep.home,map);
			} else if (ready()){
					let map = {};
					saveMap(creep.home,map);
			}
	}
	function getPath(creep,destination,range,map){
			return PathFinder.search(creep.pos, {pos: destination, range: 1}, {
					maxOps: 10000,
					plainCost: 5,
					swampCost: 10,
					maxRooms: 16,
					roomCallback: function (roomName){
							let room = Game.rooms[roomName];
							if (!room){
									return
							}						let costs = room.structureMatrix;
							//todo think about pathing through SK rooms
							if (Game.map.isCoreRoom(roomName) || Game.map.getRoomType(roomName) == 'SK'){
									return false
							}
							costs = blockKeyPositions(costs,room);
							if (ready() && access(creep.home.name) && access(creep.home.name).roadPositions){
									let positions = getRoadPositions(creep.home.name,roomName);
									if (positions){
											for (let i in positions){
													let positionObj = positions[i];
													costs.set(positionObj.x, positionObj.y, 2);
											}
									}
							}
							let exits = room.find(FIND_EXIT);
							for (let i in exits){
									costs.set(exits[i].x,exits[i].y,15);
							}
							if (map){
									if (map[roomName]){
											for (let i in map[roomName]){
													let split = i.split(',');
													costs.set(split[0],split[1],1);
											}
									}
							}
							if (room.memory.sourcePositions && room.controller.my){
									for (let i in room.memory.sourcePositions){
											if (room.memory.sourcePositions[i].pos){
													let pos = room.memory.sourcePositions[i].pos.toPos();
													if (pos && pos.lookAround(LOOK_CREEPS, 0, {filter: (c) => c.role === 'miner1'})[0]){
															let score = 255;
															costs.set(pos.x, pos.y, score);
													}
											}
									}
							}
							if (room && room.controller && room.controller.my && room.memory.upgraderPositions){
									for (let p in room.memory.upgraderPositions){
											let pos = room.memory.upgraderPositions[p].toPos();
											if (pos && costs.get(pos.x,pos.y)<100){
													costs.set(pos.x,pos.y,100);
											}
									}
							}
							return costs;
					},
			})
	}
	function savePathToMap(destinationKey,path,map){
			if (path && map){
					for (let i in path){
							let pos = path[i];
							let nextPos = path[Number.parseInt(i)+1];
							if (pos && nextPos){
									let dir = pos.getDirectionTo(nextPos);
									let posKey = pos.x+','+pos.y;
									if (!map[pos.roomName]){
											map[pos.roomName] = {};
									}
									if (!map[pos.roomName][posKey]){
											map[pos.roomName][posKey] = {};
									}
									map[pos.roomName][posKey][destinationKey] = dir;
							}
					}
			}
	}
	function moveDir(creep,dir,targetID){
			let posStr = creep.pos.toString();
			let notStuck;
			if (creepStuckCache[creep.id]){
					notStuck = creepStuckCache[creep.id].pos !== posStr;
			}
			if (creep.pos && creep.pos.onEdge() && notStuck){
					if (creep.pos.oppositeEdge().toString() === posStr){
							notStuck = false;
					}
			}
			if (!creepStuckCache[creep.id] || notStuck){
					creepStuckCache[creep.id] = {
							pos:posStr,
							time:1
					};
			} else {
					creepStuckCache[creep.id].time++;
					if (creepStuckCache[creep.id].time > 5){
							blockCreep[creep.id] = targetID;
							return
					} else {
							let inWayCreep = creep.pos.movePos(dir).creepAtPosition;
							if (inWayCreep){
									addInWayCreep(creep,inWayCreep,dir);
							}
					}
			}
			creep.pos.highlight('orange');
			creep.move(dir);
	}
	function getMap(home){
			if (ready()){
					let roomData = access(home.name);
					if (roomData.pathingNodesMap){
							return roomData.pathingNodesMap
					} else {
							return {}
					}
			}
	}
	function addInWayCreep(creep,inWayCreep,dir){
			let inWayCreeps = Memory.inWayCreeps;
			if (inWayCreep && !inWayCreep.my){
					return
			}
			if (inWayCreep && inWayCreep.role === 'miner1'){
					if (!inWayCreep.memory.inPos){
							inWayCreep.move(creep);
							creep.move(inWayCreep);
							creep.pull(inWayCreep);
					}
			} else if (inWayCreep){
					let pushDir = dir.map8(4);
					let try1, try2;
					if (!config$1.official && creep.role !== 'guard'){
							try1 = inWayCreep.pos.movePos(dir.map8(2));
							try2 = inWayCreep.pos.movePos(dir.map8(-2));
					}
					if (creep.room.class === 'bunker' && creep.room.memory.armedHostiles){
							inWayCreeps.push([inWayCreep.id, pushDir]);
					}else if (try1 && try1.isWalkable(true)){
							inWayCreeps.push([inWayCreep.id, dir.map8(2)]);
					} else if (try2 && try2.isWalkable(true)){
							inWayCreeps.push([inWayCreep.id, dir.map8(-2)]);
					} else {
							inWayCreeps.push([inWayCreep.id, pushDir]);
					}
			}
	}
	function saveMap(home,map){
			if (ready()){
					if (map){
							save(home.name,"pathingNodesMap",map);
					}
			}
	}

	playerHeap.energyDropTargetManager = {};
	playerHeap.energyDropTargetManager.roomCache = {};
	let gameTime = {};
	playerHeap.energyDropTargetManager.reservationsAllRooms = {};
	playerHeap.energyDropTargetManager.creepReservations = {};
	const cpuThreshold$2 = 3000;
	let lastReset$2 = {};
	playerHeap.energyDropTargetManager.creepDropTargets = {};
	//find energy targets within the room and reserve them so there are not two creeps going for the same energy
	function findEnergyDropTarget(room, creep){
			if (!room || !room.name || !creep || !creep.name){
					console.log('energy target mananager error');
					return
			}
			if (!playerHeap.energyDropTargetManager.reservationsAllRooms[room.name]){
					playerHeap.energyDropTargetManager.reservationsAllRooms[room.name] = {};
			}
			if (!lastReset$2[room.name]){
					lastReset$2[room.name] = Game.time;
			}
			let reservations = playerHeap.energyDropTargetManager.reservationsAllRooms[room.name];
			if (!lastReset$2[room.name] || (Game.time - lastReset$2[room.name]) > 15){
					for (let i in playerHeap.energyDropTargetManager.creepReservations){
							if (!Game.getObjectById(i) || !Game.getObjectById(i).store['energy']){
									deleteReservation$3(i, playerHeap.energyDropTargetManager.creepReservations[i][0]);
							}
					}
					for (let i in playerHeap.energyDropTargetManager.creepDropTargets){
							if (!Game.getObjectById(i) || !Game.getObjectById(i).store['energy']){
									delete playerHeap.energyDropTargetManager.creepDropTargets[i];
							}
					}
					lastReset$2[room.name] = Game.time;
			}
			if (playerHeap.energyDropTargetManager.creepReservations[creep.id]){
					let target = Game.getObjectById(playerHeap.energyDropTargetManager.creepReservations[creep.id][0]);
					if (target){
							if (creep.room.name === creep.home.name && creep.home.total('energy') > creep.home.memory.reserve
									&& Game.cpu.bucket > 9500 && creep.pos.getRangeTo(creep.home.controller.pos)<10 && creep.home.class === 'normal'){
									//redirect creeps near upLink if needed
									if (room.memory.manualLoadUpLink && room.memory.uplink){
											let upLink = Game.getObjectById(room.memory.uplink);
											if (upLink && upLink.id !== target.id && upLink.store.getFreeCapacity('energy')>200
											&& (!reservations[upLink.id] || reservations[upLink.id].length < 3)){
													deleteReservation$3(creep.id,playerHeap.energyDropTargetManager.creepReservations[creep.id][0]);
													placeReservation$3(creep, upLink);
													giveToTarget(creep, upLink);
													return true
											}
									}
							}
							giveToTarget(creep, target);
					} else if (playerHeap.energyDropTargetManager.creepReservations[creep.id][0] === 'origin'){
							let origin;
							if (room.memory.fixedBaseOrigin){
									origin = room.memory.fixedBaseOrigin.toPos();
							}
							if (!origin || creep.home.memory.storeContPosition){
									origin = creep.home.memory.storeContPosition.toPos();
							}
							if (creep.pos.isEqualTo(origin)){
									creep.drop('energy');
							} else {
									//creep.moveTo(origin,{range:0})
									flowPath(creep,origin,0);
							}
					} else {
							delete playerHeap.energyDropTargetManager.creepReservations[creep.id];
					}
					return true
			} else {
					if (!playerHeap.energyDropTargetManager.roomCache[room.name] || !gameTime[room.name]|| gameTime[room.name] !== Game.time){
							let targets = [];
							if (room.storage){
									targets.push(room.storage);
							} else if (room.memory.storeCont && Game.getObjectById(room.memory.storeCont)){
									targets.push(Game.getObjectById(room.memory.storeCont));
							} else if (room.memory.staticFillerContainer && Game.getObjectById(room.memory.staticFillerContainer)){
									targets.push(Game.getObjectById(room.memory.staticFillerContainer));
							}
							if (room.memory.uplink && Game.getObjectById(room.memory.uplink) && room.memory.manualLoadUpLink){
									targets.push(Game.getObjectById(room.memory.uplink));
							} else if (room.memory.upCont && Game.getObjectById(room.memory.upCont)){
									targets.push(Game.getObjectById(room.memory.upCont));
							}

							if (playerHeap.energyDropTargetManager.creepDropTargets && playerHeap.energyDropTargetManager.creepDropTargets[room.name]){
									let localCreepDropTargets = playerHeap.energyDropTargetManager.creepDropTargets[room.name];
									for (let i in localCreepDropTargets){
											if (localCreepDropTargets[i] && localCreepDropTargets[i] > Game.time-5){
													let target = Game.getObjectById(i);
													if (target && target.room.name && target.room.name === room.name && target.store.getFreeCapacity() > 0){
															targets.push(target);
													}
											}
									}
							}

							playerHeap.energyDropTargetManager.roomCache[room.name] = targets;
							gameTime[room.name] = Game.time;
					}
					let targetCache = playerHeap.energyDropTargetManager.roomCache[room.name];
					let targets = [];
					let possibleDropTargets = targetCache;
					let adjustedEnergy = {};
					let linkDrop;
					for (let i in possibleDropTargets){
							if (targets.length > 0 && Game.cpu.bucket < cpuThreshold$2){
									break
							}
							let possibleDropTarget = possibleDropTargets[i];
							if (possibleDropTarget){
									let amount = possibleDropTarget.store['energy'];
									if (reservations[possibleDropTarget.id]){
											for (let r in reservations[possibleDropTarget.id]){
													amount += reservations[possibleDropTarget.id][r];
											}
									}
									adjustedEnergy[possibleDropTarget.id] = amount;
									if (amount < (possibleDropTarget.store.getCapacity()) || (possibleDropTarget.structureType && possibleDropTarget.structureType === 'link' && amount < LINK_CAPACITY*1.3) || (possibleDropTarget.structureType && possibleDropTarget.structureType !== 'link' && amount < 6000)){
											targets.push(possibleDropTarget);
											if (possibleDropTarget.structureType === 'link'){
													linkDrop = true;
											}
									}
							}
					}
					if (playerHeap.energyDropTargetManager.creepReservations[creep.id]){
							return true
					}
					let noStore = !room.storage && (!room.memory.storeCont || !Game.getObjectById(room.memory.storeCont));
					if (targets && !noStore && targets.length > 0){
							if (Game.cpu.bucket > cpuThreshold$2){
									targets.sort((a, b) => {
											if (creep.room.name === room.name) {
													return a.pos.getRangeTo(creep) - b.pos.getRangeTo(creep)
											}
									});
							}
							let upLoadCont;
							if (creep.home.memory.upLoadCont){
									upLoadCont = Game.getObjectById(creep.home.memory.upLoadCont);
							}
							let checkOrder = ['storageLow','storeCont','staticFillerContainer','upCont','upLink','storage'];
							let conditions = {
									'storageLow': {
											condition: ()=>(room.total('energy')<room.memory.reserve),
											target: room.storage
									},
									'storeCont': {
											condition: ()=> (!room.storage && ((room.memory.bigSites && (creep.num%3!==0))
													|| room.controller.level === 4 || adjustedEnergy[room.memory.storeCont]<2000
															|| (room.memory.upCont && adjustedEnergy[room.memory.upCont] > 2000 && (room.controller.progressTotal-room.controller.progress) < 5000)) &&
											(!targets[0] || !targets[0].body)),
											target: room.memory.storeCont && Game.getObjectById(room.memory.storeCont)
									},
									'staticFillerContainer': {
											condition: (target)=>((!room.memory.storeCont || !Game.getObjectById(room.memory.storeCont))
													&& target.store.getFreeCapacity()>500
													&& checkContainerEnergy(target) < 1700),
											target: room.memory.staticFillerContainer && Game.getObjectById(room.memory.staticFillerContainer)
									},
									'upCont':{
											condition: (target)=>((!room.memory.upContEnergy || room.memory.upContEnergy < 1000 || !room.storage ||
													(room.memory.storeCont && adjustedEnergy[room.memory.storeCont] > 3000)
															|| target.store.getFreeCapacity()>0 ) && !room.memory.staticUpgradersHelpBuild &&
													(!targets[0] || !targets[0].body)),
											target: room.memory.upCont && Game.getObjectById(room.memory.upCont)
									},
									'upLink':{
											condition: ()=>((creep.role === 'upHauler' || creep.memory.role === 'upHauler' || linkDrop || (upLoadCont && upLoadCont.store.getFreeCapacity()>0))
													&& room.memory.manualLoadUpLink),
											target: room.memory.uplink && Game.getObjectById(room.memory.uplink)
									},
									'storage':{
											condition: ()=>(!targets[0] ||
													(room.storage && !targets[0].store.getFreeCapacity())),
											target: room.storage
									}
							};
							for (let i in checkOrder){
									let target = conditions[checkOrder[i]].target;
									if (target && conditions[checkOrder[i]].condition(target)){
											targets[0] = conditions[checkOrder[i]].target;
											break
									}
							}
							function checkContainerEnergy(target){
									let level = 0;
									if (target && target.id && adjustedEnergy[target.id] && adjustedEnergy[target.id]){
											level = adjustedEnergy[target.id];
									} else if (target.store && target.store['energy']){
											level = target.store['energy'];
									}
									return level
							}
							if (targets[0]){
									placeReservation$3(creep, targets[0]);
									creep.memory.lastDropPos = {pos:targets[0].pos.toString(),expiry:Game.time +100};
									giveToTarget(creep, targets[0]);
									return true
							}
					} else {
							if (!noStore && (creep.role === 'upHauler'|| creep.memory.role === 'upHauler') && !room.memory.staticUpgradersHelpBuild && room.memory.upCont && Game.getObjectById(room.memory.upCont)
							&& (!room.storage || !room.memory.upContEnergy || room.memory.upContEnergy < 1000)){
									let target = Game.getObjectById(room.memory.upCont);
									placeReservation$3(creep, target);
									giveToTarget(creep, target);
									return true
							}
							if (room.memory.fixedBaseOrigin && room.memory.fixedBaseOrigin.toPos() && (noStore||creep.role !== 'upHauler'&& creep.memory.role !== 'upHauler')){
									playerHeap.energyDropTargetManager.creepReservations[creep.id] = ['origin'];
									return true
							} else if (!room.memory.fixedBaseOrigin && room.memory.storeContPosition && room.memory.storeContPosition.toPos()){
									playerHeap.energyDropTargetManager.creepReservations[creep.id] = ['origin'];
									return true
							}
							return false
					}
			}
	}

	function setCreepAsDropTarget(room,creep){
			let targetCache = playerHeap.energyDropTargetManager.creepDropTargets[room.name];
			if (targetCache){
					targetCache[creep.id] = Game.time;
			} else {
					playerHeap.energyDropTargetManager.creepDropTargets[room.name] = {};
			}
	}
	function giveToTarget(creep, target){
			if (creep.room.name === target.room.name){
					new RoomVisual (creep.room.name).line(creep.pos,target.pos,{color:'yellow'});
			}
			if (target.structureType === STRUCTURE_CONTAINER){
					if (!creep.pos.isEqualTo(target.pos)){
							if (creep.pos.isNearTo(target)){
									if (target.store.getFreeCapacity() > 0){
											let ret = creep.transfer(target, 'energy');
											if (ret === 0 && target.store.getFreeCapacity() > creep.store.getUsedCapacity()){
													return
											}
									} else {
											let inPosCreep = target.pos.lookAround(LOOK_CREEPS,0)[0];
											if (inPosCreep && inPosCreep.store['energy'] && inPosCreep.memory.dropping && target.role === 'yak'){
													let ret = creep.transfer(inPosCreep, 'energy');
													if (ret === 0){
															return
													}
											} else if (inPosCreep){
													let dir = creep.pos.getDirectionTo(inPosCreep);
													creep.move(dir);
													inPosCreep.move(dir.map8(4));
													return
											}
									}
							}
							//creep.moveTo(target, {range: 0})
							flowPath(creep,target,0);
					} else {
							creep.drop('energy');
					}
			} else {
					if (target.store.getFreeCapacity('energy')<200 && creep.home.memory.upLoadCont && Game.getObjectById(creep.home.memory.upLoadCont)){
							let upLoadCont = Game.getObjectById(creep.home.memory.upLoadCont);
							if (creep.pos.isEqualTo(upLoadCont)){
									creep.drop('energy');
							} else {
									//creep.moveTo(upLoadCont,{range:0})
									flowPath(creep,upLoadCont,0);
							}
					} else {
							if (creep.pos.isNearTo(target)){
									creep.transfer(target,'energy');
							} else {
									//creep.moveTo(target, {range: 1})
									flowPath(creep,target,1);
							}
					}
			}
	}

	function deleteReservation$3(id, targetID){
			let roomName = playerHeap.energyDropTargetManager.creepReservations[id][1];
			delete playerHeap.energyDropTargetManager.creepReservations[id];
			if (roomName){
					let reservations = playerHeap.energyDropTargetManager.reservationsAllRooms[roomName];
					if (reservations[targetID]){
							delete reservations[targetID][id];
					}
			}
	}

	function placeReservation$3(creep, target){
			playerHeap.energyDropTargetManager.creepReservations[creep.id] = [target.id, target.pos.roomName];
			if (target.pos && target.pos.roomName){
					let reservations = playerHeap.energyDropTargetManager.reservationsAllRooms[target.pos.roomName];
					if (!reservations[target.id]){
							reservations[target.id] = {};
					}
					reservations[target.id][creep.id] = creep.store['energy'];
			}
	}

	function run$13 (creep){
			creep.room.name;
			var homeRoom = Game.rooms[creep.name.split(' ')[2]];
			homeRoom.name;
			if (homeRoom.memory.uplink && homeRoom.memory.linkstore){
					var uplink = Game.getObjectById(homeRoom.memory.uplink);
			} else {
					var uplink = null;
			}
			if (homeRoom.memory.armedHostiles && !homeRoom.controller.safeMode == undefined){
					return
			}
			if (creep.hits < creep.hitsMax/2 && creep.home.controller.level < 3){
					creep.suicide();
			}
			var stores = creep.room.storage;
			var num = creep.name.split(' ')[1];
			if (creep){
					if (creep.num != 1 && creep.home && !creep.home.storage && creep.home.memory.sites && Game.getObjectById(creep.home.memory.sites)
							&& (!creep.home.controller.safeMode || creep.home.controller.level > 2 || (config.conserveCpu && creep.home.memory.lotsOfDroppedEnergySlowChange && creep.num % 2 !== 0)
									|| (creep.home.memory.lotsOfDroppedEnergySlowChange && Game.cpu.bucket > 8000 && creep.num % 2 !== 0)
							)
							&& Game.getObjectById(creep.home.memory.sites).structureType != STRUCTURE_ROAD && creep.home.controller.level > 1 && creep.name.split(' ')[0] != 'builder'){
							run$12(creep);
							return
					}
					if (homeRoom.controller.ticksToDowngrade < 5000){
							var limit = 0;
					} else if (homeRoom.memory.reserve){
							var limit = homeRoom.memory.reserve;
					} else {
							var limit = 30000;
					}
					if (creep.memory.upgrading && creep.store['energy'] == 0){
							creep.memory.upgrading = false;
							creep.say('collecting');
					}
					if (!creep.memory.upgrading && creep.store['energy'] == creep.store.getCapacity()){
							creep.memory.upgrading = true;
							creep.say('upgrading');
					}
					if (homeRoom.memory.sites && !homeRoom.storage && creep.home.controller.level > 2 && (num > 1 || creep.home.memory.defcon < 5)){
							let site = Game.getObjectById(homeRoom.memory.sites);
							if (site.structureType != STRUCTURE_ROAD && homeRoom.memory.bigSites){
									creep.memory.role = 'builder';
							} else if ( creep.home.memory.defcon < 5){
									creep.memory.role = 'fixer';
							}
					} else if (creep.home.memory.defcon < 5 && creep.home.controller.level > 2 && creep.home.controller.ticksToDowngrade > CONTROLLER_DOWNGRADE[creep.home.controller.level] * 0.5 &&
					creep.home.memory.adjustedLowWallHits < config.minWalls[7]){
							creep.memory.role = 'fixer';
					}
					if (creep.memory.boost != true && creep.memory.boost != false && !Memory.emergency && creep.ticksToLive > 1400 && homeRoom.controller && homeRoom.controller.level >= 6 && stores && stores.store['energy'] > limit){
							var lab = creep.room.find(FIND_STRUCTURES, {filter: (structure) => structure.structureType == STRUCTURE_LAB && structure.mineralType == 'XGH2O' && structure.store[structure.mineralType] > 500 && structure.store['energy'] > 400})[0];
							if (lab && creep.ticksToLive > 1400){
									if (!creep.pos.isNearTo(lab)){
											creep.moveTo(lab);
									} else if (lab.boostCreep(creep) == 0){
											creep.memory.boost = true;
									}
							} else {
									creep.memory.boost = false;
							}
					} else if (creep.memory.upgrading){
							if (creep.home.controller.level < 8){
									creep.store.getCapacity();
							}
							if (creep.home.memory.storeCont && Game.getObjectById(creep.home.memory.storeCont) && Game.getObjectById(creep.home.memory.storeCont).store['energy']<500
									&& countRole('yak',creep.home)<3 && creep.num < 4){
									findEnergyDropTarget(creep.home,creep);
									return
							}
							let upgradeRet = creep.upgradeController(homeRoom.controller);
							if (upgradeRet == ERR_NOT_IN_RANGE || (homeRoom.controller.level < 4 && creep.pos.getRangeTo(homeRoom.controller) > 3)){
									if (creep.num > 5); else if (creep.num > 10);
									creep.moveTo(homeRoom.controller, {range: 2});
							} else if (homeRoom.controller.level > 4){
									if (!uplink && num == 1 && stores && creep.room.controller.pos.lookAround(LOOK_CONSTRUCTION_SITES, 4, {filter: (s) => s.structureType == STRUCTURE_LINK}).length == 0
											&& creep.room.controller.pos.lookAround(LOOK_STRUCTURES, 4, {filter: (s) => s.structureType == STRUCTURE_LINK}).length == 0){
											if (creep.pos.getRangeTo(creep.room.controller) < 4){
													if (creep.home.memory.upContPos){
															let pos = creep.home.memory.upContPos.toPos();
															if (creep.home.memory.upCont){
																	let upCont = Game.getObjectById(homeRoom.memory.upCont);
																	creep.say(upCont);
																	if (upCont){
																			upCont.destroy();
																	}
															}
															if (!creep.home.memory.thoriumMineSupportRoom){
																	pos.createConstructionSite(STRUCTURE_LINK);
															}
													}
											} else {
													creep._moveTo(creep.room.controller, {range: 3});
											}
									}
							}


					} else if (stores != null && uplink && creep.home && !creep.home.controller.isAtReducedLevel()){
							if (uplink && (!creep.pos.isNearTo(uplink))){
									creep.moveTo(uplink, {range: 1});
							} else if (uplink && uplink.store['energy'] > 0 && creep.ticksToLive > 15){
									creep.withdraw(uplink, 'energy');
							} else if (config.conserveCpu){
									creep.startNap(2);
							}
					} else {
							if (creep.ticksToLive < 10){
									creep.suicide();
							}
							let upCont = null;
							if (!uplink){
									if (homeRoom.memory.upCont){
											upCont = Game.getObjectById(homeRoom.memory.upCont);
											if (!upCont){
													delete homeRoom.memory.upCont;
											}
									} else {
											delete creep.memory.container;
											if (creep.home.memory.upContPos){
													let position = creep.home.memory.upContPos.toPos();
													let container = position.lookAround(LOOK_STRUCTURES, 0, {filter: (s) => s.structureType == STRUCTURE_CONTAINER})[0];
													if (container){
															homeRoom.memory.upCont = container.id;
													} else {
															position.createConstructionSite(STRUCTURE_CONTAINER);
													}
											} else if (creep.num == 1){
													creep.findContainer(homeRoom.controller, 3, true);
													if (creep.memory.container){
															homeRoom.memory.upCont = creep.memory.container;
													}
											}
									}
							} else if (uplink && uplink.store['energy'] > 0){
									creep.say('no pos');
									creep.goAndWithdraw(uplink, 'energy', 1);
									return
							}
							if (stores && (stores.store['energy'] > limit || creep.memory.boost == true || creep.room.controller.ticksToDowngrade < 20000 || creep.room.controller.isAtReducedLevel())){
									if (creep.withdraw(stores, 'energy') != 0){
											creep.moveTo(stores, {range: 1});
									}
							} else {
									creep.findEnergyTarget();
							}
					}
			}
	}


	let spawnCode$z = {
			priority: (room, countFunction) => {
					let upgraderCount = countFunction('upgrader',room)+countFunction('staticUpgrader',room);
					let priority = 45;
					if (room.memory.sites || (room.memory.upCont && Game.getObjectById(room.memory.upCont)
							&& Game.getObjectById(room.memory.upCont).store['energy'] == 0)){
							priority += 10;
					} else if (room.storage && room.memory.reserve && room.storage['energy'] > room.memory.reserve * 1.1){
							priority -= 20;
					} else if ((room.memory.upCont && Game.getObjectById(room.memory.upCont)
							&& Game.getObjectById(room.memory.upCont).store.getFreeCapacity() < 200)){
							priority -= 20;
					}
					if (room.storage && room.storage['energy'] < room.memory.reserve){
							priority -= 20;
					}
					if (room.controller.safemode && room.controller.ticksToDowngrade < CONTROLLER_DOWNGRADE[room.controller.level] * 0.8){
							priority = 20;
					}
					if (room.memory.priorityEnergyRoom && room.total('energy') > room.memory.reserve * 1.1){
							priority = 20;
					}
					if (config.requestEnergyRoom && config.requestEnergyRoom.includes(room.name)){
							priority = 20;
					}
					if (room.controller.level === 1 && upgraderCount < 1 && room.memory.sourcelist){
							priority = 5;
					} else if (room.controller.level === 1 && upgraderCount < 4 && room.memory.sourcelist){
							priority = 10;
					}
					if (room.controller.level < 3 && room.controller.safeMode){
							priority = 20;
					}
					if (!room.storage && room.memory.lotsOfDroppedEnergy){
							priority -= 10;
					}
					priority += upgraderCount * 3;
					return priority
			},
			isRequired: (room, countFunction,idleSpawn) => {
					let numberRequired = 1;
					let upgraderCount = countFunction('upgrader',room)+countFunction('staticUpgrader',room);
					if (room.controller.level === 8 && ((room.memory.walls < config.wallTarget) || Memory.emergency || (Memory.energyNeeded && Memory.energyNeeded.length > 0 && Game.energyCaution))){
							numberRequired = 0;
					}
					if (room.storage && room.controller.level > 4 && upgraderCount > 0){
							return false
					}
					if (countFunction('upgrader',room)<1 && room.controller.ticksToDowngrade < CONTROLLER_DOWNGRADE[room.controller.level] * 0.75 && room.total('energy')>0){
							return true
					} else if (!idleSpawn && ((room.memory.upCont && Game.getObjectById(room.memory.upCont))||(room.memory.uplink && Game.getObjectById(room.memory.uplink)))){
							//use static upgraders instead
							if (room.memory.droppedEnergyCount > 5000 && room.controller.level < 4){
									let numberRequired = Math.ceil(room.memory.droppedEnergyCount/1000);
									if (room.memory.upgraderPositions && countFunction('staticUpgrader',room) >= room.memory.upgraderPositions.length
									&& countFunction('upgrader',room)<numberRequired){
											return true
									}
							}
							return false
					}
					if (room.class === 'bunker' && room.memory.adjustedLowWallHits && room.controller.level > 4 && room.memory.adjustedLowWallHits < config.minWalls[7]){
							return false
					}
					if (room.terminal && room.total('energy') < room.memory.reserve * 1.5 && (Memory.emergency || Memory.energyCrisis)){
							return upgraderCount < numberRequired
					}
					let workerParts = 20;
					if (room.memory.assignedSourceData && room.memory.assignedSourceData.currentWorkerParts){
							workerParts = Number.parseInt(room.memory.assignedSourceData.currentWorkerParts);
					}

					if (config.requestEnergyRoom && config.requestEnergyRoom.includes(room.name) && room.storage && room.storage.store[RESOURCE_ENERGY] > room.memory.reserve * 1.3){
							workerParts += 30;
					} else if (room.storage && room.storage.store[RESOURCE_ENERGY] > room.memory.reserve * 1.3){
							workerParts += 20;
					} else if (room.storage && room.storage.store[RESOURCE_ENERGY] > room.memory.reserve * 1.2){
							workerParts += 10;
					} else if (numberRequired > 1 && room.storage && room.storage.store[RESOURCE_ENERGY] < room.memory.reserve + 3000 && room.storage.store[RESOURCE_ENERGY] > room.memory.reserve){
							workerParts -= 10;
					}
					if (room.controller.level < 8){
							let body = spawnCode$z.body(room, countFunction).body;
							if (room.memory.sites){
									if ((room.memory.storeCont && room.memory.upCont) || (room.storage && room.memory.uplink)){
											numberRequired = Game.bodySizeToNumberNeeded(workerParts / 2, body, WORK);
									} else {
											//half the time spent travel
											numberRequired = Game.bodySizeToNumberNeeded(workerParts, body, WORK);
									}
							} else {
									if ((room.memory.storeCont && room.memory.upCont) || (room.storage && room.memory.uplink)){
											numberRequired = Game.bodySizeToNumberNeeded(workerParts, body, WORK);
									} else {
											//half the time spent travel
											numberRequired = Game.bodySizeToNumberNeeded(workerParts * 2, body, WORK);
									}
							}
					}
					if (idleSpawn && numberRequired){
							let adjust = 1.5;
							if (room.controller.level < 4){
									adjust = 2;
							}
							if (!room.memory.remoteContainers || room.controller.level < 3){
									adjust = 3;
							}
							numberRequired = Math.round(numberRequired*adjust);
					}
					if (numberRequired > 1 && room.terminal && room.isEnergyDonor){
							if (room.controller.ticksToDowngrade < CONTROLLER_DOWNGRADE[room.controller.level] * 0.7){
									numberRequired = 1;
							} else {
									numberRequired = 0;
							}
					}
					if (room.memory.armedHostiles && room.controller.safeMode == undefined){
							numberRequired = 0;
					}
					if (numberRequired > upgraderCount && upgraderCount > 0 && room.storage && room.total('energy') < room.memory.reserve){
							return false
					}
					if (numberRequired > upgraderCount && upgraderCount > 1 && room.storage && room.total('energy') < room.memory.reserve + 1000){
							return false
					}
					if ((room.controller.level === 8 || room.memory.thoriumMineSupportRoom) && numberRequired > 1){
							numberRequired = 1;
					}
					if (config.level7max && room.controller.level > 6 && numberRequired > 1){
							numberRequired = 1;
					}
					let count = countFunction('upgrader', room);
					if (Game.cpu.bucket > 5000 && room.controller.level < 6){
							let newCount = countRoleAdjustingForParts('upgrader',room,spawnCode$z.body(room,countFunction));
							if (newCount !== undefined){
									count = newCount;
							}
					}
					return count < numberRequired;
			},
			spawn: (room, role, body) => {
					//decide if we need any other options
					if (body){
							//options -> TTL, creepnumber
							room.spawnCreep(role, body);
					}
			},
			body: (room, countFunction) => {
					if (room.memory.roadsDown === undefined){
							room.memory.roadsDown = false;
					}
					let bodyObject = {
							body: [],
							cost: 0
					};
					let body;
					//decide on what body to have

					let limitEnergyCap = room.energyCapacityAvailable;
					if (!config.conserveCpu && Game.cpu.bucket > 9000 && room.energyCapacityAvailable > 300 && (!room.storage || !room.memory.storeCont)){
							limitEnergyCap = room.energyCapacityAvailable/1.5;
					}
					let storage;
					if (room.storage || (room.memory.storeCont && Game.getObjectById(room.memory.storeCont))){
							storage = true;
					}
					let max;
					if (room.controller.level === 8){
							max = 20;
					} else if (room.controller.level > 2){
							max = 15;
					}
					if (config.level7max && room.controller.level > 6){
							max = 6;
					}
					body = getBody$5(limitEnergyCap,room, room.memory.roadsDown, 'upgrader',max,storage);
					bodyObject.body = body;
					if (bodyObject.body && bodyObject.body.length > 0){
							bodyObject.cost += Game.getBodyCost(bodyObject.body);
					}
					return bodyObject
			}
	};

	var upgrader = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$13,
		spawnCode: spawnCode$z
	});

	function run$12(creep){
			creep.room.name;
			var homeRoom = Game.rooms[creep.name.split(' ')[2]];
			homeRoom.name;
			creep.name.split(' ')[1];
			let limit = 1000;
			if (creep.home.controller.level > 7){
					limit = 75000;
			} else if (creep.home.controller.level > 5){
					limit = 50000;
			} else if (creep.home.controller.level > 4){
					limit = 10000;
			}
			if (!creep.home.memory.bigSites && creep.home.storage){
					limit = creep.home.memory.reserve;
			} else {
					limit = creep.home.memory.reserve-10000;
			}
			if (config.forceFill && config.forceFill === creep.home.name){
					limit = 1000;
			}

			if (creep.memory.building && creep.store['energy'] == 0){
					creep.memory.building = false;
					creep.say('collecting');
			}
			if (!creep.memory.building && creep.store['energy'] == creep.store.getCapacity()){
					creep.memory.building = true;
					creep.say('building');
			}
			if (creep.home.memory.armedHostiles){
					creep.memory.role = 'fixer';
					return
			}
			let target = Game.getObjectById(Memory.rooms[homeRoom.name].sites);
			if (creep.memory.building){
					if ((!creep.home.memory.bigSites || creep.role === 'staticUpgrader') && creep.store.getUsedCapacity() < creep.store.getCapacity()*0.5){
							//big sites will likely be close to store so no need to have builder as drop target
							setCreepAsDropTarget(creep.home,creep);
					}
					Game.getObjectById(homeRoom.memory.ramparts);
					if (creep.home.memory.storeCont && Game.getObjectById(creep.home.memory.storeCont) && Game.getObjectById(creep.home.memory.storeCont).store['energy']<500
							&& countRole('yak',creep.home)<3 && creep.num < 4 && creep.home.controller.level !== 4){
							findEnergyDropTarget(creep.home,creep);
							return
					}
					if (creep.home.controller && creep.home.controller.progressTotal < creep.home.controller.progress){
							if (!creep.pos.inRangeTo(creep.home.controller, 3)){
									creep.moveTo(creep.home.controller, {range: 3});
							} else {
									creep.upgradeController(creep.home.controller);
							}
							return
					}
					if (creep.memory.rampart && creep.memory.rampart.toPos()){
							let pos = creep.memory.rampart.toPos();
							let structure = _.filter(pos.lookFor(LOOK_STRUCTURES), (s) => s.structureType == STRUCTURE_RAMPART)[0];
							if (structure){
									if (structure && structure.hits < 20000){
											if (creep.pos.inRangeTo(structure, 3)){
													creep.repair(structure);
											} else {
													creep.moveTo(structure, {range: 3});
											}
									} else {
											delete creep.memory.rampart;
									}
							} else {
									let site = _.filter(pos.lookFor(LOOK_CONSTRUCTION_SITES), (s) => s.structureType == STRUCTURE_RAMPART)[0];
									if (site){
											if (creep.pos.inRangeTo(site, 3)){
													creep.build(site);
											} else {
													creep.moveTo(site, {range: 3});
											}
									} else {
											delete creep.memory.rampart;
									}
							}
					} else if (target != null){
							if (target.structureType == STRUCTURE_RAMPART){
									creep.memory.rampart = (target.pos).toString();
							}
							if (creep.build(target) == ERR_NOT_IN_RANGE){
									//define destination
									creep.moveTo(target, {range: 3});
							}
					} else if (creep.room.memory.plannedSites && creep.room.memory.plannedSites.length > 0 && Memory.sites < 80){
							let AllSites = creep.room.find(FIND_CONSTRUCTION_SITES).length;
							if ((AllSites && AllSites < 1) || !AllSites){
									let potentialSite = creep.room.memory.plannedSites[0];
									let type = potentialSite[0];
									let pos = potentialSite[1].toPos();
									if (type && pos && pos.createConstructionSite(type) == 0){
											creep.room.memory.plannedSites.shift();
											Memory.sites += 1;
									} else if (type && pos){
											let structure = pos.lookFor(LOOK_STRUCTURES).find((s) => s.structureType == type);
											if (structure){
													creep.room.memory.plannedSites.shift();
											}
									}
							}
					} else if (!Memory.priorityEnergyRoomName && homeRoom.controller.level > 6 && homeRoom.storage && homeRoom.memory.reserve && homeRoom.storage.store['energy'] > homeRoom.memory.reserve){
							if (creep.name.split(' ')[0] === 'fixer'){
									delete creep.memory.role;
							} else {
									run$1h(creep);
							}
					} else if ((!Memory.priorityEnergyRoomName || !homeRoom.terminal) && homeRoom.controller.level < 8){
							if (creep.name.split(' ')[0] === 'upgrader'){
									delete creep.memory.role;
									return
							}
							if (homeRoom.memory.upCont && Game.getObjectById(homeRoom.memory.upCont)){
									let upCont = Game.getObjectById(homeRoom.memory.upCont);
									if (upCont && upCont.store['energy']< upCont.store.getCapacity()){
											creep.goAndTransfer(upCont,'energy',1);
									} else {
											run$13(creep);
									}
							} else {
									run$13(creep);
							}
					} else {
							creep.rally(1, 5);
					}
			} else {
					let sources;
					if (creep.room.storage && (creep.room.storage.my == false || (creep.room.storage.store[RESOURCE_ENERGY] &&
							creep.room.class == 'restructuring') || creep.room.storage.store[RESOURCE_ENERGY] > limit)){
							sources = homeRoom.storage;
					}
					if (!sources && creep.home.terminal && creep.home.terminal.store['energy'] > 0){
							sources = creep.home.terminal;
					}
					if (!sources || (creep.home.controller.level < 4)){
							if (!creep.home.memory.bigSites || creep.role === 'staticUpgrader'){
									setCreepAsDropTarget(creep.home, creep);
							}
							creep.say('me');
							creep.findEnergyTarget();
							return
					}
					if (sources != null){
							if (creep.withdraw(sources, RESOURCE_ENERGY) == ERR_NOT_IN_RANGE){
									creep.moveTo(sources, {range: 1});
							}
					}
			}


	}

	let spawnCode$y = {
			priority: (room, countFunction) => {
					let priority = 40;
					if (room.storage && room.memory.reserve && room.storage.store['energy'] > room.memory.reserve){
							priority -= 20;
					} else if (room.memory.storeCont && Game.getObjectById(room.memory.storeCont)){
							priority -= 10;
					} else if (!room.storage && room.memory.lotsOfDroppedEnergy){
							priority -= 10;
					} else if (room.memory.sites && !room.storage && (!room.memory.storeCont || !Game.getObjectById(room.memory.storeCont))){
							priority -= 20;
					}
					priority += countFunction('builder', room);
					return priority
			},
			isRequired: (room, countFunction,idleSpawn) => {
					let numberRequired = 0;
					if (room.memory.armedHostiles && room.controller.safeMode == undefined){
							return false
					}
					if (room.controller.level > 5 && !room.ecoStable && !room.controller.safeMode){
							return false
					}
					if ((!room.storage || room.total('energy') < 5000) && countFunction('builder', room) > 3 && !room.memory.lotsOfDroppedEnergy){
							return false
					}
					let buildnum = 0;
					let noStore = !room.storage && (!room.memory.storeCont || !Game.getObjectById(room.memory.storeCont));
					if (room.memory.sites && (countFunction('staticUpgrader',room)>0 || noStore|| room.controller.level > 3)){
							let workerParts = 20;
							if (room.controller.level < 8 && room.memory.assignedSourceData && room.memory.assignedSourceData.currentWorkerParts){
									workerParts = Number.parseInt(room.memory.assignedSourceData.currentWorkerParts);
							}
							if (workerParts === 0){
									workerParts = 10;
							}
							buildnum = Game.bodySizeToNumberNeeded(workerParts / 5, spawnCode$y.body(room, countFunction).body, WORK);
					} else if (room.memory.sites && room.memory.someDroppedEnergy && room.controller.level < 3){
							buildnum = 1;
					}
					if (!config.conserveCpu && room.total('energy') > room.memory.reserve && room.memory.sites){
							buildnum++;
					}
					if (buildnum > 10){
							buildnum = 10;
					}
					if (room.class === 'restructuring' && buildnum < 3){
							buildnum = 3;
					}
					if (!room.storage && room.controller.level < 4 && room.memory.upCont && Game.getObjectById(room.memory.upCont) &&
							room.memory.storeCont && Game.getObjectById(room.memory.storeCont) && buildnum > 2 && !room.memory.lotsOfDroppedEnergy){
							buildnum = 2;
					}
					if (room.storage && room.total('energy') < room.memory.reserve && buildnum > 1){
							buildnum = 1;
							if (!room.memory.bigSites){
									buildnum = 0;
							}
					}

					if (!room.memory.bigSites && buildnum > 1){
							buildnum = 1;
					}
					if (config.forceFill && config.forceFill === room.name && buildnum > 0 && buildnum < 3){
							buildnum = 3;
					}
					numberRequired = buildnum;
					let count = countFunction('builder', room);
					if (Game.cpu.bucket > 9000 && !config.conserveCpu && room.controller.level < 6){
							let newCount = countRoleAdjustingForParts('builder',room,spawnCode$y.body(room,countFunction));
							if (newCount !== undefined){
									count = newCount;
							}
					}
					return  count < numberRequired;
			},
			spawn: (room, role, body) => {
					//decide if we need any other options
					if (body){
							//options -> TTL, creepnumber
							room.spawnCreep(role, body);
					}
			},
			body: (room, countFunction) => {
					if (room.memory.roadsDown === undefined){
							room.memory.roadsDown = false;
					}
					let key = room.energyCapacityAvailable + ':' + room.memory.roadsDown+':'+room.memory.bigSites;
					if (getCachedBody('builder',key)){
							return getCachedBody('builder',key)
					}
					let bodyObject = {
							body: [],
							cost: 0
					};
					let limitEnergyCap = room.energyCapacityAvailable;
					if (!config.conserveCpu && Game.cpu.bucket > 9000 && room.energyCapacityAvailable > 300 && (!room.storage || !room.memory.storeCont)){
							limitEnergyCap = room.energyCapacityAvailable/1.5;
					}
					if (room.memory.bigSites){
							limitEnergyCap = room.energyCapacityAvailable*0.8;
					}
					let storage;
					if (room.storage || (room.memory.storeCont && Game.getObjectById(room.memory.storeCont))){
							storage = true;
					}
					if (!room.memory.bigSites && limitEnergyCap > 1000 && room.controller.level < 7){
							limitEnergyCap = 1000;
					}
					if (!config.official && Memory.myRooms.length < 3 && room.controller.level < 7){
							limitEnergyCap = 500;
					}
					//decide on what body to have
					bodyObject.body = getBody$5(limitEnergyCap,room, room.memory.roadsDown, 'builder',undefined,storage);
					if (!room.storage && room.controller.level === 4){
							bodyObject.body = room.makeBody(['work'],true,{oneCarry:true});
					}
					if (bodyObject.body && bodyObject.body.length > 0){
							bodyObject.cost += Game.getBodyCost(bodyObject.body);
					}
					cacheBody('builder',key,bodyObject);
					return bodyObject
			}
	};

	var builder = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$12,
		spawnCode: spawnCode$y
	});

	function run$11(creep){
			//console.log(creep.pos, 'bulkTrader')
			let targetShard = creep.num;
			var flag = Game.flags['ShardTrade'];
			let portalRoomFlag = Game.flags['PortalRoom'];
			if (_.sum(creep.store) == creep.store.getCapacity() && creep.memory.target){
					creep.memory.dropping = true;
			}
			if (creep.hits < creep.hitsMax*0.8){
					Memory.blockTraders = Game.time+5000;
			}
			if (Game.shard.name != targetShard){
					if (creep.room.terminal && !creep.memory.readyToDepart){
							if (Memory.market && Memory.market.exports){
									let level5s = config$1.level5Commodities;
									let itemToWithdraw,price;
									for (let c in Memory.market.exports){
											if (!level5s.includes(c) && creep.room.terminal.store[c] && Memory.market.exports[c] && Memory.market.exports[c].volume
													&& Memory.market.exports[c].volume > 0 && Memory.market.exports[c].shard == targetShard){
													if (!itemToWithdraw || price < Memory.market.exports[c].price){
															itemToWithdraw = c;
															price = Memory.market.exports[c].price;
													}
											}
									}
									if (itemToWithdraw && creep.store.getFreeCapacity() > 0){
											let ret = creep.withdraw(creep.room.terminal, itemToWithdraw);
											if (ret == -9){
													creep.moveTo(creep.room.terminal, {range: 1, maxRooms: 1});
											} else if (ret === 0){
													let amount = creep.store.getFreeCapacity();
													if (creep.room.terminal.store[itemToWithdraw] < amount){
															amount = creep.room.terminal.store[itemToWithdraw];
													}
													Memory.market.exports[itemToWithdraw].volume -= amount;
											}
									} else if (creep.store.getUsedCapacity() > 0){
											creep.memory.readyToDepart = true;
									}
							} else if (creep.store.getUsedCapacity() > 0){
									creep.memory.readyToDepart = true;
							}
					} else if (targetShard && Game.shard.name != targetShard){
							//goTo portalRoom
							if (portalRoomFlag && portalRoomFlag.pos && creep.room.name != portalRoomFlag.pos.roomName){
									creep.goTo(portalRoomFlag.pos);
							} else {
									let goalNum = Number.parseInt(targetShard.slice(5));
									let currentNum = Number.parseInt(Game.shard.name.slice(5));
									let targetPortalNum = Number.parseInt(Game.shard.name.slice(5));
									goalNum > currentNum ? targetPortalNum++ : targetPortalNum--;
									if (!creep.room.memory.portals){
											let portals = creep.room.find(FIND_STRUCTURES, {filter: (s) => s.structureType == STRUCTURE_PORTAL});
											creep.room.memory.portals = {};
											for (let i in portals){
													let portal = portals[i];
													if (portal.destination.shard && portal.destination.shard === 'shard0' && portal.pos.lookAround(LOOK_FLAGS,0).length === 0){
															continue
													}
													creep.room.memory.portals[portal.destination.shard] = portal.pos.toString();
											}
									}
									let portal = creep.room.memory.portals['shard' + targetPortalNum];
									if (portal){
											if (creep.pos.isNearTo(portal.toPos())){
													creep.move(creep.pos.getDirectionTo(portal.toPos()));
											} else {
													creep.goTo(portal.toPos(),{range:1});
											}
									}
							}
					}
			} else if (flag && flag.room){
					if (flag.room.terminal){
							if (creep.store.getUsedCapacity() > 0){
									if (creep.room.name !== flag.room.name){
											creep.goTo(flag.room.terminal);
									} else if (!creep.pos.isNearTo(flag.room.terminal)){
											creep.moveTo(flag.room.terminal,{range:1});
									} else {
											for (let i in creep.store){
													let ret = creep.transfer(flag.room.terminal, i);
													if (ret === 0){
															if ((Memory.mineralsNeeded && Memory.mineralsNeeded[i]) ||
																	(Memory.mineralsNeeded && decompressDictionary[i] && Memory.mineralsNeeded[decompressDictionary[i]]) ||
																	(Memory.productionMandate && Memory.productionMandate[i]) ||
																	(Memory.productionMandate && compressDictionary[i] && Memory.productionMandate[compressDictionary[i]])){
																	//dont want to sell this imported item as it will either be used, compressed or decompressed
																	return
															}
															if (!Memory.importsToSell){
																	Memory.importsToSell = {};
															}
															if (!Memory.importsToSell[i]){
																	Memory.importsToSell[i] = creep.store[i];
															} else {
																	Memory.importsToSell[i] += creep.store[i];
															}
													}
											}
									}
							} else if (flag.room.memory.boostflag){
									let unb = creep.unboost(flag.room);
									if (unb == -5 || !creep.isBoosted()){
											creep.suicide();
									}
							} else {
									creep.suicide();
							}
					}
			} else if (Game.shard.name == targetShard);
	}



	let spawnCode$x = {
			priority: (room, countFunction) => {
					let priority = 40;
					return priority
			},
			isRequired: (room, countFunction) =>{
					if (!room.ecoStable || room.memory.armedHostiles || room.memory.defcon < 5 || room.energyCapacityAvailable < 5000){
							return false
					}
					let traderNum = 0;
					if (spawnCode$x.traderRequired(room)){
							traderNum = 6;
					} else {
							traderNum = 0;
					}
					return countFunction('bulkTrader', room) < traderNum;
			},
			traderRequired: (room) => {
					if (Memory.blockTraders && Memory.blockTraders > Game.time){
							return false
					}
					if (Memory.market && Memory.market.exports && Game.flags['ShardTrade'] && Game.flags['ShardTrade'].pos.roomName && Game.flags['ShardTrade'].pos.roomName == room.name && room.terminal){
							let level5s = config$1.level5Commodities;
							let shards = {};
							//check if we have enough exports to one shard to warrant a trip
							for (let c in Memory.market.exports){
									if (!level5s.includes(c) && Memory.market.exports[c].volume > 0){
											if (!shards[Memory.market.exports[c].shard]){
													shards[Memory.market.exports[c].shard] = room.terminal.store[c];
											} else {
													shards[Memory.market.exports[c].shard] += room.terminal.store[c];
											}
									}
							}
							for (let s in shards){
									if (shards[s] >= 500){
											Memory.exportShard = s;
											return true
									}
							}
					}
			},
			spawn: (room, role, body) => {
					//decide if we need any other options
					if (body){
							//options -> TTL, creepnumber
							room.spawnCreep(role, body,{creepnumber:Memory.exportShard});
					}
			},
			body: (room, countFunction) => {
					if (room.memory.roadsDown === undefined){
							room.memory.roadsDown = false;
					}
					let key = room.energyCapacityAvailable + ':' + room.memory.roadsDown;
					if (getCachedBody('bulkTrader',key)){
							return getCachedBody('bulkTrader',key)
					}
					let bodyObject = {
							body: [],
							cost: 0
					};
					//decide on what body to have
					bodyObject.body = room.makeBody([CARRY],false);

					if (bodyObject.body && bodyObject.body.length > 0){
							bodyObject.cost += Game.getBodyCost(bodyObject.body);
					}
					cacheBody('bulkTrader',key,bodyObject);
					return bodyObject
			}
	};

	var bulkTrader = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$11,
		spawnCode: spawnCode$x
	});

	let roomInputs = {};
	let roomTargets = {};
	let keepInFactoryAll = {};
	var commodityLists = {};
	var blockages;
	let ingredients = {};
	let baseIngredients = ['H', 'O', 'U', 'L', 'K', 'Z', 'X','G','energy'];
	let canBuy = [];
	let canBuyTick = Game.time;
	//todo more buying and selling of commodities based on price, raw profit and profit. If profit and raw profit is negative,
	// could make sense to buy and build up the tree. Block building/selling commodities up the chain if rawprofit -ve
	//sell if profit and rawprofit +ve and blocked moving further up tree
	//check buying of base commodities, maximise factory usage! do this only if certain factory levels are available
	function prioritise(){
			if (!Memory.market){return}
			function getAmountForEachLevel(commodity,amount){
					if (!COMMODITIES[commodity]){
							console.log('unknown commodity');
							return
					}
					getIngredients(commodity,ingredients,amount);
					console.log(JSON.stringify(ingredients));
			}
			function getIngredients(commodity,obj,number){
					if (!COMMODITIES[commodity]){
							console.log('unknown commodity at get ingredients');
							return
					}
					if (!number){
							number = 1;
					}
					let amount = number;
					if (!obj[commodity]){
							obj[commodity] = amount;
					} else {
							obj[commodity]+= amount;
					}
					for (let i in baseIngredients){
							if (baseIngredients[i] === commodity){
									return
							}
					}
					let comps = COMMODITIES[commodity].components;
					for (let i in comps){
							let component = i;
							let amount = comps[i]*(number/COMMODITIES[commodity].amount);
							if (COMMODITIES[component]){
									getIngredients(component,obj,amount);
							} else {
									//base level commodity
									if (!obj[i]){
											obj[i] = amount;
									} else {
											obj[i]+= amount;
									}
							}
					}
			}
			let multiplesOfResourcesStored = 30;
			if (config$1.season && config$1.season === 'caravan'){
					multiplesOfResourcesStored = 20;
			}
			let l5resources = ["machine","device","organism","essence"];
			for (let i in l5resources){
					let res = l5resources[i];
					if (!ingredients[res]){
							getAmountForEachLevel(res,multiplesOfResourcesStored);
							for (let i in ingredients){
									if (ingredients[i]< 20){
											ingredients[i] = 20;
									}
							}
					}
			}
			let baseCommodity = ['metal','mist','biomass','silicon'];
			if (canBuy.length === 0 && Game.time % 20 === 0 && Memory.market.resources['energy']){
					for (let i in l5resources){
							let res = l5resources[i];
							let ing = {};
							getIngredients(res,ing);
							let totalCost = 0;
							let baseCommod;
							let energyCost = Memory.market.resources['energy'].d;
							for (let y in ing){
									if (baseIngredients.includes(y) && Memory.market && Memory.market.resources && Memory.market.resources[y] && Memory.market.resources[y].w){
											//cost of buying the resources needed to produce the level 5 commodity
											//adjust the price by 1.2 to account for buying prices often being higher
											totalCost += (ing[y]*Memory.market.resources[y].w*1.2)+energyCost*ing[y];
									}
									if (baseCommodity.includes(y)){
											baseCommod = y;
									}
							}
							if (baseCommod && Memory.market && Memory.market.resources && Memory.market.resources[res] && Memory.market.resources[res].w){
									let resCost = Memory.market.resources[res].w;
									let baseCommodityPossibleTotalCost = resCost-totalCost;
									if (baseCommodityPossibleTotalCost<0){
											continue
									}
									let priceForBreakEvenWithBaseCommodity = baseCommodityPossibleTotalCost/ing[baseCommod];
									//this does not take into account transport fees etc - assume 50% cost
									priceForBreakEvenWithBaseCommodity = priceForBreakEvenWithBaseCommodity/2;
									if (Memory.market && Memory.market.resources && Memory.market.resources[baseCommod] && Memory.market.resources[baseCommod].w && Memory.market.resources[baseCommod].w < priceForBreakEvenWithBaseCommodity){
											canBuy.push(baseCommod);
									}
							}
					}
			}
	}
	function getCommodityTargets(){
			return ingredients
	}
	function getBaseCommoditiesThatCanBuy(){
			return canBuy
	}
	function run$10(room){
			if (canBuyTick !== Game.time){
					canBuy = [];
					canBuyTick = Game.time;
			}
			// for (let i in Memory.commodities.prices){
			// 		if (Memory.commodities.prices[i].profit < 0 && Memory.commodities.prices[i].rawProfit < 0){
			// 				console.log('BUY',i)
			// 		}
			// 		if (Memory.commodities.prices[i].profit > 0 && Memory.commodities.prices[i].rawProfit > 0){
			// 				console.log('SELL',i)
			// 		}
			// }
			if (!blockages){
					blockages = {};
			}
			if (blockages){
					//console.log('blockages',JSON.stringify(blockages))
					for (let i in blockages){
							if (blockages[i] < Game.time){
									delete blockages[i];
							}
					}
			}
			if (!Memory.commodities){
					Memory.commodities = {};
			}
			let factory = room.activeFactory;
			let inputs;
			if (roomInputs[room.name]){
					inputs = roomInputs[room.name];
			}
			if (!factory || room.controller.level < 8){
					setExports(room,inputs);
					return
			}
			let level = factory.level;
			if ((roomInputs[room.name] && (factory.cooldown || (Game.time + room.index) % 10+(10*(level+1)) !== 0))){
					updateInputs(factory);
					return
			}
			if (factory && (!factory.effects || factory.effects.length === 0) && !room.memory.factoryOperator){
					//ensure inactive factories are not hording resources
					level = 0;
			}
			let commodityList = [];
			if (commodityLists[level]){
					commodityList = commodityLists[level];
			} else {
					for (let i in COMMODITIES){
							if ((!COMMODITIES[i].level || COMMODITIES[i].level === level) && i != 'energy'){
									commodityList.push(i);
							}
					}
					commodityLists[level] = commodityList;
			}
			let inputNeeded = {};
			let targets = {};
			let keepInFactory = {};
			for (let i in RESOURCES_ALL){
					inputNeeded[RESOURCES_ALL[i]] = 0;
					if (factory.store[RESOURCES_ALL[i]]){
							inputNeeded[RESOURCES_ALL[i]] -= (factory.store[RESOURCES_ALL[i]]);
					}
			}
			// commodityList = commodityList.sort((a, b) => {
			// 		return room.total(a) - room.total(b)
			// })
			let producing = false;
			let possibleProductionTargets = [];
			for (let commodityType in commodityList){
					let i = commodityList[commodityType];
					let commodity = COMMODITIES[i];
					let itemNeeded = true;
					if (ingredients[i]){
							if (((commodity.level && commodity.level !== 5) || commodity === 'ghodium_melt') && Game.getResourceTotal(i)>ingredients[i]){
									itemNeeded = false;
							}
					}
					if (i === 'G'){
							//prevent loop with G
							continue
					}
					if (COMMODITIES[i] && (itemNeeded
							|| ((i == 'wire' || i == 'condesate' || i == 'alloy' || i == 'cell') && room.total(i) < config$1.commodityConst * 20)
							|| (i == 'battery')
							|| (config$1.minerals.includes(i) && room.total(i) < config$1.mineralTarget - 500)
							|| (i === 'energy' && room.total('energy') < room.memory.reserve*0.8))){
							let canProduce = true;
							let partial = false;
							if (room.total('battery')>1000){
									inputNeeded['battery'] = room.total('battery')-1000-factory.store['battery'];
							}
							//if the commodity to produce is a battery and the room does not have an excess of energy we go through this statement to prevent production of batteries
							if (i == 'battery' && room.storage && ((room.memory.defcon < 5 && room.total('energy')<room.memory.reserve*0.8) || (room.isPrayerDonor && room.total('energy') < room.memory.reserve * 1.5))){
									//if isPrayerDonor we want to import batteries and convert to energy so we can support the prayer room
									let targetBatteryLevel = 500;
									if (room.memory.defcon < 5){
											targetBatteryLevel = 10000;
									}
									if (!inputNeeded['battery']){
											inputNeeded['battery'] = targetBatteryLevel;
									} else if (inputNeeded['battery']< targetBatteryLevel) {
											inputNeeded['battery'] = targetBatteryLevel;
									}
									if (factory.store['battery'] >= 50){
											factory.produce('energy');
									}
									//if we continue this means the room wont queue up to produce batteries
									continue
							}
							if (i == 'battery' && (room.total(i)> 10000 || room.total('energy')<room.memory.reserve*1.1 || room.memory.defcon < 5 || Game.energyCaution)){
									continue
							}
							let baseCommods = ['composite','liquid','crystal','wire','cell','alloy','condensate'];
							if (config$1.minerals.includes(i)){
									//decompressing to increase mineral count (compress transfers save energy)
									if (room.total(i) >= config$1.mineralTarget - 500 || (!config$1.official && room.total(i) > config$1.excess * 0.25)){
											canProduce = false;
									} else {
											for (let j in COMMODITIES[i].components){
													if (Memory.productionMandate[j]){
															//dont decompress something we need to make
															canProduce = false;
													}
													if (!inputNeeded[j]){
															inputNeeded[j] = COMMODITIES[i].components[j];
													} else {
															inputNeeded[j] += COMMODITIES[i].components[j];
													}
													if (!factory.store[j] || factory.store[j] < COMMODITIES[i].components[j]){
															canProduce = false;
													}
											}
									}
							} else {
									for (let j in COMMODITIES[i].components){
											if (j !== 'energy' && COMMODITIES[i].level){
													keepInFactory[j] = true;
											}
											if (j != 'energy' && config$1.minerals && config$1.minerals.includes(j) && ((room.total(j) < config$1.excess * 0.25 && Memory.productionMandate
													&& Memory.productionMandate[i]) || room.total(j) < config$1.excess * 0.75 || room.total(i)>config$1.mineralTarget)){
													//don't compress if no excess or too much of compressed item
													canProduce = false;
													break
											}
											if (room.isPrayerDonor && i == 'battery'){
													canProduce = false;
													break
											}
											let gMax = 1000;
											if (ingredients && ingredients['ghodium_melt']){
													gMax = ingredients['ghodium_melt']/Memory.myRooms.length;
											}
											if (i === 'ghodium_melt' && room.total(i)>gMax){
													canProduce = false;
													break
											}
											if (!inputNeeded[j]){
													inputNeeded[j] = COMMODITIES[i].components[j];
											} else {
													inputNeeded[j] += COMMODITIES[i].components[j];
											}

											if (!factory.store[j] || factory.store[j] < COMMODITIES[i].components[j]){
													canProduce = false;
											} else if (COMMODITIES[j] && (COMMODITIES[j].level > 0 || baseCommods.includes(i))){
													partial = true;
											}
									}
							}
							if (commodity && (commodity.level > 0 || baseCommods.includes(i)) && !canProduce && partial){
									for (let j in commodity.components){
											if ((!COMMODITIES[j] || !COMMODITIES[j].level) && (!factory.store[j] || factory.store[j] < COMMODITIES[i].components[j])){
													if (!blockages[j]){
															blockages[j] = Game.time + 1000;
													}
													//console.log('blockage -',i,' need :',j)
											}
									}
							}
							if (canProduce){
									possibleProductionTargets.push(i);
									producing = true;
							}
					}
			}
			possibleProductionTargets.sort((a, b) => {
					return room.total(a) - room.total(b)
			});
			for (let i in possibleProductionTargets){
					let okay = factory.produce(possibleProductionTargets[i]);
					if (okay === 0){
							if (config$1.logEnergy && COMMODITIES[possibleProductionTargets[i]] && COMMODITIES[possibleProductionTargets[i]].components['energy']){
									let energyCost = COMMODITIES[possibleProductionTargets[i]].components['energy'];
									room.logEnergyStats('factoryCost', energyCost);
							}
							break;
					}
			}
			if (!producing && (!factory.cooldown || factory.cooldown == 0)){
					let shortSupply = [];
					for (let i in inputNeeded){
							if (inputNeeded[i] > 0){
									shortSupply.push([i, inputNeeded[i]]);
							}
					}
					//console.log('FACTORY IDLE:', room.name, level, shortSupply, JSON.stringify(factory.effects))
			}
			if (factory.store.getUsedCapacity() > factory.store.getCapacity() * 0.9){
					let highSupply = [];
					for (let i in inputNeeded){
							if (inputNeeded[i] < 0){
									highSupply.push([i, inputNeeded[i]]);
							}
					}
					console.log('FACTORY FULL:', room.name, level, highSupply);
			}
			if (!Memory.commodities.export){
					Memory.commodities.export = {};
			}
			for (let i in inputNeeded){
					//correct input needed by removing factory amount to give us the base target to compare to
					let amount = 0;
					if (factory.store[i]){
							amount = factory.store[i];
					}
					targets[i] = inputNeeded[i] + amount;
			}
			roomTargets[room.name] = targets;
			updateInputs(factory, inputNeeded,keepInFactory);
	}

	function set$1(){
			if (Game.time % 100 == 0){
					if (!Memory.produtionMandate){
							Memory.productionMandate = {};
					}
					Memory.productionMandate = blockages;
			}
	}
	function updateInputs(factory, inputNeeded,keepInFactory){
			if (!factory){
					return
			}
			let room = factory.room;
			let targets = roomTargets[room.name];
			if (!inputNeeded){
					inputNeeded = {};
					for (let i in targets){
							if (factory.store[i]){
									inputNeeded[i] = targets[i] - factory.store[i];
							} else {
									inputNeeded[i] = targets[i];
							}
					}
			}
			setExports(room,inputNeeded);
			// for (let i in inputNeeded){
			// 		if (inputNeeded[i] > 0){
			// 				room.display(`input needed ${i} :  ${inputNeeded[i]}, target: ${targets[i]}`)
			// 		}
			// }
			for (let i in keepInFactory){
					if (inputNeeded[i] < -1000){
							inputNeeded += 1000;
					} else if (inputNeeded[i] < 0){
							inputNeeded[i] = 0;
					}
			}
			keepInFactoryAll[room.name] = keepInFactory;
			roomInputs[room.name] = inputNeeded;
	}
	let lastSet = {};
	function setExports(room,inputNeeded,force){
			if (!Memory.commodities || !Memory.commodities.export){
					return
			}
			if (lastSet[room.name] && lastSet[room.name]>Game.time-50){
					return
			}
			lastSet[room.name] = Game.time;
			if (!inputNeeded){
					inputNeeded = {};
			}
			for (let i in COMMODITIES){
					if (i === 'energy' || config$1.minerals.find((min) => min === i)){
							continue
					}
					if (!Memory.commodities.export[i]){
							Memory.commodities.export[i] = {};
					}
					let q = 20;
					if (COMMODITIES[i].level){
							q = 1;
					}
					if (i && room.total(i) >= q && room.terminal.store['energy'] >= q * 2 && room.terminal.store[i] >= q && !inputNeeded[i]){
							Memory.commodities.export[i][room.name] = 1;
					} else if (Memory.commodities.export[i][room.name]){
							delete Memory.commodities.export[i][room.name];
					}
			}
	}

	let tryToUse = {};
	let otherDecoders = {};
	//use creep cache to determine if a creep has died and therefore ban a route
	let creepCache = {};

	function runSymbolManager(){
		//todo setting rooms as unreachable when creeps are spawning
		Memory.decodersAvailable = {};
		for (let i in Memory.symbolDecoders){
			let obj = Memory.symbolDecoders[i];
			if (obj.level){
				let pos2 = new RoomPosition(15, 35, i);
				Game.map.visual.text(obj.level, pos2, {fontSize: 10});
			}
			if (obj.type){
				let type = obj.type.slice(7, 10);
				let pos = new RoomPosition(10, 45, i);
				let pos2 = new RoomPosition(10, 35, i);
				Game.map.visual.text(type, pos, {fontSize: 10});
				if (obj.canDecode){
					Game.map.visual.text('\u{2705}', pos2, {fontSize: 10});
				} else if (obj.canDecode === false){
					Game.map.visual.text('\u{274C}', pos2, {fontSize: 10});
				}
			}
			if (tryToUse[i] && obj.canDecode !== undefined){
				delete tryToUse[i];
			}
			if (!obj){
				continue
			}
			if (!Memory.decodersAvailable[obj.type] && obj.owner == Game.username){
				Memory.decodersAvailable[obj.type] = 1;
			} else if (!Memory.decodersAvailable[obj.type] && obj.level > 6 && obj.canDecode == undefined && !config.blackList.includes(obj.owner)){
				//if we have not tried to decode in this room, give it a go
				if (!tryToUse[i]){
					let sector = Game.map.getSector(i);
					if (!Memory.reachableSectors[sector]){
						continue
					}
					let nearestRoom, nearestDistance;
					for (let j in Memory.myRooms){
						let range = Game.map.getRoomLinearDistance(Memory.myRooms[j], i);
						if (range <= 13 && Game.rooms[Memory.myRooms[j]] && Game.rooms[Memory.myRooms[j]].controller &&
							Game.rooms[Memory.myRooms[j]].controller.level > 6 && (!nearestRoom || nearestDistance > range)){
							nearestRoom = Memory.myRooms[j];
							nearestDistance = range;
						}
					}
					if (nearestRoom){
						tryToUse[i] = {nearestRoom: nearestRoom};
					}
				}
			} else if (!Memory.decodersAvailable[obj.type] && obj.level > 6 && obj.canDecode === false && obj.nextTry && obj.nextTry < Game.time && !config.blackList.includes(obj.owner)){
				delete obj.canDecode;
				delete obj.nextTry;
			} else if (!Memory.decodersAvailable[obj.type] && obj.canDecode && obj.level > 6){
				if (!otherDecoders[obj.type] || Game.time % 500 === 0){
					let nearestRoom, nearestDistance;
					for (let j in Memory.myRooms){
						let range = Game.map.getRoomLinearDistance(Memory.myRooms[j], i);
						if (range <= 13 && Game.rooms[Memory.myRooms[j]] && Game.rooms[Memory.myRooms[j]].controller &&
							Game.rooms[Memory.myRooms[j]].controller.level > 6 && (!nearestRoom || nearestDistance > range)){
							nearestRoom = Memory.myRooms[j];
							nearestDistance = range;
						}
					}
					if (nearestRoom && (!otherDecoders[obj.type] || (otherDecoders[obj.type].range > nearestDistance
						&& obj.level >= otherDecoders[obj.type].level) || otherDecoders[obj.type].level < obj.level)){
						otherDecoders[obj.type] = {
							level: obj.level,
							nearestRoom: nearestRoom,
							targetRoom: i,
							range: nearestDistance,
							owner: obj.owner
						};
					}
				}
			}
		}
		if (config.manualDecode){
			for (let i in config.manualDecode){
				let obj = Memory.symbolDecoders[i];
				if (obj.canDecode === false){
					obj.canDecode = undefined;
				} else if (obj.canDecode){
					otherDecoders[obj.type] = {
						level: obj.level,
						nearestRoom: config.manualDecode[i],
						targetRoom: i,
						range: 1,
						owner: obj.owner
					};
				} else {
					let homeRoom = Game.rooms[config.manualDecode[i]];
					let creep = homeRoom.sendSymbolDecoder(i);
					if (creep && creep.memory.hasDecoded && creep.store.getUsedCapacity() === 0){
						deregisterCreep(creep);
						creep.suicide();
						setAsCanDecode(i);
					}
				}
			}
		}
		if (!Memory.decoderErrors){
			Memory.decoderErrors = [];
		} else {
			if (Memory.decoderErrors.length > 25){
				Memory.decoderErrors.shift();
			}
		}
		for (let i in tryToUse){
			if (!tryToUse[i].creep){
				//console.log('try to decode in ',i)
				let room = tryToUse[i].nearestRoom;
				let creep;
				let range = Game.map.getRoomLinearDistance(i, room);
				if (range && Game.time % range === 0){
					creep = Game.rooms[room].sendSymbolDecoder(i);
				}
				if (creep){
					tryToUse[i].creep = creep.id;
					tryToUse[i].lastPos = creep.pos;
					tryToUse[i].lastAliveTime = Game.time;
				}
			} else {
				let creep = Game.getObjectById(tryToUse[i].creep);
				if (!creep){
					//creep has been killed or did not make it to destination
					setAsCannotDecode(i);
					//logging test runs is less important
					//Memory.decoderErrors.push([i,tryToUse[i].lastPos,tryToUse[i].lastAliveTime])
					delete tryToUse[i];
				} else if (creep.memory.hasDecoded && creep.store.getUsedCapacity() == 0){
					deregisterCreep(creep);
					creep.suicide();
					delete tryToUse[i];
					setAsCanDecode(i);
				} else {
					tryToUse[i].lastPos = creep.pos;
					tryToUse[i].lastAliveTime = Game.time;
					//don't want creep registered as non tester
					deregisterCreep(creep);
				}
			}
		}
		for (let res in otherDecoders){
			let target = otherDecoders[res].targetRoom;
			let room = otherDecoders[res].nearestRoom;
			let creeps = Game.rooms[room].sendSymbolDecoder(target);
			for (let c in creeps){
				let creep = creeps[c];
				if (creep && creep.memory && (creep.ticksToLive < 1300 || creep.memory.hasDecoded) && creep.store.getUsedCapacity() == 0){
					deregisterCreep(creep);
					creep.say(':)');
					creep.suicide();
				} else if (creep && creep.memory){
					registerCreep(creep);
				}
			}
			checkTargetRoomCreeps(target);
		}
		if (Memory.symbolLocations && Game.time % 50 === 0){
			for (let i in Memory.symbolLocations){
				if (Memory.symbolLocations[i] < Game.time){
					delete Memory.symbolLocations[i];
				} else {
					let found = false;
					for (let i in Game.myRooms){
						if (Game.myRooms[i] && Game.myRooms[i].memory.symbolLocations && Game.myRooms[i].memory.symbolLocations[i]){
							found = true;
						}
					}
					if (!found){
						delete Memory.symbolLocations[i];
					}
				}
			}
		}
		for (let i in Game.myRooms){
			let room = Game.myRooms[i];
			let symbolLocations = room.memory.symbolLocations;
			for (let s in symbolLocations){
				if (symbolLocations[s].expiry < Game.time || !symbolLocations[s].amount){
					delete symbolLocations[s];
					continue
				}
				let pos = s.toPos();
				if (symbolLocations[s].type){
					let type = symbolLocations[s].type.slice(7, 10);
					Game.map.visual.text(type, pos, {fontSize: 5});
					Game.map.visual.line(pos, room.controller.pos);
				}
				if (pos && pos.roomName && Game.rooms[pos.roomName]){
					if (!symbolLocations[s].id || !Game.getObjectById(symbolLocations[s].id)){
						delete symbolLocations[s];
					}
				}
			}
		}
	}

	function registerCreep(creep){
		let target = creep.num;
		if (creep.body && creep.body.length < 3){
			//test creep, don't register
			return
		}
		if (target){
			if (!creepCache[target]){
				creepCache[target] = {};
			}
			creepCache[target][creep.id] = {
				pos: creep.pos.toString(),
				time: Game.time
			};
		}
	}

	function deregisterCreep(creep){
		let target = creep.num;
		if (target){
			if (creepCache[target]){
				delete creepCache[target][creep.id];
			}
		}
	}

	function checkTargetRoomCreeps(targetRoomName){
		//check to see if any creeps on way to target have disappeared, if this is the case forbid that decoder
		let cache = creepCache[targetRoomName];
		if (!cache){
			return
		}
		for (let id in cache){
			if (!Game.getObjectById(id)){
				if (!Memory.symbolDecoders[targetRoomName].canDecode){
					Memory.decoderErrors.push([targetRoomName, cache[id].pos, cache[id].time]);
				}
				setAsCannotDecode(targetRoomName);
				delete cache[id];
			} else {
				let creep = Game.getObjectById(id);
				if (creep.memory.hasDecoded && creep.store.getUsedCapacity() == 0){
					deregisterCreep(creep);
					creep.suicide();
				}
			}
		}
	}

	function setAsCannotDecode(targetRoomName){
		console.log('setting as not decodable', targetRoomName);
		if (!Memory.symbolDecoders || !Memory.symbolDecoders[targetRoomName]){
			return
		}
		let previouslyCould = false;
		if (Memory.symbolDecoders[targetRoomName].canDecode === true){
			previouslyCould = true;
		}
		if (Memory.symbolDecoders[targetRoomName].canDecode !== false){
			let amount = 5000;
			if (previouslyCould){
				amount = 1000;
			}
			Memory.symbolDecoders[targetRoomName].canDecode = false;
			Memory.symbolDecoders[targetRoomName].nextTry = Game.time + amount;
		}
	}

	function setAsCanDecode(targetRoomName){
		console.log('setting as decodable', targetRoomName);
		Memory.symbolDecoders[targetRoomName].canDecode = true;
	}

	playerHeap.currentRoomBuyPrices = {};
	playerHeap.currentRoomSellPrices = {};
	playerHeap.hasTraded = {};
	playerHeap.roomDistanceSort = {};
	playerHeap.noExcess = {};
	playerHeap.blockRequestsAll = {};
	playerHeap.noRecipient = {};
	let allMarketOrders;
	let time$1;
	let dealsThisTick = 0;
	const dealsPerTickLimit = 10;
	function logHistory(){
			let history = Game.market.incomingTransactions;
			let arr = [];
			if (history && history.length > 0){
					for (let i in history){
							let order = history[i];
							if (order && order.sender && order.sender.username !== Game.username){
									arr.push(order);
							}
					}
			}
			Memory.incomingTransactions = arr;
	}
	function trade(room){
			//has traded caches if the room has already traded this tick and stops extra cpu usage after this
			if (!room.terminal || !room.controller || room.controller.level < 6){
					return
			}
			playerHeap.hasTraded[room.name] = false;
			room.memory.traded = true;
			var min = room.memory.min;
			var stores = room.storage;
			var terminal = room.terminal;
			var credits = Game.market.credits;
			Game.market.orders;
			if (!playerHeap.blockRequestsAll[room.name]){
					playerHeap.blockRequestsAll[room.name] = {};
			}
			let blockRequests = playerHeap.blockRequestsAll[room.name];
			if ((!allMarketOrders || time$1 != Game.time) && config$1.marketActive){
					dealsThisTick = 0;
					allMarketOrders = Game.market.getAllCachedOrders();
					time$1 = Game.time;
			}
			/*
			for (var o in orders){
					if (!Memory.complete){
					console.log(Game.market.cancelOrder(orders[o].id))
					}
			}
			Memory.complete = 1
			*/
			if (!Memory.prices){
					Memory.prices = {};
			}
			if (terminal){
					if (!Memory.terminals){
							Memory.terminals = {};
					} else {
							if (!Memory.terminals[room.name]){
									Memory.terminals[room.name] = {};
							}
					}
			}
			if (terminal){
					if (room.class == 'restructuring' && room.total('energy') < 120000){
							console.log('restructuring need energy', room.name);
							requestEnergy(room);
					} else if (Memory.toMoveStore && Memory.toMoveStore === room.name && room.total('energy') < 40000){
							requestEnergy(room);
					} else if (room.class == 'restructuring'){
							energyNotNeeded(room);
					}
			}
			let defBoost = ['LH', 'UH', 'KO'];
			if (((room.memory.armedHostiles && room.memory.defcon < 5) || Game.flags['defend' + room.name]) && room.memory.labsUp){
					for (let i in defBoost){
							if (room.total(defBoost[i]) < 5000){
									localTransfer(defBoost[i], room, 1000, 1000, true);
									requestResource(room, defBoost[i], 0.9, 5000);
							} else {
									removeResourceRequest(room, defBoost[i]);
							}
					}
			} else if (room.memory.labsUp){
					for (let i in defBoost){
							if (room.total(defBoost[i]) < 5000 && room.memory.defcon < 5){
									localTransfer(defBoost[i], room, 1000, 1000, true);
									requestResource(room, defBoost[i], 0.5, 2000);
							} else {
									removeResourceRequest(room, defBoost[i]);
							}
					}
			} else if (room.class === 'bunker'){
					if (room.total('UH') < 3000){
							localTransfer('UH', room, 1000, 1000, true);
							requestResource(room, 'UH', 0.5, 2000);
					} else {
							removeResourceRequest(room, 'UH');
					}
					if (room.total('XUH2O') < 3000){
							localTransfer('XUH2O', room, 1000, 1000, true);
							requestResource(room, 'XUH2O', 0.5, 2000);
					}
			}
			let hostileNear = false;
			delete room.memory.hostileNear;
			if (room.memory.defcon < 5 && room.memory.armedHostiles && terminal && !room.controller.safeMode && room.class !== 'bunker'){
					let hostile = terminal.pos.findClosestByRange(FIND_HOSTILE_CREEPS, {filter: (c) => !c.isWhiteListed});
					if (hostile && hostile.pos.getRangeTo(terminal) < 10){
							hostileNear = true;
							room.memory.hostileNear = true;
							//hostile creep in base -> clear term
					}
			}
			//placing and extending orders
			if (terminal && terminal.pos.lookFor(LOOK_FLAGS).length == 0 && !hostileNear){
					delete room.memory.clearing;
					//moving XGH20 to prayer room
					if ((room.memory.prayerRoom || (config$1.official && room.memory.colNeeded && Game.time - room.memory.colNeeded < 1000)
					) && terminal && (!terminal.store['XGH2O'] || terminal.store['XGH2O'] < 3000) && room.controller.level > 5 && room.controller.level < 8){
							if (!Memory.upBoostNeeded){
									Memory.upBoostNeeded = [];
							} else {
									//remove old
									let index = Memory.upBoostNeeded.findIndex((r)=>r == room.name);
									if (index >= 0){
											let arr = Memory.upBoostNeeded;
											_.pullAt(arr, index);
									}
									//put new
									if (Memory.upBoostNeeded.length > 0){
											let homeTotal = room.total('XGH2O');
											index = Memory.upBoostNeeded.findIndex((r)=>{
													if (r && Game.rooms[r]){
															return Game.rooms[r].total('XGH2O')>homeTotal
													}});
									} else {
											index = 0;
									}
									let arr = Memory.upBoostNeeded;
									if (index === -1){
											arr.push(room.name);
									} else {
											arr.splice(index, 0, room.name);
									}
							}
					} else {
							//find the room.name in the list and delete if present
							if (!Memory.upBoostNeeded); else {
									let index = Memory.upBoostNeeded.findIndex((r)=>r == room.name);
									if (index > -1){
											let arr = Memory.upBoostNeeded;
											arr.splice(index, 1);
									}
							}
					}
					if (Memory.upBoostNeeded && Memory.upBoostNeeded.length > 0 && !Memory.upBoostNeeded.includes(room.name)){
							var lowBoostRoom = Memory.upBoostNeeded[0];
							if (room.name != lowBoostRoom && room.controller.level == 8 && !room.memory.prayerRoom){
									if (terminal && !terminal.hasSent && terminal.store['XGH2O'] > 1000){
											if (terminal.send('XGH2O', 1000, lowBoostRoom) == 0){
													recordTransfer(room.name, lowBoostRoom, 'XGH2O');
											}
									}
							}
					}
					if (config$1.official && room.memory.colNeeded && Game.time - room.memory.colNeeded < 1000
							&& room.total('XGH2O')<5000){
							let ret = localTransfer('XGH2O',room,500,500);
							if (!ret){
									let price = getPrice(ORDER_BUY,'XGH2O',5000,0.2);
									createOrder('XGH2O',ORDER_BUY,1000,room,{price:price,create:true});
							}
					}

					if (config$1.season && config$1.season === 'thorium' && room.memory.reactor && room.total('T')<50000){
							let force = false;
							if (room.total('T')<20000){
									force = true;
							}
							let ret = localTransfer('T',room,0,500,force);
							console.log('import T to ',room,ret);
					}
					//local transfers
					//energyImport
					let lowPriorityEnergyNeeded,mediumPriorityEnergyNeeded,highPriorityEnergyNeeded;
					let energyRatio = room.total('energy')/room.memory.reserve;
					if (energyRatio < 1.3 && (!Memory.mediumPriorityEnergyNeed || Game.time > Memory.mediumPriorityEnergyNeed) &&
							(!Memory.highPriorityEnergyNeed || Game.time > Memory.highPriorityEnergyNeed) &&
							(room.controller.level < 8 ||
							(room.memory.adjustedLowWallHits && room.memory.adjustedLowWallHits < config$1.minWalls[room.controller.level]) ||
							(room.memory.prayerSupportRoom && room.memory.prayerSupportRoom.level < 6 && room.memory.prayerSupportRoom.level > 0 && Memory.excessEnergy && Memory.excessEnergy > 150000) ||
							(room.memory.prayerRoom && Memory.excessEnergy && Memory.excessEnergy > 150000) ||
							(room.memory.factoryOperator && Game.powerCreeps[room.memory.factoryOperator] && room.total('energy') < room.memory.reserve) ||
							(Game.flags['ShardTrade'] && Game.flags['ShardTrade'].pos.roomName == room.name) ||
							energyRatio < 0.8 || (room.memory.alert && room.memory.alert === 'high' && energyRatio < 1)
					)){
							lowPriorityEnergyNeeded = true;
					}
					if (room.memory.priorityEnergyRoom && energyRatio < 2.5){
							lowPriorityEnergyNeeded = true;
					}
					if (energyRatio < 1.3 && (!Memory.highPriorityEnergyNeed || Game.time > Memory.highPriorityEnergyNeed) &&
							((room.memory.armedHostiles && energyRatio < 0.9) || (room.memory.activeSiege && energyRatio < 1) || Game.flags['fort' + room.name] ||
							(Game.flags['fill' + room.name] && energyRatio < 1.1) || room.class === 'bunker' || energyRatio < 0.75)){
							mediumPriorityEnergyNeeded = true;
							Memory.mediumPriorityEnergyNeed = Game.time + 100;
					}
					if (energyRatio < 1.3 && (room.memory.nukeDefence || energyRatio < 0.5 ||
							(energyRatio < 0.7 && (room.memory.defcon < 5 || room.memory.armedHostiles)))
						){
							highPriorityEnergyNeeded = true;
							Memory.highPriorityEnergyNeed = Game.time + 100;
					}
					if ((lowPriorityEnergyNeeded && !Game.energyCrisis && !Memory.emergency)
					|| mediumPriorityEnergyNeeded || highPriorityEnergyNeeded){
							requestEnergy(room);
					} else {
							energyNotNeeded(room);
							if (Game.market.credits > config$1.maxCredits * 2 && room.total('energy') < room.memory.reserve * 1.5 && room.terminal && room.terminal.store.getFreeCapacity()>10000
									&& Memory.excessEnergy && Memory.excessEnergy < (Memory.myRooms.length*10000)){
									//can afford to buy large quantities of energy
									requestEnergy(room,true);
							}
					}
					if (!playerHeap.roomDistanceSort[room.name]){
							let roomSortList = [];
							for (let i in Memory.myRooms){
									let sortRoom = Game.rooms[Memory.myRooms[i]];
									if (sortRoom.terminal && sortRoom.class === 'normal' && sortRoom.controller.level > 5 && sortRoom.name != room.name){
											roomSortList.push(sortRoom.name);
									}
							}
							roomSortList.sort((a, b) => {
									Game.map.getRoomLinearDistance(room.name, a) - Game.map.getRoomLinearDistance(room.name, b, true);
							});
							playerHeap.roomDistanceSort[room.name] = roomSortList;
					}
					if (room.memory.defcon > 3 && !room.controller.safeMode && Memory.energyNeeded && !room.memory.priorityEnergyRoom && Memory.energyNeeded.length > 0 && !Memory.energyNeeded.includes(room.name) &&
							(Memory.priorityEnergyRoomName || config$1.forceEnergyDonation || (room.controller.level == 8 && room.memory.walls >= config$1.minWalls[room.controller.level]) || Memory.emergency || Memory.excessEnergy > (Memory.myRooms.length * 5000)
							|| (room.total('energy')>room.memory.reserve && room.isEnergyDonor)) &&
							!((room.memory.prayerSupportRoom && room.memory.prayerSupportRoom.level < 6) || room.memory.prayerRoom)){
							let lowEnergyRoom = Game.rooms[Memory.energyNeeded[0]];
							Game.map.getRoomLinearDistance(Memory.energyNeeded[0], room.name);
							if (lowEnergyRoom && terminal && !terminal.hasSent && terminal.store['energy'] > 3000 && (!config$1.requestEnergyRoom || !config$1.requestEnergyRoom.includes(room.name))
									&& (room.total('energy') > room.memory.reserve * 1.1 || (room.total('energy') > room.memory.reserve
											&& (room.isEnergyDonor || (lowEnergyRoom.memory.defcon && lowEnergyRoom.memory.defcon < 4) || Memory.emergency)))){
									let canSend = true;
									if (lowEnergyRoom.class === 'prayer' && !room.isPrayerDonor && lowEnergyRoom.total('energy') > 50000){
											canSend = false;
									}
									let amount = 1000;
									let mod = 1.5;
									if (room.controller.level === 8){
											mod = 1.2;
									}
									if (room.total('energy') > room.memory.reserve * 1.1 && room.terminal.store['energy'] > 5000){
											amount = 2500;
									}
									if (room.total('energy') > room.memory.reserve * mod && room.terminal.store['energy'] > 10000){
											amount = 5000;
									}
									if (room.total('energy') > room.memory.reserve * mod && room.terminal.store['energy'] > 20000){
											amount = 10000;
									}
									if (room.total('energy') > room.memory.reserve * 2 && room.terminal.store['energy'] > 30000){
											amount = 15000;
									}
									let lowEnergyRoomName = lowEnergyRoom.name;
									if (config$1.forceEnergyDonation && (!Memory.highPriorityEnergyNeed || Game.time > Memory.highPriorityEnergyNeed) &&
									(!Memory.mediumPriorityEnergyNeed || Game.time > Memory.mediumPriorityEnergyNeed)){
											lowEnergyRoomName = config$1.forceEnergyDonation;
									}
									if (canSend && terminal.send(RESOURCE_ENERGY, amount, lowEnergyRoomName) == 0){
											if (config$1.forceEnergyDonation){
													console.log('sending',amount,'energy to',config$1.forceEnergyDonation);
											}
											recordTransfer(room.name, lowEnergyRoomName, 'energy');
									} else {
											console.log('cannot send energy to', lowEnergyRoom, room.name, terminal.send(RESOURCE_ENERGY, 1000, lowEnergyRoom.name));
									}
							}
					}
					if (terminal && room.class === 'prayer'){
							if (credits > config$1.maxCredits){
									if (room.total('energy') < room.memory.reserve * 0.5){
											//if we have lots of credits then buy energy
											createOrder('energy', ORDER_BUY, 5000, room, {create:true});
									}
									if (room.total('battery') < 3000 && Memory.market.resources && Memory.market.resources['battery'] && Memory.market.resources['battery'].w){
											createOrder('battery', ORDER_BUY, 1000, room, {create:true, maxTargetPrice:Memory.market.resources['battery'].w});
									}
									if (room.total('XGH2O') < 1000 && Memory.market.resources && Memory.market.resources['XGH2O'] && Memory.market.resources['XGH2O'].w){
											createOrder('XGH2O', ORDER_BUY, 500, room, {create:true,maxTargetPrice: Memory.market.resources['XGH2O'].w});
									}
							}
					}

					if (terminal && room.class === 'bunker'){
							for (let i in config$1.minerals){
									if (room.total(config$1.minerals[i])>1000){
											localTransferAway(config$1.minerals[i],room,config$1.excess,500);
									}
							}
					}
					if (terminal){
							terminal.pos.highlight('purple');
					}
					//-----------------------only normal rooms after this------------------------------------------------------------
					let warboosts = config$1.warboosts;
					if (room.class !== 'normal'){
							return
					}
					//arbitrage
					if (Game.flags['ShardTrade'] && Game.flags['ShardTrade'].pos.roomName == room.name && Game.market.credits > config$1.minCredits){
							//buying to export
							if (Memory.market.exports && room.terminal && room.storage && room.storage.store.getUsedCapacity() < room.storage.store.getCapacity()*0.9 && room.terminal.store.getUsedCapacity() < room.terminal.store.getCapacity()*0.9){
									for (let i in Memory.market.exports){
											if (COMMODITIES[i] && COMMODITIES[i].level){
													//lets hold off on commodity arbitrage for now
													continue
											}
											if (INTERSHARD_RESOURCES.includes(i)){
													continue
											}
											if (Memory.market.exports[i].volume <= 0){
													continue
											}
											//use fixed price that does not fluctuate based on amount
											let price = getPrice(ORDER_BUY,i,1000,0);
											//adjust price given we are buying - should still be profitable based on formula for identifying items to export
											price = price*1.02;
											let amount = 1000;
											if (price > Memory.market.resources['energy'].w*100){
													amount = 100;
											}
											if (price > Memory.market.resources['energy'].w*1000){
													amount = 10;
											}
											if ((config$1.minerals.includes(i) && room.total(i)<config$1.excess) || room.total(i)< amount){
													//console.log('ordering',amount,i,'for export')
													if (amount < 1000){
															amount = amount/10;
													}
													createOrder(i,ORDER_BUY,amount,room,{create:true,maxTargetPrice:price});
											}
									}
							}

							//sell imported items
							if (Memory.importsToSell){
									for (let importedItem in Memory.importsToSell){
											if ((Memory.productionMandate && Memory.productionMandate[importedItem])
											|| (Memory.mineralsNeeded && Memory.mineralsNeeded[importedItem])
											|| (Memory.boostProductionNeeded && Memory.boostProductionNeeded[importedItem])){
													delete Memory.importsToSell[importedItem];
													continue
											}
											let amountToSell = Memory.importsToSell[importedItem];
											if (amountToSell > 5 && room.total(importedItem) > 0){
													let amount = amountToSell/10;
													if (amount < 5){
															amount = 5;
													} else if (amount > 1000){
															amount = 1000;
													}
													let price = getPrice(ORDER_SELL,importedItem,1000,0);
													//adjust price given we are selling - should still be profitable based on formula for identifying items to export
													price = price*0.98;
													createOrder(importedItem,ORDER_SELL,amount,room,{create:true,maxTargetPrice:price});
													//console.log(`sell import/${Game.shard.name}/${importedItem} ${ret}`)
											}
									}
							}
					}
					//sell imported items
					if (Memory.importsToSell){
							for (let importedItem in Memory.importsToSell){
									let amountToSell = Memory.importsToSell[importedItem];
									if (amountToSell > Memory.myRooms.length*100 && room.total(importedItem) > config$1.excess){
											let amount = amountToSell/10;
											if (amount < 5){
													amount = 5;
											} else if (amount > 100){
													amount = 100;
											}
											let price = getPrice(ORDER_SELL,importedItem,1000,0);
											//adjust price given we are selling - should still be profitable based on formula for identifying items to export
											price = price*0.98;
											createOrder(importedItem,ORDER_SELL,amount,room,{create:true,maxTargetPrice:price});
											//console.log(`sell import/${Game.shard.name}/${importedItem} ${ret}`)
									}
							}
					}
					//commodities
					let factoryList = roomInputs[room.name];
					let commodityConst = config$1.commodityConst;
					let canBuyBaseCommods = getBaseCommoditiesThatCanBuy();
					let commodityTargets = getCommodityTargets();
					if (Memory.commodities && Memory.commodities.export && room.memory.defcon > 4){
							let level5s = config$1.level5Commodities;
							level5s.forEach((c) => {
									if (Memory.market && Memory.market.exports && Memory.market.exports[c] && Memory.market.exports[c].volume && Memory.market.exports[c].volume > 0 && Game.flags['ShardTrade'] && Game.flags['ShardTrade'].room){
											//export and buy for export item if able
											let shardTradeRoom = Game.flags['ShardTrade'].room;
											if (shardTradeRoom.name != room.name && (room.terminal.store[c] || room.terminal.store[c] > 0)){
													if (room.terminal.send(c, terminal.store[c], shardTradeRoom.name) == 0){
															recordTransfer(room, shardTradeRoom.name, c, terminal.store[c]);
													} else {
															console.log('cannot transfer', c, 'to ', shardTradeRoom.name, 'from', room.name, room.terminal.send(c, terminal.store[c], shardTradeRoom.name));
													}
											} else if (room.name == shardTradeRoom.name && allMarketOrders && Game.market.credits > config$1.maxCredits * 1.25 && Memory.market.exports[c].price && Memory.commodities
													&& Memory.commodities.prices && Memory.commodities.prices[c] && Memory.commodities.prices[c].avPrice
													&& Memory.commodities.prices[c].avPrice < Memory.market.exports[c].price - 20000 && room.total(c) < 60){
													let orders = allMarketOrders.filter((o) => o.resourceType == c && o.type == 'buy');
													let price = Memory.commodities.prices[c].price;
													if (orders){
															let order = orders.sort((a, b) => b.price - a.price)[0];
															if (order && (!Memory.commodities.prices[c].avPrice || order.price < (Memory.commodities.prices[c].avPrice*0.98) || order.price < Memory.market.exports[c].price)){
																	price = order.price;
															}
															if (price && Memory.market.exports[c].volume && Memory.market.exports[c].volume > 30){
																	createOrder(c, ORDER_BUY, 30, room, {create:true,maxTargetPrice: price});
															}
													}
											}
									} else if (Memory.commodities && Memory.commodities.prices && Memory.commodities.prices[c] && Game.flags['ShardTrade'] && Game.flags['ShardTrade'].room){
											let shardTradeRoom = Game.flags['ShardTrade'].room;
											if (shardTradeRoom.name != room.name && (room.terminal.store[c] || room.terminal.store[c] > 0)){
													//if not the shard trade room -> move it there to be safer
													if (room.terminal.send(c, terminal.store[c], shardTradeRoom.name) == 0){
															recordTransfer(room, shardTradeRoom.name, c, terminal.store[c]);
													} else {
															console.log('cannot transfer', c, 'to ', shardTradeRoom.name, 'from', room.name, room.terminal.send(c, terminal.store[c], shardTradeRoom.name));
													}
											} else if (room.name == shardTradeRoom.name && room.total(c)>0){
													//is shard trade room - sell
													let price;
													let urgency = 0.1;
													let targetAmount = 50;
													if (room.total(c)>targetAmount){
															//sell off quicker - will increase and decrease price more the further away we are from target so only activate if we are higher than targetAmount
															if (Game.market.credits < config$1.minCredits){
																	urgency = 0.5;
															} else if (Game.market.credits < config$1.maxCredits){
																	urgency = 0.3;
															} else if (Game.market.credits < config$1.maxCredits*2){
																	urgency = 0.2;
															}
													} else {
															if (Game.market.credits > config$1.maxCredits){
																	urgency = 0.5;
															} else if (Game.market.credits > config$1.minCredits){
																	urgency = 0.3;
															}
													}
													price = getPrice(ORDER_SELL,c,targetAmount,urgency);
													console.log('level 5 price',c,price);
													createOrder(c, ORDER_SELL, terminal.store[c], room, {maxTargetPrice: price});
											}
									} else if (room.total(c)>0 && Memory.commodities && Memory.commodities.prices && Memory.commodities.prices[c]){
											let price = Memory.commodities.prices[c].avPrice;
											if (room.total(c) > 100){
													createOrder(c, ORDER_SELL, 10, room, {create:true,maxTargetPrice: price*0.95});
											} else {
													createOrder(c, ORDER_SELL, terminal.store[c], room, {maxTargetPrice: price});
											}
									}
							});
							for (let c in factoryList){
									let q = commodityConst;
									if (COMMODITIES[c] && COMMODITIES[c].level){
											q = commodityConst / 10;
									}
									if (requestIsBlocked(c)){
											continue
									}
									if (factoryList[c] > 0 && (room.total(c) < q * 3 || (c == 'liquid' && room.total(c) < 150) || (c == 'crystal' && room.total(c) < 150))){
											let amount = q;
											if (factoryList[c]<q){
													amount = factoryList[c];
											}
											let transfer = localTransfer(c,room,0,amount,true);
											if (!transfer && !playerHeap.hasTraded[room.name]) {
													//buy needed commodity
													if (Memory.commodities.prices && Memory.commodities.prices[c] && Game.market.credits > ((config$1.maxCredits + config$1.minCredits) / 2)){
															let data = Memory.commodities.prices[c];
															if (data.profit < 0 && data.rawProfit < 0 && Memory.market.resources && Memory.market.resources[c] && Memory.market.resources[c].w && Memory.market.resources[c].sd){
																	//set price as half an sd below average
																	let dontBuy = ['metal','mist','biomass','silicon', 'energy'];
																	if (COMMODITIES[c] && !COMMODITIES[c].level && !dontBuy.includes(c)){
																			let targetPrice = Memory.market.resources[c].w - (Memory.market.resources[c].sd / 2);
																			let ret = createOrder(c, ORDER_BUY, 1000, room, {create:true,maxTargetPrice: targetPrice});
																			if (ret !== -8){
																					console.log('commod: setting order for ', c, targetPrice, ret);
																					blockRequests[c] = Game.time + 500;
																			}
																	}
															}
													}
													if (Game.market.credits > config$1.maxCredits && canBuyBaseCommods && canBuyBaseCommods.includes(c) && commodityTargets && commodityTargets[c]
															&& Game.getResourceTotal(c) && Game.getResourceTotal(c) < commodityTargets[c]/2){
															//buy this base commodity if assess as OK in commodity manager
															let price = getPrice(ORDER_BUY,c,commodityTargets[c]/2,0.1);
															let ret = createOrder(c, ORDER_BUY, 1000, room, {create:true,maxTargetPrice: price});
															if (ret !== -8){
																	console.log('setting order for ', c, ret);
																	blockRequests[c] = Game.time + 300;
															}
													}
													if (c && COMMODITIES[c] && COMMODITIES[c] && Game.market.credits > ((config$1.maxCredits + config$1.minCredits) / 2)){
															let comps = COMMODITIES[c].components;
															for (let comp in comps){
																	if (config$1.minerals.includes(comp) && room.total(comp) < config$1.excess){
																			let price = getPrice(ORDER_BUY,comp,config$1.mineralTarget/2,0.2);
																			let ret = createOrder(comp, ORDER_BUY, 10000, room, {create:true,maxTargetPrice: price});
																			if (ret !== -8){
																					console.log('setting order for ', comp, ret);
																					blockRequests[comp] = Game.time + 300;
																			}
																	}
															}
													}
											}
									}
							}
					}
					if (terminal && credits > config$1.maxCredits && room.isPrayerDonor){
							if (room.total('battery') < 500 && Memory.market.resources && Memory.market.resources['battery'] && Memory.market.resources['battery'].w){
									createOrder('battery', ORDER_BUY, 250, room, {create:true,maxTargetPrice: Memory.market.resources['battery'].w});
							}
					}
					//warboost moving
					if (warboosts && stores && !room.memory.prayerRoom &&
							(room.memory.defcon < 4 || room.memory.boostingRequired) && (room.memory.adjustedLowWallHits > config$1.minWalls[7] || !config$1.official)){
							for (let i in warboosts){
									let boost = i;
									let n = warboosts[i];
									if (room.memory.boostingRequired){
											if (config$1.boostLevels && config$1.boostLevels[room.memory.boostingRequired] && !config$1.boostLevels[room.memory.boostingRequired].includes(i)){
													continue
											}
									}
									if (terminal && _.sum(terminal.store) < terminal.store.getCapacity() && stores && room.total(boost) < n && boost != min){
											//console.log('trying to transfer', i, 'to', room.name, (warboosts[i] / 2))
											let threshold = (warboosts[i] / 2);
											if (!config$1.official && boost !== 'UH' && boost !== 'LH' && room.memory.boostingRequired){
													threshold = 0;
											}
											let wb = localTransfer(i, room, threshold, 500);
											console.log('wb transfer',room.name, i, wb);
											console.log('boosting required',room.memory.boostingRequired);
											if (!wb && (boost === 'XUH2O' || boost === 'XLH2O' || boost === 'XKHO2') && Memory.market && Memory.market.resources
													&& Memory.market.resources[boost] && Memory.market.resources[boost].w && Game.market.credits > config$1.minCredits * 0.5 && room.memory.defcon < 4){
													let urgent = false;
													let pow = 0.2;
													if (room.memory.defcon < 5 || Memory.myRooms.length < 3){
															urgent = true;
															pow = 0.5;
													}
													let price = getPrice(ORDER_BUY,i,10000,pow);
													createOrder(i, ORDER_BUY, 5000, room, {create:true,maxTargetPrice: price,urgent:urgent});
											} else if (!wb && Memory.myRooms.length < 3 && room.memory.boostingRequired && Game.market.credits > config$1.maxCredits){
													if (Memory.market && Memory.market.resources && Memory.market.resources[boost]){
															let urgent = false;
															let pow = 0.3;
															if (Game.market.credits > config$1.maxCredits*2){
																	urgent = true;
																	pow = 0.5;
															}
															let price = getPrice(ORDER_BUY,i,10000,pow);
															console.log('try buy wb',i,createOrder(i, ORDER_BUY, 5000, room, {create:true,maxTargetPrice: price,urgent:urgent}));
													}
											}
									}
							}
					}
					let shardTradeBoosts = ['LO','GO','ZO'];
					if (room.isShardTradeRoom){
							for (let i in shardTradeBoosts){
									if (room.total(shardTradeBoosts[i]) < 2000){
											localTransfer(shardTradeBoosts[i],room,500,500,true);
									}
							}
					}
					if (config$1.scoreCollection && Game.flags['scoreDump'] && Game.flags['scoreDump'].pos && Game.flags['scoreDump'].pos.roomName){
							let scoreRoom = Game.rooms[Game.flags['scoreDump'].pos.roomName];
							if (scoreRoom && scoreRoom.name != room.name && scoreRoom.controller && scoreRoom.controller.my && scoreRoom.total('score') < 200000 &&
									scoreRoom.terminal && scoreRoom.terminal.store.getUsedCapacity() < scoreRoom.terminal.store.getCapacity() * 0.9
									&& room.terminal && room.terminal.store['energy'] > 1000){
									if (room.terminal.send('score', 1000, scoreRoom.name) === 0){
											recordTransfer(room.name, scoreRoom.name, 'score');
									}
							}
					}
					if (config$1.symbolCollection && Memory.symbolDecoders && Memory.symbolDecoders[room.name]){
							let decoderType = Memory.symbolDecoders[room.name].type;
							if (room.total(decoderType) < config$1.highSymbolBound){
									localTransfer(decoderType, room, 0, 1000);
							}
							if (otherDecoders){
									for (let i in otherDecoders){
											if (otherDecoders[i] && otherDecoders[i].nearestRoom == room.name){
													let threshold = 0;
													let target = config$1.lowSymbolBound;
													if (otherDecoders[i].level == 7){
															threshold = config$1.lowSymbolBound * 0.7;
													}
													if (room.total(i) < target){
															localTransfer(i, room, threshold, 1000);
													}
											}
									}
							}
					}
					if (config$1.roomNeedsResource && config$1.roomNeedsResource[room.name] && config$1.roomNeedsResource[room.name].resource
							&& config$1.roomNeedsResource[room.name].amount && config$1.roomNeedsResource[room.name].otherRoomThreshold != undefined){
							config$1.roomNeedsResource[room.name].resource;
							if (room.total(config$1.roomNeedsResource[room.name].resource) < config$1.roomNeedsResource[room.name].amount){
									localTransfer(config$1.roomNeedsResource[room.name].resource, room, config$1.roomNeedsResource[room.name].otherRoomThreshold, 1000);
							}
					}
					//prevent storage depletion
					delete room.memory.dump;
					if (terminal.store.getUsedCapacity() > terminal.store.getCapacity() * 0.85 && room.storage.store.getUsedCapacity() > room.storage.store.getCapacity() * 0.9){
							if (room.total('energy') > room.memory.reserve * 1.5){
									let sortedRooms = playerHeap.roomDistanceSort[room.name];
									for (let i in sortedRooms){
											let sortRoom = Game.rooms[sortedRooms[i]];
											if (sortRoom && sortRoom.terminal && sortRoom.terminal.store.getUsedCapacity() < sortRoom.terminal.store.getCapacity() * 0.7){
													room.terminal.send('energy', 5000, sortedRooms[i]);
													recordTransfer(room.name, sortedRooms[i], 'energy');
													break
											}
									}
							} else if (room.memory.armedHostiles || room.memory.defcon < 5){
									let excess = [];
									for (let i in room.terminal.store){
											if (room.total(i) > config$1.excess && config$1.minerals.includes(i)){
													excess.push(i);
											}
									}
									room.memory.dump = excess[0];
							}
					}
					if (terminal && stores){
							for (let i in terminal.store){
									if (i != 'energy' && i !== 'power'){
											let total = room.total(i);
											if (config$1.swc && total > 0){
													if (!config$1.minerals.includes(i) && i !== 'energy' && i !== 'G' && COMMODITIES[i]){
															let amount = 1000;
															if (total < amount){
																	amount = total;
															}
															createOrder(i,ORDER_SELL,amount,room,{force:true,create:false});
													}
											}
											let threshold = config$1.excess;
											if (room.storeFillRatio > 0.95){
													threshold = config$1.excess*2;
											}
											if (threshold > total-5000){
													threshold = total-5000;
											}
											if (total > 60000){
													let ret = localTransferAway(i, room, threshold, 500);
													if (!ret){
															let price = getPrice(ORDER_SELL,i,config$1.excess*1.5,0.2);
															createOrder(i, ORDER_SELL, 1000, room,{maxTargetPrice: price,create:true});
													}
											} else if (total > 40000){
													let ret = localTransferAway(i, room, threshold, 500);
													if (!ret && (!config$1.warboosts || !config$1.warboosts[i])){
															let price = getPrice(ORDER_SELL,i,config$1.excess*1.5,0.2);
															createOrder(i, ORDER_SELL, 1000, room,{maxTargetPrice: price,create:true});
													}
											} else if (config$1.minerals && config$1.minerals.includes(i) && total > (config$1.excess+2000) &&
													(!Game.flags['ShardTrade'] || !Game.flags['ShardTrade'].pos || Game.flags['ShardTrade'].pos.roomName !== room.name)){
													let ret = localTransferAway(i, room, config$1.excess-2000, 500);
													if (!ret && (!Memory.mineralsNeeded || !Memory.mineralsNeeded[i]) && total>config$1.excess+2500){
															let price = getPrice(ORDER_SELL,i,config$1.excess*1.5,0.2);
															createOrder(i, ORDER_SELL, 1000, room,{maxTargetPrice: price,create:true});
													}
											} else if (total > config$1.excess*1.1){
													localTransferAway(i, room, config$1.excess-2000, 500);
											}
									} else if (i === 'energy' && room.storeFillRatio > 0.9 && room.total('energy')>room.memory.reserve*1.1){
											localTransferAway('energy',room,room.memory.reserve*2,1000);
									}
							}
					}
					//requests
					let targetmin = ['H', 'O', 'U', 'L', 'K', 'Z', 'X', 'OH', 'G', 'ops'];
					targetmin.sort((a, b) => room.total(a) - room.total(b));
					if (room.memory.alert && room.total('ops')< 20000 && !config$1.swc){
							let req = localTransfer('ops', room, 1000, 1000);
							if (!req){
									createOrder('ops', ORDER_BUY, 1000, room, {create:true});
							}
					}
					if (targetmin && targetmin.length > 0 && stores && !room.memory.prayerRoom && room.memory.defcon > 4){
							for (let i = 0; i < targetmin.length; i++){
									if (targetmin[i] === 'ops' && !config$1.official){
											continue
									}
									if (requestIsBlocked(targetmin[i])){
											continue
									}
									let amountNeeded = config$1.mineralTarget/2;
									if (config$1.maxCredits && Game.market.credits > config$1.maxCredits*2){
											amountNeeded = (config$1.mineralTarget+config$1.excess)/2;
									} else if (config$1.maxCredits && Game.market.credits > config$1.maxCredits){
											amountNeeded = config$1.mineralTarget;
									}
									if (Memory.myRooms.length === 1){
											//ensure shard trade outposts arent short on minerals - this blocks importing to main shard
											amountNeeded = config$1.mineralTarget;
									}
									if (terminal && terminal.store.getUsedCapacity() < terminal.store.getCapacity() && stores
											&& room.total(targetmin[i]) < amountNeeded && (targetmin[i] != min ||
													(config$1.maxCredits && Game.market.credits > config$1.maxCredits))
											&& room.controller.level > 5){
											let threshold = (amountNeeded + 2000);
											if (!room.memory.product && room.total(targetmin[i])< 1500){
													threshold = 2500;
											}
											let transfer = localTransfer(targetmin[i], room, threshold, 1000);
											if (!transfer && !playerHeap.hasTraded[room.name]){
													if (terminal && terminal.store.getUsedCapacity() < terminal.store.getCapacity() - 25000){
															let price = getPrice(ORDER_BUY,targetmin[i],amountNeeded,0.4);
															if (targetmin[i] == 'OH' || targetmin[i] == 'G'){
																	createOrder(targetmin[i], ORDER_BUY, 1000, room, {maxTargetPrice: price});
																	blockRequests[room.name] = Game.time + 300;
															} else {
																	let force = false;
																	if (config$1.swc){
																			force = true;
																	}
																	createOrder(targetmin[i], ORDER_BUY, 1000, room, {create:true,maxTargetPrice: price,force:force});
																	blockRequests[room.name] = Game.time + 300;
																	//console.log('ordering minerals',targetmin[i],lOrder)
															}
													}
													let priority = 0.3;
													if (room.total(targetmin) < 1000){
															priority = 0.7;
													} else if (room.total(targetmin) < config$1.mineralTarget*0.7){
															priority = 0.5;
													}
													requestResource(room, targetmin[i], priority, 3000);
											} else {
													blockRequests[room.name] = Game.time + 300;
											}
									} else {
											removeResourceRequest(room, targetmin[i]);
									}
							}
					}
					var comps = ['XUH2O', 'XGH2O', 'XLH2O', 'XZH2O', 'XGHO2', 'XLHO2', 'XZHO2', 'XKHO2'];
					for (let c in comps){
							if (room.total(comps[c]) < 20000 && terminal && _.sum(terminal.store) < terminal.store.getCapacity() - 25000 && Memory.myRooms && Memory.myRooms.length < 5 && room.memory.defcon > 4){
									let price = 5;
									if (Memory.market && Memory.market.resources && Memory.market.resources[comps[c]] && Memory.market.resources[comps[c]].w){
											price = Memory.market.resources[comps[c]].w;
									}
									createOrder(comps[c], ORDER_BUY, 2000, room, {maxTargetPrice: price});
							}
					}
					//selling energy
					if (stores && terminal && stores.store[RESOURCE_ENERGY] > room.memory.reserve * 2 && room.controller.level == 8 && room.memory.walls > config$1.wallTarget && Memory.energyNeeded.length == 0 && Game.shard.name != 'shard2'){
							createOrder('energy', ORDER_SELL, 10000, room);
					}
					//purchasing from quota
					if (Memory.resourcePurchaseQuotas){
							for (let i in Memory.resourcePurchaseQuotas){
									let res = i;
									let obj = Memory.resourcePurchaseQuotas[i];
									if (room.total(i) < obj.roomAmount && obj.amount > 0 && Memory.market
											&& Memory.market.resources && Memory.market.resources[i] && Memory.market.resources[res].w){
											let amount = 1000;
											if (obj.amount > 100000){
													amount = 10000;
											}
											let price = Memory.market.resources[res].w * obj.margin;
											if (res === 'energy'){
													price = Memory.market.resources[res].d * obj.margin;
											}
											let ret = createOrder(res, ORDER_BUY, amount, room, {create:true,maxTargetPrice: price,force: true,urgent:true});
											//console.log('trying to order',res,ret)
											if (ret === 0){
													obj.amount -= amount;
											}
									} else if (obj.amount <= 0){
											delete Memory.resourcePurchaseQuotas[i];
									}
							}
					}
					if (room.controller.level > 7 && room.memory.nuker){
							let nuker = Game.getObjectById(room.memory.nuker);
							if (nuker && nuker.store['ghodium'] < nuker.store.getCapacity('ghodium')){
									if (terminal && _.sum(terminal.store) < terminal.store.getCapacity() && stores && room.total('G') < 1000){
											localTransfer('G', room, config$1.excess, 500);
									}
							}
					}
					if (terminal && _.sum(terminal.store) < terminal.store.getCapacity() * 0.8 && room.total('energy') < room.memory.reserve * 0.7 && Memory.energyNeeded.length > 0 && Memory.energyNeeded[0] == room.name){
							createOrder('energy', ORDER_BUY, 1000, room, {create:true});
					}
					if (terminal && room.total('energy') > 300000 && Memory.energyNeeded.length == 0 && !room.memory.prayerRoom){
							createOrder('energy', ORDER_SELL, 5000, room);
					}
					//power
					if (stores && room.controller.level == 8 && !room.memory.prayerRoom){
							let total = room.total('power');
							if (total < 3000){
									if (credits > config$1.maxCredits * 1.25){
											createOrder('power', ORDER_BUY, 1000, room, {create:true});
									}
									localTransfer('power', room, config$1.excess);
							}
							if (total > 100000){
									let price = getPrice(ORDER_SELL,'power',100000,0.05);
									createOrder('power', ORDER_SELL, 1000, room,{create:true,maxTargetPrice: price});
							} else if (total > 75000){
									localTransferAway('power',room,50000,500);
							}
					}
			} else if (terminal && (terminal.pos.lookFor(LOOK_FLAGS).length > 0 || hostileNear)){
					room.memory.clearing = true;
					console.log('WARNING - clearing room ' + terminal.room.name);
					if (!playerHeap.roomDistanceSort[room.name]){
							let roomSortList = [];
							for (let i in Memory.myRooms){
									let sortRoom = Game.rooms[Memory.myRooms[i]];
									if (sortRoom.terminal && sortRoom.class === 'normal' && sortRoom.controller.level > 5 && sortRoom.name != room.name){
											roomSortList.push(sortRoom.name);
									}
							}
							roomSortList.sort((a, b) => {
									Game.map.getRoomLinearDistance(room.name, a) - Game.map.getRoomLinearDistance(room.name, b, true);
							});
							playerHeap.roomDistanceSort[room.name] = roomSortList;
					}
					if (Memory.terminals){
							let terms = false;
							for (let t in Memory.myRooms){
									let name = Memory.myRooms[t];
									if (room.name != name && Game.rooms[name]){
											if (Game.rooms[name].terminal && _.sum(Game.rooms[name].terminal.store) < Game.rooms[name].terminal.store.getCapacity() * 0.9 && Game.rooms[name].terminal.pos.lookFor(LOOK_FLAGS).length === 0){
													terms = true;
													break
											}
									}
							}
							if ((room.total('energy') < 10000 && terminal['energy'] != terminal.store.getUsedCapacity()) ||
									(Memory.toMoveStore && Memory.toMoveStore == room.name && room.total('energy') < 150000)){
									requestEnergy(room);
							} else {
									energyNotNeeded(room);
							}
							if (terms){
									let exportList = [];
									for (let i in terminal.store){
											if (room.total(i) > 0){
													exportList.push(i);
											}
									}
									if (exportList.length > 0){
											if (config$1.marketActive){
													exportList.sort((a,b)=> Memory.market.resources[b].d-Memory.market.resources[a].d);
											}
											for (let i in exportList){
													let ex = exportList[i];
													if (ex === 'energy' && exportList.length > 1){
															continue
													}
													if (terminal.hasSent){
															break
													}
													let amount = terminal.store[ex];
													if (terminal.store['energy'] && terminal.store['energy'] < amount){
															amount = terminal.store['energy'];
													}
													if (ex === 'energy' && amount > terminal.store['energy']*0.5){
															amount = Math.round(terminal.store['energy']*0.5);
													}
													let threshold = 40000;
													if (ex === 'energy'){
															threshold = 300000;
													}
													let ret = localTransferAway(ex, room, threshold, amount,true);
													console.log('clearing',room.name,ex,ret);
											}
									}
							} else {
									console.log('no terms', room.name);
									for (let i in room.terminal.store){
											if (i !== 'energy'){
													let price;
													if (Memory.market && Memory.market.resources && Memory.market.resources[i] && Memory.market.resources[i].w){
															price = Memory.market.resources[i].w * 0.8;
													}
													createOrder(i, ORDER_SELL, 1000, room, {create:true,maxTargetPrice: price});
											}
									}
							}
					}
			}

			function createOrder(resource, type, amount, room, options){
					if (!config$1.marketActive|| !room.storage){
							return
					}
					let create = false;
					let maxTargetPrice,force;
					if (options && options.create){
							create = true;
					}
					if (Game.market.credits <= 10 && options.urgent){
							create = false;
							options.urgent = true;
					}
					if (options && options.maxTargetPrice){
							maxTargetPrice = options.maxTargetPrice;
					}
					if (options && options.force){
							force = true;
					}

					if (resource == RESOURCE_OPS && ((type == ORDER_BUY && !room.memory.factoryOperator) || (type == ORDER_SELL && room.total(resource) < 50000))){
							//console.log('Sale blocked from ',room,'for',resource,' : ',type)
							return
					}
					let myOrders = Game.market.orders;
					let allOrders;
					if (allMarketOrders){
							allOrders = allMarketOrders;
					} else {
							return -1
					}
					let price = Number.parseFloat(maxTargetPrice);
					if (!options || !options.urgent){
							//adjust price based on successful transactions
							let basePrice;
							let lastTransaction;
							if (type === ORDER_BUY && playerHeap.currentRoomBuyPrices && playerHeap.currentRoomBuyPrices[room.name] && playerHeap.currentRoomBuyPrices[room.name][resource]){
									lastTransaction = playerHeap.currentRoomBuyPrices[room.name][resource][0];
									basePrice = playerHeap.currentRoomBuyPrices[room.name][resource][1];
							}
							if (type === ORDER_SELL && playerHeap.currentRoomSellPrices && playerHeap.currentRoomSellPrices[room.name] && playerHeap.currentRoomSellPrices[room.name][resource]){
									lastTransaction = playerHeap.currentRoomSellPrices[room.name][resource][0];
									basePrice = playerHeap.currentRoomSellPrices[room.name][resource][1];
							}
							if (basePrice){
									let priceIncrement = basePrice/100;
									let timeElapsed = Game.time - lastTransaction;
									let numberOfIncrementsOffset = 10;
									if (options && options.incrementTime){
											options.incrementTime;
									}
									if (options && options.incrementOffset){
											numberOfIncrementsOffset = options.incrementOffset;
									}
									let suggestedPrice;
									if (type === ORDER_SELL){
											//we want to sell high
											suggestedPrice = basePrice+(numberOfIncrementsOffset*priceIncrement)-(Math.floor(timeElapsed/100)*priceIncrement);
											if (suggestedPrice < maxTargetPrice){
													suggestedPrice = maxTargetPrice;
											}
									} else if (type === ORDER_BUY){
											//want to sell low
											suggestedPrice = basePrice-(numberOfIncrementsOffset*priceIncrement)+(Math.floor(timeElapsed/100)*priceIncrement);
											if (basePrice/maxTargetPrice > 0.5 && suggestedPrice < basePrice){
													//lets not look past an amazing deal - keep buying if last buy price much less than target price
													suggestedPrice = basePrice;
											}
											if (suggestedPrice < 0.01){
													suggestedPrice = 0.01;
											} else if (suggestedPrice > maxTargetPrice){
													suggestedPrice = maxTargetPrice;
											}
									}
									if (suggestedPrice){
											price = suggestedPrice;
									}
							}
					}
					if (!price && type === ORDER_BUY){
							price = Memory.buyprices[resource];
							if (config$1.minerals && config$1.minerals.includes(resource) && room.total(resource) < config$1.mineralTarget * 0.5){
									price = price * 1.05;
									if (room.total(resource) < 3000){
											price = price * 1.1;
									}
							}
					} else if (!price && type === ORDER_SELL){
							price = Memory.prices[resource];
							if (room.total(resource) > config$1.excess && Game.market.credits < config$1.maxCredits){
									let adjust = config$1.excess / ((room.total(resource) + (config$1.excess * 5)) / 6);
									price = Memory.prices[resource] * adjust;
							}
					}
					if (!config$1.official && Memory.buyprices && Memory.buyprices[resource] && type === ORDER_SELL && Game.market.credits < (config$1.maxCredits+config$1.minCredits)/2){
							price = Memory.buyprices[resource];
					}
					//make a slight change to prices to hopefully give minor edge in other player sort code -> endless price hiking
					// if (price && type == ORDER_BUY){
					// 		price += 0.001
					// } else if (price && type == ORDER_SELL){
					// 		price -= 0.001
					// }
					if (!price && Game.shard.name == 'shard3'){
							console.log('no price for :', resource, type, room.name,options.maxTargetPrice);
							return -2
					}
					let maxBuyOrder = config$1.minCredits / 20;
					if (maxBuyOrder < 200){
							maxBuyOrder = 200;
					}
					if (type == ORDER_BUY && price && amount && price * amount > maxBuyOrder){
							amount = Math.ceil(maxBuyOrder / price);
					}
					if (type === ORDER_SELL);
					let energyCost;
					if (Memory.market && Memory.market.resources && Memory.market.resources['energy'] && Memory.market.resources['energy'].w){
							energyCost = Memory.market.resources['energy'].w;
					} else if (Memory.market && Memory.market.resources && Memory.market.resources['energy'] && Memory.market.resources['energy'].d){
							energyCost = Memory.market.resources['energy'].d;
					}
					if ((!energyCost || (!config$1.official && (type === ORDER_BUY || Game.market.credits < config$1.maxCredits))) && Memory.buyprices && Memory.buyprices['energy']){
							energyCost = Memory.buyprices['energy'];
					}
					let order = _.filter(myOrders, (order) => order.type == type && order.resourceType == resource && order.roomName == room.name)[0];
					let maxOrdersPer = 4;
					let lim = config$1.minCredits;
					let block;
					if (Memory.priority === 'swc' || !config$1.official){
							block = true;
							lim = 1000;
					}
					if (type === ORDER_BUY){
							maxOrdersPer = 5;
					}
					if (!playerHeap.hasTraded[room.name] && !room.terminal.cooldown && allOrders && type === ORDER_SELL && room.terminal.store['energy'] > (amount) && dealsThisTick < dealsPerTickLimit){
							//***type is order_sell but in here we look through buy orders for the highest price
							//uses market info to deal rather than place orders
							let marketorders;
							if (block !== true){
									marketorders = _.filter(allOrders, (order) => (order.resourceType == resource && order.type == 'buy' && !Game.rooms[order.roomName] && order.amount > 0));
							} else {
									marketorders = _.filter(allOrders, (order) => (order.resourceType == resource && order.type == 'buy' && Game.map.getRoomType(order.roomName) == "highway"));
							}
							let sort = [];
							if (marketorders){
									sort = marketorders.sort((a, b) => {
											let aVal = (a.price * amount) - Game.market.calcTransactionCost(amount, room.name, a.roomName) * energyCost;
											let bVal = (b.price * amount) - Game.market.calcTransactionCost(amount, room.name, b.roomName) * energyCost;
											return bVal - aVal
									});
							}
							if (sort.length > 0){
									let cost = Game.market.calcTransactionCost(amount, room.name, sort[0].roomName);
									let newAmount = amount;
									if (amount > sort[0].amount){
											newAmount = sort[0].amount;
									}
									let swcConst = 1;
									if (Memory.priority == 'swc'){
											swcConst = 0.95;
									}
									while (Game.market.calcTransactionCost(newAmount, room.name, sort[0].roomName) > room.terminal.store['energy'] && newAmount > 100){
											newAmount = newAmount - 100;
									}
									if (sort[0] && ((sort[0].price > (price + ((cost * energyCost) / newAmount)) * swcConst)||force)){
											let ret = Game.market.deal(sort[0].id, newAmount, room.name);
											if (ret == 0){
													dealsThisTick++;
													if (config$1.logEnergy){
															let estimatedCost = Game.market.calcTransactionCost(newAmount, room.name, sort[0].roomName);
															room.logEnergyStats('dealCost', estimatedCost);
													}
													playerHeap.hasTraded[room.name] = true;
													console.log('transaction: ' + room.name + ' ' + type + ' ' + newAmount + ' ' + resource);
													return 0
											} else {
													console.log('sell: ', ret, room.name, resource, sort[0].id, newAmount, amount,sort[0].roomName);
											}
									}
							}
					}
					if (type === ORDER_BUY && room.class !== 'restructuring' && room.storage.store.getUsedCapacity() > room.storage.store.getCapacity() * 0.95){
							console.log('room full -> cant buy', resource, room.name);
							return -3
					}
					if (!playerHeap.hasTraded[room.name] && !room.terminal.cooldown && dealsThisTick < dealsPerTickLimit && allOrders && type === ORDER_BUY && room.terminal.store['energy'] > (amount) && (credits > lim || force)){
							//uses market info to deal rather than place orders
							let marketorders = _.filter(allOrders, (order) => (order.resourceType == resource && order.type == 'sell' && !Game.rooms[order.roomName] && order.amount > 0));
							let sort = marketorders.sort((a, b) => {
									let aVal = (a.price * amount) + Game.market.calcTransactionCost(amount, room.name, a.roomName) * energyCost;
									let bVal = (b.price * amount) + Game.market.calcTransactionCost(amount, room.name, b.roomName) * energyCost;
									return aVal - bVal
							});
							if (sort.length > 0){
									let cost = Game.market.calcTransactionCost(amount, room.name, sort[0].roomName);
									let newAmount = amount;
									if (amount > sort[0].amount){
											newAmount = sort[0].amount;
									}
									let swcConst = 1;
									if (Memory.priority == 'swc'){
											swcConst = 0.95;
									}
									//console.log(sort[0].price,(Memory.buyprices[resource]-((cost*energycost)/amount))*swcConst)
									if (sort[0] && sort[0].price < (price - ((cost * energyCost) / newAmount)) * swcConst){
											let ret = Game.market.deal(sort[0].id, newAmount, room.name);
											if (ret == 0){
													dealsThisTick++;
													if (config$1.logEnergy){
															let estimatedCost = Game.market.calcTransactionCost(newAmount, room.name, sort[0].roomName);
															room.logEnergyStats('dealCost', estimatedCost);
													}
													console.log('transaction: ' + room.name + ' ' + type + ' ' + resource + ' ' + newAmount);
													playerHeap.hasTraded[room.name] = true;
													return 0
											} else {
													console.log('transaction failed: ' + room.name + ' ' + type + ' ' + resource + ' ' + newAmount + ' ' + ret);
											}
									}
							}
					}
					if (type === ORDER_BUY && credits < lim && !force){
							if (order && order.price != price){
									Game.market.changeOrderPrice(order.id, price);
							}
							//console.log('credits less than limit -> cannot buy', resource)
							return -4
					}
					//block to stop creating sell orders in competition format
					if (type === ORDER_SELL && block === true){
							return -5
					}
					let minAmount = amount * 0.1;
					if (minAmount > 100){
							minAmount = 100;
					}
					//is less then minAmount then we will extend order - change price first to save on fees
					if (order && order.price != price && (order.remainingAmount < minAmount ||
							(type === ORDER_BUY && order.price < price) || (type === ORDER_SELL && order.price > price))){
							//only change price of an order in one direction to prevent endless price changing fees (except if the remainingAmount is low)
							Game.market.changeOrderPrice(order.id, price);
					}
					//extend
					if (order && order.remainingAmount < minAmount && order.price < 1000 && (type == ORDER_BUY || (room.terminal.store[resource] && room.terminal.store[resource] >= amount))
							&& order.remainingAmount < amount / 2){
							Game.market.extendOrder(order.id, amount);
							return 0
					}
					//return if too many orders for this compound so as to not waste orders
					let sameTypeOrders = _.filter(myOrders, (order) => order.type == type && order.resourceType == resource).length;
					if (sameTypeOrders && sameTypeOrders >= maxOrdersPer && resource != 'energy'){
							//console.log('too many orders ->',resource)
							//trade clear up
							for (let o in Game.market.orders){
									var ord = Game.market.orders[o];
									if (ord.active == false && ord.remainingAmount === 0){
											Game.market.cancelOrder(ord.id);
									}
							}
							return -8
					}
					// no order on market
					if (!order && (create && create === true) && !playerHeap.hasTraded[room.name]){
							//while we don't need to prevent creating orders if we have traded this tick, we risk not looking for better prices and dealing if we don't check playerHeap.hasTraded here
							let create = Game.market.createOrder(type, resource, price, amount, room.name);
							if (create == -8){
									//trade clear up
									for (var o in Game.market.orders){
											var ord = Game.market.orders[o];
											if (ord.active == false && ord.remainingAmount === 0){
													Game.market.cancelOrder(ord.id);
											}
									}
							} else {
									//console.log(resource, room.name, type, 'creating order status:', create)
									return 0
							}
					}
					return -7
			}
			function requestIsBlocked(resource){
					if (blockRequests && blockRequests[resource] && Game.time < blockRequests[resource]){
							return true
					}
			}

			function energyNotNeeded(room){
					//find the room.name in the list and delete if present
					if (room.total('energy') > room.memory.reserve && !room.memory.armedHostiles || (room.total('energy') > room.memory.reserve * 2)){
							removeResourceRequest(room, 'energy');
					}
					if (!Memory.energyNeeded); else {
							let index = Memory.energyNeeded.findIndex((r)=>r == room.name);
							if (index > -1){
									let arr = Memory.energyNeeded;
									arr.splice(index, 1);
							}
					}
			}

			function requestEnergy(room,doNotaddToArray){
					if (room.isEnergyDonor && !doNotaddToArray){
							energyNotNeeded(room);
							return
					}
					if (Memory.resourcePurchaseQuotas){
							for (let i in Memory.resourcePurchaseQuotas){
									let res = i;
									let obj = Memory.resourcePurchaseQuotas[i];
									if (res === 'energy'){
											if (obj && obj.amount > 0 && room.total('energy')< obj.roomAmount){
													//energy requested separately via purchase quotas
													return
											}
									}
							}
					}
					let priority = 0.1;
					if (room.total('energy') < room.memory.reserve * 0.8 && room.memory.activeSiege){
							priority = 0.3;
					}
					if (room.total('energy') < room.memory.reserve * 0.7 && room.memory.activeSiege){
							priority = 0.4;
					}
					if (room.total('energy') < room.memory.reserve * 0.5){
							priority = 0.5;
					}
					if (room.total('energy') < room.memory.reserve*1.3 && config$1.requestEnergyRoom && config$1.requestEnergyRoom.includes(room.name) &&
							(Game.flags['defend' + room.name] || room.controller.level < 8 || room.memory.activeSiege || room.memory.sites)){
							Memory.requestingEnergy = true;
							priority = 0.7;
					} else if (room.total('energy') < room.memory.reserve*1.5 && config$1.requestEnergyRoom && config$1.requestEnergyRoom.includes(room.name) &&
							(Game.flags['defend' + room.name] || room.controller.level < 8 || room.memory.activeSiege || room.memory.sites)){
							Memory.requestingEnergy = true;
							priority = 0.6;
					}
					if (room.total('energy') < room.memory.reserve * 0.3){
							priority = 0.7;
					}
					if (room.total('energy') < 10000 && (room.memory.activeSiege || (room.memory.siege && Object.keys(room.memory.siege).length > 0))){
							priority = 0.9;
					}

					if (((room.total('energy') === 0 || room.memory.armedHostiles) && (room.memory.defcon < 5 || room.total('energy') < 10000))){
							priority = 0.95;
					}
					if ((priority >= 0.5 || Game.energyCaution)){
							if (priority > 0.3 && !Memory.emergency && !Game.energyCrisis){
									priority = 0.3;
							}
							if (priority > 0.1 && !Game.energyCaution){
									priority = 0.1;
							}
							requestResource(room, 'energy', priority, 10000);
					} else {
							removeResourceRequest(room, 'energy');
					}
					if (!Memory.energyNeeded){
							Memory.energyNeeded = [];
					} else if (!doNotaddToArray) {
							//remove old
							let arr = Memory.energyNeeded;
							if (!arr.includes(room.name)){
									arr.push(room.name);
							}
							if (arr.length > 1){
									try {
											arr.sort((a, b) => {
													let aEnergy = Game.rooms[a].total('energy');
													let bEnergy = Game.rooms[b].total('energy');
													let aRes = Game.rooms[a].memory.reserve;
													let bRes = Game.rooms[b].memory.reserve;
													if (aEnergy < 50000 || bEnergy < 50000 || !aRes || !bRes){
															return aEnergy - bEnergy
													} else {
															let aDif = aEnergy / aRes;
															let bDif = bEnergy / bRes;
															return aDif - bDif;
													}
											});
									} catch (e){
											console.log(e);
											delete Memory.energyNeeded;
									}
							}
					}
					let energyTarget = room.memory.reserve;
					//buy if no other rooms
					let pow = 0.1;
					if (room.memory.defcon < 5 || Game.energyCrisis){
							pow = 0.5;
					} else if (Game.energyCaution || Game.market.credits > config$1.maxCredits*2){
							pow = 0.2;
					}
					if (Game.market.credits > config$1.maxCredits*2 && (Game.flags['fill'+room.name]||Game.flags['bunker'+room.name])){
							pow = 0.5;
							energyTarget = room.memory.reserve*2;
					}
					let price = getPrice(ORDER_BUY,'energy',energyTarget,pow);
					let baseEnergyPrice = getPrice(ORDER_BUY,'energy',1,0);
					let batteryPrice = getPrice(ORDER_BUY,'battery',2000,0.1);
					let batteryToEnergyRatio = COMMODITIES['battery'].components['energy']/COMMODITIES['battery'].amount;
					//prevent buying batteries if they are signif more expensive than energy - adjust by 1.25 to take into account fluctuations and the fact batteries are cheaper to move
					let maxBatteryPrice = baseEnergyPrice*batteryToEnergyRatio*1.25;
					if (room.controller.level === 8 && batteryPrice && maxBatteryPrice && batteryPrice < maxBatteryPrice && room.total('battery')<5000 &&
							((Game.market.credits > config$1.maxCredits && !doNotaddToArray) || Game.market.credits > config$1.maxCredits*2)){
							createOrder('battery', ORDER_BUY, 1000, room, {create:true,maxTargetPrice:batteryPrice});
					}
					if (Memory.highEnergyCount != undefined && Memory.highEnergyCount == 0 && room.total('energy')< room.memory.reserve *0.7){
							createOrder('energy', ORDER_BUY, 5000, room, {maxTargetPrice: price,create:true});
					} else if (room.total('energy') < room.memory.reserve * 0.9 && Game.market.credits > config$1.maxCredits){
							createOrder('energy', ORDER_BUY, 10000, room, {create:true,maxTargetPrice: price});
					} else if (Game.market.credits > config$1.minCredits * 1.8 && room.total('energy') < room.memory.reserve * 0.5){
							createOrder('energy', ORDER_BUY, 5000, room, {create:true,maxTargetPrice: price,urgent:true});
					} else if (Game.market.credits > config$1.maxCredits * 2 && room.total('energy') < room.memory.reserve*2){
							if (doNotaddToArray){
									//no urgent need - even lower price
									price = price * 0.95;
							}
							createOrder('energy', ORDER_BUY, 5000, room ,{create:true,maxTargetPrice: price});
					}
					if (room.total('energy') < room.memory.reserve * 0.8 && room.memory.defcon && room.memory.defcon < 5){
							let urgent = false;
							if (room.memory.defcon < 4 || room.total('energy') < room.memory.reserve * 0.5){
									urgent = true;
							}
							createOrder('energy', ORDER_BUY, 10000, room, {create:true,maxTargetPrice: price,urgent:urgent});
					}
			}
			function getPrice(type,resource,amountNeeded,pow){
					let margin = 1;
					let roomAmount = room.total(resource);
					if (!roomAmount && type !== ORDER_BUY && type !== 'buy'){
							return false
					}
					let ratio = room.total(resource)/amountNeeded;
					if (pow === undefined || pow === false){
							//urgency of 1 -> more extreme price changes based on how far we are from target amount
							//urgency of 0 -> price will not change based on amount
							pow = 0.5;
					}
					let adjust = Math.pow(ratio,pow);
					margin = 1+(1-adjust);
					if (margin > 1+pow || !roomAmount){
							margin = 1+pow;
					} else if (margin < 1-pow){
							margin = 1-pow;
					}
					let wPrice,dPrice;
					if (Memory.market && Memory.market.resources && Memory.market.resources[resource] && Memory.market.resources[resource].w){
							wPrice = Memory.market.resources[resource].w;
					}
					if (Memory.market && Memory.market.resources && Memory.market.resources[resource] && Memory.market.resources[resource].d){
							dPrice = Memory.market.resources[resource].d;
					}
					if (dPrice && wPrice && Math.abs(1-adjust) > 0.1){
							//more than a 10% price change from standard - check if we need to daily price
							let diffenceFactor;
							if (wPrice && dPrice){
									if (wPrice > dPrice){
											diffenceFactor = wPrice/dPrice;
									} else {
											diffenceFactor = dPrice/wPrice;
									}
							}
							if (diffenceFactor>1.25){
									return dPrice*margin
							}
							//TODO if we have access to current prices and they are close to the daily price or weekly price - use these in preference
					}
					if (!config$1.official && type === ORDER_SELL && Game.credits < config$1.maxCredits && Memory.buyprices && Memory.buyprices[resource]){
							return Memory.buyprices[resource]*margin
					} else if (!config$1.official && type === ORDER_BUY && Memory.prices && Memory.prices[resource] && roomAmount <= 5000){
							return Memory.prices[resource]*margin
					}
					if (wPrice){
							return wPrice*margin
					} else {
							return dPrice*margin
					}
			}
			function localTransferAway(resource, room, threshold, transferAmount,force){
					if (!threshold || !room || !resource || !room.terminal || Memory.myRooms.length < 2){
							return false
					}
					let excessBlockTime = 2000;
					if (room.terminal.hasSent){
							//.log('local transfer away busy',resource, room)
							return false
					}
					if (playerHeap.noRecipient[resource] && playerHeap.noRecipient[resource]> Game.time && !force){
							//console.log('no recipient',resource, room)
							return false
					}
					let amount = 1000;
					if (transferAmount){
							amount = transferAmount;
					}
					if (room.terminal.store['energy'] < amount){
							amount = room.terminal['energy'];
					}
					let sortedRooms = playerHeap.roomDistanceSort[room.name];
					let recipientRoom,recipientTotal;
					if (room.terminal.store['energy'] >= 100 && amount){
							for (let i in sortedRooms){
									let checkRoom = Game.rooms[sortedRooms[i]];
									if (checkRoom.memory.activeSiege || checkRoom.memory.defcon < 4 || checkRoom.memory.clearing || checkRoom.storeFillRatio > 0.9){
											continue
									}
									if (checkRoom.total(resource) < threshold && checkRoom.terminal.store.getFreeCapacity() > 20000){
											recipientRoom = checkRoom;
											recipientTotal = checkRoom.total(resource);
											break
									} else if (checkRoom.total(resource) >= threshold);
							}
					} else {
							//console.log('lta no energy',room,resource)
							return false
					}
					if (!recipientRoom){
							playerHeap.noRecipient[resource] = Game.time + excessBlockTime;
							if (config$1.official);
							return -5
					} else {
							let ret = room.terminal.send(resource, amount, recipientRoom.name);
							if (ret == 0){
									console.log('local transfer away',room.name, recipientRoom.name, resource, amount);
									console.log(`local away transfer|${Game.shard.name}| ${Game.time}  ${room.name} ---[${resource} ${amount}]--> ${ recipientRoom.name}  threshold ${threshold} recipientTotal ${recipientTotal}`);
									recordTransfer(room.name, recipientRoom.name, resource);
									return true
							} else {
									room.display(`transfer away blocked ${ret}`);
									return ret
							}
					}
			}
	}
	function recordTransfer(origin, destination, resource, amount){
			//console.log('Transfers: sending ' + amount + ' ' + resource + ' to ' + destination + ' from ' + origin)
			if (resource == 'energy'){

					if (config$1.mapVisual && !config$1.conserveCpu){
							Game.map.visual.line(new RoomPosition(45, 45, destination), new RoomPosition(45, 45, origin));
							Game.map.visual.circle(new RoomPosition(45, 45, destination), {color: 'orange'});
					}
					if (!Game.rooms[origin].memory.energyContributed){
							Game.rooms[origin].memory.energyContributed - 0;
					}
					if (!Game.rooms[destination].memory.energyContributed){
							Game.rooms[destination].memory.energyContributed - 0;
					}
					Game.rooms[origin].memory.energyContributed += 1;
					Game.rooms[destination].memory.energyContributed -= 1;
			}
			//use room.name for origin and destination
			/*
			if(Memory.terminals[origin] && Memory.terminals[destination]){
					if (!Memory.terminals[origin].outgoing){
							Memory.terminals[origin].outgoing = []
					}
					if (!Memory.terminals[destination].incoming){
							Memory.terminals[destination].incoming = []
					}

							let recordOut = (Memory.terminals[origin].outgoing)
							if (recordOut.length < 5){
									recordOut.push(amount+' '+resource+' to '+ destination)
							} else {
									_.pullAt(recordOut, [0])
									recordOut.push(amount+' '+resource+' to '+ destination)
							}
							let recordIn = (Memory.terminals[destination].incoming)
							if (recordIn.length < 5){
									recordIn.push(amount+' '+resource+' from '+ origin)
							} else {
									_.pullAt(recordIn, [0])
									recordIn.push(amount+' '+resource+' from '+ origin)
							}
							if (Memory.stats['transferCost']){
									Memory.stats['transferCost'] = Memory.stats['transferCost'] + Game.market.calcTransactionCost(amount,origin,destination)
							} else {
									Memory.stats['transferCost'] = Game.market.calcTransactionCost(amount,origin,destination)
							}

			}*/
	}
	function localTransfer(resource, room, threshhold, transferAmount, force){
			if (threshhold === undefined || !room || !resource || room.storeFillRatio > 0.95){
					return false
			}
			if (room.total(resource)>config$1.excess){
					console.log(`announcement|${Game.shard.name}|trying to move resource to room with excess ${room.name} ${resource}`);
			}
			let amount = 1000;
			if (transferAmount){
					amount = transferAmount;
			}
			let sortedRooms = playerHeap.roomDistanceSort[room.name];
			let excessBlockTime = 2000;
			if (config$1.warboosts[resource]){
					excessBlockTime = 1;
			}
			if (playerHeap.noExcess[resource] && playerHeap.noExcess[resource] < Game.time){
					delete playerHeap.noExcess[resource];
			}
			if (!sortedRooms){
					sortedRooms = Memory.myRooms;
			}
			let donorRoom;
			if (!playerHeap.noExcess[resource] || force){
					for (let i in sortedRooms){
							let checkRoom = Game.rooms[sortedRooms[i]];
							if (checkRoom.memory.boostingRequired || checkRoom.memory.defcon < 4){
									continue
							}

							if ((resource === 'LO' || resource === 'GO' || resource === 'ZO') &&
									checkRoom.isShardTradeRoom && checkRoom.total(resource) < 2000){
									continue
							}
							if (resource === 'ops' && checkRoom.memory.alert && checkRoom.total('ops')< 30000){
									continue
							}
							if (config$1.symbolCollection && Memory.symbolDecoders && Memory.symbolDecoders[sortedRooms[i]]
									&& Memory.symbolDecoders[sortedRooms[i]].type && Memory.symbolDecoders[sortedRooms[i]].type == resource){
									continue
							}
							if (checkRoom.terminal && (checkRoom.terminal.hasSent || force)){
									continue
							}
							if (checkRoom.memory.colNeeded && Game.time - checkRoom.memory.colNeeded < 1000
									&& resource === 'XGH2O'){
									continue
							}
							if (config$1.season && config$1.season === 'thorium' && resource === 'T' && checkRoom.memory.reactor){
									continue
							}
							if (checkRoom.total(resource) > threshhold && checkRoom.terminal.store['energy'] >= amount && checkRoom.terminal.store[resource] >= amount){
									donorRoom = checkRoom;
									if (COMMODITIES[resource] && COMMODITIES[resource].level){
											//trying to bulk up some transactions
											let checkAmount = Math.round(25/COMMODITIES[resource].level);
											//console.log(resource,'checkAmount',checkAmount)

											if (amount < checkAmount && checkRoom.terminal.store[resource]>= amount){
													if (checkRoom.terminal.store[resource]>=checkAmount){
															amount = checkAmount;
													} else {
															amount = checkRoom.terminal.store[resource];
													}
											}
									}

									break
							}
					}
			} else {
					return false
			}
			if (!donorRoom){
					playerHeap.noExcess[resource] = Game.time + excessBlockTime;
					return false
			} else {
					if (donorRoom.terminal.send(resource, amount, room.name) == 0){
							console.log('local transfer',donorRoom, room.name, resource, amount);
							console.log(`local transfer|${Game.shard.name}| ${Game.time}  ${donorRoom.name} ---[${resource} ${amount}]--> ${room.name}`);
							recordTransfer(donorRoom, room.name, resource);
							return true
					} else {
							return -11
					}
			}
	}

	function setPrices(){
			//prices
			if (Game.time % 1000 == 0 || !Memory.prices){
					Memory.buyprices = {};
					Memory.prices = {};
					var orders = Game.market.getAllCachedOrders();
					var res = ['H', 'O', 'U', 'L', 'K', 'Z', 'X', 'power', 'energy', 'G', 'ops'];
					for (let n = 0; n < res.length; n++){
							let price;
							var ordersbyresource = _.filter(orders, (order) => (order.resourceType == res[n] && order.type == 'sell' && !Game.rooms[order.roomName]));
							//var totalprice = ordersbyresource.reduce(function(acc, val) {return acc + val.price; }, 0);
							if (ordersbyresource.length > 0){
									var totalprice = ordersbyresource.sort(function (a, b){
											return (a.price) - (b.price)
									});
									if (totalprice[0] != undefined){
											price = (totalprice[0].price) * 1.05;
									} else {
											price = totalprice[0].price;
									}
									if (price < 0.1 && res[n] != 'energy'){
											price = 0.1;
									}
									Memory.prices[res[n]] = price;
							} else {
									Memory.prices[res[n]] = 1;
							}
					}
					for (let n = 0; n < res.length; n++){
							var ordersbyresource = _.filter(orders, (order) => (order.resourceType == res[n] && order.type == 'buy' && !Game.rooms[order.roomName]));
							//var totalprice = ordersbyresource.reduce(function(acc, val) {return acc + val.price; }, 0);
							if (ordersbyresource.length > 0){
									let price;
									var totalprice = ordersbyresource.sort(function (a, b){
											return (b.price) - (a.price)
									});
									if (totalprice[0] != undefined){
											price = totalprice[0].price;
									} else {
											if (res[n] === 'energy'){
													price = 0.001;
											} else {
													price = 0.1;
											}
									}

									if (price > 5 && res[n] !== 'G' && res[n] != 'power' && Memory.priority != 'swc'){
											price = 5;
											if (Memory.market && Memory.market.resources[res[n]] && Memory.market.resources[res[n]].w){
													price = Memory.market.resources[res[n]].w;
											} else if (Memory.market && Memory.market.resources[res[n]] && Memory.market.resources[res[n]].d){
													price = Memory.market.resources[res[n]].d;
											}
									}

									if (res[n] === 'G'){
											let basecost = Memory.buyprices['L'] + Memory.buyprices['U'] + Memory.buyprices['Z'] + Memory.buyprices['K'];
											if (basecost && price > basecost){
													price = basecost;
											}
									}
									Memory.buyprices[res[n]] = price;
							} else {
									Memory.buyprices[res[n]] = 0.1;
							}

					}
					var comps = ['XUH2O', 'XGH2O', 'XLH2O', 'XZH2O', 'XGHO2', 'XLHO2', 'XZHO2', 'XKHO2', 'OH'];
					for (let n = 0; n < comps.length; n++){
							Memory.buyprices[comps[n]] = calculateCost(comps[n]) * 0.5;
					}
			}

			function calculateCost(res){
					let arr = res.split('');
					for (var i in arr){
							if (arr[i] === '2'){
									arr[i] = arr[i - 1];
							}
					}
					var cost = 0;
					for (var i in arr){
							let icost = Memory.buyprices[arr[i]];
							var cost = cost + icost;
					}
					return cost
			}

	}
	playerHeap.checkedTransactions = {
			//log by transaction ID
			//so we only action fresh transactions
	};
	function handleTransactions(){
			let incoming = Game.market.incomingTransactions;
			let outgoing = Game.market.outgoingTransactions;
			delete Memory.stats.transactions;
			processTransactions(incoming);
			processTransactions(outgoing);
			//directions : in (we are buying although this may be from both buy and sell orders) and out (we are selling - both types of orders)
			function processTransactions(transactions){
					for (let i in transactions){
							let transaction = transactions[i];
							if (transaction.sender && transaction.recipient && transaction.sender.username === transaction.recipient.username);
							if (!playerHeap.checkedTransactions[transaction.transactionId]){
									//we have not processed this transaction
									let direction = 'in';
									if (transaction.recipient && transaction.recipient.username !== Game.username){
											direction = 'out';
									}
									if (transaction.order && transaction.order.id){
											let time = transaction.time;
											let res = transaction.resourceType;
											let price = transaction.order.price;
											if (direction === 'in'){
													let myRoomName = transaction.to;
													if (!playerHeap.currentRoomBuyPrices[myRoomName]){
															playerHeap.currentRoomBuyPrices[myRoomName] = {};
													}
													if (!playerHeap.currentRoomBuyPrices[myRoomName][res]){
															playerHeap.currentRoomBuyPrices[myRoomName][res] = [time,price];
													} else if (playerHeap.currentRoomBuyPrices[myRoomName][res][0] < time){
															//ensure the price is the most recent
															playerHeap.currentRoomBuyPrices[myRoomName][res] = [time,price];
													}
											} else {
													if (transaction.time === (Game.time-1) && Memory.importsToSell && Memory.importsToSell[transaction.resourceType]){
															Memory.importsToSell[transaction.resourceType] -= transaction.amount;
															if (Memory.importsToSell[transaction.resourceType]<0){
																	delete Memory.importsToSell[transaction.resourceType];
															}
													}
													let myRoomName = transaction.from;
													if (!playerHeap.currentRoomSellPrices[myRoomName]){
															playerHeap.currentRoomSellPrices[myRoomName] = {};
													}
													if (!playerHeap.currentRoomSellPrices[myRoomName][res]){
															playerHeap.currentRoomSellPrices[myRoomName][res] = [time,price];
													} else if (playerHeap.currentRoomSellPrices[myRoomName][res][0] < time){
															//ensure the price is the most recent
															playerHeap.currentRoomSellPrices[myRoomName][res] = [time,price];
													}
											}
											//console.log(`transaction processed: ${transaction.order.id}  ${transaction.resourceType} ${direction}`)
									}
							}
							//ensure we set transaction as current still as still on recent list - wouldn't want to reprocess
							playerHeap.checkedTransactions[transaction.transactionId] = Game.time;
							if (!Memory.stats.transactions){
									Memory.stats.transactions = [];
							}
							let fromUser,toUser;
							let orderData = '';
							if (transaction){
									transaction.sender && transaction.sender.username ? fromUser = transaction.sender.username: fromUser ='NPC';
									transaction.recipient && transaction.recipient.username ? toUser = transaction.recipient.username: toUser ='NPC';
							}
							if (transaction.order){
									if (fromUser === Game.username){
											orderData = `__ + ${transaction.amount*transaction.order.price} cr`;
									} else {
											orderData = `__ - ${transaction.amount*transaction.order.price} cr`;
									}
							}

							let transactionStr = `${transaction.time} transaction ${fromUser} (${transaction.from}) --> ${toUser} (${transaction.to}) ${transaction.resourceType} ${transaction.amount} ${orderData}`;
							//console.log(`transfer|${Game.shard.name}|${transactionStr}`)
							if (!config$1.official || true){
									if (fromUser !== toUser || true){
											Memory.stats.transactions.push(transactionStr);
									}
							} else {
									delete Memory.stats.transactions;
							}
					}
			}
	}

	function runCaravanManager(){
			if (!config.season || config.season !== 'caravan'){
					delete Memory.caravans;
					return
			}
			for (let id in Memory.caravans){
					let caravan = Memory.caravans[id];
					if (caravan && caravan.expiry && caravan.expiry < Game.time){
							delete Memory.caravans[id];
					}
					let currentRoom = caravan.lastRoom;
					if (caravan.predictedTimes){
							currentRoom = guessCurrentRoom(id);
					}
					if (caravan && caravan.assignedRoom && currentRoom){
							console.log(`caravan ${id} in ${currentRoom} assigned to ${caravan.assignedRoom}`);
							Game.map.visual.text('C',new RoomPosition(25,25,currentRoom));
							Game.map.visual.line(new RoomPosition(25,25,caravan.assignedRoom),new RoomPosition(25,25,currentRoom));
							let targets = getCommodityTargets();
							let ableToIntercept = canIntercept(caravan.assignedRoom,id,true);
							for (let i in caravan.members){
									let member = caravan.members[i];
									if (member && member.commodity && member.amountRemaining){
											let commodity = member.commodity;
											let targetAmount = targets[commodity]*0.1;
											if (targetAmount > 2000){
													targetAmount = 2000;
											}
											if (COMMODITIES[commodity] && COMMODITIES[commodity].level && COMMODITIES[commodity].level > 2){
													targetAmount = 0;
											}
											if (commodity && COMMODITY_SCORE && COMMODITY_SCORE[commodity] && targets && targets[commodity]){
													let homeRoom = Game.rooms[caravan.assignedRoom];
													if (ableToIntercept && Game.getResourceTotal(commodity) > targetAmount && homeRoom.terminal
													&& homeRoom.terminal.store[commodity] > 0 && COMMODITIES[commodity]){
															//console.log(`could score ${commodity} in caravan ${id}, intercept room: ${ableToIntercept}`)
															let healed = false;
															if (COMMODITIES[commodity] && COMMODITIES[commodity].level && COMMODITIES[commodity].level>1){
																	healed = true;
															}
															homeRoom.sendCaravanHauler(i,id,healed);
													} else if (ableToIntercept && Game.getResourceTotal(commodity) > targetAmount && COMMODITIES[commodity]);
													if (homeRoom.total(commodity)<1000 && homeRoom.total(commodity)<Game.getResourceTotal(commodity)){
															let amount = 1000;
															if (COMMODITIES[commodity] && COMMODITIES[commodity].level){
																	amount = 1;
															}
															localTransfer(commodity,homeRoom,0,amount,true);
													}
											}
									}
							}
					}
			}
	}
	function guessCurrentRoom(id){
			if (id && Memory.caravans && Memory.caravans[id]){
					let caravan = Memory.caravans[id];
					let currentRoom = caravan.lastRoom;
					let mostRecent,mostRecentTime;
					if (caravan.predictedTimes){
							for (let i in caravan.predictedTimes){
									let time = caravan.predictedTimes[i];
									if (time < Game.time){
											if (!mostRecent || time > mostRecentTime){
													mostRecent = i;
													mostRecentTime = time;
											}
									}
							}
							if (mostRecent){
									currentRoom = mostRecent;
							}
					}
					return currentRoom
			}
	}
	function logCaravans(room){
			let creeps = room.find(FIND_CREEPS,{filter:(c)=>c.owner.username === 'Screeps'});
			if (!Memory.caravans){
					Memory.caravans = {};
			}
			let caravansInRoom = {};
			for (let i in creeps){
					let creep = creeps[i];
					let split = creep.name.split('_');
					let id = split[0].slice(5);
					let creepNum = split[1];
					if (!creep || !creep.ticksToLive){
							continue
					}
					if (!caravansInRoom[id] && creepNum === '0'){
							//leader is in this room
							caravansInRoom[id] = creep;
					}
					if (!Memory.caravans[id]){
							Memory.caravans[id] = {
									members : {},
									currentRoom:room.name,
									expiry: Game.time+(creep.ticksToLive-300)
							};
					}
					let commodity;
					for (let i in creep.store){
							if (creep.store[i]>0){
									commodity = i;
							}
					}
					if (commodity){
							Memory.caravans[id].members[creep.id] = {
									commodity : commodity,
									amountRemaining: creep.store.getFreeCapacity(commodity)
							};
					}
			}
			for (let id in caravansInRoom){
					let mem = Memory.caravans[id];
					if (mem.lastRoom && mem.lastRoom !== room.name && Game.map.getHighwaySide(room.name) !== 'corner'){
							//caravan has moved
							let dir = assessDirection(mem.lastRoom,room.name);
							Memory.caravans[id].direction = dir;
					}
					mem.lastRoom = room.name;
					if (mem.direction && !mem.assignedRoom){
							let assignedRoom = assignHomeRoom(room.name,mem.direction);
							if (assignedRoom){
									mem.assignedRoom = assignedRoom;
							}
					}
					if (mem.direction && (Game.map.getHighwaySide(room.name) !== 'corner' || (mem.expiry && mem.expiry-Game.time>500))){
							mem.predictedTimes = predictedInterceptRooms(room.name,mem.direction);
					}
			}
	}
	function assignHomeRoom(startRoom,dir){
			let currentRoom = startRoom;
			let distance = 0;
			let best,bestDif;
			while (distance <= 10){
					distance++;
					currentRoom = Game.map.moveRoom(currentRoom,dir);
					if (Game.map.getHighwaySide(currentRoom) === 'corner'){
							break
					}
					if (distance > 3){
							for (let i in Game.myRooms){
									let myRoom = Game.myRooms[i];
									let myRoomDistance = getDist(myRoom.name,currentRoom,true);
									let dif = ((distance*2)+1) - myRoomDistance;
									if (myRoomDistance && dif > 0){
											if (!best || dif > bestDif){
													best = myRoom.name;
													bestDif = dif;
											}
									}
							}
					}
			}
			if (best){
					return best
			}
	}
	function canIntercept(startRoom,caravanId,needSpawn){
			if (Memory.caravans && caravanId && Memory.caravans[caravanId]){
					let adjust = 0;
					if (needSpawn){
							adjust = 1;
					}
					let caravan = Memory.caravans[caravanId];
					let currentRoom = guessCurrentRoom(caravanId);
					let dir = caravan.direction;
					if (currentRoom && dir){
							if (!caravan.predictedTimes || (Game.map.getHighwaySide(currentRoom) === 'corner' && needSpawn)){
									return false
							}
							let distance = 0;
							while (distance <= 10){
									if (Game.map.getHighwaySide(currentRoom) === 'corner'){
											break
									}
									let myRoomDistance = getDist(startRoom,currentRoom,true);
									if (distance === 0 && myRoomDistance <= 1){
											return currentRoom
									}
									if (myRoomDistance && myRoomDistance <= (distance*2)+adjust){
											return currentRoom
									}
									distance++;
									currentRoom = Game.map.moveRoom(currentRoom,dir);
							}
					}
			}
			return false
	}
	function predictedInterceptRooms (startRoom,dir){
			let currentRoom = startRoom;
			let time = Game.time-50;
			let predictedTime = {

			};
			let distance = 0;
			while (distance <= 10){
					distance++;
					currentRoom = Game.map.moveRoom(currentRoom,dir);
					if (Game.map.getHighwaySide(currentRoom) === 'corner'){
							predictedTime[currentRoom] = time + distance*100;
							break
					}
					predictedTime[currentRoom] = time + distance*100;
			}
			return predictedTime
	}
	function logScoreStored(){
			let storedScore = {
					total:0,
					levelledTotal:0,
					1:0,
					2:0,
					3:0,
					4:0,
					5:0
			};
			for (let i in COMMODITIES){
					let commodity = COMMODITIES[i];
					let scoreMultiplier = COMMODITY_SCORE[i];
					let score;
					if (scoreMultiplier){
							score = Game.getResourceTotal(i)*scoreMultiplier;
					}
					if (score){
							storedScore.total += score;
							if (commodity.level){
									storedScore.levelledTotal += score;
									storedScore[commodity.level] += score;
							}
					}
			}
			Memory.stats.storedScore = storedScore;
	}
	function assessDirection(firstRoom,secondRoom){
			if (firstRoom === secondRoom){
					return false;
			}
			let firstSplit = firstRoom.split(/[A-Z]/);
			let secondSplit = secondRoom.split(/[A-Z]/);
			let firstQuadrant = firstRoom.split(/\d+/);
			let secondQuadrant = secondRoom.split(/\d+/);
			if (firstQuadrant[0] !== secondQuadrant[0] ||
					firstQuadrant[1] !== secondQuadrant[1]){
					//can't assess if moving between quadrants
					return
			}
			if (firstSplit[1] !== secondSplit[1] && firstSplit[2] === secondSplit[2]){
					//horizontal movement
					if (firstQuadrant[0] === 'E'){
							if (firstSplit[1]>secondSplit[1]){
									return 7
							} else {
									return 3
							}
					} else {
							if (firstSplit[1]>secondSplit[1]){
									return 3
							} else {
									return 7
							}
					}
			} else if (firstSplit[1] === secondSplit[1] && firstSplit[2] !== secondSplit[2]){
					//vertical movement
					if (firstQuadrant[1] === 'N'){
							if (firstSplit[2]>secondSplit[2]){
									return 5
							} else {
									return 1
							}
					} else {
							if (firstSplit[2]>secondSplit[2]){
									return 1
							} else {
									return 5
							}
					}
			}
	}

	function run$$(creep){
			if (!creep.memory.caravan){
					return
			}
			Game.map.visual.text('CH',creep.pos);
			let targetID = creep.memory.targetId;
			let targetCaravanID = creep.memory.caravan;
			let caravan = Memory.caravans[targetCaravanID];
			let targetInfo;
			if (caravan && caravan.members && targetID){
					targetInfo = caravan.members[targetID];
			}
			if (!targetInfo){
					if (creep.store.getUsedCapacity()===0){
							creep.memory.role = 'recycle';
					} else if (creep.home && creep.home.storage){
							creep.goAndTransfer(creep.home.storage);
					}
					return
			}
			if (creep.ticksToLive === 700){
					console.log(`announcement|${Game.shard.name}|caravan hauler ${creep.name} in ${creep.room.name} at ${Game.time} TTL 700 - to return`);
					creep.memory.return = true;
			}
			if (creep.ticksToLive === 5){
					console.log(`announcement|${Game.shard.name}|**caravan hauler ${creep.name} in ${creep.room.name} at ${Game.time} TTL 5**`);
			}

			if (creep.store.getUsedCapacity() > 0){
					creep.memory.dropping = true;
			}
			let target = Game.getObjectById(targetID);
			let commodity = targetInfo.commodity;
			if (creep.memory.return){
					if (creep.pos.isNearTo(creep.home.storage)){
							creep.transfer(creep.home.storage,commodity);
					} else if (creep.room.name === creep.home.name){
							creep.moveTo(creep.home.storage,{range:1});
					} else {
							creep.goTo(creep.home.name);
					}
					if (creep.store.getUsedCapacity()===0){
							creep.memory.role = 'recycle';
					}
					return
			}
			if (target && creep.memory.dropping && target.room.name === creep.room.name){
					if (creep.pos.isNearTo(target)){
							let amount = target.store.getFreeCapacity();
							if (amount > creep.store[commodity]){
									amount = creep.store[commodity];
							}
							let transfer = creep.transfer(target,commodity,amount);
							creep.say(transfer,true);
					} else {
							creep.moveTo(target,{range:1});
					}
					if (target.store.getFreeCapacity() === 0 || creep.store.getUsedCapacity() === 0){
							if (creep.store.getUsedCapacity()>0){
									creep.memory.return = true;
							} else {
									creep.suicide();
							}
					}
			} else if (creep.memory.dropping){
					let interceptRoom = canIntercept(creep.room.name,targetCaravanID);
					if (interceptRoom){
							creep.goTo(interceptRoom);
					} else {
							//can't intercept
							creep.memory.return = true;
							console.log(`announcement|${Game.shard.name}|caravan hauler return ${creep.name} in ${creep.room.name} at ${Game.time}`);
					}
			} else if (creep.home.terminal){
					creep.goAndWithdraw(creep.home.terminal,commodity);
			}
	}

	var caravanHauler = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$$
	});

	function run$_(creep){
			//claim-homeRoomName-chain
			var homeRoomName = creep.name.split(' ')[2];
			var pFlag = Game.flags['portal' + homeRoomName];
			var pExit = Game.flags['pExit' + homeRoomName];
			Game.map.visual.text('Cl',creep.pos);
			let targetRoom = creep.num;
			if (pExit && pExit.room && creep.room.name == pExit.room.name){
					creep.memory.pFlag = true;
			} else if (pFlag && pFlag.room && creep.room.name == pFlag.room.name){
					delete creep.memory.pFlag;
			}
			if (Game.rooms[targetRoom]){
					let core = Game.rooms[targetRoom].find(FIND_STRUCTURES, {filter: (s) => s.structureType == STRUCTURE_INVADER_CORE})[0];
					if (core && !core.level){
							requestSquad(creep.home, targetRoom, {attackers: 1, medics: 1, type: 'C', boosted: 0});
					}
					//CombatManager.requestSquadsViaCombatManager(targetRoom,'G')
			}
			if (!creep.memory.WP || creep.memory.WP != 'fin'){
					waypoints(creep, undefined, true);
			} else if (!creep.memory.portal && pFlag){
					creep._moveTo(pFlag,{range:0});
			} else if (targetRoom && creep.room.name == targetRoom){
					if (creep.room.controller){
							creep.signController(creep.room.controller, `territory of ${Game.username}`);
							// if (!creep.room.controller.reservation || creep.room.controller.reservation.ticksToEnd < 5 ){
							// 		creep.reserveController(creep.room.controller)
							// 		creep.moveTo(creep.room.controller)
							// 		return
							// }
							// creep.attackController(creep.room.controller)
							let claim = creep.claimController(creep.room.controller);
							if (claim === -9){
									creep.moveTo(creep.room.controller, {range: 1, maxRooms: 1});
							} else {
									if (creep.room.controller.my === true){
											delete creep.home.largeClaimer;
									} else if (creep.room.controller.reservation && creep.room.controller.reservation.username !== Game.username && claim !== 0){
											creep.home.memory.largeClaimer = true;
											creep.attackController(creep.room.controller);
									}
							}
					} else if (config.season && config.season === 'thorium'){
							let reactor = creep.room.find(FIND_REACTORS)[0];
							if (reactor && !reactor.my){
									if (creep.pos.isNearTo(reactor)){
											creep.claimReactor(reactor);
									} else {
											creep.moveTo(reactor);
									}
							}
					}
			} else if (targetRoom){
					if (creep.body.length > 2);
					console.log(targetRoom);
					if (Game.map.getRoomType(targetRoom)==='centre'){
							creep.goTo(targetRoom, {SK: true});
					} else if (Memory.expansionPath && Memory.expansionPath.end && Game.flags['rally' + creep.home.name] &&
							Memory.expansionPath.end.toPos() && Memory.expansionPath.end.toPos().roomName == targetRoom){
							let path = creep.moveUsingSavedPath(Memory.expansionPath.path, Game.flags['rally' + creep.home.name].pos, Memory.expansionPath.end.toPos(),{deleteOn:8});
							//console.log('claimer path',path)
							if (path === 'delete'){
									delete Memory.expansionPath;
									delete creep.memory.path;
							}
					} else {
							if (!creep.memory.path){
									creep.say('me');
									if (!Game.rooms[targetRoom] || !Game.flags['rally' + creep.home.name] || !Game.flags['rally' + creep.home.name].pos){
											creep.goTo(targetRoom, {SK: true});
											return
									}
									let pos = Game.rooms[targetRoom].controller.pos;
									let swampCost = 1;
									if (config.beefyClaimer){
											swampCost = 3;
									}
									let pathObj = PathFinder.search(Game.flags['rally' + creep.home.name].pos, {pos: pos, range: 1}, {
											swampCost: swampCost,
											maxOps: 50000,
											maxRooms: 100,
											roomCallback: function (roomName){
													if (Game.map.isCoreRoom(roomName)&& !config.canPassThroughRooms.includes(roomName)){
															return false
													}
													if (Memory.ownedRooms[roomName] && !config.canPassThroughRooms.includes(roomName)){
															return false
													}
													if (Game.map.getRoomType(roomName) == 'SK' && !config.beefyClaimer){
															let matrix = Game.map.getSKMatrix(roomName);
															if (matrix){
																	if (pos && pos.roomName === roomName){
																			let neighbours = pos.neighbours(8, true);
																			for (let n in neighbours){
																					let neighbour = neighbours[n];
																					let terrain = neighbour.getTerrain();
																					if (terrain === 'plain'){
																							matrix.set(neighbour.x, neighbour.y, 1);
																					} else if (terrain === 'swamp'){
																							matrix.set(neighbour.x, neighbour.y, 5);
																					}
																			}
																	}
																	return matrix
															} else {
																	return false
															}
													} else {
															if (Game.map.getRoomType(roomName) !== 'highway' && Game.rooms[roomName]){
																	return Game.rooms[roomName].structureMatrix
															}
													}
											}
									});
									if (pathObj && !pathObj.incomplete){
											let end = pathObj.path[pathObj.path.length - 1].toString();
											let sPath = PathFinder.serializePath(Game.flags['rally' + creep.home.name].pos, pathObj);
											creep.memory.path = {path: sPath, end: end};
									} else {
											console.log('claim path borked');
											console.log(JSON.stringify(pathObj));
											console.log('target', Game.rooms[targetRoom].controller.pos);
									}
							} else {
									let path = creep.moveUsingSavedPath(creep.memory.path.path, Game.flags['rally' + creep.home.name].pos, creep.memory.path.end.toPos());
									console.log(creep.pos,'claimer path',path,creep.memory.path.path.length);
									if (creep.ticksToLive < creep.memory.path.path.length && creep.ticksToLive < 300){
											creep.suicide();
									}
							}
					}
			}

	}
	let spawnCode$w = {
			priority: (room, countFunction) => {
					let priority = 10;
					if (room && room.memory.reserve && room.total('energy') > room.memory.reserve){
							priority -= 5;
					}
					return priority
			},
			isRequired: (room, countFunction) => {
					if (room.energyCapacityAvailable < 600){
							return false
					}
					// if (Game.shard.name === 'shard1' || (Game.shard.name === 'shard2' && room.name === 'E27N3')){
					// //manual cross shard claim
					// 		let target = 'E51N3'
					// 		if (room.creepList && room.creepList.filter((c) => c.name.split(' ')[0] == 'claimer' && c.name.split(' ')[1] == target).length < 1){
					// 				return target
					// 		}
					// }
					return false
			},
			spawn: (room, role, body) => {
					//decide if we need any other options
					if (body){
							//options -> TTL, creepnumber
							room.spawnCreep(role, body, {creepnumber: spawnCode$w.isRequired(room)});
					}
			},
			body: (room, countFunction) => {
					if (room.memory.roadsDown === undefined){
							room.memory.roadsDown = false;
					}
					let bodyObject = {
							body: [],
							cost: 0
					};
					//decide on what body to have
					if (room.energyAvailable < 850){
							bodyObject.body = [CLAIM, MOVE,CLAIM,MOVE,CLAIM,MOVE];
					} else if (!room.memory.largeClaimer){
							bodyObject.body = [ MOVE, MOVE, MOVE, MOVE, MOVE,CLAIM];
					} else {
							bodyObject.body = room.makeBody([ MOVE, MOVE, MOVE, MOVE, MOVE,CLAIM], false, {noMove: true});
					}
					if (config.beefyClaimer){
							bodyObject.body = room.makeBody([ MOVE, MOVE, MOVE, MOVE,HEAL], false, {noMove: true,sort:true,fixedSection:[CLAIM,MOVE]});
					}

					if (bodyObject.body && bodyObject.body.length > 0){
							bodyObject.cost += Game.getBodyCost(bodyObject.body);
					}
					return bodyObject
			}
	};

	var claimer = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$_,
		spawnCode: spawnCode$w
	});

	function run$Z(creep){
			if (!creep.home){
					return
			}
			if (!creep.memory.squad){
					creep.say('no sq',true);
					let rally = Game.flags['rally' + creep.home.name];
					if (rally && !creep.pos.inRangeTo(rally, 3)){
							creep.moveTo(rally.pos, {range: 3});
					} else {
							creep.startNap(3);
					}
			}
	}



	function getBody(room,level,type){
			let body;
			let energyCap = room.energyCapacityAvailable-650;
			let fixedSection = [RANGED_ATTACK, MOVE, RANGED_ATTACK, MOVE, RANGED_ATTACK, MOVE];
			if (level && config.boostLevels[level] && (config.boostLevels[level].includes('GO') || config.boostLevels[level].includes('GHO2')||
					config.boostLevels[level].includes('XGHO2'))){
					fixedSection = [RANGED_ATTACK, MOVE, RANGED_ATTACK, MOVE, RANGED_ATTACK, MOVE,TOUGH,TOUGH,TOUGH,TOUGH,TOUGH,MOVE,MOVE,MOVE,MOVE,MOVE];
					if (type === 'C'){
							fixedSection = [TOUGH,TOUGH,TOUGH,MOVE,MOVE,MOVE];
					}
			}
			if ((!body || Game.getBodyCost(body) > energyCap)){
					body = room.makeBody([HEAL], false, {sort: true,oneClaim:true,level:level,fixedSection: fixedSection});
			}
			if (!body|| Game.getBodyCost(body) > energyCap || room.controller.level < 5){
					body = [MOVE,CLAIM];
			}
			if (Game.getBodyCost(body) > energyCap){
					return false
			}
			return body
	}
	({
			1:(_.repeat('move ', 16) + _.repeat('heal ', 30) + _.repeat('ranged_attack ', 3) + 'move').split(' '),
			2:(_.repeat('move ', 12) + _.repeat('heal ', 32) + _.repeat('ranged_attack ', 5)  + 'move').split(' '),
			3:(_.repeat('tough ', 3) + _.repeat('move ', 12) + _.repeat('tough ', 2) + _.repeat('ranged_attack ', 2) + _.repeat('heal ', 30) + 'move').split(' '),
			4:(_.repeat('tough ', 5) + _.repeat('move ', 9) + _.repeat('ranged_attack ', 2) + _.repeat('heal ', 33) + 'move').split(' '),
			5:(_.repeat('tough ', 7) + _.repeat('move ', 9) + _.repeat('tough ', 2) + _.repeat('ranged_attack ', 2) + _.repeat('heal ', 29) + 'move').split(' ')
	});

	var claimMedic = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$Z,
		getBody: getBody
	});

	function run$Y(creep){
			Game.rooms[creep.name.split(' ')[2]];
			var homeRoomName = creep.name.split(' ')[2];
			creep.room.name;
			Game.map.visual.text('Col',creep.pos);
			var speed = 'low';
			if ((creep.room.controller && creep.room.controller.safeMode && creep.room.controller.level > 3) || creep.room.memory.defcon < 4
			|| config.official){
					speed = 'high';
			}
			var pFlag = Game.flags['portal' + homeRoomName];
			var pExit = Game.flags['pExit' + homeRoomName];
			if (creep.room.memory.lowWall){
					Game.getObjectById(creep.room.memory.lowWall);
			}
			let targetRoom = creep.num;
			if (config.mapVisual){
					Game.map.visual.text('col', creep.pos, {fontSize: 5});
			}
			if (config.superColonists && creep.hits < creep.hitsMax){
					creep.heal();
			}
			let sblab;
			let boost = 'XGH2O';
			if (creep.ticksToLive > 1400 && config.official && creep.memory.boosted === undefined && creep.home.memory.sboostlab
			&& creep.home.memory.sboostlab[boost]){
					sblab = Game.getObjectById(creep.home.memory.sboostlab[boost]);
			}
			if (targetRoom && creep.room.name === targetRoom && creep.room.controller.owner && !creep.room.controller.my){
					requestSquadsViaCombatManager(creep.room.name,'D',{count:2});
			}
			if (creep.memory.boosted === undefined && (!Game.rooms[targetRoom] || !Game.rooms[targetRoom].memory.hostiles) && sblab){
					if (!sblab || (sblab.store[boost] < 500) || sblab.store['energy'] < 500){
							creep.memory.boosted = true;
					}
					if (creep.isBoosted()){
							creep.memory.boosted = true;
					}
					if (sblab && sblab.boostCreep(creep) == -9){
							creep._moveTo(sblab, {range: 1});
							return
					}
			}
			if ((Game.time % 1000 == 0 && Game.cpu.bucket > 1000)){
					var structures = creep.room.find(FIND_HOSTILE_STRUCTURES, {
							filter: (s) => s.structureType == STRUCTURE_EXTENSION || s.structureType == STRUCTURE_LINK
									|| s.structureType == STRUCTURE_TOWER || s.structureType == STRUCTURE_RAMPART || s.structureType == STRUCTURE_EXTRACTOR || s.structureType == STRUCTURE_LAB ||
									s.structureType == STRUCTURE_SPAWN || s.structureType == STRUCTURE_NUKER || s.structureType == STRUCTURE_OBSERVER
					});
					for (var i in structures){
							structures[i].destroy();

					}
			}
			if (pExit && pExit.room && creep.room.name == pExit.room.name){
					creep.memory.pFlag = true;
			} else if (pFlag && pFlag.room && creep.room.name == pFlag.room.name){
					delete creep.memory.pFlag;
			}
			if (targetRoom && Game.rooms[targetRoom]){
					let tRoom = Game.rooms[targetRoom];
					if (tRoom.storage && tRoom.controller && tRoom.controller.my && tRoom.controller.level > 3 && tRoom.memory.defcon === 5 && creep.home){
							if (Memory.nextClaims && Memory.nextClaims[targetRoom]){
									delete Memory.nextClaims[targetRoom];
							}
					}
			}

			if (creep.hits < creep.hitsMax){
					creep.heal(creep);
			}
			if (creep.memory.dropping && creep.store['energy'] == 0){
					creep.memory.dropping = false;
					creep.say('collecting');
			}
			if (!creep.memory.dropping && creep.store['energy'] == creep.store.getCapacity()){
					creep.memory.dropping = true;
					creep.say('dropping');
			}
			if (creep.hits < creep.hitsMax && !creep.room.memory.hostiles && creep.room.controller && creep.room.controller.my){
					creep.towerHeal(creep.room);
			}
			if (creep.hits < creep.hitsMax*0.5){
					if (!Memory.colonistEscort){
							Memory.colonistEscort = {};
					}
					Memory.colonistEscort[targetRoom] = Game.time + 2000;
			}
			if (creep.memory.dropping){
					let roomClass;
					if (targetRoom && creep.room.name != targetRoom){
							delete creep.memory.dropping;
							return
					} else {
							roomClass = creep.room.class;
					}
					let sites = creep.room.find(FIND_CONSTRUCTION_SITES);
					let site;
					if (creep.room.memory.sites){
							site = Game.getObjectById(creep.room.memory.sites);
					}
					let towerSite = sites.filter((s) => s.structureType == STRUCTURE_TOWER)[0];
					sites.filter((s) => s.structureType == STRUCTURE_SPAWN)[0];
					let rampartsite = sites.filter((s) => s.structureType == STRUCTURE_RAMPART || (s.structureType === STRUCTURE_WALL && s.room && (s.room.class === 'outpost' || (s.room.controller && s.room.controller.safeMode))))[0];
					let spawn = creep.room.find(FIND_STRUCTURES,{filter:(s)=>s.structureType == STRUCTURE_SPAWN})[0];
					let nobuild = creep.room.find(FIND_FLAGS, {filter: (f) => f.name == "doNotBuild"})[0];
					var tower = creep.room.find(FIND_STRUCTURES, {filter: (s) => s.structureType == STRUCTURE_TOWER && s.store['energy'] < 700})[0];
					let wall = creep.room.memory.lowWall;
					if (wall){
							wall = Game.getObjectById(wall);
					}
					let rampart;
					if (!spawn){
							rampart = creep.room.find(FIND_STRUCTURES,{filter:(s)=>s.structureType == STRUCTURE_RAMPART && s.hits < 10000})[0];
					}
					if (spawn && spawn.store.getFreeCapacity('energy')> 0 && creep.room.class !== 'thoriumMine' && creep.room && (!creep.room.creepList || creep.room.creepList.length < 10)){
							creep.goAndTransfer(spawn,'energy',1);
							return
					}
					if (Game.time%20===0){
							delete creep.room.memory.sites;
					}
					if (wall){
							wall.pos.highlight('brown');
					}
					let prioRampSite;
					creep.home.memory.colNeeded = Game.time;
					if (creep.room.controller && creep.room.controller.upgradeBlocked){
							let neighbours = creep.room.controller.pos.neighbours();
							for (let i in neighbours){
									let site = neighbours[i].lookAround(LOOK_CONSTRUCTION_SITES,0,{filter:(s)=>s.structureType === 'rampart'})[0];
									if (!site){
											neighbours[i].createConstructionSite('rampart');
									} else {
											prioRampSite = site;
											break
									}
							}
					}
					if (creep.room.controller.my && (creep.room.controller.level < 2 || creep.room.controller.ticksToDowngrade < CONTROLLER_DOWNGRADE[creep.room.controller.level] * 0.5)
							&& !creep.room.controller.upgradeBlocked && (!creep.room.controller.safeModeAvailable || creep.room.controller.safeModeCooldown)){
							creep.say('up1');
							let range = creep.pos.getRangeTo(creep.room.controller);
							let targetRange = creep.memory.targetRange;
							if (!targetRange){
									targetRange = Math.ceil(Math.random()*3);
									creep.memory.targetRange = targetRange;
							}
							if (range > targetRange){
									creep._moveTo(creep.room.controller,{range:targetRange});
							}
							if (range < 4){
									creep.upgradeController(creep.room.controller);
							}
							let uplink;
							if (creep.room.memory.uplink){
									uplink = Game.getObjectById(creep.room.memory.uplink);
							}
							if (uplink){
									if (uplink && uplink.store[RESOURCE_ENERGY] > 0 &&
											creep.pos.isNearTo(uplink) && (creep.store.getUsedCapacity()<= creep.store.getCapacity()*0.5 || Game.cpu.bucket > 7000)){
											creep.withdraw(uplink, RESOURCE_ENERGY);
									}
							}
					} else if (prioRampSite){
							creep.say('siteRamp');
							if (creep.build(prioRampSite) == ERR_NOT_IN_RANGE){
									creep._moveTo(prioRampSite, {range: 3, maxRooms: 1});
							}
					}else if (towerSite){
							creep.say('siteT');
							if (creep.build(towerSite) == ERR_NOT_IN_RANGE){
									creep._moveTo(towerSite, {range: 3, maxRooms: 1});
							}
					} else if (site && site.progress && site.progress > 90000 && site.structureType !== STRUCTURE_ROAD){
							creep.say('site1');
							if (creep.build(site) == ERR_NOT_IN_RANGE){
									creep._moveTo(site, {range: 3, maxRooms: 1});
							}
					} else if (wall && wall.hits < 1000000 && false && creep.room.name === 'E29S9'){
							if (creep.pos.inRangeTo(wall,3)){
									creep.repair(wall);
							} else {
									creep._moveTo(wall,{range:3});
							}
					} else if (rampartsite && creep.num === 1){
							creep.say('rampSite');
							if (creep.build(rampartsite) == ERR_NOT_IN_RANGE){
									creep._moveTo(rampartsite, {range: 3, maxRooms: 1});
							}
					} else if (rampart && creep.room.class === 'outpost'){
							creep.say('ramp');
							if (creep.pos.inRangeTo(rampart,3)){
									creep.repair(rampart);
							} else {
									creep._moveTo(rampart,{range:3});
							}
					}else if (creep.room.controller && creep.room.controller.my && !creep.room.controller.upgradeBlocked
							&& (((creep.pos.inRangeTo(creep.room.controller, 3) && creep.room.controller.ticksToDowngrade < CONTROLLER_DOWNGRADE[creep.room.controller.level] * 0.8) || creep.room.controller.ticksToDowngrade < CONTROLLER_DOWNGRADE[creep.room.controller.level] * 0.75) ||
									(creep.room.controller.level < 3 && false) || (creep.memory.boosted && !creep.room.memory.bigSites)) || nobuild){
							creep.say('up2');
							if (creep.upgradeController(creep.room.controller) == ERR_NOT_IN_RANGE){
									creep._moveTo(creep.room.controller, {range: 1, maxRooms: 1});
							}
					} else if (tower && (!creep.room.memory.spawn || !Game.spawns[creep.room.memory.spawn] || (creep.room.class === 'bunker' && !creep.room.storage))){
							creep.say('tower');
							if (creep.transfer(tower, RESOURCE_ENERGY) == ERR_NOT_IN_RANGE){
									creep._moveTo(tower, {range: 1, maxRooms: 1});
							}
					} else if (rampart){
							creep.say('ramp');
							if (creep.pos.inRangeTo(rampart,3)){
									creep.repair(rampart);
							} else {
									creep._moveTo(rampart,{range:3});
							}
					} else if (site &&  site.structureType !== STRUCTURE_ROAD){
							creep.say('site2');
							if (creep.build(site) == ERR_NOT_IN_RANGE){
									creep._moveTo(site, {range: 3, maxRooms: 1});
							}
					} else if (wall && ((creep.room.memory.defcon && creep.room.memory.defcon < 5 && creep.room.controller.level > 5) || (roomClass && roomClass === 'outpost'))){
							creep.say('wall');
							if (creep.repair(wall) == ERR_NOT_IN_RANGE){
									creep._moveTo(wall, {range: 3, maxRooms: 1});
							}
					}  else if (creep.room.controller && !creep.room.controller.upgradeBlocked && roomClass && (roomClass !== 'outPost' || creep.room.controller.level < 3) && creep.room.controller.my && creep.room.controller.level < 5){
							creep.say('up3');
							let range = 2;
							if (creep.name.split(' ')[4] && creep.name.split(' ')[4]%3===0){
									range = 1;
							}
							if (creep.pos.getRangeTo(creep.room.controller)>range){
									creep._moveTo(creep.room.controller,{range:range});
							}
							creep.upgradeController(creep.room.controller);

					} else if (site){
							creep.say('site3');
							if (creep.build(site) == ERR_NOT_IN_RANGE){
									creep._moveTo(site, {range: 3, maxRooms: 1});
							}
					}else if (creep.room.controller && !creep.room.controller.upgradeBlocked  && creep.room.controller.my){
							creep.say('up4');
							if (creep.upgradeController(creep.room.controller) == ERR_NOT_IN_RANGE){
									var dest = creep.room.controller;
									creep._moveTo(dest, {range: 3, maxRooms: 1});
							}

					} else {
							creep.say('err');
							if (creep.room.controller && creep.pos.getRangeTo(creep.room.controller)> 4){
									creep._moveTo(creep.room.controller,{range:3});
							}
					}


			} else {
					if (targetRoom && !pFlag  && creep.shard === Game.shard.name && !creep.memory.atDest && creep.room.name != targetRoom && Memory.colonistEscort && Memory.colonistEscort[targetRoom]){
							if (!creep.memory.squad && creep.home){
									requestSquad(creep.home,creep.home.name,{escortId:creep.id,type:'E',hybrids:1});
									creep.rally(2);
							} else {
									Memory.squads[creep.memory.squad].targetRoom = targetRoom;
							}
					} else if (targetRoom && creep.room.name != targetRoom && (!creep.memory.WP || creep.memory.WP != 'fin')){
							waypoints(creep);
					} else if (targetRoom && creep.room.name != targetRoom && !creep.memory.portal && pFlag){
							creep._moveTo(pFlag,{range:0});
					} else if (targetRoom && (creep.room.name != targetRoom|| creep.pos.onEdge())){
							creep.goTo(targetRoom, {SK: true});
					} else {
							if (creep.memory.squad){
									let squad = Memory.squads[creep.memory.squad];
									if (squad){
											delete Memory.squads[creep.memory.squad].escortId;
									}
							}
							creep.memory.atDest = true;
							let labid = creep.room.memory.buildBoostLab;
							let buildLab = null;
							if (labid && Game.getObjectById(labid) && creep.ticksToLive > 600 && !creep.isBoosted() && speed === 'high'){
									let lab = Game.getObjectById(labid);
									if (lab && lab.mineralType === 'XLH2O' && lab.store[lab.mineralType] > 500 && lab.store['energy'] > 500){
											buildLab = lab;
									}
							}
							var energy = creep.pos.findClosestByRange(FIND_DROPPED_RESOURCES, {filter: (r) => r.resourceType == 'energy' && r.amount > 200});
							var tomb = creep.room.find(FIND_TOMBSTONES, {filter: (t) => t.store['energy'] > 200})[0];
							if (buildLab){
									if (buildLab.boostCreep(creep) != 0){
											creep._moveTo(buildLab);
									}
							} else if ((speed === 'high' || creep.room.class === 'thoriumMine') && creep.room.total('energy') > 2000 && ((creep.room.storage && creep.room.storage.my) || (creep.room.terminal && creep.room.terminal.my))){
									let store = creep.room.storage;
									let term = creep.room.terminal;
									if (store && (store.store['energy'] > 5000 || (creep.room.class === 'thoriumMine' && store.store['energy'] > 500))){
											if (creep.withdraw(store, RESOURCE_ENERGY) == ERR_NOT_IN_RANGE){
													creep._moveTo(store);
											}
									} else {
											if (term && term.store['energy'] > 0){
													if (creep.withdraw(term, RESOURCE_ENERGY) == ERR_NOT_IN_RANGE){
															creep._moveTo(term);
													}
											}
									}
							} else if (energy){
									if (creep.pickup(energy, RESOURCE_ENERGY) == ERR_NOT_IN_RANGE){
											creep._moveTo(energy, {range: 1, maxRooms: 1});
									}
							} else if (tomb && !creep.memory.hostiles){
									if (creep.withdraw(tomb, 'energy') == ERR_NOT_IN_RANGE){
											creep._moveTo(tomb, {range: 1, maxRooms: 1});
									}
							} else {
									//todo change this crappy energy collection
									var cont = creep.room.find(FIND_STRUCTURES, {filter: (s) => s.structureType == STRUCTURE_CONTAINER && s.store['energy'] > 500})[0];
									if (!cont || cont.store['energy'] === 0){
											var store = creep.room.find(FIND_STRUCTURES, {filter: (s) => s.structureType == STRUCTURE_STORAGE})[0];
									}
									var target = creep.pos.findClosestByRange(FIND_SOURCES_ACTIVE);
									if (creep.num === 1 && creep.room.memory.s1){
											target = Game.getObjectById(creep.room.memory.s1);
									}
									if (creep.num === 2 && creep.room.memory.s2){
											target = Game.getObjectById(creep.room.memory.s2);
									}
									if (target){
											creep.say(target.id);
									}
									if (cont && cont.store['energy'] > 500){
											if (creep.withdraw(cont, RESOURCE_ENERGY) == ERR_NOT_IN_RANGE){
													creep._moveTo(cont, {range: 1, maxRooms: 1});
											}
									} else if (store && (store.my || store.structureType === 'container') && (store.store['energy'] > 5000 || store.my == false)){
											if (creep.withdraw(store, RESOURCE_ENERGY) == ERR_NOT_IN_RANGE){
													creep._moveTo(store, {range: 1, maxRooms: 1});
											} else if (creep.withdraw(store, 'energy') == -6 && store.my == false){
													store.destroy();
											}
									} else if (creep.harvest(target) == ERR_NOT_IN_RANGE){
											creep._moveTo(target, {range: 1, maxRooms: 1});
									}
							}
					}
			}


	}


	let spawnCode$v = {
			priority: (room, countFunction) => {
					let priority = 35;
					if (room && room.ecoStable){
							priority -= 10;
					}
					if (config.superColonists){
							priority = 20;
					}
					if (config.official && Game.market.credits > config.maxCredits*2 && !Game.energyCrisis){
							priority = 20;
					}
					priority += countFunction('colonist', room) * 2;
					return priority
			},
			isRequired: (room, countFunction) => {
					if (room.energyCapacityAvailable < 600){
							return false
					}
					if (room.total('energy')<room.memory.reserve*0.7 || room.memory.armedHostiles || room.squadSpawningBlockCivs|| room.memory.defcon < 4 || room.memory.underHarassment || room.memory.brigade){
							return false
					}
					if (config.crossShardSupport){
							let target;
							crossShardLoop:
							for (let i in config.crossShardSupport){
									let obj = config.crossShardSupport[i];
									if (obj.colonistRooms && obj.colonistRooms[Game.shard.name]){
											for (let r in obj.colonistRooms[Game.shard.name]){
													if (obj.colonistRooms[Game.shard.name][r] === room.name){
															target = i.split('-')[1];
															break crossShardLoop
													}
											}
									}
							}
							if (target && room.creepList && room.creepList.filter((c) => c.name.split(' ')[0] == 'colonist' && c.name.split(' ')[1] == target).length < 1){
									return target
							}
					}
			},
			spawn: (room, role, body) => {
					//decide if we need any other options
					if (body){
							//options -> TTL, creepnumber
							room.spawnCreep(role, body, {creepnumber: spawnCode$v.isRequired(room)});
					}
			},
			body: (room, countFunction) => {
					if (room.memory.roadsDown === undefined){
							room.memory.roadsDown = false;
					}
					let key = room.energyCapacityAvailable + ':' + room.memory.roadsDown;
					if (getCachedBody('colonist',key)){
							return getCachedBody('colonist',key)
					}
					let bodyObject = {
							body: [],
							cost: 0
					};
					//decide on what body to have
					bodyObject.body = getBody$5(room.energyCapacityAvailable,room, false, 'colonist');
					if (config.superColonists){
							bodyObject.body = room.makeBody([WORK,WORK,CARRY],false,{fixedSection:[HEAL,HEAL,HEAL,MOVE,MOVE,MOVE],sort:true});
					}
					if (config.official){
							bodyObject.body = room.makeBody([WORK,WORK,WORK,WORK,CARRY],false);
					}
					if (bodyObject.body && bodyObject.body.length > 0){
							bodyObject.cost += Game.getBodyCost(bodyObject.body);
					}
					cacheBody('colonist',key,bodyObject);
					return bodyObject
			}
	};

	var colonist = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$Y,
		spawnCode: spawnCode$v
	});

	function run$X(creep){
			let room = creep.home.memory.col;
			if (Game.rooms[room.split('-')[1]]){
				let target = Game.flags[room].room;

				if (!creep.memory.WP || creep.memory.WP != 'fin'){
					waypoints(creep);
				} else if (target && target.controller && creep.room.name != target.name){
					creep.moveTo(target.controller);
				} else {
					creep.memory.role = "miner1";
					creep.memory.room = room;
				}
			}
	}

	var colonistMiner = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$X
	});

	function run$W(creep){
		var homeRoom = Game.rooms[creep.name.split(' ')[2]];
		creep.name.split(' ')[1];
		var targetFlag = Game.flags['ambush' + homeRoom.name];
		if (targetFlag && (!targetFlag.room || creep.room.name != targetFlag.room.name || !targetFlag.room.memory.hostiles)){
			creep.moveTo(targetFlag);
		} else if (targetFlag && targetFlag.room){
			let matrix = Cache.access(targetFlag.room.name + '.defenceMatrix');
			if (matrix && matrix != -1){
				//store game.time the creep has been moved so that if another creep has moved it we don't recalculate the movement
				if (!creep.memory.timeMoved || creep.memory.timeMoved < Game.time);
			} else {
				let newMatrix = new CostMatrix;
				for (let i in targetFlag.room.find(FIND_HOSTILE_CREEPS)){
					let hos = targetFlag.room.find(FIND_HOSTILE_CREEPS)[i];
					//set pos 3 away as 1 to move towards
					let n = hos.neighbours(3);
					for (let ni in n){
						newMatrix.set(n[ni].x, n[ni].y, 1);
					}
					//set pos 2 and 1 away as no go
					n = hos.neighbours(2);
					for (let ni in n){
						newMatrix.set(n[ni].x, n[ni].y, 255);
					}
					n = hos.neighbours(1);
					for (let ni in n){
						newMatrix.set(n[ni].x, n[ni].y, 255);
					}
				}
			}
		}
	}

	var convoyAmbusher = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$W
	});

	function run$V(creep){
			let targetRoom = creep.num;
			if (!creep.memory.collecting && creep.store.getUsedCapacity() == 0){
					if (creep.room.name === creep.home.name && creep.ticksToLive < 750){
							creep.memory.role = 'recycle';
					} else if (creep.ticksToLive < 700){
							creep.suicide();
					}
					creep.memory.collecting = true;
			} else if (creep.store.getFreeCapacity() == 0 || creep.ticksToLive < 750){
					delete creep.memory.collecting;
			}
			if (targetRoom && creep.memory.collecting){
					if (creep.room.name != targetRoom){
							creep.goTo(targetRoom, {SK: true});
					} else {
							if (targetRoom.hostiles){
									let nearHostiles = creep.pos.lookAround(LOOK_CREEPS, 5, {filter: (c) => !c.my});
									nearHostiles.sort((a, b) => a.pos.getRangeTo(creep) - b.pos.getRangeTo(creep));
									let near = nearHostiles[0];
									let range = near.pos.getRangeTo(creep);
									if (range < 4){
											creep.moveFrom(near);
									}
									return
							}
							let cont = creep.room.find(FIND_STRUCTURES, {filter: (s) => s.structureType == STRUCTURE_CONTAINER && s.store.getUsedCapacity() > 0 && s.effects && s.effects.length > 0})[0];
							if (!cont){
									let ruins = creep.room.find(FIND_RUINS,{filter:(s) => s.store.getUsedCapacity() > 0});
									if (ruins[0]){
											cont = ruins[0];
									}
							}
							if (cont){
									if (creep.pos.isNearTo(cont)){
											for (let i in cont.store){
													creep.withdraw(cont, i);
											}
									} else {
											creep.moveTo(cont, {range: 1, maxRooms: 1});
									}
							} else {
									delete creep.memory.collecting;
									delete Memory.coreRooms[targetRoom];
									if (creep.store.getUsedCapacity() == 0){
											creep.suicide();
									}
							}
					}
			} else if (creep.store.getUsedCapacity() > 0 && creep.home.storage){
					if (creep.pos.isNearTo(creep.home.storage)){
							for (let i in creep.store){
									creep.transfer(creep.home.storage, i);
							}
					} else if (creep.room.name != creep.home.name){
							creep.goTo(creep.home.storage,{SK:true});
					} else {
							creep.moveTo(creep.home.storage, {range: 1, maxRooms: 1});
					}
			}
	}

	var coreHauler = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$V
	});

	function run$U(creep){
			let targets;
			if (Memory.rooms[creep.room.name] && Memory.rooms[creep.room.name].hostiles){
					targets = creep.pos.findClosestByRange(FIND_HOSTILE_CREEPS, {
							filter: (creep) => creep.owner.username != "Source Keeper" && !creep.isWhiteListed && (creep.stats().attack || creep.stats().ranged_attack)
					});
					if (!targets){
							targets = creep.pos.findClosestByRange(FIND_HOSTILE_CREEPS, {
									filter: (creep) => creep.owner.username != "Source Keeper" && !creep.isWhiteListed
							});
					}
			}
			let dest;
			if (creep.num.toString().isRoomName()){
					dest = new RoomPosition(25, 25, creep.num);
			}
			if (creep.home.memory.remoteRooms && !dest){
					for (let i in creep.home.memory.remoteRooms){
							if (config.ignoreRemotes && config.ignoreRemotes.includes(i)){
									delete creep.home.memory.remoteRooms[i];
									continue
							}
							if (Game.map.isCoreRoom(i)){
									delete creep.home.memory.remoteRooms[i];
									continue
							}
							let rRoom = creep.home.memory.remoteRooms[i];
							if (rRoom.coreDetected){
									dest = new RoomPosition(25, 25, i);
							}
					}
			}
			if (dest && !targets && creep.room.name === dest.roomName){
					let core = creep.room.findStructures('invaderCore')[0];
					if (core && Memory.sectors[creep.home.sector]){
							targets = core;
							Memory.sectors[creep.home.sector].needCoreKilling = Game.time + 5000;
					} else if (creep.home.memory.remoteRooms && creep.home.memory.remoteRooms[dest.roomName]){
							delete creep.home.memory.remoteRooms[dest.roomName].coreDetected;
					}
			}
			if (!creep.room.hostiles && creep.hits < creep.hitsMax && !creep.stats().heal){
					creep.towerHeal(creep.home);
			}
			if (creep.home.memory.underHarassment && creep.home.memory.underHarassment < Game.time){
					delete creep.home.memory.underHarassment;
			}
			/*
			if (creep.hits < creep.hitsMax*0.5){
					creep.home.memory.escalate = true
			} else {
					creep.home.memory.escalate = false
			}*/
			if (targets){
					if (!creep.pos.isNearTo(targets)){
							creep.moveTo(creep.moveTo(targets, {range: 1}));
					} else {
							creep.attack(targets);
					}
			} else if (dest && dest.roomName && dest.roomName == creep.room.name){
					if (creep.home.memory.remoteRooms && creep.home.memory.remoteRooms[dest.roomName]){
							creep.home.memory.remoteRooms[dest.roomName].guardNeeded = false;
					}
			} else if (dest && creep.room.name != dest.roomName){
					creep.moveTo(dest, {range: 10});
			} else {
					creep.role = 'recycle';
			}
	}

	let spawnCode$u = {
			priority: (room, countFunction) => {
					let priority = 25;
					return priority
			},
			isRequired: (room, countFunction) => {
					let soldierNum = 0;
					let guardNeeded = false;
					if (room && room.memory.blockSoldiers && Game.time < room.memory.blockSoldiers){
							console.log('core killer blocked',room);
							return false
					} else if (room.memory.blockSoldiers){
							delete room.memory.blockSoldiers;
					}
					for (let i in room.memory.remoteRooms){
							if (room.memory.remoteRooms[i].coreDetected){
									guardNeeded = true;
							}
							if (!room.memory.remoteRooms[i].route || Game.time % 10000 == 0){
									room.memory.remoteRooms[i].route = [];
							}
					}
					if (guardNeeded){
							soldierNum = Game.bodySizeToNumberNeeded(10,spawnCode$u.body(room).body,'attack');
					}
					if (room.memory.faceClaimed || room.memory.boostingRequired){
							soldierNum = 0;
					}
					if (room.memory.defcon < 4){
							soldierNum = 0;
					}
					return countFunction('coreKiller', room) < soldierNum;
			},
			spawn: (room, role, body) => {
					//decide if we need any other options
					if (body){
							//options -> TTL, creepnumber
							room.spawnCreep(role, body);
					}
			},
			body: (room, countFunction) => {
					if (room.memory.roadsDown === undefined){
							room.memory.roadsDown = false;
					}
					let bodyObject = {
							body: [],
							cost: 0
					};
					//decide on what body to have
					bodyObject.body = room.makeBody([ATTACK], false, {
							sort: true,
							maxParts: 20
					});

					if (bodyObject.body && bodyObject.body.length > 0){
							bodyObject.cost += Game.getBodyCost(bodyObject.body);
					}
					return bodyObject
			}
	};

	var coreKiller = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$U,
		spawnCode: spawnCode$u
	});

	function run$T (creep){
			var homeRoom = Game.rooms[creep.name.split(' ')[2]];
			homeRoom.name;
			var f1 = Game.flags['t1'];
			var f2 = Game.flags['t2'];
			var RP = Game.flags['tr'];

			var hostiles = creep.pos.findInRange(FIND_HOSTILE_CREEPS, 6)[0];
			if (!creep.memory.t){
					var random = Math.floor(Math.random() * 2);
					creep.memory.t = random;
			}
			if (!creep.memory.retreat || hostiles){
					if (creep.memory.t && creep.memory.retreat && creep.memory.retreat === 0){
							if (creep.memory.t === '1'){
									creep.memory.t = '2';
							} else if (creep.memory.t === '2'){
									creep.memory.t = '1';
							}
					}
					creep.memory.retreat = '1';
			}
			if (creep.memory.retreat === '1'){
					creep.moveTo(RP);
			} else if (creep.memory.retreat === '0'){
					if (creep.memory.t === '2'){
							creep.moveTo(f1);
							creep.memory.t = '2';
					} else if (creep.memory.t === '1'){
							creep.moveTo(f2);
					}
			}
			if (RP && creep.pos.isEqualTo(RP)){
					creep.memory.retreat = '0';
			}
	}

	var decoy = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$T
	});

	//stop a deposit from being harvested
	function run$S(creep){
			if (!creep.memory.targetPos){
					creep.say('no pos');
					//creep.suicide()
					return
			}
			let depositPos = creep.memory.targetPos.toPos();
			if (depositPos && !creep.memory.near){
					let path = loadPath(creep.home, depositPos, Memory.deposits[creep.memory.targetPos]);
					let range;
					if (creep.room.name === depositPos.roomName){
							range = creep.pos.getRangeTo(depositPos);
					}
					if (path && (creep.room.name !==  depositPos.roomName || creep.pos.onEdge() || (range && range>5))){
							creep.moveUsingSavedPath(path.sPath, path.start.toPos(), path.end.toPos());
					} else if (creep.room.name !==  depositPos.roomName){
							creep.goTo(depositPos.roomName);
					} else if (range && range>3) {
							creep.moveTo(depositPos,{range:3});
					} else {
							creep.memory.near = true;
					}
			}
			function loadPath(room, pos, mem){
					if (mem && mem.path && mem.path.pos == pos.toString()){
							return mem.path.path
					} else if (room.storage){
							console.log('depCarry no path');
					}
			}
	}

	var depositBlocker = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$S
	});

	function run$R(creep){
		if (!creep.home){
			console.log(creep.name,creep.home);
				return
		}
		let stores = creep.home.storage;
		if (!stores || !creep.home.memory.depositTargets){
			console.log(creep.name, 'no targets');
			creep.memory.role = 'recycle';
			return
		}
		let full = creep.store.getUsedCapacity() >= creep.store.getCapacity() * 0.8;
		let old = creep.ticksToLive < 400;
		let possibleDeposits = creep.home.memory.depositTargets;
		if (!possibleDeposits){
			console.log(creep, 'no possible deposits');
			creep.suicide();
			return
		}
		let myDeposit = possibleDeposits[creep.num - 1];
		if (!myDeposit || !Memory.deposits[myDeposit]){
			creep.say('no mem');
			//console.log(creep.name,'no mem')
			return
		}
		let mem = Memory.deposits[myDeposit];
		let depositPos = myDeposit.toPos();
		if (Memory.deposits[myDeposit] && creep.hits < creep.hitsMax && creep.room.controller && !creep.room.controller.owner && !creep.room.controller.my){
			//path is bad - delete deposit memory and recalculate
			delete Memory.deposits[myDeposit];
			creep.suicide();
			return
		}
		if (!mem){
			//console.log(creep.name,'no mem')
			creep.say('no mem');
			creep.startNap(10);
			return
		}
		if (full || old){
			creep.memory.in = true;
		}
		if (depositPos && !creep.memory.in){
			let path = loadPath$1(creep.home, depositPos, mem);
			if (!creep.pos.inRangeTo(depositPos, 3)){
				if (path){
					creep.moveUsingSavedPath(path.sPath, path.start.toPos(), path.end.toPos());
				}
			} else {
				creep.wipePath();
				let miner = depositPos.lookAround(LOOK_CREEPS, 1, {filter: (c) => c.my && c.role === 'depositMiner' && c.store.getUsedCapacity()>0})[0];
				if (miner){
						miner.pos.highlight('purple');
					if (!creep.pos.isNearTo(miner)){
						creep.moveTo(miner, {range: 1});
					} else {
							if (miner.store.getUsedCapacity() > 0){
									for (let i in miner.store){
											miner.transfer(creep, i);
									}
							}
					}
				} else {
						creep.startNap(10);
				}
			}
		} else if (creep.memory.in && creep.store.getUsedCapacity() > 0){
			if (creep.pos.inRangeTo(stores, 2)){
				creep.goAndTransfer(stores);
			} else {
				let path = loadPath$1(creep.home, depositPos, mem);
				if (path){
					let sPath = PathFinder.reverseSerializedPath(path.sPath);
					creep.moveUsingSavedPath(sPath, path.end.toPos(), path.start.toPos());
				}
			}
		} else if (creep.memory.in){
			delete creep.memory.in;
			delete creep.memory.depositRoom;
			creep.suicide();
		} else {
			creep.wipePath();
		}
	}

	function loadPath$1(room, pos, mem){
		if (mem && mem.path && mem.path.pos == pos.toString()){
			return mem.path.path
		} else if (room.storage){
			console.log('depCarry no path');
		}
	}



	let spawnCode$t = {
		priority: (room, countFunction) => {
			let priority = 51;
			return priority
		},
		isRequired: (room, countFunction,idleSpawn,returnPartsNeeded,returnNumberNeeded) => {
			if (Game.energyCrisis || countFunction('depositMiner',room)===0 || !room.ecoStable  || room.controller.level < 7 || room.memory.armedHostiles || room.memory.defcon < 5
					|| !room.storage || room.storage.store.getFreeCapacity() < 50000){
				return false
			}
			if (room.memory.blockOptionalSpawning && room.memory.blockOptionalSpawning>Game.time){
					return false
			}
			let numberRequired = 0;
			if (room.memory.depositTargets){
					let currentDeposit = room.memory.depositTargets[0];
					if (currentDeposit && Memory.deposits[currentDeposit]){
							Memory.deposits[currentDeposit].spots ? numberRequired = Math.ceil(Memory.deposits[currentDeposit].spots/2) : numberRequired = 1;
					}
			}
			if (numberRequired > 3){
				numberRequired = 3;
			}
			if (!config.official && numberRequired > 1){
					numberRequired = 1;
			}
			if (returnNumberNeeded){
					return numberRequired
			}
			return countFunction('depositCarry', room) < numberRequired;
		},
		spawn: (room, role, body) => {
			//decide if we need any other options
			if (body){
				//options -> TTL, creepnumber
				room.spawnCreep(role, body);
			}
		},
		body: (room, countFunction) => {
			if (room.memory.roadsDown === undefined){
				room.memory.roadsDown = false;
			}
			let key = room.energyCapacityAvailable + ':' + room.memory.roadsDown;
				if (getCachedBody('depositCarry',key)){
						return getCachedBody('depositCarry',key)
				}
			let bodyObject = {
				body: [],
				cost: 0
			};
				let max = 25;
				if (room.controller.level > 7){
						max = 50;
				}
			//decide on what body to have
			bodyObject.body = room.makeBody([CARRY], false,{maxParts:max});

			if (bodyObject.body && bodyObject.body.length > 0){
				bodyObject.cost += Game.getBodyCost(bodyObject.body);
			}
				cacheBody('depositCarry',key,bodyObject);
			return bodyObject
		}
	};

	var depositCarry = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$R,
		spawnCode: spawnCode$t
	});

	function run$Q(creep){
			if (!creep.home){
					return
			}
		if (!creep.home.memory.depositTargets){
			console.log(creep.name, 'no targets');
			creep.memory.role = 'recycle';
			return
		}
		let possibleDeposits = creep.home.memory.depositTargets;
		if (!possibleDeposits){
			console.log(creep, 'no possible deposits');
			creep.suicide();
			return
		}
		let myDeposit = possibleDeposits[0];
		if (!myDeposit || !Memory.deposits[myDeposit]){
				if (!Memory.deposits[myDeposit]){
						creep.home.memory.depositTargets.splice(creep.num-1,1);
				}
			creep.say('no mem');
			//console.log(creep.name,'no mem')
			return
		}
		if (creep.isBoosted()){
			console.log(creep.pos, 'isBoosted depMiner');
		}
		let mem = Memory.deposits[myDeposit];
		if (Memory.deposits[myDeposit] && creep.hits < creep.hitsMax && creep.room.controller && !creep.room.controller.owner && !creep.room.controller.my){
			//path is bad - delete deposit memory and recalculate
			delete Memory.deposits[myDeposit];
			creep.suicide();
			return
		}
		let depositPos = myDeposit.toPos();
		creep.say(depositPos.roomName);
		let path = loadPath(creep.home, depositPos, mem);
		if (depositPos && creep.room.name === creep.home.name && creep.home.memory.sboostlab && creep.home.memory.sboostlab['UO'] && !creep.isBoosted()){
			let lab = Game.getObjectById(creep.home.memory.sboostlab['UO']);
			if (lab && lab.store['energy'] > 300 && lab.store['UO'] > 300){
				creep.moveTo(lab, {range: 1});
				lab.boostCreep(creep);
				return
			}
		}
		if (depositPos && !creep.pos.inRangeTo(depositPos, 2)){
			if (path){
				creep.moveUsingSavedPath(path.sPath, path.start.toPos(), path.end.toPos());
			}
		} else if (mem.id && Game.getObjectById(mem.id)){
			let deposit = Game.getObjectById(mem.id);
			if (creep.store.getUsedCapacity() < creep.store.getCapacity() - 25){
				if (creep.pos.getRangeTo(deposit) < 3){
					if (config.mapVisual){
						Game.map.visual.text('\u{26CF}', creep.pos);
					}
					if (!creep.pos.isNearTo(deposit)){
						creep.moveTo(deposit, {range: 1});
						return
					} else {
						creep.harvest(deposit);
					}
				}
			}
			if (deposit.cooldown && deposit.cooldown>3){
				creep.startNap(deposit.cooldown-2);
			}
		}
	}

	function loadPath(room, pos, mem){
		if (mem && mem.path && mem.path.pos == pos.toString()){
			return mem.path.path
		} else if (room.storage){
			console.log('depCarry no path');
		}
	}



	let spawnCode$s = {
		priority: (room, countFunction) => {
			let priority = 50;
			return priority
		},
		isRequired: (room, countFunction,idleSpawn,returnPartsNeeded,returnNumberNeeded) => {
			if (Game.energyCrisis || room.controller.level < 7 || !room.ecoStable || room.memory.armedHostiles
					|| room.memory.defcon < 5 || !room.storage || room.storage.store.getFreeCapacity() < 50000){
				return false
			}
			if (Game.market.credits > config.maxCredits && config.swc){
					//no need to mine for sales
					return false
			}
				if (room.memory.blockOptionalSpawning && room.memory.blockOptionalSpawning>Game.time){
						return false
				}
			let numberRequired = 0;
				if (room.memory.depositTargets){
						let currentDeposit = room.memory.depositTargets[0];
						if (currentDeposit && Memory.deposits[currentDeposit]){
								Memory.deposits[currentDeposit].spots ? numberRequired = Memory.deposits[currentDeposit].spots : numberRequired = 1;
						}
						if (Memory.deposits[currentDeposit] && Memory.deposits[currentDeposit].lastCooldown && Memory.deposits[currentDeposit].maxCooldown &&
								Memory.deposits[currentDeposit].lastCooldown > Memory.deposits[currentDeposit].maxCooldown){
								numberRequired = 0;
						}
				}
				if (!config.official && numberRequired > 1){
						numberRequired = 1;
				}
				if (returnNumberNeeded){
						return numberRequired
				}
			return countFunction('depositMiner', room) < numberRequired;
		},
		spawn: (room, role, body) => {
			//decide if we need any other options
			if (body){
				//options -> TTL, creepnumber
				room.spawnCreep(role, body);
			}
		},
		body: (room, countFunction) => {
			if (room.memory.roadsDown === undefined){
				room.memory.roadsDown = false;
			}
			let key = room.energyCapacityAvailable + ':' + room.memory.roadsDown;
				if (getCachedBody('depositMiner',key)){
						return getCachedBody('depositMiner',key)
				}
			let bodyObject = {
				body: [],
				cost: 0
			};
			let max = 25;
				if (room.controller.level > 7){
						max = 50;
				}
			//decide on what body to have
			bodyObject.body = room.makeBody([WORK], false, {fixedSection: ['carry', 'carry', 'carry', 'carry', 'carry', 'carry'],maxParts:max});

			if (bodyObject.body && bodyObject.body.length > 0){
				bodyObject.cost += Game.getBodyCost(bodyObject.body);
			}
				cacheBody('depositMiner',key,bodyObject);
			return bodyObject
		}
	};

	var depositMiner = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$Q,
		spawnCode: spawnCode$s
	});

	function run$P(creep){
		let targetRoom = creep.num;
		if (config.mapVisual){
			Game.map.visual.text('don', creep.pos, {fontSize: 5});
		}
		if (creep.store.getUsedCapacity() == 0 && creep.home.terminal && creep.room.name == creep.home.name && creep.home.memory.supplyTo){
			let mem = creep.home.memory.supplyTo[targetRoom];
			if (creep.pos.isNearTo(creep.home.terminal)){
				for (let i in mem){
					if (mem[i] > 0){
						let withD = creep.withdraw(creep.home.terminal, i);
						creep.say(withD);
						if (withD == 0){
							mem[i] -= creep.store.getFreeCapacity();
							break
						}
					}
				}
			} else {
				creep.moveTo(creep.home.terminal, {range: 1});
			}
		} else if (creep.store.getUsedCapacity() > 0){
			if (targetRoom && creep.room.name != targetRoom){
				creep.goTo(targetRoom);
			} else if (targetRoom && Game.rooms[targetRoom]){
				let dest = Game.rooms[targetRoom].terminal;
				if (!dest || dest.store.getFreeCapacity() < dest.store.getCapacity()){
					dest = Game.rooms[targetRoom].storage;
				}
				if (!creep.pos.onEdge()){
					creep.suicide();
				}
				if (dest){
					let res;
					for (let i in creep.store){
						if (creep.store[i] > 0){
							res = i;
							break
						}
					}
					let ret = creep.transfer(dest, res);
					if (ret == -9){
						creep.moveTo(dest, {range: 1, maxRooms: 1});
					} else if (ret !== 0){
						creep.suicide();
					}
				}
			} else ;
		} else ;
	}

	var donor = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$P
	});

	//stop a deposit from being harvested

	let exitPositionsAll = {};
	let tick = 0;
	function run$O(creep){
			let targetRoom = creep.num;
			if (!Memory.exitBlocks || !targetRoom || !Memory.exitBlocks[targetRoom]){
					creep.say('no pos');
					//creep.suicide()
					return
			}
			if (creep.hits < creep.hitsMax || creep.room.armedHostileList.length > 0 || creep.room.type === 'SK' || (creep.room.controller && creep.room.controller.owner && !creep.room.controller.my)){
					if (creep.stats().heal || true){
							engage(creep,undefined,undefined,'D');
					}
			}
			if (creep.room.name !== targetRoom || creep.pos.onEdge()){
					creep.goTo(targetRoom,{SK:true});
			} else {
					let exitPositions,reserved;
					if (exitPositionsAll[targetRoom] && tick === Game.time){
							tick = Game.time;
							exitPositions = exitPositionsAll[targetRoom];
					} else {
							exitPositions = [];
							for (let i in Memory.exitBlocks[targetRoom].blockPositions){
									exitPositions.push(Memory.exitBlocks[targetRoom].blockPositions[i].toPos());
							}
							exitPositionsAll[targetRoom] = exitPositions;
							reserved = {};
					}
					for (let i in exitPositions){
							if (exitPositions[i].isEqualTo(creep.pos)){
									return
							}
					}
					let nearestFree = creep.pos.findClosestByRange(exitPositions,{filter:(p)=> p.isWalkable(true) && !reserved[p]});
					if (nearestFree){
							reserved[nearestFree] = true;
							new RoomVisual(creep.room.name).line(nearestFree.pos,creep.pos);
							creep.moveTo(nearestFree,{range:0});
					}
			}
	}

	var exitBlocker = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$O
	});

	function run$N(creep){
			var homeRoom = Game.rooms[creep.name.split(' ')[2]];
			var homeRoomName = creep.name.split(' ')[2];
			var targetflag = Game.flags['fill' + homeRoomName];
			var pFlag = Game.flags['portal' + homeRoomName];
			var pExit = Game.flags['pExit' + homeRoomName];
			if (creep.home && creep.hits < creep.hitsMax*0.7){
					creep.home.memory.fillerBlock = Game.time + 1500;
			}
			if (creep.stats().heal && (creep.room.memory.armedHostiles || creep.hits < creep.hitsMax)){
					creep.heal(creep);
			}
			if (!targetflag || !targetflag.pos.roomName || !Game.rooms[targetflag.pos.roomName]
					|| !Game.rooms[targetflag.pos.roomName].controller || !Game.rooms[targetflag.pos.roomName].controller.my){
					if (targetflag){
							targetflag.remove();
					}
					if (!pFlag){
							creep.suicide();
					}
			}
			if (pExit && pExit.room && creep.room.name == pExit.room.name){
					creep.memory.pFlag = true;
			} else if (pFlag && pFlag.room && creep.room.name == pFlag.room.name){
					delete creep.memory.pFlag;
			}
			if ((!targetflag || !targetflag.pos) && !pFlag){
					return
			}
			let pos;
			let path;
			if (targetflag){
					pos= targetflag.pos;
					path = loadPath(creep.home, targetflag.pos);
					if (!path && !config.highwayWalls){
							path = savePath(creep.home, targetflag.pos);
					}
			}
			if (_.sum(creep.store) == creep.store.getCapacity()){
					creep.memory.dropping = true;
			}
			if (creep.memory.dropping || Game.shard.name != creep.name.split(' ')[3]){
					if ((!creep.memory.WP || creep.memory.WP != 'fin')){
							waypoints(creep);
					} else if (!creep.memory.portal && pFlag){
							creep._moveTo(pFlag,{range:0});
					} else if (pos && pos.roomName && pos.roomName === creep.room.name){
							let cont = pos.lookAround(LOOK_STRUCTURES, 0, {
									filter: (s) => s.structureType === STRUCTURE_STORAGE ||
											s.structureType === STRUCTURE_CONTAINER
							})[0];
							if (creep.room.storage && creep.room.storage.my){
									cont = creep.room.storage;
							}
							if (creep.store.getUsedCapacity() > 0){
									if (cont){
											if (creep.transfer(cont, 'energy') != 0){
													creep.moveTo(cont,{range:1});
											}
											if (cont.store.getFreeCapacity() == 0 && creep.pos.isEqualTo(cont.pos)){
													creep.suicide();
											}
									} else if (pos && (!pos.roomName || creep.room.name !== pos.roomName)){
											creep.say('here1');
											creep.goTo(pos);
									} else if (pos && !creep.pos.isEqualTo(pos)){
											creep.say('here2');
											creep.moveTo(pos,{range:0});
									} else {
											creep.suicide();
									}
							} else if (creep.room.controller && creep.room.controller.my || true){
									let range = getDist(creep.home.name,creep.room.name);
									if (range < 4){
											//reuse filler if distance is low
											delete  creep.memory.dropping;
											return
									}
									if (pos && pos.roomName && Game.rooms[pos.roomName] && Game.rooms[pos.roomName].class == 'restructuring'){
											creep.memory.role = 'mover';
											creep.memory.homeRoom = pos.roomName;
									} else {
											let spawn = creep.room.findStructures('spawn')[0];
											if (spawn){
													if (creep.pos.isNearTo(spawn)){
															spawn.recycleCreep(creep);
													} else {
															creep.moveTo(spawn,{range:1});
													}
											}
											creep.suicide();
									}

							}
					} else if (path){
							let room = creep.home;
							let startPos = room.getPositionAt(room.storage.pos.x, room.storage.pos.y + 1);
							if (room.memory.storageWithdawPos){
									startPos = room.memory.storageWithdawPos.toPos();
							}
							creep.moveUsingSavedPath(path.sPath, startPos, pos);
					} else if (!path && pos && pos.roomName && creep.roomName != pos.roomName){
							creep.goTo(pos);
					} else {
							//creep.memory.role = 'recycle'
							console.log(creep.name + ' no target flag');
					}
			} else {
					let stores = homeRoom.storage;
					if (stores && stores.store['energy'] > creep.home.memory.reserve*0.6){
							if (creep.withdraw(stores, RESOURCE_ENERGY) != 0){
									creep.moveTo(stores,{range:1});
							}
					}
			}

			function loadPath(room, pos){
					if (config.highwayWalls || !room || !room.memory.fillPath ||
							(creep.memory.sPath && creep.memory.sPath.pos && creep.memory.sPath.error && creep.memory.sPath.error == 'structure')){
							creep.wipePath();
							return
					}
					let mem = room.memory.fillPath;
					if (mem && mem.path && mem.expiry > Game.time && mem.pos == pos.toString()){
							return mem.path
					} else {
							return null
					}
			}

			function savePath(room, pos){
					if (!pos || !room || !Game.rooms[pos.roomName] || Game.cpu.bucket < 1000){
							return
					}
					let startPos = room.getPositionAt(room.storage.pos.x, room.storage.pos.y + 1);
					if (room.memory.storageWithdawPos){
							startPos = room.memory.storageWithdawPos.toPos();
					}
					//find path if loadPath return null and creep is near container (as this means the path will no be on the unwalkable mining spot)
					let path = PathFinder.search(startPos, {pos: pos, range: 1}, {
							plainCost: 1,
							swampCost: 5,
							maxOps: 20000,
							maxRooms: 50,
							roomCallback: function (roomName){

									if (Game.map.getRoomType(roomName) == 'SK'){
											return false
									}
									if (Game.map.isCoreRoom(roomName)){
											return false
									}
									if (Memory.dangerRooms && Memory.dangerRooms[roomName] ){
											return false
									}
									if (Memory.ownedRooms[roomName] && !config.canPassThroughRooms.includes(roomName)){
											//owned room that we can path through
											return false
									}
									if (Game.rooms[roomName]){
											return Game.rooms[roomName].structureMatrix
									}
							},
					});
					if (path.path){
							for (let i in path.path){
									path.path[i].highlight('blue');
							}
					}
					//serialize
					if (path.incomplete){
							console.log('path incomplete for filler', pos, path.ops);
							return null
					}
					let sPath = PathFinder.serializePath(startPos, path);
					//save, with an expiry in order to ensure fresh paths
					room.memory.fillPath = {
							pos: pos.toString(),
							path: {
									sPath: sPath,
									start: startPos.toString(),
									end: path.path[path.path.length - 1].toString()
							},
							expiry: Game.time + 100000
					};
					//path obj needs serialized path as well as a start pos and end pos
					return room.memory.fillPath.path
					//return pathObj
			}
	}



	let spawnCode$r = {
			priority: (room, countFunction) => {
					let priority = 40;
					if (room.total('energy')>room.memory.reserve*1.2){
							priority = 36;
					}
					if (room.total('energy')> room.memory.reserve && Memory.excessEnergy > 10000){
							priority = 30;
					}
					if (room.total('energy')> room.memory.reserve*1.5 && Memory.excessEnergy > 50000){
							priority = 25;
					}
					if (Memory.noLowLevelTerminals){
							priority = 30;
					}
					if (Game.shard.name === 'shard1'){
							priority = 30;
					}
					if (config.official && Game.market.credits > config.maxCredits*2 && !Game.energyCrisis){
							priority = 21;
					}
					priority += countFunction('filler', room);
					return priority
			},
			isRequired: (room, countFunction) => {
					if (!room.ecoStable || room.memory.armedHostiles || room.memory.defcon < 5 || room.class == 'restructuring' || room.squadSpawningBlockCivs){
							//console.log('1st filler block',room.ecoStable,room.squadSpawningBlockCivs)
							return false
					}
					if (room.memory.fillerBlock && room.memory.fillerBlock > Game.time){
							//console.log('filler block')
							return false
					}
					let numberRequired = 0;
					if (config.crossShardSupport){
							let target;
							crossShardLoop:
									for (let i in config.crossShardSupport){
											let obj = config.crossShardSupport[i];
											if (obj.fillerRooms && obj.fillerRooms[Game.shard.name]){
													for (let r in obj.fillerRooms[Game.shard.name]){
															if (obj.fillerRooms[Game.shard.name][r] === room.name){
																	target = i.split('-')[1];
																	break crossShardLoop
															}
													}
											}
									}
							if (target){
									numberRequired = 3;
									if (room.total('energy')>room.memory.reserve*0.8){
											return countFunction('filler', room) < numberRequired;
									}
							}
					}
					if (room.total('energy')<room.memory.reserve-5000 && Game.energyCrisis){
							return false
					}
					if (Game.flags['fill' + room.name]){
							//room.memory.blockOptionalSpawning = Game.time + 200
							numberRequired = 6;
							let targetRoomName = Game.flags['fill' + room.name].pos.roomName;
							if (Memory.colonistEscort && Memory.colonistEscort[targetRoomName]){
									numberRequired = 0;
							}
							if (!Game.energyCaution && config.official){
									numberRequired = 15;
							}
							if (room.total('energy')>room.memory.reserve*1.1){
									numberRequired = 5;
							}
							if (room.total('energy')>room.memory.reserve*1.5 || (Memory.noLowLevelTerminals && Memory.excessEnergy > 50000)){
									numberRequired = 10;
									if (room.controller.level === 8){
											numberRequired = 15;
									}
							}
							if (room.total('energy')>room.memory.reserve*2 && room.controller.level === 8){
									numberRequired = 20;
							}
							let targetRoom = Game.rooms[targetRoomName];
							if (targetRoom && targetRoom.controller && targetRoom.controller.owner && !targetRoom.controller.my){
									numberRequired = 0;
									if (config.allies && config.allies.includes(targetRoom.controller.owner.username)){
											if (!targetRoom.controller.safeModeCooldown){
													numberRequired = 2;
													if (targetRoom.find(FIND_STRUCTURES,{filter:(s)=>s.structureType === 'spawn'})[0]){
															numberRequired = 1;
													}
											}
											if (targetRoom.memory.armedHostiles){
													numberRequired = 0;
											}
									}
							} else if (targetRoom && targetRoom.memory.armedHostiles){
									numberRequired = 0;
							} else if (!targetRoom) {
									numberRequired = 0;
									room.sendVisionCreep(targetRoomName);
							}
					} else {
							delete room.memory.fillPath;
					}
					return countFunction('filler', room) < numberRequired;
			},
			spawn: (room, role, body) => {
					//decide if we need any other options
					if (body){
							//options -> TTL, creepnumber
							room.spawnCreep(role, body);
					}
			},
			body: (room, countFunction) => {
					if (room.memory.roadsDown === undefined){
							room.memory.roadsDown = false;
					}
					let key = room.energyCapacityAvailable + ':' + room.memory.roadsDown;
					if (getCachedBody('filler',key)){
							return getCachedBody('filler',key)
					}
					let bodyObject = {
							body: [],
							cost: 0
					};
					//decide on what body to have
					bodyObject.body = room.makeBody([CARRY], false);

					if (bodyObject.body && bodyObject.body.length > 0){
							bodyObject.cost += Game.getBodyCost(bodyObject.body);
					}

					cacheBody('filler', key, bodyObject);
					return bodyObject
			}
	};

	var filler = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$N,
		spawnCode: spawnCode$r
	});

	function run$M(creep){
			Game.flags['gnat' + room.name];
			let hostiles = creep.room.hostileList;
			let retreat = null;
			if (!creep.memory.lastRooms){
					creep.memory.lastRooms = [creep.room.name];
			}
			for (let i in hostiles){
					let id = hostiles[i].id;
					if (Memory.hostiles[id]){
							let hosStats = Memory.hostiles[id];
							if (hosStats.attackPower > 0 || hosStats.rangePower > 0){
									retreat = true;
									break
							}
					}
			}
			if (retreat){
					let retreatRoom = null;
					if (!retreatRoom){
							retreatRoom = creep.home.name;
					}
					creep.memory.retreat = retreatRoom;
			}
			creep.rangedMassAttack();
	}


	//put this in the role under the runPCs function, to control the spawning for that role

	let spawnCode$q = {
			priority: (room, countFunction) => {
					let priority = 60;
					return priority
			},
			isRequired: (room, countFunction) => {
					let numberRequired = 0;
					if (Game.flags['gnat' + room.name] && config.autoHarassEnemies === true && room.storage && room.storage.store['energy'] > room.memory.reserve){
							numberRequired = 2;
					}
					return countFunction('harasser', room) < numberRequired;
			},
			spawn: (room, role, body) => {
					//decide if we need any other options
					if (body){
							//options -> TTL, creepnumber
							room.spawnCreep(role, body);
					}
			},
			body: (room, countFunction) => {
					if (room.memory.roadsDown === undefined){
							room.memory.roadsDown = false;
					}
					let bodyObject = {
							body: [],
							cost: 0
					};
					//decide on what body to have
					bodyObject.body = [ATTACK, MOVE];
					if (bodyObject.body && bodyObject.body.length > 0){
							bodyObject.cost += Game.getBodyCost(bodyObject.body);
					}
					return bodyObject
			}
	};

	var gnat = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$M,
		spawnCode: spawnCode$q
	});

	function run$L(creep){
			//logic performed in defence manager
			if (creep.home && creep.home.controller && creep.home.controller.safeMode && creep.home.class !== 'bunker' && creep.home.controller.safeMode > creep.ticksToLive){
					creep.suicide();
			}
			if (creep.home.name !== creep.room.name){
					creep.goTo(creep.home.name);
			} else if ((creep.home.renewDefenceCreeps) && (creep.memory.renewing || creep.ticksToLive < 300)){
					let ret = creep.renew();
					if (ret){
							return;
					}
			}
			if (!creep.home.memory.armedHostiles){
					creep.rally(1);
					return
			}
			creep.home.memory.activeGuards.push(creep.id);
	}

	let spawnCode$p = {
			priority: (room, countFunction) => {
					let priority = 10;
					priority += countFunction('guard', room);
					return priority
			},
			isRequired: (room, countFunction) => {
					let guardnum = room.memory.guardNum;
					let lowWallHits = room.memory.adjustedLowWallHits;
					if ((!guardnum || guardnum < 2) && (Game.flags['defend' + room.name] || (room.memory.alert && room.memory.alert === 'high' && !room.memory.faceClaimed && (lowWallHits < config.minWalls[7] || room.memory.defcon != 5)) || (config.alwaysGuard && config.alwaysGuard.includes(room.name) && room.controller.level > 5))){
							guardnum = 2;
							if (room.memory.adjustedLowWallHits >= config.minWalls[7]){
									guardnum = 1;
							}
					} else if (!guardnum){
							guardnum = 0;
					}
					if (Game.flags['defend' + room.name] && (!guardnum || guardnum < 2)){
							guardnum = 4;
					}
					if (room.controller.safeMode && room.controller.safeMode > 500 && room.class !== 'bunker'){
							guardnum = 0;
					}
					if (guardnum > 10){
							guardnum = 10;
					}
					if (room.level < 7 && guardnum > 5){
							guardnum = 5;
					}
					if (room.class === 'bunker' && room.storage && room.memory.spawn && Game.spawns[room.memory.spawn]){
							guardnum = 2;
							if (room.controller.level === 7){
									guardnum = 3;
							}
							if (!room.memory.lastAttacked || Game.time-room.memory.lastAttacked>50000 ){
									guardnum = 2;
							}
					} else if (room.class === 'bunker'){
							guardnum = 0;
					} else if (!room.memory.walls || room.memory.walls < 50000){
							return false
					}
					if ((!config.official && (Memory.emergency || Game.safemodeActive)  && Game.gcl.level > 1 && Memory.myRooms.length < 10 && guardnum === 0) ||
							room.memory.nearbyAttack && Game.time < room.memory.nearbyAttack && room.memory.adjustedLowWallHits < 1500000){
							guardnum = 1;
							if (Memory.excessEnergy && Memory.excessEnergy > 5000*Game.gcl.level && room.memory.adjustedLowWallHits && room.memory.adjustedLowWallHits < 1000000){
									guardnum = 2;
							}
					}
					room.display(`guardnum  ${guardnum}`);
					return countFunction('guard', room) < guardnum;
			},
			spawn: (room, role, body) => {
					//decide if we need any other options
					if (body){
							//options -> TTL, creepnumber
							room.spawnCreep(role, body);
					}
			},
			body: (room, countFunction) => {
					if (room.memory.roadsDown === undefined){
							room.memory.roadsDown = false;
					}
					let useRanged = room.memory.useRangedGuards;
					let key = room.energyCapacityAvailable + ':' + room.memory.roadsDown + useRanged;
					if (getCachedBody('guard', key)){
							return getCachedBody('guard', key)
					}
					let bodyObject = {
							body: [],
							cost: 0
					};
					//decide on what body to have
					if (!useRanged && room.class !== 'bunker'){
							bodyObject.body = room.makeBody([ATTACK], true);
					} else {
							bodyObject.body = room.makeBody([RANGED_ATTACK], true);
					}

					if (bodyObject.body && bodyObject.body.length > 0){
							bodyObject.cost += Game.getBodyCost(bodyObject.body);
					}
					cacheBody('guard', key, bodyObject);
					return bodyObject
			}
	};

	var guard = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$L,
		spawnCode: spawnCode$p
	});

	function run$K(creep){
			if (!creep.home.memory.hostileRemotes){
					return
			}
			if (config.mapVisual){
					Game.map.visual.text('H', creep.pos, {fontSize: 5});
			}
			if (creep.memory.lastSeenHostile+100 > Game.time){
					creep.say('retreating');
					retreat();
					return
			}
			let savedRemotes = Object.keys(creep.home.memory.hostileRemotes);
			if (!creep.room.memory.armedHostiles && (!creep.memory.targetRoom || (creep.memory.go && creep.memory.go == 'ERROR'))){
					let remotes = [];
					for (let i in savedRemotes){
							if (Memory.dangerRooms && Memory.dangerRooms[savedRemotes[i]] && Memory.dangerRooms[savedRemotes[i]].expiry > Game.time ){
									continue
							}
							let distance = Game.map.getRoomLinearDistance(creep.room.name, savedRemotes[i]);
							if (config.harassRooms && config.harassRooms[creep.home.name]){
									distance = 1;
							}
							if (distance <= 10){
									let val = 11 - distance;
									while (val > 0){
											remotes.push(savedRemotes[i]);
											val--;
									}
							}
					}
					let random = Math.floor(Math.random() * remotes.length);
					creep.memory.targetRoom = remotes[random];
			}
			if ((!creep.memory.targetRoom || creep.room.name !== creep.memory.targetRoom) && !creep.room.memory.armedHostiles){
					//opportunistically harass enemy rooms we stumble upon
					if (creep.room.controller && creep.room.controller.reservation && !Memory.dangerRooms[creep.room.name] && ((
							creep.room.controller.reservation.username.isEnemy))){
							//detect via reservation
							creep.memory.targetRoom = creep.room.name;
							if (!creep.home.memory.hostileRemotes[creep.room.name]){
									creep.home.memory.hostileRemotes[creep.room.name] = Game.time + 2000;
							}
					} else if ((!creep.room.controller || !creep.room.controller.reservation) && !Memory.dangerRooms[creep.room.name]){
							//detect rooms that are not reserved and have containers and creeps
							let hoslist = creep.room.hostileList;
							if (hoslist && hoslist.length > 0){
									for (let i in hoslist){
											if (!hoslist[i].owner.username.isEnemy){
													continue
											}
											let cont = hoslist[i].pos.lookAround(LOOK_STRUCTURES,1,{filter:(s)=>s.structureType === STRUCTURE_CONTAINER})[0];
											if (cont){
													creep.memory.targetRoom = creep.room.name;
													if (!creep.home.memory.hostileRemotes[creep.room.name]){
															creep.home.memory.hostileRemotes[creep.room.name] = Game.time + 10000;
													}
													break
											}
									}
							}
					}
			}
			if (creep.room.memory.armedHostiles){
					creep.memory.lastSeenHostile = Game.time;
			}
			if (creep.room.memory.armedHostiles && ((creep.memory.targetRoom && creep.memory.targetRoom === creep.room.name) ||
					(creep.room.controller && creep.room.controller.reservation && !creep.room.controller.reservation.username !== Game.username))){
					creep.say('retreat');
					delete creep.memory.targetRoom;
					Memory.dangerRooms[creep.room.name] = {expiry:Game.time+500,time:Game.time};
			}
			if ((!creep.memory.WP || creep.memory.WP != 'fin')){
					waypoints(creep);
			} else if (creep.memory.targetRoom){
					if (creep.room.name !== creep.memory.targetRoom){
							creep.goTo(creep.memory.targetRoom, {SK: true});
					} else {
							if (!creep.room.controller || !creep.room.controller.my){
									if (creep.getType() == 'attacker'){
											if (!creep.memory.target || Game.time % 5 == 0){
													let hos = creep.pos.findClosestByPath(FIND_HOSTILE_CREEPS, {filter: (c) => c.owner.username !== 'Source Keeper' && !c.isWhiteListed &&
																	c.pos.x > 2 && c.pos.x < 47 && c.pos.y > 2 && c.pos.y < 47});
													if (hos){
															creep.memory.target = hos.id;
													} else {
															let ret = getSabotageTarget();
															if (!ret){
																	return
															}
													}
											}
											if (creep.memory.target){
													let target = Game.getObjectById(creep.memory.target);
													if (target && target.room.name == creep.room.name){
															let attack = creep.attack(target);
															if (attack == ERR_NOT_IN_RANGE){
																	creep.moveTo(target, {maxRooms: 1});
																	let road = creep.pos.lookAround(LOOK_STRUCTURES, 1, {filter: (s) => s.structureType === STRUCTURE_ROAD})[0];
																	if (road){
																			creep.attack(road);
																	}
															} else if (attack !== 0){
																	creep.move(creep.pos.getDirectionTo(target));
																	let road = creep.pos.lookAround(LOOK_STRUCTURES, 1, {filter: (s) => s.structureType === STRUCTURE_ROAD})[0];
																	if (road){
																			creep.attack(road);
																	}
															}
													} else {
															delete creep.memory.target;
													}
											}
									} else {
											if (!creep.memory.target){
													let ret = getSabotageTarget();
													if (!ret){
															return
													}
											}
											if (creep.memory.target){
													let target = Game.getObjectById(creep.memory.target);
													if (target && target.room.name == creep.room.name){
															if (creep.dismantle(target) == ERR_NOT_IN_RANGE || creep.pos.onEdge()){
																	creep.moveTo(target, {maxRooms: 1});
																	let road = creep.pos.lookAround(LOOK_STRUCTURES, 1, {filter: (s) => s.structureType === STRUCTURE_ROAD})[0];
																	if (road){
																			creep.dismantle(road);
																	}
															}
													} else {
															delete creep.memory.target;
													}
											}
									}
							}
					}
			} else {
					retreat();
			}
			function getSabotageTarget(){
					let sites = creep.pos.findClosestByPath(FIND_CONSTRUCTION_SITES,{filter:(s)=>(s.owner.username.isEnemy || (!s.my && config.attackAll)) && s.progress > 500 &&
									s.pos.x > 2 && s.pos.x < 47 && s.pos.y > 2 && s.pos.y < 47});
					let structure = creep.pos.findClosestByPath(FIND_STRUCTURES, {filter: (s) => (s.structureType == STRUCTURE_ROAD || s.structureType == STRUCTURE_CONTAINER) &&
									s.pos.x > 2 && s.pos.x < 47 && s.pos.y > 2 && s.pos.y < 47});
					if (sites){
							creep.memory.target = sites.id;
							return true
					} else if (structure){
							creep.memory.target = structure.id;
							return true
					} else {
							delete creep.memory.targetRoom;
							return false
					}
			}
			function retreat(){
					{
							creep.goTo(Game.map.getSector(creep.room.name),{SK:true});
					}
			}
	}


	//put this in the role under the runPCs function, to control the spawning for that role

	let spawnCode$o = {
			priority: (room, countFunction) => {
					let priority = 50;
					if (config.harassRooms && config.harassRooms[room.name]){
							priority = 45;
							if (room.total('energy') > room.memory.reserve){
									priority = 35;
							}
					}
					return priority
			},
			isRequired: (room, countFunction) => {
					let numberRequired = 0;
					if (room.memory.armedHostiles || room.memory.underHarassment || room.memory.defcon < 4){
							return false
					}
					if (room.controller.level > 3){
							//use squads instead
							return false
					}
					if (room.memory.hostileRemotes && Object.keys(room.memory.hostileRemotes).length > 0 && config.autoHarassEnemies=== true &&
							room.storage && room.storage.store['energy'] > room.memory.reserve){
							for (let i in room.memory.hostileRemotes){
									if (!Memory.dangerRooms[i]){
											//room is safe to harass
											numberRequired = 2;
											break
									}
							}
					}
					// if (lastSpawned[room.name] && lastSpawned[room.name]>Game.time){
					// 		return false
					// }
					// if (numberRequired === 3){
					// 		lastSpawned[room.name] = Game.time+1000
					// }
					return countFunction('harasser', room) < numberRequired;
			},
			spawn: (room, role, body) => {
					//decide if we need any other options
					if (body){
							//options -> TTL, creepnumber
							room.spawnCreep(role, body);
					}
			},
			body: (room, countFunction) => {
					if (room.memory.roadsDown === undefined){
							room.memory.roadsDown = false;
					}
					let bodyObject = {
							body: [],
							cost: 0
					};
					bodyObject.body = [ATTACK, MOVE];
					let rand = Math.ceil(Math.random() * 3);
					if ( rand === 3){
							bodyObject.body = [WORK, WORK,WORK,WORK,WORK,MOVE,MOVE,MOVE,MOVE, MOVE];
					} else if (rand === 2){
							bodyObject.body = [WORK, MOVE];
					}
					if (bodyObject.body && bodyObject.body.length > 0){
							bodyObject.cost += Game.getBodyCost(bodyObject.body);
					}
					return bodyObject
			}
	};

	var harasser = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$K,
		spawnCode: spawnCode$o
	});

	playerHeap.extenionManager = {};
	playerHeap.extenionManager.allReservations = {};
	playerHeap.extenionManager.allRooms = {};
	const allGenerators = {};

	//todo pathing home is suboptimal route, in fact all the pathing is...
	function pushExtensionGenerators(){
			for (let i in allGenerators){
					if (Game.cpu.bucket < 200){
							break
					}
					if (allGenerators[i] && Game.rooms[i]){
							console.log(`pushing extension generation for ${i}`);
							set(Game.rooms[i]);
					}
			}
	}

	function set(room, force){
			//allow pausing halfway to avoid crashing due to low cpu
			if (!room || Game.cpu.bucket < 20){
					return
			}
			console.log('setting extensions', room.hyperlink);
			if (!allGenerators[room.name]){
					allGenerators[room.name] = _set(room, force);
			}
			try {
					let ret = allGenerators[room.name].next();
					// console.log('extension gen ->',ret.value)
					if (ret.done === true){
							delete allGenerators[room.name];
							return 'done'
					}
			} catch (err){
					console.log(err.stack.split("at"), 'ext gen');
					delete delete allGenerators[room.name];
			}
	}

	//optimisations
	//moveby path saved to generate map
	//cache the status of the nodes and update on spawn and fill
	function* _set(room, force){
			let extensions = room.find(FIND_MY_STRUCTURES, {filter: (s) => s.structureType == STRUCTURE_SPAWN || s.structureType == STRUCTURE_EXTENSION});
			let possibleInactive = false;
			//check numbers to see if it is possible for any spawns/extensions to be inactive
			let extCheck = extensions.filter((s)=>s.structureType === 'extension');
			let spawnCheck = extensions.filter((s)=>s.structureType === 'spawn');
			if (CONTROLLER_STRUCTURES['extension'][room.controller.level]>extCheck.length ||
					CONTROLLER_STRUCTURES['spawn'][room.controller.level]>spawnCheck.length){
					possibleInactive = true;
			}

			let segment = access(room.name);
			let roomIndex = Memory.myRooms.indexOf(room.name);
			if ((Game.time + roomIndex) % 50 !== 0 && Memory.myRooms.length > 5 && !force){
					return
			}
			if (!segment){
					yield 'no segment';
			}
			let extensionMap = segment.extensionMap;
			let extensionPositions = segment.extensionPositions;
			if (playerHeap.extenionManager.allRooms[room]){
					delete playerHeap.extenionManager.allRooms[room];
			}
			playerHeap.extenionManager.allReservations[room.name] = {};

			if (extensions && (!room.memory.extensionsLength || extensions.length != room.memory.extensionsLength || force || !extensionPositions)){
					let spawn = Game.spawns[room.memory.spawn];
					let positions = {};
					if (!spawn && !room.storage){
							console.log('ext', room.memory.spawn, spawn);
							delete room.memory.spawn;
							console.log(`incorrect spawn in ${room.name}`);
							return
					}
					let startNode;
					if (spawn){
							startNode = new RoomPosition(spawn.pos.x, spawn.pos.y - 2, room.name);
					}
					if (!startNode && room.storage){
							startNode = new RoomPosition(room.storage.pos.x, room.storage.pos.y + 1, room.name);
					}
					if (room.memory.fixedBaseOrigin && !room.memory.smallFixedBase){
							let origin = room.memory.fixedBaseOrigin.toPos();
							positions[origin.toString()] = [];
							let spawns = room.find(FIND_STRUCTURES, {filter: (s) => s.structureType === STRUCTURE_SPAWN});
							for (let s in spawns){
									positions[origin].push(spawns[s].id);
							}
							let checkPositions;
							if (room.memory.staticFillerSpots){
									let fillerSpots = [];
									for (let i in room.memory.staticFillerSpots){
											fillerSpots.push(room.memory.staticFillerSpots[i].toPos());
									}
									 checkPositions = fillerSpots.concat([
									// 		RoomDesigner.findRelativePosition(origin, 3, 3, room.memory.fixedBaseDir),
									// 		RoomDesigner.findRelativePosition(origin, 4, 4, room.memory.fixedBaseDir),
									// 		RoomDesigner.findRelativePosition(origin, 3, 0, room.memory.fixedBaseDir),
									// 		RoomDesigner.findRelativePosition(origin, 4, 0, room.memory.fixedBaseDir),
											findRelativePosition(origin, 3, -3, room.memory.fixedBaseDir),
											findRelativePosition(origin, 4, -4, room.memory.fixedBaseDir),
											findRelativePosition(origin, 0, -3, room.memory.fixedBaseDir),
											findRelativePosition(origin, 0, -4, room.memory.fixedBaseDir),
											findRelativePosition(origin, -3, -3, room.memory.fixedBaseDir),
											findRelativePosition(origin, -4, -4, room.memory.fixedBaseDir),
											findRelativePosition(origin, -3, 0, room.memory.fixedBaseDir),
											findRelativePosition(origin, -4, 0, room.memory.fixedBaseDir),
											findRelativePosition(origin, -3, 3, room.memory.fixedBaseDir),
											findRelativePosition(origin, -4, 4, room.memory.fixedBaseDir)
									]);
							} else {
									checkPositions = [
											findRelativePosition(origin, 3, 3, room.memory.fixedBaseDir),
											findRelativePosition(origin, 4, 4, room.memory.fixedBaseDir),
											findRelativePosition(origin, 3, 0, room.memory.fixedBaseDir),
											findRelativePosition(origin, 4, 0, room.memory.fixedBaseDir),
											findRelativePosition(origin, 3, -3, room.memory.fixedBaseDir),
											findRelativePosition(origin, 4, -4, room.memory.fixedBaseDir),
											findRelativePosition(origin, 0, -3, room.memory.fixedBaseDir),
											findRelativePosition(origin, 0, -4, room.memory.fixedBaseDir),
											findRelativePosition(origin, -3, -3, room.memory.fixedBaseDir),
											findRelativePosition(origin, -4, -4, room.memory.fixedBaseDir),
											findRelativePosition(origin, -3, 0, room.memory.fixedBaseDir),
											findRelativePosition(origin, -4, 0, room.memory.fixedBaseDir),
											findRelativePosition(origin, -3, 3, room.memory.fixedBaseDir),
											findRelativePosition(origin, -4, 4, room.memory.fixedBaseDir)
									];
							}
							let extensionsAssigned = {};
							console.log('checkPos',checkPositions);
							for (let i in checkPositions){
									let checkPos = checkPositions[i];
									checkPos.highlight('purple');
									let nearExtensions = checkPos.lookAround(LOOK_STRUCTURES, 1, {filter: (s) => s.structureType == STRUCTURE_EXTENSION || s.structureType === 'spawn'});
									if (nearExtensions && nearExtensions.length > 0){
											for (let e in nearExtensions){
													let ext = nearExtensions[e];
													if (!extensionsAssigned[ext.id]){
															extensionsAssigned[ext.id] = true;
															if (!positions[checkPos.toString()]){
																	positions[checkPos.toString()] = [ext.id];
															} else if (positions[checkPos.toString()]){
																	positions[checkPos.toString()].push(ext.id);
															}
													}
											}
									}
							}
					} else {
							let sourceExtensions = {};
							if (room.memory.sourcePositions && room.memory.fixedBaseOrigin && room.memory.smallFixedBase){
									//remove the source extensions if fixedBased
									for (let i in room.memory.sourcePositions){
											let sourcePos = room.memory.sourcePositions[i];
											if (sourcePos.e1){
													let pos = sourcePos.e1.toPos();
													if (pos){
															let ext = pos.lookAround(LOOK_STRUCTURES, 0, {filter: (s) => s.structureType === STRUCTURE_EXTENSION})[0];
															if (ext){
																	sourceExtensions[ext.id] = true;
															}
													}
											}
											if (sourcePos.e2){
													let pos = sourcePos.e2.toPos();
													if (pos){
															let ext = pos.lookAround(LOOK_STRUCTURES, 0, {filter: (s) => s.structureType === STRUCTURE_EXTENSION})[0];
															if (ext){
																	sourceExtensions[ext.id] = true;
															}
													}
											}
									}
							}
							positions[startNode.toString()] = [];
							let doneExtensions = {};
							if (room.memory.staticFillerSpots){
									let fillerSpots = [];
									for (let i in room.memory.staticFillerSpots){
											fillerSpots.push(room.memory.staticFillerSpots[i].toPos());
									}
									for (let i in fillerSpots){
											let fSpot = fillerSpots[i];
											let extensions = fSpot.lookAround(LOOK_STRUCTURES,1,{filter:(s)=> s.my &&
															(s.structureType === 'extension' || s.structureType === 'spawn') && !doneExtensions[s.id]});
											for (let e in extensions){
													let extension = extensions[e];
													let str = fSpot.toString();
													if (!positions[str]){
															positions[str] = [extension.id];
													} else if (positions[str]){
															positions[str].push(extension.id);
													}
													doneExtensions[extension.id] = true;
											}
									}
							}
							for (let i in extensions){
									let extension = extensions[i];
									if (doneExtensions[extension.id]){
											continue
									}
									if (sourceExtensions[extension.id]){
											continue
									}
									if (extension &&(!possibleInactive || extension.isActive())){
											//check the neighbours for each extension and push the neighbour nearest to the most other extensions to the positions list, saving its id to that position
											let position = null;
											let extsNearCount = 0;
											let neighbours = extension.pos.neighbours(1);
											for (let n in neighbours){
													if (Game.cpu.bucket < 50){
															console.log('yield finding nodes', room.name);
															yield 'finding nodes';
													}
													let neighbour = neighbours[n];
													let extsNear = neighbour.lookAround(LOOK_STRUCTURES, 1, {filter:(s)=> s.my &&
																	(s.structureType === 'extension' || s.structureType === 'spawn') && !doneExtensions[s.id]}).length;
													if (extsNear && (!position || extsNear > extsNearCount) && neighbour.isWalkable()){
															position = neighbour;
															extsNearCount = extsNear;
													}
											}
											if (position){
													//new RoomVisual(position).circle(position,{fill:'yellow',radius:0.5})
													position = position.toString();
													if (!positions[position]){
															positions[position] = [extension.id];
													} else if (positions[position]){
															positions[position].push(extension.id);
													}
											} else {
													new RoomVisual(room.name).circle(extension.pos, {fill: 'red', radius: 0.5});
													if (!room.memory.blockExtPos){
															room.memory.blockExtPos = [extension.pos.toString()];
													} else {
															room.memory.blockExtPos.push(extension.pos.toString());
													}
													//extension.destroy()
													console.log('trying to destroy extensions', room.name);
											}
									}
							}
					}
					save(room.name, 'extensionPositions', positions);
					extensionPositions = positions;
					room.memory.extensionLength = extensions.length;
					extensionMap = undefined;
			}
			if (extensionPositions && (!extensionMap || force
					|| Object.keys(extensionMap).length < Object.keys(extensionPositions).length)){
					let extensionMapData = {};
					let keys = Object.keys(extensionPositions);
					//keys is a list of positions of the nodes
					for (let i in keys){
							if (Game.cpu.bucket < 100){
									console.log('yield mapping', room.name);
									yield 'building map';
							}
							let visited = {};
							let pos = keys[i].toPos();
							new RoomVisual(pos.roomName).circle(pos, {fill: 'yellow', radius: 0.5});
							extensionMapData[keys[i]] = {};
							flood(pos, pos, visited, extensionMapData[keys[i]], extensionMapData);
					}
					if (Game.cpu.bucket < 100){
							console.log('yield pre val', room.name);
							yield 'pre-validating';
					}
					verifyMap(extensionMapData, room);
					save(room.name, 'extensionMap', extensionMapData);
			}
			return true

			function verifyMap(obj, room){
					if (playerHeap.extenionManager.allRooms[room]){
							delete playerHeap.extenionManager.allRooms[room];
					}
					manageReservations$1(room);
					//this uses a fill to find all clusters that are seperate, if there are more than one they will be joined
					// by the central store point
					let clusters = [];
					let notFound = [];
					for (let i in obj){
							notFound.push(i);
					}
					//generate clusters
					while (notFound.length > 0){
							let start = notFound.shift();
							let cluster = findCluster(start, obj, notFound, room);
							if (cluster){
									clusters.push(cluster);
							}
					}
					//if >1 clusters this means the tree is not complete so clusters need to be joined
					if (clusters.length > 0){
							let spawn = Game.spawns[room.memory.spawn];
							if (spawn){
									let storeNodePos = spawn.room.getPositionAt(spawn.pos.x, spawn.pos.y - 2);
									if (room.memory.fixedBaseOrigin){
											storeNodePos = room.memory.fixedBaseOrigin.toPos();
									}
									let nodesThatNeedConnecting = [];
									for (let i in clusters){
											//find the closest point to the storeNode
											nodesThatNeedConnecting.push(storeNodePos.findClosestByRange(clusters[i]));
									}
									//connect nodes to store
									for (let i in nodesThatNeedConnecting){
											let pos = nodesThatNeedConnecting[i];
											if (!pos){
													return
											}
											let path1 = PathFinder.search(pos, storeNodePos, {
													roomCallback: function (roomName){
															let room = Game.rooms[roomName];
															if (!room){
																	return
															}
															let costs = room.structureMatrix;
															if (room.roadMatrix){
																	let merged = PathFinder.mergeMatrix(costs,room.roadMatrix);
																	if (merged){
																			costs = merged;
																	}
															}
															return costs
													}
											});
											if (path1){
													new RoomVisual().circle(pos, {fill: 'blue', radius: 0.5});
													new RoomVisual().poly([pos].concat(path1.path), {strokeWidth: 0.3});
													if (!obj[pos.toString()]){
															obj[pos.toString()] = {};
													}
													obj[pos.toString()][storeNodePos.toString()] = PathFinder.serializePath(pos, path1);
													layRoadsOnPath(room,path1);
											}
											let path2 = PathFinder.search(storeNodePos, pos, {
													roomCallback: function (roomName){
															let room = Game.rooms[roomName];
															if (!room){
																	return
															}
															let costs = room.structureMatrix;
															if (room.roadMatrix){
																	let merged = PathFinder.mergeMatrix(costs,room.roadMatrix);
																	if (merged){
																			costs = merged;
																	}
															}
															return costs
													}
											});
											if (path2){
													if (!obj[storeNodePos.toString()]){
															obj[storeNodePos.toString()] = {};
													}
													obj[storeNodePos.toString()][pos.toString()] = PathFinder.serializePath(storeNodePos, path2);
											}
									}
							}
					}
					function findCluster(start, obj, notFound, room){
							//performs search through the tree to find clusters while removing from notFound list,
							//does not return clusters that are connected to the storeNode
							if (!start){
									console.log('search no start node');
									return
							}
							let spawn = Game.spawns[room.memory.spawn];
							if (!spawn){
									return
							}
							let storeNode = spawn.room.getPositionAt(spawn.pos.x, spawn.pos.y - 2).toString();
							if (room.memory.storageWithdawPos){
									storeNode = room.memory.storageWithdawPos.toPos();
							}
							//breadth first search along map to find a node that is not full and not reserve
							let visited = {start: true};
							let queue = [start];
							let mem = obj;
							let connectedToCentre = false;
							let cluster = [];
							while (queue.length > 0){
									//remove and check the node at the start of the queue
									let currentNode = queue.shift();
									//if the cluster contains the storeNode -> dont return it as we don't need to connect it up
									if (currentNode === storeNode || start === storeNode){
											connectedToCentre = true;
									}
									let index = notFound.findIndex((e) => {
											return e === currentNode
									});
									if (index && index != -1){
											notFound.splice(index, 1);
									}
									if (!connectedToCentre){
											cluster.push(currentNode.toPos());
									}
									// otherwise check nearby nodes and add them to the back of the queue
									let nearbyNodes = mem[currentNode];
									//nearby Nodes is obj with nearbyNode:pathToNearbyNode
									for (let i in nearbyNodes){
											if (!visited[i]){
													queue.push(i);
													visited[i] = true;
											}
									}
							}
							if (connectedToCentre){
									return null
							}
							return cluster
					}
			}

			/*
			extensionMap = {
					node1 : {
							neighbour1:path,
							neighbour2:path
					},
					node2...
			}
			 if (room.memory.extensionMap){

					let visited = {}
					for (let i in room.memory.extensionMap){
							for (let n in room.memory.extensionMap[i]){
									//each route saved to a pos
									let pos = i.toPos()
									let newPos = pos
									for (let j in room.memory.extensionMap[i][n]){
											newPos = newPos.movePos(room.memory.extensionMap[i][n][j])
											new RoomVisual(room.name).circle(newPos,{fill:'purple'})
									}
							}
					}
			 }*/
			function layRoadsOnPath(room,path){
					if (room.controller.level < 6 && Game.cpu.bucket > 100){
							if (room.roadMatrix){
									for (let p in path.path){
											let pos = path.path[p];
											if (pos){
													let cost = room.roadMatrix.get(pos.x,pos.y);
													if (cost === 1){
															let sites = pos.lookAround(LOOK_CONSTRUCTION_SITES,0);
															let structures = pos.lookAround(LOOK_STRUCTURES,0);
															if (sites.length === 0 && structures.length === 0){
																	pos.createConstructionSite('road');
															}
													}
											}
									}
							}
					}
			}
			function flood(start, current, visited, ret, mem){
					if (!ret){
							ret = {};
					}
					let room = Game.rooms[start.roomName];
					visited[current.toString()] = 1;
					let neighbours = current.neighbours(1);
					for (let n in neighbours){
							let neighbour = neighbours[n];
							if (neighbour.getRangeTo(start) > 4 || (room.memory.fixedBaseOrigin && neighbour.getRangeTo(start) > 3)){
									return
							}
							if (neighbour.isWalkable() && !extensionPositions[neighbour.toString()] && !visited[neighbour.toString()]){
									flood(start, neighbour, visited, ret, mem);
							} else if (extensionPositions[neighbour.toString()] && !ret[neighbour.toString()] && !visited[neighbour.toString()]){
									let path = PathFinder.search(start, neighbour, {
											roomCallback: function (roomName){
													let room = Game.rooms[roomName];
													if (!room){
															return
													}
													let costs = room.structureMatrix;
													if (room.roadMatrix){
															let merged = PathFinder.mergeMatrix(costs,room.roadMatrix);
															if (merged){
																	costs = merged;
															}
													}
													return costs
											}
									});
									new RoomVisual(room.name).circle(start, {fill: 'violet', radius: 0.5});
									//new RoomVisual().text('E',neighbour);
									new RoomVisual(room.name).poly([start].concat(path.path), {strokeWidth: 0.3});
									if (path){
											ret[neighbour.toString()] = PathFinder.serializePath(start, path);
											layRoadsOnPath(room,path);
									}
									let path1 = PathFinder.search(neighbour, start, {
											roomCallback: function (roomName){
													let room = Game.rooms[roomName];
													if (!room){
															return
													}
													let costs = room.structureMatrix;
													if (room.roadMatrix){
															let merged = PathFinder.mergeMatrix(costs,room.roadMatrix);
															if (merged){
																	costs = merged;
															}
													}
													return costs
											}
									});
									if (path1 && mem){
											if (!mem[neighbour.toString()]){
													mem[neighbour.toString()] = {};
											}
											mem[neighbour.toString()][start.toString()] = PathFinder.serializePath(neighbour, path1);
											new RoomVisual().circle(neighbour, {fill: 'blue', radius: 0.5});
									}
							}
					}
			}

			//build the tree with the distances between each node and which nodes can move to which other nodes -> may be easier to connect if in walking range of 3 and dont cross any other node
			//maybe a small floodfill from each node
			//also save simple path between each node - work out distance using this path -> save less stuff
			//each point will need to save an [] of nearby points with each one saving path and point pos
			//if a point has no points in 3 range, connect to grid by nearest point
	}

	function manageReservations$1(room){
			if (!playerHeap.extenionManager.allReservations[room.name]){
					playerHeap.extenionManager.allReservations[room.name] = {};
			}
			let reservations = playerHeap.extenionManager.allReservations[room.name];
			for (let id in reservations){
					if (id){
							let creep = Game.getObjectById(id);
							if (!creep || (creep.role !== 'harvester' && (!creep.memory.runAsHarvester || creep.memory.runAsHarvester > Game.time))){
									delete reservations[id];
							}
					}
			}
	}
	function staticFill(creep){
			let room = creep.home;
			if (!playerHeap.extenionManager.allReservations[room.name]){
					playerHeap.extenionManager.allReservations[room.name] = {};
			}
			let reservations = playerHeap.extenionManager.allReservations[room.name];
			if (!ready()){
					return
			}
			if (!room.memory.haveSetExtensions){
					set(creep.home,true);
					room.memory.haveSetExtensions = true;
					return
			}
			if (room.energyAvailable === room.energyCapacityAvailable){
					return 'full'
			}
			let currentNode = creep.pos;
			if (currentNode){
					if (!reservations[creep.id]){
							for (let i in reservations){
									if (reservations[i] && reservations[i].isEqualTo(currentNode)){
											delete reservations[i];
									}
							}
							reservations[creep.id] = currentNode;
					}
					let str = currentNode.toString();
					if (isFull(str,room)){
							return 'full'
					}
					fillNode(creep,str);
			}
	}
	function fillExtensions(creep){
			let room = creep.home;
			if (creep.memory.tempPaths && Game.time % 10 == 0){
					delete creep.memory.tempPaths;
			}
			if (creep.home.energyAvailable === creep.home.energyCapacityAvailable){
					delete creep.memory.filling;
					delete creep.memory.extPath;
					creep.wipePath();
					return
			}
			if (!playerHeap.extenionManager.allReservations[room.name]){
					playerHeap.extenionManager.allReservations[room.name] = {};
			}
			let reservations = playerHeap.extenionManager.allReservations[room.name];
			if (!ready()){
					return
			}
			let segment = access(creep.home.name);
			let resetTime = 1000*room.controller.level;
			if (segment && (!segment.extensionMap || !room.memory.haveSetExtensions || !segment.extensionPositions || (Game.time + (room.index*50)%resetTime ===0))){
					creep.pos.highlight('red');
					console.log('no segment extension map');
					set(creep.home,true);
					room.memory.haveSetExtensions = true;
					return
			}
			let currentNode = reservations[creep.id];
			let homePos;
			if (room.storage){
					homePos = room.getPositionAt(room.storage.pos.x, room.storage.pos.y + 1);
			}
			if (room.memory.storageWithdawPos){
					homePos = room.memory.storageWithdawPos.toPos();
			}
			//find the next closest extension position using breadth first search
			if (currentNode){
					if (creep.store['energy'] == 0){
							//if creep is not near store
							if (creep.room.storage && creep.pos.isNearTo(creep.room.storage)){
									//delete reservation and state
									reservations[creep.id] = null;
									delete creep.memory.filling;
									delete creep.memory.extPath;
									creep.wipePath();
							} else if (currentNode.isEqualTo(homePos)){
									//moveUsingSavedPath back to storage
									if (!creep.memory.lastNode || !creep.memory.lastNode.toPos()){
											delete creep.memory.filling;
											delete creep.memory.extPath;
											creep.wipePath();
											delete creep.memory.lastNode;
											return
									}
									creep.memory.lastNode.toPos();
									let tryExtPath = extPath(currentNode);
									if (!tryExtPath){
											creep.say('pathing home');
											creep.moveTo(currentNode,{range:0});
									}
									return
							} else {
									creep.say('home');
									let newNode = homePos;
									if (newNode && !isReserved(newNode.toString(), room)){
											reservations[creep.id] = newNode;
											extPath(newNode);
											creep.memory.lastNode = currentNode.toString();
									} else {
											reservations[creep.id] = null;
											delete creep.memory.filling;
											delete creep.memory.extPath;
											creep.wipePath();
									}
									return
							}
					} else if (isFull(currentNode.toString(), room)){
							//if current node is full -> find a new node using current as the start point
							let newNode = searchMap(currentNode, room, creep);
							reservations[creep.id] = newNode;
							extPath(newNode);
							//find route to next ext using map

					} else {
							if (creep.pos.isEqualTo(currentNode)){
									fillNode(creep, currentNode);
							} else {
									let tryExtPath = extPath(currentNode);
									if (!tryExtPath) {
											creep.say('moveTo');
											creep.moveTo(currentNode, {range: 0});
											if (!currentNode.isWalkable()){
													console.log(room, 'node not walkable, extension manager');
													set(creep.home, true);
											} else if ((creep.memory.still > 2 || Game.cpu.bucket > 1000) && creep.pos.isNearTo(currentNode)){
													let inWay = currentNode.lookAround(LOOK_CREEPS, 0, {filter: (c) => c.my && c.role != 'harvester'})[0];
													if (inWay){
															let dir = creep.pos.getDirectionTo(inWay);
															inWay.move(dir.map8(4));
															creep.move(dir);
													}
											}
									}
							}
					}
			} else {
					delete creep.memory.extPath;
					creep.wipePath();
					manageReservations$1(room);
					if (creep.store['energy'] == 0);
					findNextNode();
			}
			let nearExts;
			if (room.memory.fixedBaseOrigin && currentNode && (creep.home.controller.level < 7 || creep.pos.getRangeTo(currentNode) < 2)){
					nearExts = creep.pos.lookAround(LOOK_STRUCTURES, 1, {
							filter: (s) => (s.structureType == STRUCTURE_EXTENSION || s.structureType == STRUCTURE_SPAWN)
									&& s.store['energy'] < s.store.getCapacity('energy') && s.pos.isNearTo(currentNode)
					})[0];
			} else if (!room.memory.fixedBaseOrigin){
					nearExts = creep.pos.lookAround(LOOK_STRUCTURES, 1, {filter: (s) => (s.structureType == STRUCTURE_EXTENSION || s.structureType == STRUCTURE_SPAWN) && s.store['energy'] < s.store.getCapacity('energy')})[0];
			}
			if (nearExts){
					creep.transfer(nearExts, 'energy');
			} else if (creep.store.getFreeCapacity() > 0 && room.storage && creep.pos.isNearTo(room.storage)){
					creep.withdraw(room.storage, 'energy');
			}
			if (creep.home && creep.home.memory.defcon && creep.home.memory.defcon < 4){
					let nearLabs = creep.pos.lookAround(LOOK_STRUCTURES, 1, {
							filter: (s) => (s.structureType == STRUCTURE_LAB)
									&& s.store['energy'] < s.store.getCapacity('energy') * 0.7
					})[0];
					if (nearLabs){
							creep.transfer(nearLabs, 'energy');
					}
			}
			function findNextNode(){
					//find closest to start node (spawn.x,spawn.y-2)
					let spawn = Game.spawns[room.memory.spawn];
					let startPos;
					if (!spawn && room.storage){
							startPos = new RoomPosition(room.storage.pos.x, room.storage.pos.y + 1, room.name);
					} else if (room.memory.storageWithdawPos){
							startPos = room.memory.storageWithdawPos.toPos();
					} else if (spawn){
							startPos = spawn.room.getPositionAt(spawn.pos.x, spawn.pos.y - 2);
					}
					if (startPos){
							if (room.memory.fixedBaseOrigin){
									startPos = room.memory.fixedBaseOrigin.toPos();
							}
							let newNode = searchMap(startPos, room, creep);
							if (!newNode){
									delete creep.memory.filling;
									return
							}
							reservations[creep.id] = newNode;
							extPath(newNode);
					}
			}
			function extPath(currentNode){
					if (currentNode && currentNode.roomName){
							new RoomVisual(creep.room.name).line(creep.pos,currentNode);
					} else {
							return
					}
					if (creep.home.memory.smallFixedBase){
							creep.moveTo(currentNode);
							return
					}
					if (creep.memory.extPath && creep.memory.extPath.target && creep.memory.extPath.target == currentNode.toString()){
							creep.pos.highlight('pink');
							creep.say('moveBy');
							let mem = creep.memory.extPath;
							//sPath,startPos,target,options
							let ret = creep.moveUsingSavedPath(mem.path, mem.start.toPos(), currentNode);
							if (ret === 'delete' && creep.blockedByStructure){
									set(creep.home, true);
									console.log(room.name, 'room extension error -> structure in path', room.energyCapacityAvailable, room.energyAvailable);
									creep.wipePath();
									delete creep.memory.extPath;
							} else {
									return true
							}
					}
			}
	}

	function searchMap(start, room, creep, retry, home){
			let cpuStart = Game.cpu.getUsed();
			let ret = _searchMap(start, room, creep, retry, home);
			Memory.stats['extensionsCPU.searchMap'] += Game.cpu.getUsed() - cpuStart;
			Memory.stats['extensionsCPU.searchMapTotal']++;
			return ret
	}

	function _searchMap(start, room, creep, retry, home){
			if (!start){
					console.log('searchMap no start node');
					return
			}
			let homePos;
			if (room.storage){
					homePos = room.getPositionAt(room.storage.pos.x, room.storage.pos.y + 1);
			}
			if (room.memory.storageWithdawPos){
					homePos = room.memory.storageWithdawPos.toPos();
			}
			//breadth first search along map to find a node that is not full and not reserve
			start = start.toString();
			let visited = {};
			let queue = [start];
			let segment = access(room.name);
			if (!segment || !segment.extensionPositions || !segment.extensionMap){
					return false
			}
			let mem = segment.extensionMap;
			let res = false;
			let blocked = false;
			while (queue.length > 0){
					//remove and check the node at the start of the queue
					let currentNode = queue.shift();
					let reserved = isReserved(currentNode, room);
					if (!home && !isFull(currentNode, room) && !reserved){
							//if it is suitable return currentNode
							//work out the path to the node
							let pathToNode = formPathFromMapUsingVisited(start, currentNode, visited, room);
							//save the path to the node to the creeps memory
							if (pathToNode){
									creep.memory.extPath = {path: pathToNode, start: start, target: currentNode};
							} else {
									delete creep.memory.extPath;
							}
							return currentNode.toPos()
					}
					if (home && !reserved){
							if (currentNode.toPos().isEqualTo(homePos)){
									//work out the path to the node
									let pathToNode = formPathFromMapUsingVisited(start, currentNode, visited, room);
									//save the path to the node to the creeps memory
									if (pathToNode){
											creep.memory.extPath = {path: pathToNode, start: start, target: currentNode};
									}
									return currentNode.toPos()
							} else {
									blocked = true;
							}
					}
					if (reserved){
							res = true;
					}
					// otherwise check nearby nodes and add them to the back of the queue
					let nearbyNodes = mem[currentNode];
					//nearby Nodes is obj with nearbyNode:pathToNearbyNode
					for (let i in nearbyNodes){
							if (!visited[i]){
									queue.push(i);
									//save the currentNode to visited so we can build a path to the target
									visited[i] = currentNode;
							}
					}
			}
			let reservations = playerHeap.extenionManager.allReservations[room.name];
			let energyCap = room.energyCapacityAvailable;
			if (room.memory.sourcePositions && room.memory.fixedBaseOrigin){
					//remove the source extensions if fixedBased
					for (let i in room.memory.sourcePositions){
							let sourcePos = room.memory.sourcePositions[i];
							if (sourcePos.e1){
									let pos = sourcePos.e1.toPos();
									if (pos){
											let ext = pos.lookAround(LOOK_STRUCTURES, 0, {filter: (s) => s.structureType === STRUCTURE_EXTENSION})[0];
											if (ext){
													energyCap -= ext.store.getFreeCapacity('energy');
											}
									}
							}
							if (sourcePos.e2){
									let pos = sourcePos.e2.toPos();
									if (pos){
											let ext = pos.lookAround(LOOK_STRUCTURES, 0, {filter: (s) => s.structureType === STRUCTURE_EXTENSION})[0];
											if (ext){
													energyCap -= ext.store.getFreeCapacity('energy');
											}
									}
							}
					}
			}
			if (Object.keys(mem).length < Object.keys(segment.extensionPositions).length ||
					(res == false && room.energyAvailable < energyCap)){
					let message = `${room.name} room ext error, res: ${res},retry: ${retry}, ${reservations},blocked: ${blocked}, ${Game.time}, 
				cap ${energyCap} avail ${room.energyAvailable} time ${Game.time}`;
					console.log(message);
					Memory.error1 = message;
					if (retry){
							console.log('set no extensions', room.hyperlink);
							sourceStructures(room);
							set(room, true);
					} else {
							if (playerHeap.extenionManager.allRooms[room.name]){
									delete playerHeap.extenionManager.allRooms[room.name];
							}
							playerHeap.extenionManager.allReservations[room.name] = {};
							searchMap(start, room, creep, true);
					}
			}

	}

	function formPathFromMapUsingVisited(start, end, visited, room){
			let cpuStart = Game.cpu.getUsed();
			let ret = _formPathFromMapUsingVisited(start, end, visited, room);
			Memory.stats['extensionsCPU.formPath'] += Game.cpu.getUsed() - cpuStart;
			Memory.stats['extensionsCPU.formPathTotal']++;
			return ret
	}

	function _formPathFromMapUsingVisited(start, end, visited, room){
			//this cuts on doing a search as we have already done one earlier, if you have not done a search use the other function
			let segment = access(room.name);
			if (!segment || !segment.extensionMap || start == end){
					return false
			}
			//array of nodes visited -> IN REVERSE ORDER starting with end
			let arr = [];
			let concat = '';
			//visited[end] will contain node prior to end -> keep working back until visited[x] = true as that is the start
			let currentNode = end;
			let count = 50;
			while ((visited[currentNode] !== start) && count > 0){
					arr.push(currentNode);
					currentNode = visited[currentNode];
					count--;
			}
			arr.push(currentNode);
			arr.push(start);
			while (arr.length > 1){
					let lastItem = arr.pop();
					let serial = segment.extensionMap[lastItem][arr[arr.length - 1]];
					if (serial){
							concat = concat.concat(serial);
					} else {
							console.log('no ext map',room);
						return false
					}
			}
			//see if we can use moveUsingSavedPath with concat as the sPath
			//start,path,count
			if (start.toPos()){
					return concat
			}
	}

	function isFull(node, room){
			if (!playerHeap.extenionManager.allRooms[room.name]){
					playerHeap.extenionManager.allRooms[room.name] = {
							energy: room.energyAvailable,
							full: {}
					};
			} else {
					if (room.energyAvailable < playerHeap.extenionManager.allRooms[room.name].energy){
							playerHeap.extenionManager.allRooms[room.name].full = {};
					}
					playerHeap.extenionManager.allRooms[room.name].energy = room.energyAvailable;
			}
			let segment = access(room.name);
			if (!segment || !segment.extensionPositions || !segment.extensionMap){
					return false
			}
			//node should be a string
			//check the extensions connected to a node to see if any need filling
			let mem = segment.extensionPositions;
			let extsAtNode = mem[node];
			let ret = true;
			if (extsAtNode){
					//check if node full in cache
					if (playerHeap.extenionManager.allRooms[room.name].full[node]){
							new RoomVisual(room.name).circle(node.toPos(), {fill: 'orange', radius: 0.7});
							return true
					}
					//extsAtNode should be a list of extension ids at a node
					for (let i in extsAtNode){
							let ext = Game.getObjectById(extsAtNode[i]);
							if (ext){
									if (ext.store['energy'] < ext.store.getCapacity('energy')){
											new RoomVisual(ext.room.name).circle(ext.pos, {fill: 'red', radius: 0.5});
											new RoomVisual(ext.room.name).line(ext.pos, node.toPos());
											ret = false;
											break
									} else {
											new RoomVisual(ext.room.name).circle(ext.pos, {fill: 'green', radius: 0.5});
									}
							}
					}
					if (ret == true){
							playerHeap.extenionManager.allRooms[room.name].full[node] = true;
					}
			}
			return ret
	}

	function fillNode(creep, node){
			creep.pos.highlight('gray');
			let segment = access(creep.home.name);
			if (!segment || !segment.extensionPositions || !segment.extensionMap){
					creep.say('no ext');
					if (Game.cpu.bucket > 1000 && Game.time % 25 === 0){
							set(creep.home);
					}
					return false
			}
			//node should be a string
			//check the extensions connected to a node to see if any need filling
			let mem = segment.extensionPositions;
			let extsAtNode = mem[node];
			if (extsAtNode){
					//extsAtNode should be a list of extension ids at a node
					for (let i in extsAtNode){
							let ext = Game.getObjectById(extsAtNode[i]);
							if (ext){
									if (ext.store['energy'] < ext.store.getCapacity('energy')){
											creep.transfer(ext, 'energy');
											break
									}
							}
					}
			}
	}

	function isReserved(node, room){
			//node is a string
			let ret = false;
			let reservations = playerHeap.extenionManager.allReservations[room.name];
			//loop through reservations to check if current node is reserved
			for (let i in reservations){
					if (reservations[i] && reservations[i].toString() === node){
							ret = true;
							break
					}
			}
			return ret
	}

	function run$J(creep){
		if (!creep.memory.pullee){
			delete creep.memory.lastPulled;
			if (!creep.home.memory.pullers){
				creep.home.memory.pullers = [];
			}
			if (!creep.home.memory.pullers.includes(creep.id)){
				creep.home.memory.pullers.push(creep.id);
			}
			creep.rally(1);
		} else {
			let pullee = creep.memory.pullee;
			if (pullee && (!Game.getObjectById(pullee) || !Game.getObjectById(pullee).memory.puller)){
				delete creep.memory.pullee;
				return
			}
			if (creep.memory.lastPulled && Game.time > creep.memory.lastPulled + 5){
				if (pullee && Game.getObjectById(pullee)){
					Game.getObjectById(pullee).dismissPuller();
				} else {
					delete creep.memory.pullee;
				}
			}
		}
	}



	let spawnCode$n = {
		priority: (room, countFunction) => {
			let priority = 10;
			if (countFunction('puller', room) < 1 && countFunction('miner1', room) > 0){
				priority = 2;
			} else {
				priority += countFunction('puller', room);
			}
			return priority
		},
		isRequired: (room, countFunction) => {
				//have change to spawn on demand
				return false
		},
		spawn: (room, role, body) => {
			//decide if we need any other options
			if (body){
				//options -> TTL, creepnumber
				room.spawnCreep(role, body);
			}
		},
		body: (room, countFunction) => {
			if (room.memory.roadsDown === undefined){
				room.memory.roadsDown = false;
			}
			let bodyObject = {
				body: [],
				cost: 0
			};
			//decide on what body to have
			if (countFunction('scoreMiners', room) > 0 && countFunction('harvester', room) > 0){
				bodyObject.body = room.makeBody([MOVE], false, {maxParts: 25});
			} else {
				let numberParts = (room.energyCapacityAvailable / 50);
				if (countFunction('harvester', room) == 0){
					numberParts = (room.energyAvailable / 50);
				}
				if (numberParts > 10){
					numberParts = 10;
				}
				bodyObject.body = room.makeBody([MOVE], false, {maxParts: numberParts});
			}
			if (room.controller.level == 1){
				bodyObject.body = [MOVE];
			}

			if (bodyObject.body && bodyObject.body.length > 0){
				bodyObject.cost += Game.getBodyCost(bodyObject.body);
			}
			return bodyObject
		}
	};

	var puller = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$J,
		spawnCode: spawnCode$n
	});

	function run$I(creep){
			let spots = creep.home.memory.staticFillerSpots;
			let spot;
			let index = Number.parseInt(creep.num)-1;
			if (spots && spots[index]){
					spot = spots[index].toPos();
			}
			let action = false;
			if (spot && creep.home.memory.staticFillerContainer){
					let full = false;
					if ((creep.memory.inPos && Game.time % 5 !== 0 && creep.home.controller.level < 7) || creep.pos.isEqualTo(spot)){
							creep.memory.inPos = true;
							let fill = staticFill(creep);
							if (fill && fill === 'full'){
									creep.say('full');
									full = true;
							} else {
									action = true;
							}
					} else {
							delete creep.memory.inPos;
							creep.moveTo(spot,{range:0});
					}
					let cont = Game.getObjectById(creep.home.memory.staticFillerContainer);
					let tower;
					if (creep.home.memory.staticFillerTower){
							tower = Game.getObjectById(creep.home.memory.staticFillerTower);
					}
					if (full && creep.store['energy'] > 50 && creep.num < 3){
							let target = cont;
							let amount = creep.store.getCapacity()-EXTENSION_ENERGY_CAPACITY[creep.home.controller.level];
							if (creep.num === 2){
									if (tower){
											target = tower;
									} else {
											target = undefined;
									}
							}
							if (target && target.store.getFreeCapacity('energy')<amount){
									amount = target.store.getFreeCapacity('energy');
							}
							if (creep.store['energy'] < amount || amount < 50){
									amount = creep.store['energy'];
							}
							if (target && target.store.getFreeCapacity('energy') >= amount){
									creep.transfer(target,'energy',amount);
									action = true;
							}
					}
					if (creep.num === 1 && (!full || creep.store.getFreeCapacity() > 0) && creep.home.memory.storeCont){
							let storeCont = Game.getObjectById(creep.home.memory.storeCont);
							if (storeCont){
									let drop = storeCont.pos.lookAround(LOOK_ENERGY,0)[0];
									if (drop && drop.amount > 50){
											let ret = creep.pickup(drop);
											if (ret === 0){
													return
											}
									}
							}
							if (storeCont && storeCont.store['energy']){
									if (creep.store.getUsedCapacity() === 0 && storeCont.store['energy']>= 300);
									let ret = creep.withdraw(storeCont,'energy');
									creep.say(ret);
									if (ret === -9 && creep.pos.isEqualTo(spot) && creep.home.memory.storeContPosition){
											let savedStoreContPosition = creep.home.memory.storeContPosition.toPos();
											let actualPos;
											let room = creep.home;
											if (room.memory.fixedBaseOrigin){
													actualPos = room.memory.fixedBaseOrigin.toPos();
													if (room.memory.staticFillerSpots){
															actualPos = findRelativePosition(actualPos,1,1,room.memory.fixedBaseDir);
													}
													if (!actualPos.isEqualTo(savedStoreContPosition)){
															delete creep.home.memory.storeContPosition;
															storeCont.destroy();
															console.log(`announcement|${Game.shard.name}|deleting storeCont ${creep.home.name}`);
													}
											}
									}
									return
							}
					}
					if (creep.num === 4 && (!full || creep.store.getFreeCapacity() > 0)){
							//withdraw from tower
							if (tower && tower.store['energy'] > 400){
									let amount = EXTENSION_ENERGY_CAPACITY[creep.home.controller.level];
									if (creep.store.getUsedCapacity() === 0 || full){
											amount = 300;
									}
									if (amount > creep.store.getCapacity()){
											amount = 50;
									}
									creep.withdraw(tower,'energy',amount);
							}
							return
					}
					if (cont && cont.store['energy'] && (((creep.num !== 1|| !creep.home.memory.storeCont) && creep.store.getFreeCapacity() > 0) || !full)){
							EXTENSION_ENERGY_CAPACITY[creep.home.controller.level];
							if ((creep.store.getUsedCapacity() === 0 || full) && creep.num !== 1);
							creep.withdraw(cont,'energy');
							action = true;
					}
					if (!action && creep.home.controller.level > 6){
							creep.startNap(3);
					}
			}
	}
	function staticFillingIsOn(room){
			if (room.memory.fixedBaseOrigin && room.memory.staticFillerSpots && room.energyCapacityAvailable > 450){
					return true
			}
	}

	let spawnCode$m = {
			priority: (room, countFunction) => {
					let priority = 3;
					let harvCount =  countFunction('harvester', room);
					if (harvCount > 0){
							priority = 2;
					}
					return priority
			},
			isRequired: (room, countFunction) => {
					//harvbod is the total number of parts we want spawned
					let numberRequired = 0;
					let count = countFunction('staticFiller', room);
					if (staticFillingIsOn(room) && room.memory.staticFillerContainer &&
							Game.getObjectById(room.memory.staticFillerContainer)){
							numberRequired = room.memory.staticFillerSpots.length;
					}
					if (room.findStructures('tower',(s)=>s.my).length === 0 || room.energyCapacityAvailable < 850){
							numberRequired--;
					}
					return count < numberRequired;
			},
			spawn: (room, role, body) => {
					//decide if we need any other options
					if (body){
							//options -> TTL, creepnumber
							room.spawnCreep(role, body);
					}
			},
			body: (room, countFunction) => {
					if (room.memory.roadsDown === undefined){
							room.memory.roadsDown = false;
					}
					let bodyObject = {
							body: [],
							cost: 0
					};
					let size = ((EXTENSION_ENERGY_CAPACITY[room.controller.level]/50)*2)+1;
					if (countFunction('staticFiller',room) === 0){
							size += 5;
					} else if (countFunction('staticFiller',room) < 2){
							size += 3;
					}
					let body = room.makeBody([CARRY],false,{oneMove:true,maxParts:size});
					bodyObject.body = body;
					if (bodyObject.body && bodyObject.body.length > 0){
							bodyObject.cost += Game.getBodyCost(bodyObject.body);
					}
					return bodyObject
			}
	};

	var staticFiller = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$I,
		staticFillingIsOn: staticFillingIsOn,
		spawnCode: spawnCode$m
	});

	function run$H(creep){
			var homeRoom = Game.rooms[creep.name.split(' ')[2]];
			var homeRoomName = homeRoom.name;
			creep.room.name;
			var num = creep.name.split(' ')[1];
			new RoomVisual(creep.room.name).text('H', creep.pos);
			if (!creep.memory.stopwithdrawing || Game.time % 20 === 0 || creep.home.energyAvailable < creep.home.energyCapacityAvailable){
					creep.memory.stopwithdrawing = false;
			}
			if (Game.time % 100 == 0 && creep.memory.role === 'harvester'){
					delete creep.memory.role;
					return
			}
			if (creep.memory.pullee && creep.home.controller.level === 1){
					run$J(creep);
					return
			}
			if (creep.home.memory.armedHostiles && creep.home.energyCapacity > 500 && (creep.memory.renewing || creep.ticksToLive < 300)){
					let ret = creep.renew();
					if (ret){
							return;
					}
			}
			if (creep.memory.filling){
					if (!creep.memory.currentPos){
							creep.memory.currentPos = creep.pos.toString();
					}
					if (creep.memory.currentPos === creep.pos.toString()){
							if (!creep.memory.still){
									creep.memory.still = 1;
							} else {
									creep.memory.still++;
							}
							if (creep.memory.still > 9){
									for (let i in creep.memory){
											delete creep.memory[i];
									}
									let rand = Math.ceil(Math.random() * 8);
									creep.move(rand);
							}
					} else {
							creep.memory.still = 1;
							creep.memory.currentPos = creep.pos.toString();
					}
					creep.pos.highlight('blue');
					if (creep.home.memory.staticFillerContainer){
							let staticCont = Game.getObjectById(creep.home.memory.staticFillerContainer);
							if (staticCont && (creep.num % 2 === 0 || staticCont.store['energy'] === 0) && creep.store['energy'] > 0 && staticCont && staticCont.store['energy']<500){
									creep.goAndTransfer(staticCont,'energy',1);
									return
							}
							if (staticCont && creep.pos.isEqualTo(staticCont.pos) && staticCont.store['energy']<500){
									creep.drop('energy');
							}
					}
					if (!creep.home.storage && (creep.num > 1 || !creep.home.memory.storageWithdawPos || creep.room.controller.level < 3 ||
							!creep.home.memory.storeCont || !Game.getObjectById(creep.home.memory.storeCont))){
							if (creep.store['energy'] > 0 && creep.room.name == creep.home.name && !creep.pos.onEdge()){
									basicFill();
							} else if (creep.room.name !== creep.home.name || creep.pos.onEdge()){
									creep.moveTo(creep.home.controller, {range: 1});
							} else {
									delete creep.memory.filling;
							}
							return
					} else if (creep.home.class === 'bunker'){
							basicFill();
							return;
					}
					function basicFill(){
							let ext = creep.pos.findClosestByRange(FIND_STRUCTURES, {filter: (s) => ((s.structureType == STRUCTURE_SPAWN && (creep.room.class === 'normal' ||
													(!creep.room.roleList || !creep.room.roleList['transfer']
															|| (creep.home.memory.bunkerOrigin && creep.home.memory.bunkerOrigin.toPos() && !s.pos.isNearTo(creep.home.memory.bunkerOrigin.toPos())))))
											|| s.structureType == STRUCTURE_EXTENSION) && s.store['energy'] < s.store.getCapacity('energy')});
							if (ext){
									if (creep.transfer(ext, 'energy') == -9){
											creep.moveTo(ext, {range: 1, maxRooms: 1});
									}
							} else {
									let spawn = creep.pos.findClosestByRange(FIND_STRUCTURES, {filter: (s) => (s.structureType == STRUCTURE_SPAWN && s.store['energy'] < s.store.getCapacity('energy'))});
									if (spawn){
											creep.goAndTransfer(spawn,'energy');
									} else {
											delete creep.memory.filling;
									}
							}
					}
					if (!Memory.profile){
							Memory.profile = {};
					}
					let a = Game.cpu.getUsed();
					fillExtensions(creep);
					if (Memory.profile && !Memory.profile.fillExt){
							Memory.profile.fillExt = {cpu: 0, count: 0};
					} else {
							Memory.profile.fillExt.cpu += Game.cpu.getUsed() - a;
							Memory.profile.fillExt.count++;
					}
					return
			}
			if (creep.memory.dropping && creep.store['energy'] == 0){
					creep.memory.dropping = false;
					creep.say('collecting');
			}
			if (!creep.memory.dropping && creep.store['energy'] == creep.store.getCapacity()){
					creep.memory.dropping = true;
					creep.say('dropping');
			}
			var homeflag = Game.flags['RP' + homeRoomName];
			/*if (spawn.room.memory.hostiles) {
					var safe = []

					var visited = Memory.visited[spawn.room]
					if (visited){
					safeloop:
					for (i = 0; i < (Math.floor(visited.length)); i += 2) {
							if (creep.pos.x== visited[i] && creep.pos.y== visited[i+1]){
									var creepsafe = true
									 break safeloop
							}}
							if (!creepsafe || creepsafe != true) {
											creep.memory.retreat = true
									}

					}
			}
			else if (!spawn.room.memory.hostiles || Game.time % 50 == 0) {
					creep.memory.retreat = null
			}*/

			if (creep.memory.retreat == true){
					if (creep.fatigue == 0){
							creep.moveTo(homeflag);
					}
			} else {
					if (creep.memory.dropping){
							Game.cpu.getUsed();
							let tower = Game.getObjectById(homeRoom.memory.towers);
							let stores = Game.getObjectById(homeRoom.memory.stores);
							let limit,powerspawn,lab;
							if (homeRoom.memory.reserve){
									limit = homeRoom.memory.reserve;
							} else {
									limit = 30000;
							}
							Game.getObjectById(homeRoom.memory.terminal);
							if (num == 2){
									lab = Game.getObjectById(homeRoom.memory.lab);
									powerspawn = Game.getObjectById(homeRoom.memory.powerspawn);
							}
							let nuker = Game.getObjectById(homeRoom.memory.nuker);
							if (!stores && homeRoom.memory.storeCont){
									stores = Game.getObjectById(homeRoom.memory.storeCont);
							}
							if ((num == 2 || (num == 3 && homeRoom.memory.hostiles) || countRole('harvester',creep.home) === 1) && tower != null && tower.store['energy'] < 700){
									creep.memory.stopwithdrawing = false;
									creep.goAndTransfer(tower, 'energy');
							} else if (powerspawn && Memory.priority && Memory.priority !== "power" && num == 2
									&& creep.home.memory.canLoadPowerSpawn &&
									stores && stores.store[RESOURCE_ENERGY] > limit && homeRoom.memory.walls && homeRoom.memory.walls > 10000000 && powerspawn.store['energy'] < powerspawn.store.getCapacity('energy') * 0.9){
									creep.memory.stopwithdrawing = false;
									creep.goAndTransfer(powerspawn, 'energy');
							} else if (creep.home.energyAvailable < creep.home.energyCapacityAvailable && (!creep.home.memory.operator || (creep.home.memory.operator.split('-')[0] && creep.home.memory.operator.split('-')[0] != 'eco')
									|| (!Game.getObjectById(creep.home.memory.operator)) || creep.home.controller.level < 8 || creep.home.memory.hostiles)){
									creep.say('now filling');
									creep.memory.filling = true;
									delete creep.memory.dropping;
							} else if (creep.home.energyAvailable < creep.home.energyCapacityAvailable * 0.3 &&
									creep.home.memory.operator && Game.getObjectById(creep.home.memory.operator) &&
									((Game.getObjectById(creep.home.memory.operator).store['ops'] < 2)
											&& Game.getObjectById(creep.home.memory.operator).room.name == creep.home.name)){
									creep.memory.filling = true;
									delete creep.memory.dropping;
							} else if (tower != null && tower.store['energy'] < 700){
									creep.memory.stopwithdrawing = false;
									creep.goAndTransfer(tower, 'energy');
							} else if (lab && stores && creep.home.energyAvailable === creep.home.energyCapacityAvailable && (stores.store[RESOURCE_ENERGY] > limit + 2000 || homeRoom.memory.activeSiege)){
									creep.memory.stopwithdrawing = false;
									creep.goAndTransfer(lab, 'energy');
							} else if (powerspawn && powerspawn.store['energy'] < powerspawn.store.getCapacity('energy') * 0.6 && stores && creep.home.energyAvailable === creep.home.energyCapacityAvailable && homeRoom.memory.walls && homeRoom.memory.walls > 10000000 && creep.home.memory.canLoadPowerSpawn
									&& (stores.store[RESOURCE_ENERGY] > limit * 1.3 || (Memory.energyNeeded && Memory.energyNeeded.length == 0 && stores.store[RESOURCE_ENERGY] > limit) || (Memory.priority && Memory.priority == "power" && stores.store[RESOURCE_ENERGY] > limit))){
									creep.memory.stopwithdrawing = false;
									creep.goAndTransfer(powerspawn, 'energy');
							} else if (nuker && nuker.store['energy'] < nuker.store.getCapacity('energy') && stores && creep.home.energyAvailable === creep.home.energyCapacityAvailable && (stores.store[RESOURCE_ENERGY] > limit * 1.2 || (Memory.energyNeeded && Memory.energyNeeded.length == 0 && stores.store[RESOURCE_ENERGY] > limit))){
									creep.memory.stopwithdrawing = false;
									creep.goAndTransfer(nuker, 'energy');
							} else if (stores != null && stores.store['energy'] < limit && !stores.ticksToDecay){
									creep.memory.stopwithdrawing = true;
									creep.goAndTransfer(stores, 'energy');
							} else {
									if (creep.store['energy'] == 0){
											delete creep.memory.dropping;
									} else {
											let origin = creep.home.memory.fixedBaseOrigin;
											if (origin){
													origin = origin.toPos();
											}
											if (creep.home.storage){
													if (!creep.pos.inRangeTo(creep.home.storage, 2)){
															creep.moveTo(creep.home.storage, {range: 2});
													} else {
															creep.startNap(3);
													}
											} else if (origin){
													 creep.rally(3,5);
											}
									}
							}

					} else {
							let mainStorage = homeRoom.storage;
							let originDrop;
							let blockPickUp;
							if (!mainStorage && homeRoom.memory.storeCont){
									let sc = Game.getObjectById(homeRoom.memory.storeCont);
									if (sc && sc.store['energy'] > 0){
											mainStorage = sc;
									}
									if (countRole('upHauler',creep.home)>1 && countRole('harvester',creep.home)>1 && sc && creep.num === 1){
											//let uphauler go to the source
											blockPickUp = true;
									}
							}
							if (homeRoom.memory.fixedBaseOrigin){
									let originPos = homeRoom.memory.fixedBaseOrigin.toPos();
									if (originPos){
											originDrop = originPos.lookAround(LOOK_RESOURCES, 0,
													{filter: (r) => r.resourceType == 'energy' && r.amount > 0})[0];
									}
							}
							if (mainStorage && mainStorage.store['energy'] == 0 && homeRoom.terminal){
									mainStorage = homeRoom.terminal;
							} else if (mainStorage && mainStorage.store['energy'] == 0){
									mainStorage = null;
							}
							if (mainStorage && !mainStorage.my &&
									creep.home.energyAvailable < creep.home.energyCapacityAvailable){
									if (creep.withdraw(mainStorage, RESOURCE_ENERGY) == ERR_NOT_IN_RANGE){
											creep.moveTo(mainStorage, {range: 1, maxRooms: 1});
									} else if (creep.withdraw(mainStorage, 'energy') == -6 && mainStorage.my == false){
											mainStorage.destroy();
									}
							} else if (mainStorage && mainStorage.store[RESOURCE_ENERGY] > 0 && (creep.memory.stopwithdrawing == false)){
									creep.goAndWithdraw(mainStorage, RESOURCE_ENERGY);
							} else if (originDrop){
									creep.goAndPickup(originDrop);
							} else if (blockPickUp){
									if (creep.store.getUsedCapacity() > 0){
											creep.memory.dropping = true;
									}
									let origin = creep.home.memory.fixedBaseOrigin;
									if (origin){
											origin = origin.toPos();
									}
									if (creep.home.storage){
											if (!creep.pos.inRangeTo(creep.home.storage, 2)){
													creep.moveTo(creep.home.storage, {range: 2});
											}
									} else if (origin){
											if (!creep.pos.inRangeTo(origin, 2)){
													creep.moveTo(origin, {range: 2});
											}
									}
							} else if (!creep.home.storage || creep.home.total('energy') < 500){
									let ret = creep.findEnergyTarget();
									if (ret === false){
											if (creep.home.controller.level === 1 && creep.home.civList && creep.home.civList.length < 5){
													run$J(creep);
													return
											}
									}
							} else if (creep.store['energy'] > 0){
									creep.memory.dropping = true;
							} else {
									if (creep.num > 3){
											creep.rally(1,2);
									} else if (Game.cpu.bucket < 9000){
											creep.startNap(3);
									}
							}
					}
			}
	}

	let bodyCache = {
			//cache body so we don't duplicate body calc for similar rooms
	};
	let spawnCode$l = {
			priority: (room, countFunction) => {
					if (room.storage && room.storage['energy'] > 0){
							priority = 1;
					}
					let priority = 3;
					let count = countFunction('harvester', room);
					if (room.controller.level > 3 || count > 3){
							priority += count * 2;
					}
					return priority
			},
			isRequired: (room, countFunction) => {
					//harvbod is the total number of parts we want spawned
					let harvBodyNeeded = 12;
					if (room.controller.level > 7){
							harvBodyNeeded = 48;
					} else if (room.controller.level > 6){
							harvBodyNeeded = 24;
					} else if (!room.storage && !room.memory.storeCont && !room.memory.brigade){
							harvBodyNeeded = 48;
					}
					if (staticFillingIsOn(room) && countFunction('staticFiller',room) > 0){
							harvBodyNeeded = Math.round(harvBodyNeeded/3);
					}
					if (!room.memory.roadsDown || (room.memory.smallFixedBase && room.controller.level > 5)){
							harvBodyNeeded = harvBodyNeeded * 1.5;
					}
					if ((room.memory.activeSiege && !room.memory.fixedBaseOrigin) || config.multipleHarvesters ||
							(Game.cpu.bucket > 9000 && room.controller.level < 6)
							|| (room.energyAvailable < room.energyCapacityAvailable * 0.3 &&
									(!config.official ||room.energyAvailable < room.energyCapacityAvailable*0.1))){
							harvBodyNeeded = harvBodyNeeded * 1.5;
					}
					let body = spawnCode$l.body(room, countFunction).body;
					let numberRequired = Game.bodySizeToNumberNeeded(harvBodyNeeded, body);
					let max = 10;
					if (room.controller.level > 2){
							max = 5;
					} else if (room.controller.level === 2){
							max = 7;
					}
					if (numberRequired > max){
							numberRequired = max;
					}
					if (numberRequired < 2 && countFunction('harvester', room) === 1 && room.creepList){
							let harvester = room.creepList.find((c) => c.role === 'harvester');
							if (harvester && harvester.body.length < harvBodyNeeded){
									numberRequired++;
							}
					}
					if (room.nukeTime && body && room.nukeTime < body.length * 3){
							numberRequired += 2;
					}
					if (config.multipleHarvesters && numberRequired === 1){
							numberRequired = 2;
					}
					let count = countFunction('harvester', room);
					if (Game.cpu.bucket > 6000 && room.controller.level < 6){
							let newCount = countRoleAdjustingForParts('harvester',room,spawnCode$l.body(room,countFunction));
							if (newCount !== undefined){
									//console.log('harvester',count,newCount)
									count = newCount;
							}
					}
					if (room.class === 'bunker' && (room.controller.safeMode || !room.memory.armedHostiles)){
							numberRequired = 2;
					} else if (room.class === 'bunker'){
							return false
					}
					if (room.memory.smallFixedBase && numberRequired < 2){
							numberRequired = 2;
					}
					if (room.controller.level > 7 && numberRequired > 2){
							//console.log('high harv count',room.name,numberRequired,harvBodyNeeded)
							numberRequired = 2;
					}
					if (room.memory.activeSiege && room.controller.level > 7 && !room.memory.fixedBaseOrigin && numberRequired < 2){
							numberRequired = 2;
					}
					if (numberRequired < 1){
							numberRequired = 1;
					}
					return count < numberRequired;
			},
			spawn: (room, role, body) => {
					//decide if we need any other options
					if (body){
							//options -> TTL, creepnumber
							room.spawnCreep(role, body);
					}
			},
			body: (room, countFunction) => {
					if (room.memory.roadsDown === undefined){
							room.memory.roadsDown = false;
					}
					let bodyObject = {
							body: [],
							cost: 0
					};
					//decide on what body to have
					let maxParts = 50;
					if (room.controller.level < 7){
							maxParts = 25;
					}
					if (room.storage && (room.memory.fixedBaseOrigin || !config.conserveCpu)){
							//want to make harvesters size of each arm of base
							let carryNeeded = EXTENSION_ENERGY_CAPACITY[room.controller.level] * 8;
							let carryParts = (carryNeeded / 50);
							if (room.memory.roadsDown){
									maxParts = Math.ceil(carryParts * 1.5);
							} else {
									maxParts = carryParts * 2;
							}
					}
					if (staticFillingIsOn(room) && room.controller.level <= 5 && room.controller.level > 2){
							maxParts = 6;
					}
					let harvCount = countFunction('harvester', room);
					let key = `${room.energyCapacityAvailable},${maxParts},${room.controller.level}`;
					if (key && bodyCache[key] && bodyCache[key].expiry > Game.time && harvCount && harvCount > 0){
							return bodyCache[key].bodyObject
					}
					let body = room.makeBody([CARRY], true, {maxParts: maxParts});
					if (!config.conserveCpu && !room.storage && bodyObject.body.length > 4){
							body = room.makeBody([CARRY], true, {maxParts: bodyObject.body.length / 2});
					}
					if (harvCount === 0 && room.creepList){
							let harvester = room.creepList.find((c) => c.role === 'harvester');
							if (!harvester){
									body = room.makeBody([CARRY], true, {maxParts: maxParts, energyAvailable: true});
							}
					}
					if ((room.controller.level === 1) || (room.energyCapacityAvailable === 300 && harvCount === 0)){
							body = [CARRY, MOVE];
					}
					bodyObject.body = body;
					if (bodyObject.body && bodyObject.body.length > 0){
							bodyObject.cost += Game.getBodyCost(bodyObject.body);
					}
					if (key && room.controller.level > 4){
							bodyCache[key] = {
									expiry : Game.time + (3000*room.controller.level),
									bodyObject : bodyObject
							};
					}
					return bodyObject
			}
	};

	var harvester = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$H,
		spawnCode: spawnCode$l
	});

	playerHeap.remoteEnergyCollectionTargetManager = {};
	playerHeap.remoteEnergyCollectionTargetManager.roomCache = {};
	playerHeap.remoteEnergyCollectionTargetManager.reservationsAllRooms = {};
	playerHeap.remoteEnergyCollectionTargetManager.creepReservations = {};

	const cpuThreshold$1 = 2000;
	let lastReset$1 = {};

	//find energy targets within the room and reserve them so there are not two creeps going for the same energy
	function findRemoteEnergyTarget(room, creep){
			if (!room || !room.name || !creep || !creep.name || !room.memory.sourcelist || !room.memory.finalSources){
					console.log('remote energy target manager error');
					return
			}
			if (!playerHeap.remoteEnergyCollectionTargetManager.reservationsAllRooms[room.name]){
					playerHeap.remoteEnergyCollectionTargetManager.reservationsAllRooms[room.name] = {};
			}
			if (!lastReset$1[room.name]){
					lastReset$1[room.name] = Game.time;
			}
			let reservations = playerHeap.remoteEnergyCollectionTargetManager.reservationsAllRooms[room.name];
			if (!lastReset$1[room.name] || (Game.time - lastReset$1[room.name]) > 25){
					for (let i in playerHeap.remoteEnergyCollectionTargetManager.creepReservations){
							if (!Game.getObjectById(i)){
									deleteReservation$2(i, playerHeap.remoteEnergyCollectionTargetManager.creepReservations[i][0]);
							}
					}
					for (let i in reservations){
							if (!Game.getObjectById(i)){
									delete reservations[i];
							}
					}
					lastReset$1[room.name] = Game.time;
			}
			if (playerHeap.remoteEnergyCollectionTargetManager.creepReservations[creep.id]){
					let target = Game.getObjectById(playerHeap.remoteEnergyCollectionTargetManager.creepReservations[creep.id][0]);
					if (target){
							getFromTarget$1(creep, target);
					} else {
							delete playerHeap.remoteEnergyCollectionTargetManager.creepReservations[creep.id];
							return false
					}
					return 'res'
			} else {
					if (!playerHeap.remoteEnergyCollectionTargetManager.roomCache[room.name]
							|| (playerHeap.remoteEnergyCollectionTargetManager.roomCache[room.name].time != Game.time && Game.cpu.bucket > 5000) || (playerHeap.remoteEnergyCollectionTargetManager.roomCache[room.name].time < Game.time-5)){
							let drops = [];
							for (let i in room.memory.finalSources){
									let pos = room.memory.finalSources[i].toPos();
									let distance = room.memory.sourcelist[room.memory.finalSources[i]];
									let energy = pos.lookAround(LOOK_ENERGY,1);
									if (energy && energy.length > 0){
											for (let e in energy){
													let drop = energy[e];
													let amount = drop.amount;
													if (reservations[drop.id]){
															for (let r in reservations[drop.id]){
																	amount -= reservations[drop.id][r];
															}
													}
													if (amount > 0){
															drops.push({drop:drop.id,distance:distance});
													}
											}
									}
							}
							drops.sort((a, b) => a.distance - b.distance);
							playerHeap.remoteEnergyCollectionTargetManager.roomCache[room.name] = {
									drops: drops,
									time: Game.time
							};
					}
					let energyCache = playerHeap.remoteEnergyCollectionTargetManager.roomCache[room.name];
					let targets = [];
					let drops = energyCache.drops;
					for (let i in drops){
							let drop = Game.getObjectById(drops[i].drop);
							if (drop && drop.pos && drop.pos.roomName){
									if (!creep.home.checkRemoteIsAccessible(drop.pos.roomName)){
											continue
									}
							}
							if (drop){
									let amount = drop.amount;
									if (reservations[drop.id]){
											for (let r in reservations[drop.id]){
													amount -= reservations[drop.id][r];
											}
									}
									if (amount > 0){
											targets.push({drop:drop,distance:drops[i].distance});
											if (Game.cpu.bucket < cpuThreshold$1){
													break
											}
									}
							}
					}
					if (targets && targets.length > 0){
							if (creep.memory.lastDropPos && Game.time < creep.memory.lastDropPos.expiry){
									let dropPos = creep.memory.lastDropPos.pos;
									while (targets.length > 0 && targets[0].drop.pos && targets[0].drop.pos.toString() === dropPos){
											targets.shift();
									}
							} else if (creep.memory.lastDropPos){
									delete creep.memory.lastDropPos;
							}
							if (targets[0]){
									placeReservation$2(creep, targets[0].drop);
									getFromTarget$1(creep, targets[0].drop);
									return 'targ'
							}
					} else {
							if (creep.home.memory.lotsOfDroppedEnergy && Game.cpu.bucket > 1000){
									creep.memory.localEnergyPickUp = true;
									return
							}
							if (!creep.home.memory.remoteContainers || !creep.home.memory.remoteContainers.length){
									creep.rally(2,5);
							}
							creep.memory.localEnergyPickUp = true;
					}
			}
	}
	function canCollectDroppedEnergyFromRemotes (room){
			if (room.underHarassment || room.controller.level > 4 ||
					(room.memory.finalSources && room.memory.remoteContainers && room.memory.finalSources.length === room.memory.remoteContainers.length)){
					return false
			}
			return true
	}
	function getFromTarget$1(creep, target){
			if (creep.pos.isNearTo(target)){
					creep.pickup(target);
					deleteReservation$2(creep.id, target.id);
					creep.memory.dropping = true;
			} else {
					//creep.moveTo(target, {range: 1})
					flowPath(creep,target,1,{addToMatrix:true});
			}
	}

	function deleteReservation$2(id, targetID){
			let roomName = playerHeap.remoteEnergyCollectionTargetManager.creepReservations[id][1];
			delete playerHeap.remoteEnergyCollectionTargetManager.creepReservations[id];
			if (roomName){
					let reservations = playerHeap.remoteEnergyCollectionTargetManager.reservationsAllRooms[roomName];
					if (reservations[targetID]){
							delete reservations[targetID][id];
					}
			}
	}

	function placeReservation$2(creep, target){
			playerHeap.remoteEnergyCollectionTargetManager.creepReservations[creep.id] = [target.id, creep.home.name];
			if (target.pos && target.pos.roomName){
					let reservations = playerHeap.remoteEnergyCollectionTargetManager.reservationsAllRooms[creep.home.name];
					if (!reservations[target.id]){
							reservations[target.id] = {};
					}
					reservations[target.id][creep.id] = creep.store.getFreeCapacity();
			}
	}

	const containerCache = {};
	const repairInterval$1 = 5000;
	let noTargetCache = {};
	function run$G(creep){
			if (Game.time % 1500 == 0){
					delete creep.memory.hostile;
			}
			//profileInsert()
			creep.room.name;
			var homeRoom = Game.rooms[creep.name.split(' ')[2]];
			var homeRoomName = homeRoom.name;
			creep.name.split(' ')[1];
			let stores = homeRoom.storage;
			if (creep.memory.dropping && creep.store['energy'] === 0){
					delete creep.memory.dropping;
					delete creep.memory.energyPickUp;
					delete creep.memory.localEnergyPickUp;
					delete creep.memory.fatigue;
					delete creep.memory.upCont;
					delete creep.memory.noRoads;
					delete creep.memory.checkedHomeRoom;
					delete creep.memory.target;
					delete creep.memory.container;
					creep.wipePath();
					creep.say('collecting');
					//profileInsert()
			}
			if (!creep.memory.dropping && creep.store['energy'] == creep.store.getCapacity()){
					creep.memory.dropping = true;
					delete creep.memory.target;
					delete creep.memory.role;
					creep.wipePath();
					creep.say('dropping');
			}
			if (stores && _.sum(stores.store) == stores.store.getCapacity()){
					stores = homeRoom.terminal;
			}
			if (config$1.season && config$1.season === 'thorium' && creep.store['energy']>0 &&
			creep.room.controller && creep.room.controller.my && creep.room.storage && creep.room.class === 'thoriumMine'){
					if (creep.room.controller.level < 6){
							if (creep.pos.isNearTo(creep.room.storage)){
									creep.transfer(creep.room.storage,'energy');
							} else {
									creep.moveTo(creep.room.storage,{range:1,maxRooms:1});
							}
							return
					}
			}
			let pos;
			if (creep.home.memory.homePeripheralDropsCount && creep.home.memory.homePeripheralDropsCount > 1000 && Game.time % 30 === 0 && creep.room.name === creep.home.name && creep.store['energy'] === 0){
					creep.memory.localEnergyPickUp = true;
			}
			if (creep.memory.localEnergyPickUp && creep.store.getUsedCapacity() === 0){
					let ret = creep.findEnergyTarget(creep.home);
					if (ret !== false){
							return
					}
			}
			//profileInsert()
			let checkedDropped = false;
			if (!creep.memory.dropping && canCollectDroppedEnergyFromRemotes(creep.home)){
					if ((!canSpawnReserves(creep.home) || creep.memory.energyPickUp) && creep.store['energy'] === 0){
							creep.memory.energyPickUp = true;
							let ret = findRemoteEnergyTarget(creep.home, creep);
							creep.pos.highlight('purple');
							//profileInsert()
							if (ret){
									return
							} else {
									delete creep.memory.energyPickUp;
									checkedDropped = true;
							}
					} else if (!canSpawnReserves(creep.home)|| creep.memory.energyPickUp){
							creep.memory.dropping = true;
							delete creep.memory.energyPickUp;
					}
			}
			if (!creep.memory.target && !creep.memory.dropping){
					if (creep.name.split(' ')[0] !== 'yak'){
							creep.memory.role === 'recycle';
					}
					if (creep.ticksToLive < 200){
							//todo more expensive - uphaulers costly?
							if (config$1.conserveCpu && creep.store.getUsedCapacity()=== 0){
									creep.suicide();
							}
							let room = creep.home;
							if ((!room.memory.uplink || !Game.getObjectById(room.memory.uplink) || room.memory.lotsOfDroppedEnergy
									|| room.memory.manualLoadUpLink) && (room.storage || room.memory.storeCont)){
									if (config$1.season && config$1.season === 'power'){
											creep.memory.role = 'mover';
											//profileInsert()
											return
									}
									creep.memory.role = 'upHauler';
									//profileInsert()
									return
							} else if (creep.room.name === creep.home.name){
									creep.role = 'recycle';
							}
							if (Game.time % 10 == 0){
									creep.suicide();
							}
					}
					findTarget();
			} else if (!creep.memory.dropping) {
					pos = creep.memory.target.toPos();
			}
			//profileInsert()
			if (!creep.memory.dropping && canCollectDroppedEnergyFromRemotes(creep.home) && !checkedDropped){
					if (!creep.memory.target && creep.store['energy'] === 0){
							let ret = findRemoteEnergyTarget(creep.home,creep);
							//profileInsert()
							if (ret){
									return
							}
					} else if (!creep.memory.dropping && !creep.memory.target){
							creep.memory.dropping = true;
					}
			}

			let homeflag = Game.flags['rally' + homeRoomName];
			if (!homeflag){
					homeflag = creep.home.controller;
			}
			if (!pos && (!config$1.conserveCpu || Game.time % 20 === 0)){
					delete creep.home.memory.checkedHomeRoom;
			}
			//profileInsert()
			if (!creep.memory.checkedHomeRoom){
					if (creep.home.storage && creep.home.controller.level < 7 && creep.home.memory.someDroppedEnergy){
							if (creep.store.getUsedCapacity() > 0){
									creep.goAndTransfer(creep.home.storage, 'energy', 1);
									//profileInsert()
									return
							} else {
									let localEnergy = creep.findEnergyTarget();
									if (!localEnergy){
											creep.memory.checkedHomeRoom = true;
									} else {
											//profileInsert()
											return
									}
							}
					} else {
							creep.memory.checkedHomeRoom = true;
					}
			}
			//profileInsert()
			//new RoomVisual(creep.room.name).text('Y', creep.pos)
			if (!pos && creep.store.getUsedCapacity() === 0){
					//creep.memory.reason = 'redundant'
					//creep.memory.role = 'recycle'
					if (creep.home.controller.level > 7 && config$1.conserveCpu && (config$1.official)){
							creep.startNap(10);
							return
					}
					delete creep.memory.role;
					creep.rally(1,5);
					//profileInsert()
					return
			}
			let hostile;
			if (creep.room.memory.hostiles && creep.room.name != homeRoom.name){
					hostile = Game.getObjectById(creep.room.memory.hostiles);
			}
			if (hostile){
					checkGuardNeeded(creep);
			}
			//profileInsert()
			if (creep.hits < creep.hitsMax){
					if (Game.map.getRoomType(creep.pos.roomName) === 'SK'){
							if (creep.home.memory.yakOutPaths && pos){
									delete creep.home.memory.yakOutPaths[pos.toString()];
									console.log('delete YOP',pos);
							}
							if (creep.home.memory.sourcePaths){
									let container;
									if (creep.memory.container){
											container = Game.getObjectById(creep.memory.container);
									}
									if (container && container.pos){
											delete creep.home.memory.sourcePaths[container.pos.toString()];
											console.log('delete SP',container.pos);
									}

							}
					}
					creep.towerHeal(homeRoom);
					//profileInsert()
			} else if (homeflag && creep.memory.hostile){
					creep.moveTo(homeflag, {range: 3});
					if (creep.pos.inRangeTo(homeflag, 5)){
							creep.memory = {};
					}
					//profileInsert()
			} else if (!creep.memory.hostile){
					if (creep.memory.dropping){
							drop();
							//profileInsert()
					} else {
							collect();
							//profileInsert()
					}
			}
			//profileInsert()
			function drop(){
					let origin;
					if (creep.home.memory.fixedBaseOrigin){
							origin = creep.home.memory.fixedBaseOrigin.toPos();
					}
					if (creep.home.memory.storeCont && Game.getObjectById(creep.home.memory.storeCont)){
							origin = Game.getObjectById(creep.home.memory.storeCont).pos;
					}
					if (!origin && creep.home.memory.storeContPosition){
							origin = creep.home.memory.storeContPosition.toPos();
					}
					if (origin){
							if (creep.home.controller.level < 8 && (Game.cpu.bucket > 7000 || !stores) && !creep.pos.onEdge() && creep.room.name === creep.home.name){
									findEnergyDropTarget(creep.home,creep);
									if (Game.cpu.bucket > 7000 && creep.room.controller.level < 5 && creep.pos.inRangeTo(creep.room.controller,5)){
											let nearUpgraders = creep.pos.lookAround(LOOK_CREEPS, 1, {filter: (c) => c.my && (c.role == 'upgrader' || c.role == 'builder' || c.role == 'harvester') && c.store.getFreeCapacity() >= 50});
											if (nearUpgraders && nearUpgraders[0]){
													creep.transfer(nearUpgraders[0], 'energy');
											}
									}
							} else if (!creep.pos.isEqualTo(origin)){
									if (stores && creep.pos.isNearTo(stores)){
											creep.transfer(stores, 'energy');
									} else {
											let path;
											let container;
											if (creep.memory.container){
													container = Game.getObjectById(creep.memory.container);
											}
											if (container){
													path = loadPath(creep.home, container.pos);
													if (path == null && (Game.time + Number.parseInt(creep.num)) % 10 == 0){
															path = savePath(homeRoom, container.pos, origin);
													}
											}
											if (path && path.sPath){
													let test = creep.moveUsingSavedPath(path.sPath, path.start.toPos(), origin);
													if (test === 'delete'){
															delete creep.home.memory.sourcePaths[container.pos.toString()];
															creep.wipePath();
													}
													if (creep.room.name != creep.home.name && creep.memory.dropping && path.start
															&& (Game.cpu.bucket > 9000 || creep.num < 3)){
															//no filter as if creep is standing on it them it is most likely a road - worth the cpu save
															let road = creep.pos.lookAround(LOOK_STRUCTURES, 0)[0];
															if (!road && creep.pos.isOnPath(path.start.toPos(), path.sPath)){
																	if (!creep.memory.noRoads){
																			creep.memory.noRoads = 1;
																	} else {
																			creep.memory.noRoads++;
																	}
																	if (container && (!creep.home.memory.remoteRep[container.pos.toString()] || !creep.home.memory.remoteRep[container.pos.toString()][1] || creep.home.memory.remoteRep[container.pos.toString()][1] < Game.time)){
																			creep.home.memory.remoteRep[container.pos.toString()] = [1, Game.time + repairInterval$1];
																			//console.log(creep.name,'setting new repairs route')
																	}
																	if (creep.memory.noRoads && creep.memory.noRoads>5){
																			//need some roads built!
																			creep.home.memory.remoteRoadsNeedBuilding = Game.time + 500;
																	}
															}
													}
											} else if (stores){
													creep.say('NP',true);
													creep.moveTo(stores, {range: 1});
											} else {
													creep.moveTo(origin, {range: 0});
											}
									}
							} else {
									if (stores){
											creep.transfer(stores, 'energy');
									} else {
											creep.drop('energy');
									}
							}
					} else if (stores && !creep.pos.isNearTo(stores)){
							let path;
							let container;
							if (creep.memory.container){
									container = Game.getObjectById(creep.memory.container);
							}
							if (container){
									path = loadPath(creep.home, container.pos);
									if (path == null && (Game.time + Number.parseInt(creep.num)) % 10 == 0){
											path = savePath(homeRoom, container.pos);
									}
							}
							let upCont;
							if (creep.home.memory.upCont && creep.home.total('energy') > creep.home.memory.reserve*0.5){
									upCont = Game.getObjectById(creep.home.memory.upCont);
							}
							if (upCont && creep.num % 2 === 0 && (upCont.store['energy'] < 1000 || creep.memory.upCont)){
									creep.memory.upCont = true;
									creep.goAndTransfer(upCont,'energy');
							} else if (path && path.sPath && stores){
									let test = creep.moveUsingSavedPath(path.sPath, path.start.toPos(), stores);
									if (test === 'delete' && container){
											delete creep.home.memory.sourcePaths[container.pos.toString()];
											creep.wipePath();
									}
							} else {
									creep.moveTo(stores, {range: 1});
							}
					} else if (stores){
							creep.transfer(stores,'energy');
					}
			}
			function collect(){
					let dest = pos;
					if (dest && dest.roomName && (creep.room.name != dest.roomName || !creep.pos.isNearTo(dest))){
							let outPath = loadOutPath(creep.home, dest);
							if (!outPath && (Game.time + Number.parseInt(creep.num)) % 10 == 0){
									outPath = saveOutPath(creep.home, dest);
							}
							if (pos && pos.roomName && Game.map.getRoomType(pos.roomName) ==='SK'){
									let needToAvoidSkGuard = avoidSKGuards(creep,pos);
									if (needToAvoidSkGuard){
											return
									}
							}
							if (!config$1.official && Game.cpu.bucket > 9000 && creep.home.memory.remoteRoadsNeedBuilding && Game.time < creep.home.memory.remoteRoadsNeedBuilding){
									//likely building roads - more efficient to custom path
									creep.moveTo(dest, {range: 1});
							} else if (outPath && outPath.sPath){
									let test = creep.moveUsingSavedPath(outPath.sPath, outPath.start.toPos(), dest);
									if (test === 'delete'){
											delete creep.home.memory.yakOutPaths[dest.toString()];
											creep.wipePath();
									}
							} else {
									creep.moveTo(dest, {range: 1});
							}
					} else if (pos){
							let conts;
							if (creep.memory.container){
									conts = Game.getObjectById(creep.memory.container);
							}
							if (Game.map.getRoomType(pos.roomName)=== 'SK'){
									let tomb = pos.lookAround(LOOK_TOMBSTONES,0)[0];
									if (tomb && tomb.store['energy']){
											creep.withdraw(tomb,'energy');
									}
							}
							if (conts && conts.store && conts.structureType === 'container' && conts.store['energy'] > 50){
									if (!creep.pos.isNearTo(conts)){
											creep.moveTo(conts, {range: 1});
									} else {
											creep.remoteWithdraw(conts);
									}
							} else {
									creep.memory.dropping = true;
							}
					}
			}
			function loadPath(room, sourcepos){
					if (!room.memory.sourcePaths){
							room.memory.sourcePaths = {};
					}
					let mem = room.memory.sourcePaths[sourcepos.toString()];
					if (mem && mem.path && mem.expiry > Game.time){
							return mem.path
					} else {
							return null
					}
			}

			function loadOutPath(room, sourcepos){
					if (!room.memory.yakOutPaths){
							room.memory.yakOutPaths = {};
					}
					if (!sourcepos){
							console.log('no sourcepos', creep.name);
							return
					}
					let mem = room.memory.yakOutPaths[sourcepos.toString()];
					if (mem && mem.path && mem.expiry > Game.time){
							return mem.path
					} else {
							return null
					}
			}

			function saveOutPath(room, sourcepos){
					if (creep.room.name != room.name || !sourcepos){
							return
					}
					console.log('finding out path', sourcepos);
					let start;
					if (room.storage){
							start = room.getPositionAt(room.storage.pos.x, room.storage.pos.y + 1);
					} else if (room.memory.storeCont){
							let storeCont = Game.getObjectById(room.memory.storeCont);
							if (storeCont){
									start = storeCont.pos;
							}
					} else if (room.memory.fixedBaseOrigin){
							start = room.memory.fixedBaseOrigin.toPos();
					}
					if (!start){
							return
					}
					if (room.memory.storageWithdawPos){
							room.memory.storageWithdawPos.toPos();
					}
					let needSKmatrix = false;
					//find path if loadPath return null and creep is near container (as this means the path will no be on the unwalkable mining spot)
					let path = PathFinder.search(start, {pos: sourcepos, range: 1}, {
							plainCost: 1,
							swampCost: 1,
							maxOps:20000,
							roomCallback: function (roomName){
									let room = Game.rooms[roomName];
									if (Memory.ownedRooms[roomName]){
											return false
									}
									if (Game.map.isCoreRoom(roomName)){
											return false
									}
									let costs = new PathFinder.CostMatrix;
									if (room && room.memory.upgraderPositions){
											for (let i in room.memory.upgraderPositions){
													let pos = room.memory.upgraderPositions[i].toPos();
													if (pos){
															costs.set(pos.x,pos.y,20);
													}
											}
									}
									if (Game.map.getRoomType(roomName) == 'SK'){
											let newM = Game.map.getSKMatrix(roomName);
											if (!newM){
													needSKmatrix = true;
													return false
											} else {
													costs = PathFinder.mergeMatrix(costs,newM);
													if (!costs){
															return
													}
											}
											//allow near end
											if (roomName === sourcepos.roomName){
													let neighbours = sourcepos.neighbours(6);
													for (let i in neighbours){
															let cost = costs.get(neighbours[i].x,neighbours[i].y);
															if (cost > 20){
																	costs.set(neighbours[i].x,neighbours[i].y,20);
															}
													}
											}
									}
									if (ready() && access(creep.home.name) && access(creep.home.name).roadPositions){
											let positions = access(creep.home.name).roadPositions;
											for (let i in positions){
													let posString = i;
													let positionObj = positions[i];
													let get = costs.get(positionObj.x, positionObj.y);
													if (get > 40){
															continue
													}
													if (posString.includes(roomName)){
															costs.set(positionObj.x, positionObj.y, 3);
													}
											}
											if (!room){
													return costs
											}
									}
									if (!room) return costs;
									room.find(FIND_STRUCTURES).forEach(function (struct){
											if (struct.structureType === STRUCTURE_ROAD){
													// Don't roads over plain tiles
													costs.set(struct.pos.x, struct.pos.y, 2);
											} else if (struct.structureType !== STRUCTURE_RAMPART ||
													!struct.my){
													// Can't walk through non-walkable buildings
													costs.set(struct.pos.x, struct.pos.y, 0xff);
											}
									});
									if (room.memory.fixedBaseOrigin){
											let origin = room.memory.fixedBaseOrigin.toPos();
											if (origin){
													costs.set(origin.x, origin.y, 1);
											}
									}

									room.find(FIND_CONSTRUCTION_SITES).forEach((s) => {
											if (s.my && s.structureType != STRUCTURE_ROAD && s.structureType != STRUCTURE_CONTAINER && s.structureType != STRUCTURE_RAMPART){
													costs.set(s.pos.x, s.pos.y, 0xff);
											}
									});
									room.find(FIND_EXIT).forEach((e) => {
											if (e.oppositeEdge() && (Memory.ownedRooms[e.oppositeEdge().roomName] || Game.map.isCoreRoom(e.oppositeEdge().roomName))){
													costs.set(e.x, e.y, 0xff);
											}
									});
									costs = blockKeyPositions(costs,room);
									return costs;
							},
					});
					if (path.incomplete || needSKmatrix){
							return null
					} else {
							for (let i in path.path){
									path.path[i].highlight('orange');
							}
					}
					//serialize
					let sPath = PathFinder.serializePath(start, path);
					//save, with an expiry in order to ensure fresh paths
					let expiry = 100000;
					if (!config$1.conserveCpu){
							expiry = 10000;
					}
					room.memory.yakOutPaths[sourcepos.toString()] = {
							path: {
									sPath: sPath,
									start: start.toString(),
									end: path.path[path.path.length - 1].toString()
							},
							expiry: Game.time + expiry
					};
					//path obj needs serialized path as well as a start pos and end pos
					//return pathObj
					return room.memory.yakOutPaths[sourcepos.toString()].path
			}

			function findTarget(){
					if (noTargetCache[creep.home.name] && noTargetCache[creep.home.name] > Game.time){
							if (canCollectDroppedEnergyFromRemotes(creep.home)){
									creep.memory.energyPickUp = true;
							}
							return;
					}
					let mem = creep.home.memory.remoteContainers;
					let arr = [];
					if (mem){
							if (!containerCache[creep.home] || Game.time % 100 === 0){
									for (let i in mem){
											arr.push(i);
									}
									arr.sort((a, b) => (mem[a].distance + (2000 - mem[a].freeEnergy)) - (mem[b].distance + (2000 - mem[b].freeEnergy)));
									containerCache[creep.home] = arr;
							} else {
									arr = containerCache[creep.home];
							}
							for (let i in arr){
									//check
									let contMem = mem[arr[i]];
									let trigger = creep.store.getCapacity() / 2;
									if (contMem && (!contMem.distance || creep.ticksToLive > contMem.distance * 3) && contMem.freeEnergy >= trigger){
											//reserve and break
											let cont = Game.getObjectById(arr[i]);
											if (cont && cont.pos && cont.pos.roomName && (cont.pos.roomName === creep.home.name || creep.home.checkRemoteIsAccessible(cont.pos.roomName))){
													creep.remoteReserve(cont);
													creep.say('res');
													return
											}
									}
							}
					}
					creep.say('no target');
					let num = 5;
					if (creep.home.controller.level > 6){
							num += 5;
					}
					if (config$1.conserveCpu){
							num += 10;
					}
					noTargetCache[creep.home.name] = Game.time+num;
					if (canCollectDroppedEnergyFromRemotes(creep.home)){
							creep.memory.energyPickUp = true;
					}
			}
	}

	function savePath(home, sourcepos, origin){
			let dest;
			if (home.storage){
					dest = {pos: home.storage.pos, range: 1};
			}
			if (origin){
					dest = {pos: origin, range: 0};
			}
			if (!dest){
					return
			}
			if (!sourcepos || !Game.rooms[sourcepos.roomName]){
					return
			}
			console.log('finding in path', sourcepos);
			let needSKmatrix = false;
			let noRoads = false;
			if (checkIfNeedToPauseInfrastructureDueToHarassment(home) || !canSpawnReserves(home)){
					noRoads = true;
			}
			//find path if loadPath return null and creep is near container (as this means the path will no be on the unwalkable mining spot)
			let plainCost = 4;
			let swampCost = 5;
			//normally - the benefit of avoiding swamps is negated by the roads, and having shorter distance is more important, a full swamp path would still be profitable up to a distance of 200
			//however investment into the roads is substantial especially if a room is in its infancy
			if (noRoads){
					//less likely to have to eco to support building swamp roads - or we are having our remotes harassed
					plainCost = 2;
					swampCost = 10;
			}
			let path = PathFinder.search(sourcepos, dest, {
					maxOps: 20000,
					plainCost: plainCost,
					swampCost: swampCost,
					roomCallback: function (roomName){
							let room = Game.rooms[roomName];
							if (Memory.ownedRooms[roomName]){
									return
							}
							if (Game.map.isCoreRoom(roomName)){
									return false
							}
							let costs = new PathFinder.CostMatrix;
							if (ready() && access(home.name) && access(home.name).roadPositions){
									let positions = getRoadPositions(home.name,roomName);
									if (positions){
											for (let i in positions){
													let positionObj = positions[i];
													let get = costs.get(positionObj.x, positionObj.y);
													if (get > 40){
															continue
													}
													costs.set(positionObj.x, positionObj.y, 1);
											}
									}
							}

							if (Game.map.getRoomType(roomName) == 'SK'){
									let newM = Game.map.getSKMatrix(roomName);
									if (!newM){
											needSKmatrix = true;
											return false
									} else {
											costs = PathFinder.mergeMatrix(costs,newM);
											if (!costs){
													return
											}
									}
									//allow near end
									if (roomName === sourcepos.roomName){
											let neighbours = sourcepos.neighbours(6);
											for (let i in neighbours){
													let cost = costs.get(neighbours[i].x,neighbours[i].y);
													if (cost > 20 && neighbours[i].getTerrain() !== 'wall'){
															costs.set(neighbours[i].x,neighbours[i].y,20);
													}
											}
									}
							}
							if (!room) return costs;
							if (room.structureMatrix){
									costs = PathFinder.mergeMatrix(costs,room.structureMatrix);
							}
							if (room && room.memory.upgraderPositions){
									for (let i in room.memory.upgraderPositions){
											let pos = room.memory.upgraderPositions[i].toPos();
											if (pos){
													costs.set(pos.x,pos.y,20);
											}
									}
							}
							if (origin){
									costs.set(origin.x, origin.y, 1);
							}
							room.find(FIND_CONSTRUCTION_SITES).forEach((s) => {
									if (s.my && s.structureType != STRUCTURE_ROAD && s.structureType != STRUCTURE_CONTAINER && s.structureType != STRUCTURE_RAMPART){
											costs.set(s.pos.x, s.pos.y, 0xff);
									}
							});
							room.find(FIND_EXIT).forEach((e) => {
									if (e.oppositeEdge() && (Memory.ownedRooms[e.oppositeEdge().roomName]|| Game.map.isCoreRoom(e.oppositeEdge().roomName))){
											costs.set(e.x, e.y, 0xff);
									}
							});
							costs = blockKeyPositions(costs,room);
							if (room.controller && room.controller.my){
									let neighbours = room.controller.pos.neighbours(3);
									for (let i in neighbours){
											let n = neighbours[i];
											let cost = costs.get(n.x, n.y);
											if (cost < 30){
													costs.set(n.x, n.y, 30);
											}
									}
							}

							let sources;
							if (Game.rooms[roomName] && Game.map.getRoomType(roomName) != 'SK'){
									sources = Game.rooms[roomName].find(FIND_SOURCES);
							}
							if (sources && sources.length > 0){
									for (let s in sources){
											let neighbours = sources[s].pos.neighbours(1);
											let neighbours2 = sources[s].pos.neighbours(2);
											for (let n in neighbours){
													let neighbour = neighbours[n];
													if (costs.get(neighbour.x, neighbour.y) < 5 && neighbour.getTerrain() !== 'wall'){
															costs.set(neighbour.x, neighbour.y, 10);
													}
											}
											for (let n in neighbours2){
													let neighbour = neighbours2[n];
													if (costs.get(neighbour.x, neighbour.y) < 5 && neighbour.getTerrain() !== 'wall'){
															costs.set(neighbour.x, neighbour.y, 10);
													}
											}
									}
							}
							if (roomName === 'E27N17'){
									for (let x = 0; x < 50; x++){
											for (let y = 0;y < 50;y++){
													let cost = costs.get(x,y);
													new RoomVisual(room.name).text(cost,x,y);
											}
									}
							}
							return costs;
					},
			});

			//serialize
			if (path.incomplete || needSKmatrix){
					console.log('source path incomplete', JSON.stringify(path));
					return null
			}
			if (path.path){
					let rooms = {};
					for (let i in path.path){
							let pos = path.path[i];
							if (pos){
									pos.highlight('purple');
									if (!rooms[pos.roomName]){
											rooms[pos.roomName] = [];
									}
									rooms[pos.roomName].push(pos);
							}
					}
					if (!noRoads){
							for (let i in rooms){
									setRoadPositions(home.name,i,rooms[i]);
							}
					}
			} else {
					console.log('no road positions');
					return
			}
			let sPath = PathFinder.serializePath(sourcepos, path);
			//save, with an expiry in order to ensure fresh paths
			let expiry = 100000;
			if (!config$1.conserveCpu){
					expiry = 10000;
			}
			home.memory.sourcePaths[sourcepos.toString()] = {
					path: {
							sPath: sPath,
							start: sourcepos.toString(),
							end: path.path[path.path.length - 1].toString(),
							noRoads: noRoads
					},
					expiry: Game.time + expiry
			};
			//path obj needs serialized path as well as a start pos and end pos
			return home.memory.sourcePaths[sourcepos.toString()].path
			//return pathObj
	}

	let spawnCode$k = {
			priority: (room, countFunction) => {
					let priority = 40;
					let mod = 0.5;
					priority += Math.round(countFunction('yak', room)*mod);
					if (room.storage && room.total('energy')>room.memory.reserve*1.5){
							priority+=10;
					} else if (room.controller.level < 4 && room.memory.lotsOfDroppedEnergy){
							priority+=10;
					}
					return priority
			},
			isRequired: (room, countFunction,idleSpawn) => {
					let numberRequired = 0;
					if ((room.memory.armedHostiles && (!room.justInvader || !room.ecoStable)) || room.memory.underHarassment || room.memory.brigade || pauseRemotes(room)){
							return false
					}
					if (room.ecoStable && room.terminal && config$1.official && room.memory.faceClaimed && room.total('energy') > room.memory.reserve * 0.5){
							return false
							//free up spawning for squads
					}
					if (room.memory.totalYakParts && !Game.flags['defend' + room.name] && countFunction('remoteminer', room) > 0 && room.memory.remoteContainers && Object.keys(room.memory.remoteContainers).length > 0){
							numberRequired = Math.ceil(room.memory.totalYakParts/spawnCode$k.body(room,countFunction).body.length);
							numberRequired = Math.ceil(numberRequired*room.memory.remoteAdjust);
							room.memory.yak = numberRequired;
					} else if (room.memory.totalYakParts && countFunction('remoteminer', room) > 0 && room.memory.remoteminer && room.memory.remoteAdjust && !Game.flags['defend' + room.name]){
							let targetMiners = Math.ceil(room.memory.remoteminer * room.memory.remoteAdjust);
							let ratio = countFunction('remoteminer', room)/targetMiners;
							let targetYaks =  Math.ceil(room.memory.totalYakParts/spawnCode$k.body(room,countFunction).body.length);
							numberRequired = Math.round(targetYaks*ratio);
					} else {
							numberRequired = 0;
					}
					if (room.storage && room.total('energy') > room.memory.reserve * 2){
							numberRequired = numberRequired / 2;
					}
					let hardMax = numberRequired * 1.2;
					if (countFunction('yak', room) < hardMax && room.memory.remoteContainers && room.memory.finalSources && (room.controller.level > 4 || room.memory.remoteContainers.length === room.memory.finalSources.length)){
							let lowEnergy = true;
							let highEnergyCount = 0;
							for (let i in room.memory.remoteContainers){
									if (room.memory.remoteContainers[i].freeEnergy >= 1900){
											highEnergyCount++;
									} else if (room.memory.remoteContainers[i].freeEnergy > 1000){
											lowEnergy = false;
									}
							}
							if (highEnergyCount && highEnergyCount > 1 || (numberRequired < 3 && highEnergyCount > 0)){
									return true
							}
							if (lowEnergy){
									return false
									//reduce spawning if there is not much energy to collect
							}
					}
					if (idleSpawn && numberRequired){
							numberRequired = Math.round(numberRequired*1.2);
					}
					let count = countFunction('yak', room);
					if (Game.cpu.bucket > 5000 && room.controller.level < 6){
							let newCount = countRoleAdjustingForParts('yak',room,spawnCode$k.body(room,countFunction),'carry');
							if (newCount !== undefined){
									count = newCount;
							}
					}
					return count < numberRequired;
			},
			spawn: (room, role, body) => {
					//decide if we need any other options
					if (body){
							//options -> TTL, creepnumber
							room.spawnCreep(role, body);
					}
			},
			body: (room, countFunction) => {
					let roadsDown = remoteRoadsPresent(room);
					let pause = checkIfNeedToPauseInfrastructureDueToHarassment(room);
					let key = room.energyCapacityAvailable + ':' + roadsDown+':'+pause;
					if (getCachedBody('yak',key) && Game.time % 500 !== 0){
							return getCachedBody('yak',key)
					}
					let bodyObject = {
							body: [],
							cost: 0
					};
					let toggleRoadsDownCheck = true;
					if (pause){
							toggleRoadsDownCheck = false;
					}
					//decide on what body to have
					bodyObject.body = room.makeBody([CARRY], toggleRoadsDownCheck,{remoteRoads:true});
					let div = 3;
					if (config$1.conserveCpu){
							div = 2;
					}
					let maxSize = (room.energyCapacityAvailable/50)/div;
					if (staticFillingIsOn(room) && countFunction('staticFiller',room)>0){
							let staticFillEnergyCap = 110;
							if (room.energyCapacityAvailable < staticFillEnergyCap){
									staticFillEnergyCap = room.energyCapacityAvailable;
							}
							if (maxSize < staticFillEnergyCap/50){
									maxSize = staticFillEnergyCap/50;
							}
					}
					if (maxSize < 6){
							maxSize = 6;
					}
					if (maxSize > 25 && Game.cpu.bucket > 7000 && (!config$1.official || config$1.conserveCpu)){
							maxSize = 25;
					}
					if (Game.cpu.bucket < 100 || (config$1.conserveCpu && Game.cpu.bucket < 8000)){
							maxSize = (room.energyCapacityAvailable/50)*0.8;
					}
					if (maxSize>50){
							maxSize = 50;
					}
					if (room.energyCapacityAvailable < 1500 && bodyObject.body.length >= maxSize){
							//dont have capacity for reservers so spawn smaller yaks to ensure we are using up spawn time
							bodyObject.body = room.makeBody([CARRY], toggleRoadsDownCheck,{maxParts:maxSize,remoteRoads:true});
					} else if (!config$1.conserveCpu && Game.cpu.bucket >= 7000 && room.controller.level < 7 && bodyObject.body.length >= maxSize){
							bodyObject.body = room.makeBody([CARRY], toggleRoadsDownCheck,{maxParts:maxSize,remoteRoads:true});
					} else if (!config$1.conserveCpu && Game.cpu.bucket >= 3000 && room.controller.level < 7 && bodyObject.body.length >=25){
							let maxLength = 25;
							bodyObject.body = room.makeBody([CARRY], toggleRoadsDownCheck,{maxParts:maxLength,remoteRoads:true});
					} else if (!config$1.conserveCpu && Game.cpu.bucket >= 3000 && bodyObject.body.length >=35){
							let maxLength = 35;
							bodyObject.body = room.makeBody([CARRY], toggleRoadsDownCheck,{maxParts:maxLength,remoteRoads:true});
					}
					if (bodyObject.body && bodyObject.body.length > 0){
							bodyObject.cost += Game.getBodyCost(bodyObject.body);
					}
					cacheBody('yak',key,bodyObject);
					return bodyObject
			}
	};

	var yak = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$G,
		savePath: savePath,
		spawnCode: spawnCode$k
	});

	function runSupportManager(room){
			if (Game.time % 1000 === 0){
					removeDefenceRequest(room.name);
			}
			if (!Memory.myRooms || Memory.myRooms.length === 1){
					return
			}
			if ((!room.memory.supportRooms || Game.time > room.memory.supportRooms.expiry) && (Game.time + room.index) % Memory.myRooms.length === 0){
					room.memory.supportRooms = {
							expiry: Game.time + 5000,
							rooms: {}
					};
					let roomFound = false;
					for (let i in Memory.myRooms){
							let range = Game.map.getRoomLinearDistance(room.name, Memory.myRooms[i]);
							if (range <= 15 && Game.rooms[Memory.myRooms[i]] && Game.rooms[Memory.myRooms[i]].class == 'normal'){
									let actualRange = 20;
									let route = Game.map.findRoute(room.name, Memory.myRooms[i]);
									if (route && route !== -2 && route.length > 0){
											actualRange = route.length;
									}
									if (actualRange <= 15){
											roomFound = true;
											room.memory.supportRooms.rooms[Memory.myRooms[i]] = actualRange;
									}
							}
					}
					if (!roomFound){
							let bestRange, best;
							for (let i in Memory.myRooms){
									let range = Game.map.getRoomLinearDistance(room.name, Memory.myRooms[i]);
									if (range <= 20 && Game.rooms[Memory.myRooms[i]] && Game.rooms[Memory.myRooms[i]].class == 'normal' &&
											Game.rooms[Memory.myRooms[i]].controller.level > 3 && (!bestRange || range < bestRange)){
											bestRange = range;
											best = Memory.myRooms[i];
									}
							}
							if (best){
									room.memory.supportRooms.rooms[best] = bestRange;
							}
					}
			}
			if (room.memory.supportRooms && room.memory.supportRooms.rooms && ((room.memory.spawnPos && room.memory.spawnPos.toPos()) || room.memory.fixedBaseOrigin || room.storage) && ((Game.time + room.index) % Memory.myRooms.length === 0) || room.controller.level < 3){
					let spawnPos, storePos;
					if (room.storage && room.storage.my){
							storePos = room.storage.pos;
					} else if (room.memory.fixedBaseOrigin && room.memory.fixedBaseOrigin.toPos()){
							storePos = room.memory.fixedBaseOrigin.toPos();
					} else if (room.memory.spawnPos){
							spawnPos = room.memory.spawnPos.toPos();
							storePos = room.getPositionAt(spawnPos.x, spawnPos.y - 3);
					}
					let nearest;
					if ((room.controller.level < 6 || !room.terminal || room.memory.defcon < 4 || room.class == 'restructuring' || room.class === 'bunker') && !room.memory.armedHostiles){
							let currentRange;
							for (let i in room.memory.supportRooms.rooms){
									let nearRoom = Game.rooms[i];
									if ((!currentRange || room.memory.supportRooms.rooms[i] < currentRange) && nearRoom && (nearRoom.terminal || (nearRoom.storage && Memory.myRooms.length < 4)) && nearRoom.controller && nearRoom.controller.my && nearRoom.controller.level > 3 && !nearRoom.memory.hostiles
											&& nearRoom.memory.defcon && nearRoom.memory.defcon == 5){
											currentRange = room.memory.supportRooms.rooms[i];
											nearest = i;
									}
									if (room.memory.defcon < 4){
											nearRoom.memory.nearbyAttack = Game.time+500;
									}
							}
					}
					if (!room.controller.safeModeAvailable || room.controller.safeModeCooldown || Game.safemodeActive ||
							room.controller.ticksToDowngrade < CONTROLLER_DOWNGRADE[room.controller.level] * 0.6
							|| (room.controller.safeMode && room.controller.safeMode < 1000)){
							let manualDefenceSquad = false;
							if (config.operations){
									for (let o in config.operations){
											if (o === room.name && config.operations[o].type === 'D'){
													console.log('blocking auto defence for manual override',room.name);
													manualDefenceSquad = true;
											}
									}
							}
							if (!manualDefenceSquad && room.controller.level < 7 && (room.memory.lastAttacked > Game.time-3000 || !room.findStructures('tower')[0]
									|| !room.findStructures('spawn')[0])){
									let count = 1;
									if (room.memory.lastAttacked && room.memory.lastAttacked > Game.time-3000){
											count = 2;
									}
									requestSquadsViaCombatManager(room.name,'D',{maxLevel:4,count:count});
									requestDefence(room,0.5);
							} else if (room.findStructures('spawn').length ===0 || (room.class === 'bunker' && room.findStructures('storage').length ===0
									&& room.controller.level > 4)){
									requestSquadsViaCombatManager(room.name,'G',{maxLevel:4,count:1});
							}
					}
					if (nearest && Game.rooms[nearest]){
							if (room.findStructures('spawn').length === 0 || (room.energyCapacityAvailable < 700 && room.class === 'bunker')){
									Game.rooms[nearest].sendColonists(room.name);
							}
					}
					let forceFill = (config.forceFill && config.forceFill === room.name && !room.terminal );
					if (nearest && storePos && Game.rooms[nearest]){
							if (room.class == 'restructuring'){
									Game.rooms[nearest].sendColonists(room.name);
							}
							if (((room.class === 'bunker' && (room.total('energy')<room.memory.reserve*1.2 || !room.storage)) ||
									(Memory.excessEnergy > (20000*Memory.myRooms.length)&&config.official))&& (room.total('energy')<room.memory.reserve*1.8 || !room.storage)
									&& !room.terminal && !room.memory.armedHostiles){
									if (room.class === 'bunker' && !room.storage && room.memory.upContPos && room.memory.upContPos.toPos()){
											storePos = room.memory.upContPos.toPos();
									}
									storePos.createFlag('fill' + nearest);
							} else if (Game.time % 500 === 0 && !forceFill) {
									let fillFlag = room.find(FIND_FLAGS, {filter: (f) => f.name.slice(0, 4) === 'fill'})[0];
									if (fillFlag){
											fillFlag.remove();
									}
							}
							room.display('support manager here');
							// let flags = storePos.lookAround(LOOK_FLAGS, 0, {filter: (f) => (f.name.slice(0, 4) === 'fill' && f.name != 'fill' + nearest) && f.name.split('-')[1] != nearest})
							// let cFlags = room.controller.pos.lookAround(LOOK_FLAGS, 0, {filter: (f) => f.name.split('-')[0] == 'col' && f.name.split('-')[1] != nearest})
							// if (flags){
							// 	flags.forEach((f) => f.remove())
							// }
							// if (cFlags){
							// 	cFlags.forEach((f) => f.remove())
							// }
					} else if (!forceFill) {
							let flags = room.controller.pos.lookAround(LOOK_FLAGS, 0, {filter: (f) => f.name.slice(0, 4) === 'fill'});
							if (flags){
									flags.forEach((f) => f.remove());
							}
					}
			}
			// if (room.memory.spawn && !Game.spawns[room.memory.spawn]){
			// 		console.log('requesting support for',room.name)
			// 		let nearest
			// 		let currentRange
			// 		for (let i in room.memory.supportRooms.rooms){
			// 				let nearRoom = Game.rooms[i]
			// 				if ((!currentRange || room.memory.supportRooms.rooms[i] < currentRange) && nearRoom && nearRoom.terminal && nearRoom.controller && nearRoom.controller.my && nearRoom.controller.level > 6 && !nearRoom.memory.hostiles
			// 						&& (!Memory.priorityEnergyRoomName || Memory.priorityEnergyRoomName != nearRoom.name) && nearRoom.memory.defcon && nearRoom.memory.defcon == 5){
			// 						currentRange = room.memory.supportRooms.rooms[i];
			// 						nearest = i
			// 				}
			// 		}
			// 		if (nearest){
			// 				let pos = room.controller.pos;
			// 		}
			// }
	}

	const repairInterval = 5000;
	let reserved = {};
	//todo debug RF not tending to some remote roads, see E18N18 and E27S7
	//maybe once at rest have the fixer audit all the outPaths to active sources to check for low levels
	//could even prioritise based on this audit, take needed energy out with it as well to ensure no wasted trips
	function run$F(creep){
			//todo they end up queuing when low level, be best if they all worked on the current road if in range
			creep.room.name;
			var homeRoom = creep.home;
			var homeRoomName = homeRoom.name;
			var stores = homeRoom.storage;
			let origin;
			if (creep.home.memory.fixedBaseOrigin){
					origin = creep.home.memory.fixedBaseOrigin.toPos();
			}
			creep.name.split(' ')[1];
			if (creep.home.memory.remoteRoadsNeedBuilding);
			if (!creep.memory.status){
					creep.memory.status = 'out';
			}
			if (!stores && homeRoom.memory.storeCont){
					stores = Game.getObjectById(homeRoom.memory.storeCont);
			}
			let currentSource = creep.memory.currentSource;
			if (!reserved[creep.home.name]){
					reserved[creep.home.name] = {};
			}
			let reservations = reserved[creep.home.name];
			if (Game.time % 10 === 0){
					for (let i in reservations){
							if (!Game.getObjectById(i)){
									delete reservations[i];
							}
					}
			}
			if (currentSource){
					reservations[creep.id] = currentSource;
			} else {
					delete reservations[creep.id];
			}
			let takenSources = Object.values(reservations);
			let mem = creep.home.memory.remoteRep;
			let pos = false;
			if (!currentSource){
					findPos();
					if (creep.memory.currentSource){
							pos = creep.memory.currentSource.toPos();
					}
			} else {
					pos = currentSource.toPos();
			}
			if (creep.memory._fatigue === null || creep.memory._fatigue === undefined){
					creep.memory._fatigue = 0;
			} else {
					if (creep.fatigue > 0 && !creep.pos.onEdge()){
							creep.memory._fatigue++;
					}
			}

			function findPos(){
					//go to the mem value with the lowest number above Game.time
					let lowest = null;
					let current = null;
					let noChange = false;
					for (let i in mem){
							if (takenSources.includes(i)){
									noChange = true;
									continue
							}
							let val = mem[i];
							let roomName = i.split(' ')[1];
							let isAccessible = creep.home.checkRemoteIsAccessible(roomName);
							if (((val[0] && val[0] === 1) || (val[1] && val[1] < Game.time+(repairInterval * 0.5))) && val[1] && (!lowest || val[1] < lowest) && isAccessible){
									lowest = val[1];
									current = i;
							}
					}
					if (current){
							creep.memory.currentSource = current;
					} else if (creep.home.controller.level < 8 && !Memory.priorityEnergyRoomName && !noChange && creep.home.controller.level >= 4){
							if (creep.home.memory.sites){
									creep.memory.role = 'builder';
							} else {
									creep.memory.role = 'fixer';
							}
							delete creep.home.memory.remoteRoadsNeedBuilding;
							return
					} else {
							delete creep.home.memory.remoteRoadsNeedBuilding;
							//creep.suicide()

							if (config.requestEnergyRoom && config.requestEnergyRoom.includes(creep.home.name)){
									creep.memory.role = 'upgrader';
									return
							}
					}
			}

			if (!pos){
					//console.log(creep.name,'remfix no pos')
					for (let i in creep.memory){
							delete creep.memory[i];
					}
					if (creep.home.memory.sites){
							run$12(creep);
					}
					return
			}
			let hostile;
			let homeflag = Game.flags['rally' + homeRoomName];
			if (!homeflag){
					homeflag = creep.home.controller;
			}
			if (creep.room.memory.hostiles && creep.room.name != creep.home.name){
					hostile = Game.getObjectById(creep.room.memory.hostiles);
			}
			if (hostile){
					checkGuardNeeded(creep);
			}
			if (homeflag && creep.memory.hostile){
					creep.moveTo(homeflag, {range: 3});
					if (creep.pos.inRangeTo(homeflag, 5)){
							creep.memory = {};
					} else {
							return
					}
			}

			function setNextVisitTime(){
					//if another visit is needed (creep empty) then add 5000 on to mem value
					let val = mem[pos.toString()];
					if ((creep.store['energy'] == 0 || (creep.memory.fatigue && creep.memory.fatigue > 1)) || !loadPath(creep.home, pos)){
							val = [1, Game.time + repairInterval];
							delete creep.memory.fatigue;
					} else {
							val = [0, Game.time + repairInterval];
					}
					creep.home.memory.remoteRep[pos.toString()] = val;
			}

			new RoomVisual(creep.room.name).text('RF', creep.pos);

			//load a reusable path to the source
			var path = loadPath(creep.home, pos);
			let sites = null;
			let rep = null;
			if (creep.store['energy'] > 0 || creep.memory.status === 'in'){
					if ((!creep.room.controller || !creep.room.controller.my || (creep.room.memory.prayerRoom)) && creep.room.memory.sites){
							let range = 0;
							if (creep.memory.status !== 'in'){
									range = 1;
							}
							sites = creep.pos.lookAround(LOOK_CONSTRUCTION_SITES, range, {filter: (s) => s.structureType == STRUCTURE_ROAD})[0];
					}
					let range = 0;
					if (creep.home && creep.room.name == creep.home.name){
							range = 0;
					}
					if (!sites){
							rep = creep.pos.lookAround(LOOK_STRUCTURES, range, {filter: (s) => s.structureType == STRUCTURE_ROAD && s.hits < s.hitsMax - 1600})[0];
					}
			}
			let home = stores;
			if (origin){
					home = origin;
			}
			if (!home){
					console.log('no home fixer', creep.name);
					return
			}
			if (pos && pos.roomName && Game.map.getRoomType(pos.roomName) ==='SK'){
					let needToAvoidSkGuard = avoidSKGuards(creep,pos);
					if (needToAvoidSkGuard){
							return
					}
			}
			if (sites && !creep.pos.isEqualTo(pos) && (creep.store['energy'] > 0 || creep.memory.status === 'in') && !creep.memory.nearRF){
					creep.build(sites);
					let nearYak = creep.pos.lookAround(LOOK_CREEPS, 1, {filter: (c) => c.my && c.role === 'yak' && c.store['energy'] > 0})[0];
					if (nearYak){
							nearYak.transfer(creep, 'energy');
							nearYak.cancelOrder('move');
							nearYak.startNap(3);
					}
					//want to set is moving to true so the creep is not moved by any yaks
					creep.isMoving = true;
					if (Game.time % 5 === 0){
							let nearRF = creep.pos.lookAround(LOOK_CREEPS, 1, {filter: (c) => c.my && c.role === 'remotefixer' && c.num < creep.num})[0];
							if (nearRF){
									creep.memory.nearRF = true;
							}
					}
					if (creep.store['energy'] === 0 && Game.time % 5 === 0 && pos){
							let structures = pos.lookAround(LOOK_STRUCTURES, 0, {filter: (s) => s.structureType == STRUCTURE_CONTAINER});
							let cont;
							if (structures){
									cont = structures[0];
							}
							if (cont && cont.pos.lookAround(LOOK_CREEPS, 0, {filter: (c) => c.my}).length === 0){
									creep.memory.status = 'out';
							} else if (cont){
									let contMem = creep.home.memory.remoteContainers[cont.id];
									if (contMem && contMem.freeEnergy > 100 && contMem.reservations.length === 0){
											creep.memory.status = 'out';
									}
							}
					}
			} else if (rep && creep.store['energy'] > 0){
					creep.repair(rep);
			} else if (creep.memory.status === 'out'){
					if (!creep.pos.inRangeTo(pos, 2)){
							if (creep.countParts('move')/creep.body.length < 0.3){
									creep.pullTo(pos);
							} else if (!path){
									creep.goTo(pos);
							} else {
									let road = creep.pos.lookAround(LOOK_STRUCTURES, 0, {filter: (s) => s.structureType == STRUCTURE_ROAD})[0];
									let startPos = path.end.toPos();
									let sPath = PathFinder.reverseSerializedPath(path.sPath);
									let test = creep.moveUsingSavedPath(sPath, path.end.toPos(), pos);
									if ((test == 'OK') && !road && (creep.store['energy'] > 0)){
											let onPath = creep.pos.isOnPath(startPos, sPath);
											if (onPath){
													creep.pos.createConstructionSite(STRUCTURE_ROAD);
											}
									} else if (test === 'delete' && pos){
											delete creep.home.memory.sourcePaths[pos.toString()];
											creep.wipePath();
									}
							}
					} else {
							setNextVisitTime();
							creep.memory.status = 'cont';
					}
			} else if (creep.memory.status === 'cont'){
					let conts = pos.lookAround(LOOK_STRUCTURES, 0, {filter: (s) => s.structureType == STRUCTURE_CONTAINER});
					let cont;
					if (conts && conts.length > 0){
							cont = conts[0];
					} else {
							delete creep.home.memory.remoteRep[pos.toString()];
					}
					if (cont && creep.store['energy'] < creep.store.getCapacity()){
							if (creep.withdraw(cont, 'energy') === -9){
									creep.goTo(cont, {range: 1});
							} else if (cont.store['energy'] === 0 && (creep.pos.isEqualTo(cont.pos) || cont.pos.lookAround(LOOK_CREEPS, 0, {filter: (c) => c.my}).length === 0)){
									if (!creep.pos.isEqualTo(cont.pos)){
											creep.moveTo(cont, {range: 0});
									} else {
											let source = creep.pos.lookAround(LOOK_SOURCES, 1)[0];
											creep.harvest(source);
									}
							} else {
									creep.memory.status = 'in';
							}
					} else {
							creep.memory.status = 'in';
					}
			} else if (creep.memory.status === 'in'){
					if (!creep.pos.inRangeTo(home, 1)){
							if (!path){
									creep.say('no path');
									creep.goTo(stores, {range: 1});
							} else {
									let road = creep.pos.lookAround(LOOK_STRUCTURES, 0, {filter: (s) => s.structureType == STRUCTURE_ROAD})[0];
									let startPos = path.start.toPos();
									let sPath = path.sPath;
									let test = creep.moveUsingSavedPath(sPath, startPos, home);
									creep.say('me');
									if (!creep.pos.isEqualTo(pos) && (creep.fatigue > 0 || test == 'OK') && !road && (creep.store['energy'] >= CONSTRUCTION_COST['road'] || creep.store.getCapacity() < CONSTRUCTION_COST['road'] || creep.pos.getTerrain())){
											let onPath = creep.pos.isOnPath(startPos, sPath);
											if (onPath){
													creep.pos.createConstructionSite(STRUCTURE_ROAD);
											}
											creep.cancelOrder('move');
											creep.isMoving = true;
									} else if (test === 'delete' && pos){
											delete creep.home.memory.sourcePaths[pos.toString()];
											creep.wipePath();
									}
							}
					} else {
							if (stores && stores.store['energy'] > stores.room.memory.reserve * 0.9 && creep.store['energy'] < creep.store.getCapacity()){
									if (creep.withdraw(stores, 'energy') === -9){
											creep.goTo(stores, {range: 1});
									}
							} else {
									delete creep.memory.currentSource;
									delete creep.memory.status;
									delete creep.memory.panicPos;
									creep.wipePath();
									delete creep.memory.fatigue;
									delete creep.memory.nearRF;
							}
					}
			}

			function loadPath(room, sourcepos){
					if (!room.memory.sourcePaths){
							room.memory.sourcePaths = {};
					}
					if (!sourcepos){
							delete creep.memory.currentSource;
							return
					}
					let mem = room.memory.sourcePaths[sourcepos.toString()];
					if (mem && mem.path && !mem.noRoads && mem.expiry > Game.time){
							return mem.path
					} else {
							let origin;
							if (room.memory.fixedBaseOrigin){
									origin = room.memory.fixedBaseOrigin.toPos();
							}
							if (room.memory.storeCont && Game.getObjectById(room.memory.storeCont)){
									origin = Game.getObjectById(room.memory.storeCont).pos;
							}
							savePath(room, sourcepos, origin);
							return null
					}
			}
	}


	let lastBodyCheckTime = {};
	let spawnCode$j = {
			priority: (room, countFunction) => {
					if (room.memory.armedHostiles || room.memory.defcon < 4){
							return false
					}
					let priority = 35;
					if (countFunction('remotefixer', room) > 1 && room.controller.level > 6){
							priority = 50;
					} else {
							priority += countFunction('remotefixer', room)*2;
					}
					return priority
			},
			isRequired: (room, countFunction) => {
					let numberRequired = 0;
					let remoteFixerNeeded = false;
					if (room.memory.armedHostiles || pauseRemotes(room) || room.memory.underHarassment || room.memory.defcon < 4 || room.memory.brigade || !canSpawnReserves(room)){
							return false
					}
					let fixerMem = room.memory.remoteRep;
					for (let i in fixerMem){
							if (fixerMem[i] && fixerMem[i][0] && fixerMem[i][0] === 1 && fixerMem[i][1] && (Game.time - fixerMem[i][1])<5000){
									remoteFixerNeeded = true;
									break
							} else if (!fixerMem[i][1] || (fixerMem[i][1] && (Game.time - fixerMem[i][1])>=5000)){
									//remove old sources
									delete fixerMem[i];
							}
					}
					let bodyNeeded = calculateRFBod(room);
					if (!remoteRoadsPresent(room) || (room.memory.remoteRoadsNeedBuilding && room.memory.remoteRoadsNeedBuilding > Game.time)){
							bodyNeeded = bodyNeeded * 2;
					}
					let checkPause = checkIfNeedToPauseInfrastructureDueToHarassment(room);
					if (checkPause){
							return false
					}
					if (remoteFixerNeeded){
							numberRequired = Game.bodySizeToNumberNeeded(bodyNeeded, spawnCode$j.body(room, countFunction).body, 'work');
							if (!numberRequired){
									numberRequired = 1;
							}
					}
					if (config.conserveCpu && spawnCode$j.body(room, countFunction).body.length > 20 && remoteFixerNeeded){
							numberRequired = 1;
					}
					if (room.memory.remoteRoadsNeedBuilding && room.memory.remoteRoadsNeedBuilding > Game.time && numberRequired < 2){
							numberRequired = 2;
					}
					return countFunction('remotefixer', room) < numberRequired;
			},
			spawn: (room, role, body) => {
					//decide if we need any other options
					if (body){
							//options -> TTL, creepnumber
							room.spawnCreep(role, body);
					}
			},
			body: (room, countFunction) => {
					let roadsDown = remoteRoadsPresent(room);
					let key = room.energyCapacityAvailable + ':' + roadsDown;
					if (getCachedBody('remotefixer',key)&& lastBodyCheckTime[key] && lastBodyCheckTime[key] > Game.time){
							return getCachedBody('remotefixer',key)
					}
					let bodyObject = {
							body: [],
							cost: 0
					};
					let max = 48;
					if (roadsDown && !room.remoteRoadsNeedBuilding && (!config.conserveCpu || Game.cpu.bucket>1000)){
							max = calculateRFBod(room);
							//adjust to carry and move parts
							max = max * 4;
							//adjust to add an excess in order to keep roads well established
							max += 6;
							if (max > 48){
									max = 48;
							}
					} else if (!config.official && room.energyCapacityAvailable > 300){
							if (room.controller.level < 7){
									max = 10;
							} else if (room.controller.level === 7){
									max = 20;
							} else {
									max = 30;
							}
					} else if (!config.official){
							max = 10;
					}
					if (max <4){
							max = 4;
					}
					//decide on what body to have
					bodyObject.body = room.makeBody([WORK, CARRY], true, {maxParts: max,remoteRoads:true});
					if (bodyObject.body && bodyObject.body.length > 0){
							bodyObject.cost += Game.getBodyCost(bodyObject.body);
					}
					cacheBody('remotefixer', key, bodyObject);
					lastBodyCheckTime[key] = Game.time + 300;
					return bodyObject
			}
	};

	function calculateRFBod(room){
			if (!room.memory.assignedSourceData){
					return 0
			}
			//distance*hits lost per 1000 tick (100)*swampyGroundMod(5)/1000(amount of ticks) -> hits needed to repair this length of road per tick
			let roadRepairCost = ROAD_DECAY_AMOUNT;
			if (config.swampyGround){
					roadRepairCost = ROAD_DECAY_AMOUNT * 5;
			}
			let hitsPerTick = (room.memory.assignedSourceData.currentDistance * roadRepairCost) / ROAD_DECAY_TIME;
			// /repair power = number of work parts needed
			//while we want some excess to ensure roads are repaired towards the max, this is ok as the estimate includes roads in our room
			return Math.ceil(hitsPerTick/ REPAIR_POWER)
	}

	var remotefixer = /*#__PURE__*/Object.freeze({
		__proto__: null,
		repairInterval: repairInterval,
		run: run$F,
		spawnCode: spawnCode$j
	});

	function run$E(creep){
			if (Game.time % 150 == 0){
					delete creep.memory.hostile;
			}
			if (creep.home && !creep.home.memory.remoteRep){
					creep.home.memory.remoteRep = {};
			}
			let homeRoom = creep.home;
			let homeRoomName = homeRoom.name;
			let homeflag = Game.flags['rally' + homeRoomName];
			if (!homeflag){
					homeflag = creep.home.controller;
			}
			let pos;
			if (homeRoom.memory.finalSources && homeRoom.memory.finalSources[creep.num - 1]){
					pos = homeRoom.memory.finalSources[creep.num - 1].toPos();
			}
			if (creep.memory.checkedPath && Game.time % 300 === 0 && Game.cpu.bucket > 3000){
					delete creep.memory.checkedPath;
			}
			if (!pos){
					creep.memory.reason = 'redundant';
					creep.memory.role = 'recycle';
					return
			}
			if (pos && pos.roomName && Game.map.isCoreRoom(pos.roomName)){
					delete Memory.sources[pos.toString()];
					delete homeRoom.memory.finalSources[creep.num - 1];
					delete homeRoom.memory.sourcelist[pos.toString()];
					return
			}
			if (creep.ticksToLive > 1490){
					if (!creep.home.checkRemoteIsAccessible(pos.roomName)){
							creep.memory.hostile = true;
					}
			}
			if (!homeRoom.memory.remoteRooms){
					homeRoom.memory.remoteRooms = {};
			} else if (!homeRoom.memory.remoteRooms[pos.roomName]){
					homeRoom.memory.remoteRooms[pos.roomName] = {};
			} else if (!homeRoom.memory.remoteRooms[pos.roomName].route){
					homeRoom.memory.remoteRooms[pos.roomName].route = [];
			} else if (!creep.room.name != creep.home.name && !creep.pos.onEdge() && (Game.time + creep.num) % 10 === 0 && !homeRoom.memory.remoteRooms[pos.roomName].route.includes(creep.room.name)){
					homeRoom.memory.remoteRooms[pos.roomName].route.push(creep.room.name);
			}

			let hostile;
			if (creep.room.memory.hostiles){
					hostile = Game.getObjectById(Memory.rooms[creep.room.name].hostiles);
			}
			if (creep.memory.hostile){
					creep.wipePath();
			}
			if (hostile){
					checkGuardNeeded(creep);
			} else if (pos && pos.roomName && creep.room.name === pos.roomName && creep.home.memory.remoteRooms && creep.home.memory.remoteRooms[creep.room.name]){
					delete creep.home.memory.remoteRooms[creep.room.name].guardNeeded;
					delete creep.home.memory.remoteRooms[creep.room.name].retreat;
			}
			if (homeflag && creep.memory.hostile){
					creep.pos.highlight('#690101');
					creep.moveTo(homeflag, {range: 3});
					if (Game.time % 10 === 0){
							if (pos && pos.roomName && creep.home.checkRemoteIsAccessible(pos.roomName)){
									delete creep.memory.hostile;
							}
					}
					return
			}
			if (creep.hits < creep.hitsMax){
					delete creep.memory.panicPos;
					creep.towerHeal(homeRoom);
					if (pos && creep.home.memory.minerPaths && Game.map.getRoomType(creep.pos.roomName) === 'SK'){
							delete creep.home.memory.minerPaths[pos.toString()];
					}
			} else if (!creep.memory.hostile){
					if (pos){
							if (pos && pos.roomName && ((creep.room.name === pos.roomName && Game.map.getRoomType(pos.roomName) ==='SK')|| creep.memory.goToPanicPos)){
									let needToAvoidSkGuard = avoidSKGuards(creep,pos);
									if (needToAvoidSkGuard){
											requestSquad(creep.home, creep.room.name, {
													type: 'SKE',attackers:1,medics:0
											});
											return
									}
							}
							if (creep.room.name == pos.roomName && creep.room.controller && creep.room.controller.level && !creep.room.controller.my && creep.room.controller.owner &&
									creep.room.controller.owner.username !== 'Invader'){
									console.log(pos, pos.roomName, ' room settled by other player!!!');
									if (creep.room.controller.level > 2){
											delete Memory.sources[pos.toString()];
											delete homeRoom.memory.finalSources[creep.num - 1];
											delete homeRoom.memory.sourcelist[pos.toString()];
											//creep.suicide()
									} else if (!config.allies.includes(creep.room.controller.owner.username)){
											requestSquad(creep.home, creep.room.name, {type: 'D'});
									}
									return
							}
							if (creep.home.remoteRooms && creep.home.memory.remoteRooms[pos.roomName] &&
									creep.home.memory.remoteRooms[pos.roomName].controllerClearNeeded == true && creep.room.name == pos.roomName){
									console.log(creep, 'controller  clearing');
									let wall = creep.room.controller.pos.lookAround(LOOK_STRUCTURES, 1, {
											filter: (s) => {
													return s.structureType == STRUCTURE_WALL
											}
									})[0];
									if (wall && creep.dismantle(wall) != 0){
											creep.moveTo(wall, {range: 1});
									} else if (!wall && creep.home.memory.remoteRooms[creep.room.name] && creep.home.memory.remoteRooms[creep.room.name].controllerClearNeeded){
											delete creep.home.memory.remoteRooms[creep.room.name].controllerClearNeeded;
									}
							} else if (!creep.pos.isNearTo(pos)){
									let path = loadPath(homeRoom, pos);
									if (!path && !creep.memory.checkedPath){
											path = savePath(homeRoom, pos);
											creep.memory.checkedPath = true;
									}
									if (!creep.memory.moveRatio){
											creep.memory.moveRatio = creep.countParts('move')/creep.countParts('work');
									}
									let moveRatio = creep.memory.moveRatio;
									if (moveRatio < 0.5 || (moveRatio === 0.5 && !creep.home.memory.roadsDown)){
											creep.pullTo(pos);
									} else if (path){
											creep.say('tp path');
											let test = creep.moveUsingSavedPath(path.sPath, path.start.toPos(), pos);
											if (test == 'delete'){
													console.log('delete', creep.pos);
													delete creep.home.memory.minerPaths[pos.toString()];
													creep.wipePath();
													delete creep.home.memory.brigade;
											}
									} else {
											if (creep.memory.container && Game.getObjectById(creep.memory.container) && creep.room.name === pos.roomName){
													creep.say('tp cont');
													creep.moveTo(Game.getObjectById(creep.memory.container),{range:0});
											} else if (creep.memory.cSite && Game.getObjectById(creep.memory.cSite)){
													creep.say('tp cs');
													creep.moveTo(Game.getObjectById(creep.memory.cSite).pos, {range: 0});
											} else {
													creep.say('tp pos');
													creep.moveTo(pos, {range: 1});
											}
									}
									let contMem = creep.memory.container;
									let cont;
									if (contMem){
											cont = Game.getObjectById(contMem);
									}
									if (!creep.memory.container && creep.room.name == pos.roomName){
											let lookCont = pos.lookAround(LOOK_STRUCTURES, 1, {filter: (s) => s.structureType == STRUCTURE_CONTAINER})[0];
											if (lookCont){
													creep.memory.container = lookCont.id;
													cont = lookCont;
											}
									}
									if (cont && creep.home.memory.remoteRep[cont.pos.toString()] && !creep.home.memory.remoteRep[cont.pos.toString()][1]){
											delete creep.home.memory.remoteRep[cont.pos.toString()];
									}
									if (!cont && creep.room.name == pos.roomName){
											creep.memory.needRep = true;
									} else if (cont && (!creep.home.memory.remoteRep[cont.pos.toString()] || !creep.home.memory.remoteRep[cont.pos.toString()][1])){
											creep.memory.needRep = true;
									} else if (cont && creep.memory.needRep == undefined && creep.home.memory.remoteRep[cont.pos.toString()] && creep.home.memory.remoteRep[cont.pos.toString()][1]
											&& creep.home.memory.remoteRep[cont.pos.toString()][1] < Game.time && creep.pos.roomName == pos.roomName){
											//if remoteRep > Game.time -> repair that room
											let roads = creep.room.find(FIND_STRUCTURES, {filter: (s) => s.structureType == STRUCTURE_ROAD && s.hits < s.hitsMax * 0.25});
											if (roads && roads.length > 0){
													creep.memory.needRep = true;
											} else {
													creep.memory.needRep = false;
											}
									}
							} else {
									if (creep.room.controller && creep.room.controller.reservation && creep.room.controller.reservation.username == 'Invader' && Game.time % 100 == 0){
											if (homeRoom && homeRoom.memory.remoteRooms && homeRoom.memory.remoteRooms[creep.room.name]){
													homeRoom.memory.remoteRooms[creep.room.name].smallReserve = Game.time + 5000;
											}
									}
									if (!creep.memory.timeToSource){
											creep.memory.timeToSource = CREEP_LIFE_TIME-creep.ticksToLive;
									}
									creep.wipePath();
									//memorising room to spawn reserver
									if (Game.time % 100 == 0 || !homeRoom.memory.remoteRooms){
											let controller = creep.room.controller;
											let reserveNeeded;
											if (controller && ((controller.reservation && controller.reservation.username == Game.username && controller.reservation.ticksToEnd > 1000) || controller.my === true)){
													reserveNeeded = false;
											} else if (controller){
													reserveNeeded = true;
											}
											if (!homeRoom.memory.remoteRooms){
													homeRoom.memory.remoteRooms = {};
											} else if (!homeRoom.memory.remoteRooms[creep.room.name]){
													homeRoom.memory.remoteRooms[creep.room.name] = {};
											} else {
													homeRoom.memory.remoteRooms[creep.room.name].reserveNeeded = reserveNeeded;
											}
									}
									let source = null;
									if (!creep.memory.source){
											source = pos.lookAround(LOOK_SOURCES, 1)[0];
											if (source){
													creep.memory.source = source.id;
											}
									} else if (creep.memory.source){
											source = Game.getObjectById(creep.memory.source);
									}
									if (!source){
											console.log(creep,creep.pos,'no source');
											return
									}
									if (source && source.energy == 0){
											creep.startNap(source.ticksToRegeneration);
											Memory.stats['remote.EnergyGained'] += source.energyCapacity;
									}
									if (source && source.ticksToRegeneration == 1){
											Memory.stats['remote.EnergyGained'] += source.energyCapacity - source.energy;
											Memory.stats['remote.EnergyLost'] += source.energy;
									}
									let container;
									if (!creep.memory.container && canBuildContainer(creep)){
											let structurelist = creep.pos.lookFor(LOOK_STRUCTURES);
											container = structurelist.filter((structure) => structure.structureType == STRUCTURE_CONTAINER)[0];
											if (container && container.pos && creep.pos.isEqualTo(container.pos)){
													creep.memory.container = container.id;
											} else {
													creep.findContainer(source);
											}
									} else if (creep.memory.container){
											container = Game.getObjectById(creep.memory.container);
									}
									if (container && creep.memory.needRep === true && (!creep.home.memory.remoteRep[container.pos.toString()] || !creep.home.memory.remoteRep[container.pos.toString()][1] || creep.home.memory.remoteRep[container.pos.toString()][1] < Game.time)){
											creep.home.memory.remoteRep[container.pos.toString()] = [1, Game.time + repairInterval];
											//console.log(creep.name,'setting new repairs route')
											delete creep.memory.needRep;
									} else if (creep.memory.needRep === false && container && creep.home.memory.remoteRep[container.pos.toString()][1] && creep.home.memory.remoteRep[container.pos.toString()][1] < Game.time){
											creep.home.memory.remoteRep[container.pos.toString()] = [0, Game.time + repairInterval];
									}

									if (!config.conserveCpu && Game.cpu.bucket > 6000 && Game.time % 100 === 0 && container){
											if (creep.home.memory.minerPaths && creep.home.memory.minerPaths[pos.toString()] &&
													creep.home.memory.minerPaths[pos.toString()].path.end != container.pos.toString()){
													delete creep.home.memory.minerPaths[pos.toString()];
													delete creep.home.memory.brigade;
											}
									}
									if (creep.home.memory.minerPaths && !config.conserveCpu  && !creep.home.memory.minerPaths[pos.toString()] && Game.time % 100 == 0){
											if (container && container.pos){
													savePath(creep.home, pos, container.pos);
											} else if (creep.memory.cSite && Game.getObjectById(creep.memory.cSite)){
													savePath(creep.home, pos,Game.getObjectById(creep.memory.cSite).pos);
											} else {
													savePath(creep.home, pos);
											}
									}
									if (Game.time % 10 === 0 && container){
											//try to save on position check
											let equal = creep.pos.isEqualTo(container.pos);
											if (!equal){
													delete creep.memory.inPos;
											} else {
													creep.memory.inPos = true;
											}
									}
									if (container && !creep.memory.inPos && !creep.pos.isEqualTo(container.pos)){
											creep.moveTo(container, {range: 0});
									} else if (container && container.hits < container.hitsMax * 0.8 && creep.store['energy'] == creep.store.getCapacity() && creep.store.getCapacity()>0){
											creep.repair(container);
									} else if (pos && !container && (!source || (source && !creep.pos.isNearTo(source)))){ //define destination
											creep.moveTo(pos, {range: 1});
											if (creep.pos.isNearTo(pos)){
													delete creep.memory.source;
											}
									} else if ((!container || (container.hits < container.hitsMax * 0.8) || container.store.getUsedCapacity() < container.store.getCapacity()) && source.energy > 0){
											let ret = creep.harvest(source);
											if (ret === -1){
													let corePresent = checkForCore(creep);
													if (corePresent){
															creep.memory.role = 'recycle';
													}
											}
											if (!container && Game.map.getRoomType(creep.room.name) === 'SK'){
													let energy = creep.pos.lookAround(LOOK_ENERGY,1)[0];
													if (energy){
															creep.pickup(energy);
															creep.cancelOrder('harvest');
													}
											}
											if (creep.home.energyCapacityAvailable < 2000){
													let desiredParts = 6;
													if (!canSpawnReserves(creep.home)){
															desiredParts = 3;
													}
													if (creep.countParts('work') < desiredParts){
															requestSecondCreep(source,(desiredParts-creep.countParts('work')));
													}
											}
									} else if (Game.map.getRoomType(creep.room.name) === 'SK' && container && creep.store['energy'] > 0 &&
											container.store.getFreeCapacity()> creep.store.getUsedCapacity()){
											creep.drop('energy');
									} else if (Game.map.getRoomType(creep.room.name) === 'SK' && container && Game.time % 2 === 0){
											let energy = creep.pos.lookAround(LOOK_ENERGY,1)[0];
											if (energy){
													creep.pickup(energy);
													creep.cancelOrder('harvest');
											}
									} else if (source.ticksToRegeneration > 5 && source.energy === 0){
											creep.startNap(5);
									}
									if (container && (Game.time+creep.num) % 10 == 0){
											creep.say('manage');
											manageReservations(container, homeRoom.memory.finalSources[creep.num - 1], creep);
									} else if (Game.map.getRoomType(pos.roomName) === 'SK' && !container){
											requestSquad(creep.home, creep.room.name, {
													type: 'SKE',attackers:1,medics:1
											});
									}
							}
					}


			}
			function requestSecondCreep(source,parts){
					if (!source){
							return
					}
					if (creep.memory.canRequestSecondCreep === undefined){
							let neighbours = source.pos.neighbours();
							let count = 0;
							for (let i in neighbours){
									if (neighbours[i].getTerrain() !== 'wall'){
											count++;
									}
							}
							creep.memory.canRequestSecondCreep = count > 1;
					} else if (creep.memory.canRequestSecondCreep){
							creep.home.requestSecondRemoteMiner(creep,source.pos,parts);
					}
			}
			function loadPath(room, sourcepos){
					if (!room.memory.minerPaths){
							room.memory.minerPaths = {};
					}
					let mem = room.memory.minerPaths[sourcepos.toString()];
					if (mem && mem.path && mem.expiry > Game.time){
							return mem.path
					} else {
							return null
					}
			}

			function savePath(home, sourcepos, cont){
					let start;
					if (home.storage){
							start = home.getPositionAt(home.storage.pos.x, home.storage.pos.y + 1);
					} else if (home.memory.storeCont){
							let storeCont = Game.getObjectById(home.memory.storeCont);
							if (storeCont){
									start = storeCont.pos;
							}
					}
					let range = 1;
					let target = sourcepos;
					if (cont && cont.roomName){
							target = cont;
							range = 0;
					}
					if (!start){
							return
					}
					if (home.memory.storageWithdawPos){
							start = home.memory.storageWithdawPos.toPos();
					}
					let needSKmatrix = false;
					//find path if loadPath return null and creep is near container (as this means the path will no be on the unwalkable mining spot)
					let path = PathFinder.search(start, {pos: target, range: range}, {
							maxOps: 20000,
							plainCost: 2,
							swampCost: 5,
							roomCallback: function (roomName){
									let room = Game.rooms[roomName];
									if (Memory.ownedRooms[roomName]){
											return
									}
									if (Game.map.isCoreRoom(roomName)){
											return false
									}
									let costs = new PathFinder.CostMatrix;
									if (ready() && access(home.name) && access(home.name).roadPositions){
											let positions = getRoadPositions(home.name,roomName);
											if (positions){
													for (let i in positions){
															let positionObj = positions[i];
															costs.set(positionObj.x, positionObj.y, 1);
													}
											}
									}
									if (Game.map.getRoomType(roomName) == 'SK'){
											let newM = Game.map.getSKMatrix(roomName);
											if (!newM){
													needSKmatrix = true;
											} else {
													costs = PathFinder.applySKMatrix(roomName,newM);
											}
											if (!costs){
													return
											}
											//allow near end
											if (roomName === target.roomName){
													let neighbours = target.neighbours(6);
													for (let i in neighbours){
															let cost = costs.get(neighbours[i].x,neighbours[i].y);
															if (cost > 20){
																	costs.set(neighbours[i].x,neighbours[i].y,20);
															}
													}
											}
									}
									if (!room) return costs;
									if (room && room.memory.upgraderPositions){
											for (let i in room.memory.upgraderPositions){
													let pos = room.memory.upgraderPositions[i].toPos();
													if (pos){
															costs.set(pos.x,pos.y,20);
													}
											}
									}
									room.find(FIND_STRUCTURES).forEach(function (struct){
											if (struct.structureType === STRUCTURE_ROAD){
													// Favor roads over plain tiles
													costs.set(struct.pos.x, struct.pos.y, 1);
											} else if (struct.structureType === STRUCTURE_CONTAINER){
													// Favor roads over plain tiles
													costs.set(struct.pos.x, struct.pos.y, 5);
											} else if (struct.structureType !== STRUCTURE_RAMPART ||
													!struct.my){
													// Can't walk through non-walkable buildings
													costs.set(struct.pos.x, struct.pos.y, 0xff);
											}
									});

									costs = blockKeyPositions(costs,room);
									room.find(FIND_EXIT).forEach((e) => {
											if (e.oppositeEdge() && Memory.ownedRooms[e.oppositeEdge().roomName]){
													costs.set(e.x, e.y, 0xff);
											}
									});
									room.find(FIND_CONSTRUCTION_SITES).forEach((s) => {
											if (s.my && s.structureType != STRUCTURE_ROAD && s.structureType != STRUCTURE_CONTAINER && s.structureType != STRUCTURE_RAMPART){
													costs.set(s.pos.x, s.pos.y, 0xff);
											}
									});
									return costs;
							},
					});
					if (path.incomplete || needSKmatrix){
							console.log('incomplete',needSKmatrix,path.ops,path.cost,path.path);
							for (let i in path.path){
									path.path[i].highlight('red');
							}
							return null
					}
					if (path.path){
							let rooms = {};
							for (let i in path.path){
									let pos = path.path[i];
									if (pos){
											if (!rooms[pos.roomName]){
													rooms[pos.roomName] = [];
											}
											rooms[pos.roomName].push(pos);
									}
							}
							for (let i in rooms){
									setRoadPositions(home.name,i,rooms[i]);
							}
					} else {
							console.log('no road positions');
							return
					}
					//serialize
					let sPath = PathFinder.serializePath(start, path);
					let obj = {
							sPath: sPath,
							start: start.toString(),
							end: path.path[path.path.length - 1].toString()
					};
					//save, with an expiry in order to ensure fresh paths
					home.memory.minerPaths[sourcepos.toString()] = {
							path: obj,
							expiry: Game.time + 50000
					};
					//path obj needs serialized path as well as a start pos and end pos
					return obj
			}
	}
	function canBuildContainer(creep){
			if (!canSpawnReserves(creep.home) || !creep.countParts('carry') === 0){
					return false
			}
			if (creep.home.controller.level > 3 || (!creep.home.memory.remoteContainers && creep.num === 1) ||
					(creep.home.memory.remoteContainers && Object.keys(creep.home.memory.remoteContainers).length+1 >= creep.num)){
					return true
			}
	}
	function manageReservations(container, sourcePos, creep){
			let memory = creep.home.memory.remoteContainers;
			if (!container || !container.id){
					return
			}
			if (!memory){
					creep.home.memory.remoteContainers = {};
					memory = creep.home.memory.remoteContainers;
			}
			let distance = 0;
			let cStr = container.pos.toString();
			if (sourcePos && Memory.sources && Memory.sources[sourcePos]){
					distance = Memory.sources[sourcePos].distance;
			} else if (creep.room.memory.assignedEnergyHomeRoomDistance) {
					distance = Math.round(creep.room.memory.assignedEnergyHomeRoomDistance/3);
			} else {
					return
			}
			if (!memory[container.id] || !memory[container.id].distance){
					memory[container.id] = {
							reservations: [],
							freeEnergy: 0,
							expiry: Game.time + 1000,
							pos: cStr,
							distance: distance
					};
			}
			let contMem = memory[container.id];
			contMem.expiry = Game.time + 1000;
			let reservedEnergy = 0;
			let newReservations = [];
			for (let i in contMem.reservations){
					let yak = Game.getObjectById(contMem.reservations[i][0]);
					if (yak && yak.memory.target && yak.memory.target == cStr){
							reservedEnergy += contMem.reservations[i][1];
							newReservations.push(contMem.reservations[i]);
					}
			}
			contMem.freeEnergy = container.store['energy'] - reservedEnergy;
			if (Game.map.getRoomType(container.pos.roomName)=== 'SK'){
					let tombs = container.pos.lookAround(LOOK_TOMBSTONES,0);
					tombs.forEach((e)=>contMem.freeEnergy += e.store['energy']);
			}
			contMem.reservations = newReservations;
	}

	let spawnCode$i = {
			priority: (room, countFunction) => {
					let priority = 39;
					priority += countFunction('remoteminer', room);
					if (room.total('energy')>room.memory.reserve*1.5){
							priority+=10;
					}
					return priority
			},
			isRequired: (room, countFunction) => {
					let numberRequired = 0;
					if ((room.memory.armedHostiles && (!room.justInvader || !room.ecoStable)) && room.memory.underHarassment|| pauseRemotes(room)){
							return false
					}
					if (room.ecoStable && room.terminal && config.official && room.memory.faceClaimed && room.total('energy') > room.memory.reserve * 0.5){
							return false
							//free up spawning for squads
					}
					if (room.memory.remoteminer && !Game.flags['defend' + room.name]){
							numberRequired = Math.ceil(room.memory.remoteminer * room.memory.remoteAdjust);
					}
					if (room.memory.finalSources && numberRequired > room.memory.finalSources.length){
							numberRequired = room.memory.finalSources.length;
					}
					//todo number required should minus any remotes that are not accessible - when spawning take this into account and pass the specific spawn number
					return countFunction('remoteminer', room) < numberRequired;
			},
			spawn: (room, role, body) => {
					//decide if we need any other options
					if (body){
							//options -> TTL, creepnumber
							let creepsalive = room.creepList.filter((c) => c.role === 'remoteminer');
							let creepNum;
							if (creepsalive.length > 0){
									for (let i = 1; i <= creepsalive.length + 1; i++){
											let tryCreep = _.filter(creepsalive, (creep) =>
													creep.name.split(' ')[1] == i && (creep.ticksToLive == undefined || creep.ticksToLive > creep.TTLRespawnDue)
											)[0];
											if (!tryCreep){
													creepNum = i;
													break
											}
									}
							} else {
									creepNum = 1;
							}
							if (config.weirdSources){
									if (creepNum && Memory.bigBoiSources && room.memory.finalSources && room.memory.finalSources[creepNum - 1]
											&& Memory.bigBoiSources[room.memory.finalSources[creepNum - 1]]){
											//making the remoteMiners for singles sources bigger
											console.log('big boi body', creepNum);
											if (!room.memory.remoteRoadsNeedBuilding || room.energyCapacityAvailable < 1700){
													body = room.makeBody([WORK, MOVE], false, {noMove: true, oneCarry: true, maxParts: 15});
											} else {
													body = room.makeBody([WORK], false, {oneMove: true, oneCarry: true, maxParts: 15});
											}
									}
							} else {
									if (creepNum && room.memory.finalSources && room.memory.finalSources[creepNum - 1]){
											let pos = room.memory.finalSources[creepNum - 1].toPos();
											if (pos && pos.roomName && Game.map.getRoomType(pos.roomName) !== 'normal'){
													//making the remoteMiners forSK sources bigger
													body = room.makeBody([WORK], true, { oneCarry: true, maxParts: 15});
											}
									}
							}
							room.spawnCreep(role, body);
					}
			},
			body: (room, countFunction) => {
					let bodyObject = {
							body: [],
							cost: 0
					};
					//decide on what body to have
					let body;
					if ((config.swampyGround && (room.controller.level < 4 || room.memory.remoteRoadsNeedBuilding)) || room.energyCapacityAvailable < 1250){
							let maxParts = 13;
							body = room.makeBody([WORK], true, {oneCarry: true, maxParts: maxParts,remoteRoads:true});
							if (!canSpawnReserves(room)){
									body = room.makeBody([WORK], true, {maxParts: 6,remoteRoads:true});
							}
					} else if (room.memory.roadsDown){
							body = [WORK, WORK, WORK, WORK, WORK, WORK, WORK, WORK, CARRY, MOVE, MOVE, MOVE, MOVE];
							if (room.energyCapacityAvailable > 3000 && Game.myRooms.length > 20 && Game.cpu.bucket < 10000){
									body = [WORK, WORK, WORK, WORK, WORK, WORK, WORK, WORK, WORK, WORK,WORK, WORK, WORK, WORK, WORK, WORK, CARRY, CARRY,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE];
							} else if (room.energyCapacityAvailable > 3000 && config.conserveCpu && Game.cpu.bucket < 10000){
									body = [WORK, WORK, WORK, WORK, WORK, WORK, WORK, WORK, WORK, WORK,WORK, WORK, CARRY, CARRY,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE];
							}
					} else {
							body = [WORK, WORK, WORK, WORK, WORK, WORK, WORK, WORK, CARRY, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE];
					}
					bodyObject.body = body;
					if (bodyObject.body && bodyObject.body.length > 0){
							bodyObject.cost += Game.getBodyCost(bodyObject.body);
					}
					return bodyObject
			}
	};

	var remoteminer = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$E,
		manageReservations: manageReservations,
		spawnCode: spawnCode$i
	});

	function run$D(creep){
			creep.room.name;
			var homeRoom = Game.rooms[creep.name.split(' ')[2]];
			var creepnumber = creep.num;
			if (creep.memory.room && Game.flags[creep.memory.room]){
					homeRoom = Game.flags[creep.memory.room].room;
			}
			function pullTo(destination,nextTo){
					if (destination.pos){
							destination = destination.pos;
					}
					if (nextTo && Game.cpu.bucket > 9000){
							let spots = destination.neighbours();
							let walkable = false;
							for (let i in spots){
									if (spots[i].isWalkable(true)){
											walkable = true;
											break
									}
							}
							if (!walkable){
									creep.startNap(10);
									return
							}
					}
					if ((creep.memory.canMove || creep.countParts('move')>0) && (config.conserveCpu || config.official || creep.countParts('move')>2)){
							creep.memory.canMove = true;
							let range = 1;
							if (nextTo){
									range = 0;
							}
							creep.moveTo(destination,{range:range});
					} else {
							creep.pullTo(destination,nextTo);
					}
			}
			if ((homeRoom && homeRoom.name && creep.room.name != homeRoom.name) || creep.pos.onEdge()){
					pullTo(homeRoom.controller.pos);
					return
			}
			if (creep.home.controller.level < 4 && creep.countParts('move') === 0 && !creep.memory.inPos &&
			creep.home.memory.storeContPosition && creep.home.memory.storeContPosition.toPos()){
					if (creep.pos.isEqualTo(creep.home.memory.storeContPosition.toPos())){
							let nearCreeps = creep.pos.lookAround(LOOK_CREEPS,1, {filter: (c) => c.my && c.countParts('move')>0});
							let nearCreep = nearCreeps[0];
							nearCreep.cancelOrder('move');
							nearCreep.pull(creep);
							creep.move(nearCreep);
							nearCreep.move(creep);
							nearCreep.skipTurn = true;
							return
					}
					if (creep.ticksToLive < 1300){
							creep.suicide();
					}
			}
			if (!creep.home.memory.sourcePositions){
					console.log(creep.name,'building sourcePositions');
					sourceStructures(creep.home);
			}
			if (!creep.store.getCapacity() && creep.room.energyCapacityAvailable >= 650){
					creep.say('no carry');
					if (creep.num != 1){
							creep.suicide();
					} else {
							let otherMiner = creep.room.find(FIND_MY_CREEPS, {filter: (c) => c.role === 'miner1' && c.store.getCapacity() > 0 && c.ticksToLive > 50})[0];
							if (otherMiner){
									creep.suicide();
							}
					}
			}
			var homeRoomName = homeRoom.name;
			let target, linksource, mem;
			if (creepnumber == 1 || creepnumber == 3 || !homeRoom.memory.s2){
					target = Game.getObjectById(homeRoom.memory.s1);
					linksource = Game.getObjectById(homeRoom.memory.linksource1);
					if (!linksource){
							delete homeRoom.memory.linksource1;
					}
					if (homeRoom.memory.s1 && homeRoom.memory.sourcePositions && homeRoom.memory.sourcePositions[homeRoom.memory.s1]){
							mem = homeRoom.memory.sourcePositions[homeRoom.memory.s1];
					}
			}
			if (homeRoom.memory.s2){
					if (creepnumber == 2 || creepnumber == 4 || !creepnumber){
							target = Game.getObjectById(homeRoom.memory.s2);
							linksource = Game.getObjectById(homeRoom.memory.linksource2);
							if (!linksource){
									delete homeRoom.memory.linksource2;
							}
							if (homeRoom.memory.s2 && homeRoom.memory.sourcePositions && homeRoom.memory.sourcePositions[homeRoom.memory.s2]){
									mem = homeRoom.memory.sourcePositions[homeRoom.memory.s2];
							}
					}
			} else if (creep.num > 1){
					mem = undefined;
			}
			//for retreating if outside walls
			Game.flags['rally' + homeRoomName];

			if (creep.memory.retreat == true){
					if (creep.fatigue == 0);
			} else {
					let pos = null;
					if (mem && mem.pos && creepnumber < 3){
							pos = mem.pos.toPos();
					} else if (linksource && !creep.memory.pos){
							pos = findPos(linksource, target);
							if (pos){
									creep.memory.pos = pos.toString();
							}
					} else if (linksource){
							pos = creep.memory.pos.toPos();
					}
					let e1, e2;
					if (creep.memory.e1){
							e1 = Game.getObjectById(creep.memory.e1);
							if (!e1){
									delete creep.memory.e1;
							}
					} else if (mem && mem.e1 && !creep.memory.blockE1){
							let e = mem.e1.toPos().lookAround(LOOK_STRUCTURES, 0, {filter: (s) => s.structureType == STRUCTURE_EXTENSION})[0];
							if (e){
									e1 = e;
									creep.memory.e1 = e.id;
							} else {
									creep.memory.blockE1 = true;
							}
					}
					if (creep.memory.e2){
							e2 = Game.getObjectById(creep.memory.e2);
							if (!e2){
									delete creep.memory.e2;
							}
					} else if (mem && mem.e2 && !creep.memory.blockE2){
							let e = mem.e2.toPos().lookAround(LOOK_STRUCTURES, 0, {filter: (s) => s.structureType == STRUCTURE_EXTENSION})[0];
							if (e){
									e2 = e;
									creep.memory.e2 = e.id;
							} else {
									creep.memory.blockE2 = true;
							}
					}
					let inPos = false;
					if (creep.memory.inPos && (Game.time+creepnumber)%5!==0){
							inPos = true;
					} else if (pos && !creep.pos.isEqualTo(pos)){
							delete creep.memory.inPos;
							if (creep.num > 2 || (creep.num > 1 && !creep.home.memory.s2)){
									pullTo(target.pos);
							} else if (!creep.pos.inRangeTo(pos,6)){
									pullTo(pos);
							} else {
									pullTo(pos, true);
							}
					} else if (pos){
							inPos = true;
							if (!creep.memory.inPos){
									creep.memory.inPos = true;
							}
					}
					if (!creep.memory.workParts){
							creep.memory.workParts = creep.countParts('work');
					}
					let storeCap = creep.store.getCapacity()-creep.body.length;
					if (creep.memory.workParts){
							storeCap = creep.store.getCapacity()-(creep.memory.workParts*HARVEST_POWER);
					}
					if (creep.store['energy'] >= storeCap && e1 && (inPos || creep.pos.isNearTo(e1)) && e1.store.getFreeCapacity('energy') > 0){
							creep.transfer(e1, RESOURCE_ENERGY);
					} else if (creep.store['energy'] >= storeCap && e2 && (inPos || creep.pos.isNearTo(e2)) && e2.store.getFreeCapacity('energy') > 0){
							creep.transfer(e2, RESOURCE_ENERGY);
					} else if (creep.store['energy'] >= storeCap && linksource && (inPos || creep.pos.isNearTo(linksource)) && linksource.store['energy']< LINK_CAPACITY){
							creep.transfer(linksource, RESOURCE_ENERGY);
					} else if (inPos && linksource && linksource.store['energy'] < linksource.store.getCapacity('energy') && Game.time % 30 == 0){
							let drops = creep.pos.lookFor(LOOK_RESOURCES)[0];
							if (drops && drops.resourceType == 'energy'){
									creep.pickup(drops);
							}
					}
					if (linksource && linksource.store.getFreeCapacity('energy')===0){
							creep.home.memory.sourceLinkFull = true;
							creep.say('source full');
					} else if (Game.time % 10 === 0){
							delete creep.home.memory.sourceLinkFull;
					}
					let cont;
					if (creep.home && creep.home.controller && canSpawnReserves(creep.home) && target && creep.pos.isNearTo(target) && !creep.memory.container && !linksource){
							cont = creep.pos.lookAround(LOOK_STRUCTURES, 1, {
									filter: (structure) => structure.structureType == STRUCTURE_CONTAINER
							})[0];
							creep.say('look for cont');
							if ((creep.num == 1 || creep.num == 2) && pos && creep.pos.isEqualTo(pos)){
									homeRoom.createConstructionSite(pos, STRUCTURE_CONTAINER);
							}
							if (cont){
									creep.memory.container = cont.id;
							}
					} else if (creep.memory.container && !linksource){
							cont = Game.getObjectById(creep.memory.container);
							if (!pos && cont && !creep.pos.isEqualTo(cont)){
									pullTo(cont, true);
							}
					}
					if (inPos){
							creep.isMoving = true;
							let blockHarvest = creep.store.getFreeCapacity()===0 && linksource;
							if (target && target.energy && !blockHarvest){
									creep.harvest(target);
							}
					} else if (!pos){
							creep.say('target');
							if (target && !creep.pos.isNearTo(target)){
									pullTo(target);
							} else if (creep.num > 2 || (creep.num > 1 && !creep.home.memory.s2)){
									creep.harvest(target);
							}
					}
					if (cont){
							manageReservations(cont, target.pos, creep);
					}
					let controller = homeRoom.controller;
					if (!linksource && controller.level > 5 && (Game.time + 10) % 100 == 0 && creep.pos.getRangeTo(controller) > 3){
							if (cont && creep.pos.isEqualTo(cont)){
									placeLink();
							}
					}
					if (target && target.energy == 0 && !cont){
							let time = target.ticksToRegeneration;
							if (target && target.effects && target.effects.length > 0){
									time = 5;
							}
							creep.startNap(time);
					}

			}

			function findPos(link, source){
					if (!link || !source){
							return
					}
					let n = source.pos.neighbours(1);
					for (let i in n){
							let ne = n[i];
							if (ne.isNearTo(link) && (ne.isWalkable() || ne.isEqualTo(creep.pos))){
									return ne
							}
					}
			}

			function placeLink(){
					if (mem && mem.link){
							homeRoom.createConstructionSite(mem.link.toPos(), STRUCTURE_LINK);

					}
			}
	}




	let spawnCode$h = {
			priority: (room, countFunction) => {
					let priority = 2;
					if (room.class === 'bunker'){
							priority = 5;
					}
					priority += countFunction('miner1', room) * 2;
					return priority
			},
			isRequired: (room, countFunction) => {
					let roleCount = countFunction('miner1', room);
					let numberRequired = 0;
					if (room.memory.armedHostiles){
							console.log('no miner, armed hostiles',room.hyperlink);
							return false
					}
					if (room.energyCapacityAvailable < 550 && (room.memory.s2 || config.weirdSources)){
							numberRequired = 4;
					} else if ((room.energyCapacityAvailable >= 550 && room.memory.s2) || (room.energyCapacityAvailable < 550 && !room.memory.s2)){
							numberRequired = 2;
					} else {
							numberRequired = 1;
					}
					if (roleCount < numberRequired){
							return true
					}
					return false
			},
			spawn: (room, role, body) => {
					//decide if we need any other options
					if (body){
							//options -> TTL, creepnumber
							room.spawnCreep(role, body);
					}
			},
			body: (room, countFunction) => {
					if (room.memory.roadsDown === undefined){
							room.memory.roadsDown = false;
					}
					let bodyObject = {
							body: [],
							cost: 0
					};
					//decide on what body to have
					if ((room.energyCapacityAvailable < 850 || countFunction('miner1', room) == 0) || (!room.storage || room.storage.store['energy'] < 1000 || countFunction("harvester", room) == 0 || room.controller.level < 4)){
							if (room.energyCapacityAvailable >= 650 && countFunction('miner1', room) > 0){
									bodyObject.body = [WORK, WORK, WORK, WORK, WORK, CARRY, CARRY, MOVE];
							} else if (room.energyCapacityAvailable >= 550 && countFunction('miner1', room) > 0){
									bodyObject.body = [WORK, WORK, WORK, WORK, WORK, CARRY];
							} else {
									bodyObject.body = [WORK, WORK, WORK];
									if (!room.memory.s2 || room.class === 'bunker'){
											bodyObject.body = [WORK, WORK, CARRY, MOVE];
											if (room.energyAvailable >= 350){
													bodyObject.body = [WORK,WORK,WORK,CARRY];
											}
									}
							}
					} else if (room.energyCapacityAvailable < 1250 || Game.cpu.bucket === 10000){
							bodyObject.body = [WORK, WORK, WORK, WORK, WORK, WORK, CARRY,MOVE,MOVE,MOVE];
					} else {
							bodyObject.body = [WORK, WORK, WORK, WORK, WORK, WORK, WORK, WORK, WORK, WORK, CARRY, CARRY];
							if (room.energyCapacityAvailable > 3000 && config.official && config.conserveCpu){
									bodyObject.body = [WORK, WORK, WORK, WORK, WORK, WORK, WORK, WORK, WORK, WORK,WORK, WORK, WORK, WORK, WORK,CARRY,CARRY,CARRY,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE];
							} else if (room.energyCapacityAvailable > 1500 && (config.official || config.conserveCpu)){
									bodyObject.body = [WORK, WORK, WORK, WORK, WORK, WORK, WORK, WORK, WORK, WORK, CARRY, CARRY,MOVE,MOVE,MOVE,MOVE];
							}
					}
					if (!room.memory.s2 && config.weirdSources && (countFunction('miner1', room) > 0 || room.energyAvailable === room.energyCapacityAvailable || (room.civList && room.civList.length > 5))){
							bodyObject.body = room.makeBody([WORK], false, {noMove: true, oneCarry: true, maxParts: 15});
					}
					if (room.controller.level === 1 && countFunction('miner1', room) < 2){
							bodyObject.body = [WORK, WORK];
					}
					if (bodyObject.body && bodyObject.body.length > 0){
							bodyObject.cost += Game.getBodyCost(bodyObject.body);
					}
					return bodyObject
			}
	};

	var miner1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$D,
		spawnCode: spawnCode$h
	});

	function run$C(creep){
			var mem = creep.home.memory.prayerSupportRoom;
			mem.roomName;
			var pSpawn = Game.spawns['pray' + creep.home.name];
			if (!pSpawn){
				return
			}
			if (!pSpawn.room.controller.my){
				creep.startNap(10);
				return
			}
			var route = pSpawn.room.memory.prayRoute;
			var stores = pSpawn.room.storage;
			var term = pSpawn.room.terminal;
			var lab = Game.getObjectById(pSpawn.room.memory.lab);
			//moving route so start is next to lab
			var route0 = route.slice(0, 5);
			var route1 = route.slice(5);
			var route = route1.concat(route0);
			//container
			if (pSpawn && pSpawn.room.controller.level < 6){
				var cont = creep.pos.findInRange(FIND_STRUCTURES, 1, {filter: (s) => s.structureType == STRUCTURE_CONTAINER && s.store['energy'] > 0})[0];
			} else {
				var stores = pSpawn.room.storage;
			}
			if (pSpawn && (pSpawn.room.controller.level === 8 && pSpawn.storage && pSpawn.storage.store['energy'] < 900000)){
				creep.memory.role = 'recycle';
			}
			//monknumber
			if (pSpawn.memory.monks){
				1200 / pSpawn.memory.monks;
			}
			if (creep.room.name != pSpawn.room.name || creep.pos.onEdge()){
				creep.goTo(pSpawn);
				return
			}
			if (pSpawn && route && route.length > 0){
				if (pSpawn.room.memory.monkOrder){
					let posNum = pSpawn.room.memory.monkOrder.findIndex((m) => m === creep.id);
					if (!posNum && posNum !== 0 || posNum === -1){
						pSpawn.room.memory.monkOrder.splice(3, 0, creep.id);
						return
					}
					if (!route[posNum]){
						//pSpawn.room.memory.monkOrder.push(creep.id)
						return
					}
					let pos = pSpawn.room.getPositionAt(route[posNum].x, route[posNum].y);
					let boostdir = pSpawn.room.controller.pos.getDirectionTo(pSpawn);
					let boostPos;
					if (boostdir){
						boostPos = pSpawn.pos.movePos(boostdir);
						boostPos = boostPos.movePos(boostdir);
					}
					if (boostPos && creep.pos.isEqualTo(boostPos)){
						if (!creep.memory.boosted && creep.ticksToLive > 1410){
							if (creep.room.controller.level > 5 && lab && lab.store[lab.mineralType] > 300 && lab.store['energy'] > 150 && term && (term.store['energy'] + stores.store['energy']) > 40000){
								lab.boostCreep(creep);
								creep.memory.boosted = true;
							}
						}
					}
					new RoomVisual(creep.room.name).text(posNum, pos);
					creep.moveTo(pos, {maxRooms: 1});
					if (posNum === 0 && creep.pos.isEqualTo(pos)){
						if (creep.home.memory.prayerSupportRoom.monkNum >= creep.num){
							if ((creep.ticksToLive < 1420 && (!creep.memory.boosted || creep.room.controller.level < 6)) || (creep.ticksToLive < 300 && creep.memory.boosted) && pSpawn.store['energy'] > 0){
								pSpawn.renewCreep(creep);
								delete creep.memory.boosted;
							}
						}
						if (pSpawn.room.controller.level < 4 || !pSpawn.room.storage){
							let structs = creep.pos.lookFor(LOOK_STRUCTURES);
							let container = null;
							if (structs.length > 0 && structs[0] && structs[0].structureType == STRUCTURE_CONTAINER){
								container = structs[0];
							} else if (structs.length > 1 && structs[1] && structs[1].structureType == STRUCTURE_CONTAINER){
								container = structs[1];
							} else {
								if (creep.pos.lookFor(LOOK_CONSTRUCTION_SITES).length == 0){
									creep.pos.createConstructionSite(STRUCTURE_CONTAINER);
								} else {
									creep.build(creep.pos.lookFor(LOOK_CONSTRUCTION_SITES)[0]);
								}
							}
							if (container && container.hits < container.hitsMax * 0.8){
								creep.repair(container);
							}
						}
					}
					//withdraw
					if (cont && _.sum(creep.store) < creep.store.getCapacity()){
						creep.withdraw(cont, 'energy');
					} else if (stores && creep.pos.isNearTo(stores) && _.sum(creep.store) < creep.store.getCapacity() && stores.store['energy'] > 0){
						creep.withdraw(stores, RESOURCE_ENERGY);
					} else if (term && creep.pos.isNearTo(term) && _.sum(creep.store) < creep.store.getCapacity() && term.store['energy'] > 0){
						creep.withdraw(term, 'energy');
					}
					//upgrade
					if ((!term || !lab) && pSpawn.room.controller.level > 5 && creep.pos.findInRange(FIND_CONSTRUCTION_SITES, 3).length > 0){
						var site = creep.pos.findInRange(FIND_CONSTRUCTION_SITES, 3)[0];
						creep.build(site);
					} else if (creep.store['energy'] > 0){
						let site = Game.getObjectById('5e6d09f413766c55b4ef6a1b');
						creep.build(site);
						creep.upgradeController(pSpawn.room.controller);
					}
				}
			}
		}

	var monk = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$C
	});

	function run$B(creep){
			let homeRoom;
			if (creep.memory.homeRoom && Game.rooms[creep.memory.homeRoom]){
					homeRoom = Game.rooms[creep.memory.homeRoom];
			}
			if (!homeRoom){
					homeRoom = creep.home;
			}
			if (spawnManager && countRole('harvester', creep.home) < 1 &&
					(creep.store.getUsedCapacity() === 0 || creep.store.getUsedCapacity() === creep.store['energy'])){
					creep.memory.role = 'harvester';
					creep.say('harvmem');
					return
			}
			var homeRoomName = homeRoom.name;
			var total = creep.store.getUsedCapacity();
			var roommin = homeRoom.memory.min;
			let term = homeRoom.terminal;
			var nuker = Game.getObjectById(homeRoom.memory.nuker);
			let stores = homeRoom.storage;
			if (term && term.effects){
					for (let i in term.effects){
							if (term.effects[i].effect === 15){
									//terminal disrupted
									term = undefined;
									break
							}
					}
			}
			if (creep.pos.onEdge()){
					creep.moveTo(homeRoom.controller);
					return
			}
			new RoomVisual(creep.room.name).text('M', creep.pos);
			let ps = Game.getObjectById(homeRoom.memory.powerspawn);
			let loadPS = true;
			if (ps && creep.home.memory.transferPos){
					let tPos = creep.home.memory.transferPos.toPos();
					if (tPos && ps.pos.isNearTo(tPos)){
							loadPS = false;
					}
			}
			let boostlab;
			let boostmin;
			let needMoreSafeMode = false;
			if (creep.home && creep.home.controller && (!creep.home.controller.safeModeAvailable || creep.home.controller.safeModeAvailable < 2) &&
					(!creep.home.memory.armedHostiles || creep.home.controller.safeMode)
					&& ((creep.store['G'] && creep.store['G'] >= SAFE_MODE_COST) || creep.home.total('G') >= SAFE_MODE_COST)){
					needMoreSafeMode = true;
					console.log(creep.home.name, 'need new safe mode', creep.home.controller.safeModeAvailable);
			}
			if (homeRoom && homeRoom.memory.restructuring){
					if (creep.ticksToLive < 100 && creep.store.getUsedCapacity() === 0){
							creep.suicide();
					}
					if (creep.store.getFreeCapacity() === 0){
							delete creep.memory.pickingUp;
					} else if (creep.store.getUsedCapacity() === 0){
							creep.memory.pickingUp = true;
					}
					if (homeRoom.memory.emptyRestruct && Game.getObjectById(homeRoom.memory.emptyRestruct) && homeRoom.memory.fillRestruct && Game.getObjectById(homeRoom.memory.fillRestruct)){
							let empty = Game.getObjectById(homeRoom.memory.emptyRestruct);
							let fill = Game.getObjectById(homeRoom.memory.fillRestruct);
							if (creep.memory.pickingUp){
									creep.goAndWithdraw(empty);
							} else {
									creep.goAndTransfer(fill);
							}
					} else if (!creep.memory.pickingUp && homeRoom.memory.fillRestruct && Game.getObjectById(homeRoom.memory.fillRestruct)){
							let fill = Game.getObjectById(homeRoom.memory.fillRestruct);
							creep.goAndTransfer(fill);
					} else if (creep.memory.pickingUp){
							let drops = Game.getObjectById(homeRoom.memory.drops);
							let conts = Game.getObjectById(homeRoom.memory.conts);
							let conts1 = Game.getObjectById(homeRoom.memory.conts1);
							if (creep.num === 2 && conts1){
									creep.goAndWithdraw(conts1, 'energy');
							} else if (conts){
									creep.goAndWithdraw(conts, 'energy');
							} else if (conts1){
									creep.goAndWithdraw(conts1, 'energy');
							} else if (drops){
									creep.goAndPickup(drops);
							}
					} else if (homeRoom.storage){
							creep.goAndTransfer(homeRoom.storage);
					}
					return
			}
			let toClearList = [];
			if (homeRoom.memory.blabs && homeRoom.memory.boostLabs){
					for (let min in homeRoom.memory.boostLabs){
							if (min === 'list'){
									continue
							}
							let bl = Game.getObjectById(homeRoom.memory.boostLabs[min]);
							if (bl && min && bl.mineralType && bl.mineralType !== min &&
									(creep.store.getUsedCapacity()=== 0 || creep.store[bl.mineralType])){
									toClearList.push(bl);
							}
							if (!boostlab && bl && min && (homeRoom.total(min) > 0 || creep.store[min]) && ((homeRoom.terminal && homeRoom.terminal.store[min]>0) ||
									(homeRoom.storage && homeRoom.storage.store[min] > 0) || (creep.store[min] && creep.store[min]> 0))){
									if (((bl.mineralType == min && bl.store[min] < 2700)
											|| !bl.store[min] || bl.mineralType != min)){
											boostlab = bl;
											boostmin = min;
									}
							}
					}
			}
			if (!boostlab && homeRoom.memory.sblabs && homeRoom.memory.sboostlab){
					for (let i in homeRoom.memory.sboostlab){
							let bl;
							if (homeRoom.memory.sboostlab[i]){
									bl = Game.getObjectById(homeRoom.memory.sboostlab[i]);
							}
							if (bl && i && bl.mineralType && bl.mineralType !== i &&
									(creep.store.getUsedCapacity()=== 0 || creep.store[bl.mineralType])){
									toClearList.push(bl);
							}
							if (bl && ((homeRoom.total(i) > 500 && homeRoom.terminal && homeRoom.terminal.store[i] > 0) || (creep.store[i] && creep.store[i]> 0))){
									if (((bl.mineralType == i && bl.store[i] < 2700)
											|| !bl.store[i] || bl.mineralType != i)){
											boostlab = bl;
											boostmin = i;
											break
									}
							}
					}
			}
			let room = homeRoom;
			var product = homeRoom.memory.product;
			var r1 = homeRoom.memory.r1;
			var r2 = homeRoom.memory.r2;
			var conts = Game.getObjectById(homeRoom.memory.resconts);
			if (room.memory.armedHostiles){
					conts = undefined;
			}
			var r1lab = Game.getObjectById(homeRoom.memory.r1lab);
			var r2lab = Game.getObjectById(homeRoom.memory.r2lab);
			creep.home.display(`reaction ${r1} ${r1lab} ${r2} ${r2lab} ${product}`);
			let unBoostCont;
			let boostPoint;
			if (homeRoom.storage){
					boostPoint = homeRoom.getPositionAt(homeRoom.storage.pos.x, homeRoom.storage.pos.y + 5);
			}
			if (homeRoom.memory.labPoint){
					boostPoint = homeRoom.memory.labPoint.toPos();
			}
			if (creep.home.isShardTradeRoom && boostPoint){
					unBoostCont = boostPoint.lookAround(LOOK_STRUCTURES, 0, {filter: (s) => s.structureType == STRUCTURE_CONTAINER})[0];
			}
			//for retreating if outside walls
			Game.flags['RP' + homeRoomName];
			Memory.visited[homeRoomName];
			var emptyLabs = false;

			//symbol
			let symbolType, decoderPos;
			if (creep.ticksToLive > 100 && config.symbolCollection && creep.home.controller.level > 7 && !creep.home.armedHostiles
					&& creep.home.memory.defcon == 5){
					let mem = Memory.symbolDecoders;
					if (mem && mem[creep.home.name]){
							symbolType = mem[creep.home.name].type;
							decoderPos = mem[creep.home.name].pos.toPos();
					}
			}
			if (!creep.home.armedHostiles && creep.memory.runAsHarvester && creep.memory.runAsHarvester > Game.time){
					creep.say('harv');
					run$H(creep);
					return
			}
			if (!creep.home.armedHostiles && creep.memory.runAsPuller && (creep.memory.runAsPuller > Game.time || creep.memory.pullee)){
					creep.say('pull');
					run$J(creep);
					return
			} else {
					creep.stopPulling();
			}
			let lowEnergyLab = Game.getObjectById(homeRoom.memory.lab);
			let tower = Game.getObjectById(homeRoom.memory.towers);
			let energyDrop;
			if (tower != null && tower.store['energy'] < 600){
					energyDrop = tower;
			} else if (lowEnergyLab && lowEnergyLab.store['energy'] < lowEnergyLab.store.getCapacity('energy') * 0.8){
					energyDrop = lowEnergyLab;
			} else if (!Memory.energyCrisis && nuker && !boostlab && (!toClearList || toClearList.length === 0) && nuker.store['energy'] < NUKER_ENERGY_CAPACITY && (room.total('energy') > room.memory.reserve * 1.1 || (room.total('energy') > room.memory.reserve * 0.8 && config.bombard && config.bombard.length > 0))){
					energyDrop = nuker;
			}
			if (creep.num !== 1){
					energyDrop = null;
			}
			if (energyDrop && creep.store.getFreeCapacity() == creep.store.getCapacity()){
					creep.goAndWithdraw(homeRoom.storage, 'energy');
					creep.say('energyCollect');
					return
			} else if (energyDrop && creep.store['energy'] > 0){
					creep.say('energyDrop');
					new RoomVisual(creep.room.name).line(creep.pos, energyDrop.pos);
					creep.goAndTransfer(energyDrop, 'energy');
					return
			}

			if (creep.num === 1 && (!homeRoom.memory.blabs || homeRoom.memory.blabs.length == 0) && homeRoom.controller.level < 7 && homeRoom.storage && homeRoom.terminal && product && creep.ticksToLive > 50
					&& (!conts || (_.sum(conts.store) < 1500) || (_.sum(conts.store) < 1500 && room.memory.labCycle && (room.memory.labCycle.ready || room.memory.labCycle.react)))){
					creep.say('cycle');
					let room = homeRoom;
					if (!room.memory.labCycle){
							room.memory.labCycle = {};
					}
					let mem = room.memory.labCycle;
					if (!mem.product){
							mem.product = product;
					}
					if (product != mem.product){
							delete mem.react;
							delete mem.ready;
							delete mem.product;
							return
					}
					let terminal = homeRoom.terminal;
					let labPoint = homeRoom.getPositionAt(homeRoom.storage.pos.x, homeRoom.storage.pos.y + 5);
					if (labPoint && r1lab && r2lab && term){
							if (room.memory.labPoint){
									labPoint = room.memory.labPoint.toPos();
							}
							if (mem.react){
									creep.say('react');
									if (creep.pos.isEqualTo(labPoint)){
											let labs = creep.pos.lookAround(LOOK_STRUCTURES, 1, {filter: (s) => s.structureType == STRUCTURE_LAB});
											for (let i in labs){
													let lab = labs[i];
													if (!lab){
															continue
													}
													//withdraw r labs if wrong
													if (lab.id == r1lab.id){
															if (lab.store[lab.mineralType] > 0 && lab.mineralType != r1){
																	let withdraw = creep.withdraw(lab, lab.mineralType);
																	if (withdraw === 0){
																			return
																	}
															}
															continue
													}
													if (lab.id == r2lab.id){
															if (lab.store[lab.mineralType] > 0 && lab.mineralType != r2){
																	let withdraw = creep.withdraw(lab, lab.mineralType);
																	if (withdraw === 0){
																			return
																	}
															}
															continue
													}
													//withdraw all product labs
													if (lab.store[lab.mineralType] > 0){
															let withdraw = creep.withdraw(lab, lab.mineralType);
															if (withdraw === 0){
																	return
															}
													}
											}
											//deposit r labs
											if (creep.store[r1]){
													creep.transfer(r1lab, r1);
													return
											}
											if (creep.store[r2]){
													creep.transfer(r2lab, r2);
													return
											}
											//reset if no reactant

											if (creep.store[r2] === 0 && creep.store[r1] === 0 && ((!r1lab.mineralType || r1lab.mineralType !== r1)
													|| (!r2lab.mineralType || r2lab.mineralType !== r2) || r1lab.store[r1lab.mineralType] < 5 || r2lab.store[r2lab.mineralType] < 5)){
													delete mem.react;
													creep.pos.highlight('red');
											}
											let totalDersiredComps = creep.store.getUsedCapacity(r1) + creep.store.getUsedCapacity(r2) + creep.store.getUsedCapacity(product);
											let totalSpaceUsed = creep.store.getUsedCapacity();
											if (totalDersiredComps < totalSpaceUsed){
													//have something we dont want in the creep store
													delete mem.react;
													creep.pos.highlight('red');
											}
											return
									} else {
											creep.moveTo(labPoint, {range: 0});
											return
									}
							} else {
									//get carryCap of reactants
									if (!mem.ready){
											creep.say('clear labs');
											if (creep.store.getUsedCapacity() > 0){
													for (let i in creep.store){
															creep.goAndTransfer(homeRoom.terminal, i);
													}
													return
											}
											//empty labs
											let fullLabs = creep.room.find(FIND_STRUCTURES, {
													filter: (s) => s.structureType == STRUCTURE_LAB && s.store[s.mineralType] > 0 &&
															((!room.memory.blabs || !room.memory.blabs.includes(s.id)) && (!room.memory.sblabs || !room.memory.sblabs.includes(s.id)))
											});
											if (fullLabs.length > 0){
													creep.goAndWithdraw(fullLabs[0], fullLabs[0].mineralType);
													return
											}
											mem.ready = true;
									} else {
											let am = creep.store.getCapacity() / 2;
											if (creep.store.getUsedCapacity() > 0 && !creep.store[r1] && !creep.store[r2]){
													delete room.memory.product;
													delete room.memory.labCycle;
													delete room.memory.react;
											}
											if ((!creep.store[r1] || !creep.store[r2]) && creep.store.getFreeCapacity() === 0){
													delete room.memory.product;
													delete room.memory.labCycle;
													delete room.memory.react;
											}
											if (!creep.store[r1] && terminal.store[r1] && terminal.store[r1] >= am){
													creep.say('coll cy0');
													creep.goAndWithdraw(terminal, r1,1, am);
													return
											}
											if (!creep.store[r2] && terminal.store[r2] && terminal.store[r1] >= am){
													creep.say('coll cy1');
													creep.goAndWithdraw(terminal, r2,1, am);
													return
											}
											if (terminal.store[r1] < am || terminal.store[r2] < am){
													console.log('mover delete cycle');
													delete room.memory.product;
													delete room.memory.labCycle;
											}
											//set memory to react & delete ready
											mem.react = true;
											delete mem.ready;
											return
									}
							}
					}
			}
			if (creep.home.memory.clearing || emptyLabs === true){
					creep.say('clear');
					let message = 'Ghosts room';
					if (creep.room.controller && creep.room.controller.sign.text != message){
							if (creep.pos.isNearTo(creep.room.controller)){
									console.log(creep.signController(creep.room.controller, message), message);
							} else {
									creep.moveTo(creep.room.controller);
							}
					} else {
							if (_.sum(creep.store) === 0){
									delete creep.memory.dropping;
							} else if (_.sum(creep.store) === creep.store.getCapacity()){
									creep.memory.dropping = true;
							}

							if (creep.memory.dropping){
									creep.goAndTransfer(term);
							} else {

									var lab = creep.room.find(FIND_STRUCTURES, {filter: (s) => s.structureType == STRUCTURE_LAB && s.store[s.mineralType] > 0})[0];
									if (lab){
											creep.goAndWithdraw(lab, lab.mineralType);
									}
							}
					}
			} else {
					if (creep.ticksToLive < 50){
							if (total > 0){
									for (let i in creep.carry){
											creep.goAndTransfer(stores, i);
									}
							} else {
									creep.memory.reason = 'elderly';
									creep.memory.role = 'recycle';
							}
					} else {
							if (creep.memory.dropping && total == 0){
									creep.memory.dropping = false;
									creep.say('collecting');
							}
							if (!creep.memory.dropping && total == creep.store.getCapacity()){
									creep.memory.dropping = true;
									creep.say('dropping');
							}
							if (creep.memory.dropping){
									creep.say('drop');
									if (symbolType && creep.store[symbolType] > 0){
											let decoder = decoderPos.lookAround(LOOK_SYMBOL_DECODERS, 0)[0];
											creep.goAndTransfer(decoder, symbolType, 1);
									}
									if (Object.values(creep.store).length > 1){
											var dest = stores;
									} else if (creep.store['energy']){
											if (Memory.priority === 'power' && loadPS && creep.home.memory.canLoadPowerSpawn && !homeRoom.memory.activeSiege && (ps && ps.store['energy'] < ps.store.getCapacity('energy') * 0.9) && homeRoom.memory.defcon > 4){
													var dest = ps;
											} else if (stores){
													var dest = stores;
											}
									} else if (creep.store['G'] && creep.store['G'] >= SAFE_MODE_COST && needMoreSafeMode){
											if (creep.pos.isNearTo(creep.home.controller)){
													creep.generateSafeMode(creep.home.controller);
											} else {
													creep.moveTo(creep.home.controller, {range: 1});
											}
											return
									} else if (creep.store[RESOURCE_POWER]){
											if (ps && ps.store['power'] < ps.store.getCapacity('power') * 0.5 && homeRoom.memory.defcon > 4){
													creep.goAndTransfer(ps, RESOURCE_POWER);
											} else if (stores && stores.store.getUsedCapacity() < stores.store.getCapacity()){
													creep.goAndTransfer(stores, RESOURCE_POWER);
											} else if (term && term.store.getUsedCapacity() < term.store.getCapacity()){
													creep.goAndTransfer(term, RESOURCE_POWER);
											}
									} else if (homeRoom.controller && homeRoom.controller.level == 8 && creep.store['G'] && nuker && nuker.store['G'] < nuker.store.getCapacity('G')){
											var dest = nuker;
									} else if (boostlab && boostmin && ((boostlab.mineralType == boostmin && boostlab.store[boostlab.mineralType] < 2700) || !boostlab.store[boostlab.mineralType]) && creep.store[boostmin]){
											var dest = boostlab;
									} else if (r1lab && ((r1lab.mineralType == r1 && r1lab.store[r1lab.mineralType] < 2000) || !r1lab.store[r1lab.mineralType]) && creep.store[r1] && creep.room.controller.level > 6){
											var dest = r1lab;
									} else if (r2lab && ((r2lab.mineralType == r2 && r2lab.store[r2lab.mineralType] < 2000) || !r2lab.store[r2lab.mineralType]) && creep.store[r2] && creep.room.controller.level > 6){
											var dest = r2lab;
									} else if (term && (!stores || term.pos.getRangeTo(creep) <= stores.pos.getRangeTo(creep))  && term.store.getFreeCapacity()>25000){
											var dest = term;
									} else {
											var dest = stores;
									}
									if (dest){
											creep.say(dest.structureType);
									}
									creep.goAndTransfer(dest);
							} else {
									let tomb = null;
									//tomb cache so as to save on finds
									if (creep.memory.tomb && !room.memory.hostiles){
											let tombObj = Game.getObjectById(creep.memory.tomb);
											if (tombObj && _.sum(tombObj.store) > 100){
													tomb = tombObj;
											} else {
													//finding a new tomb once the old one expires
													let tombObj = creep.room.find(FIND_TOMBSTONES, {filter: (t) => t.store.getUsedCapacity() > 0 && (!t.store['energy'] || t.store['energy'] > 200|| t.store['energy'] !== t.store.getUsedCapacity())})[0];
													if (tombObj){
															creep.memory.tomb = tombObj.id;
													} else {
															delete creep.memory.tomb;
													}
											}
									} else if (Game.time % 20 == 0){
											let tombObj = creep.room.find(FIND_TOMBSTONES, {filter: (t) => t.store.getUsedCapacity() > 0 && (!t.store['energy']  || t.store['energy'] > 50 || t.store['energy'] !== t.store.getUsedCapacity())})[0];
											if (tombObj){
													creep.memory.tomb = tombObj.id;
											}
									}
									let drops = Game.getObjectById(homeRoom.memory.dropres);
									let plabs = homeRoom.memory.plabs;
									let plist = [];
									let plab;
									if (plabs && plabs.length > 0){
											for (let i = 0; i < plabs.length; i++){
													plist.push(Game.getObjectById(plabs[i]));
											}
									}
									for (let i = 0; i < plist.length; i++){
											if (plist[i].store[plist[i].mineralType] > 200 || (plist[i].mineralType != product && plist[i].store[plist[i].mineralType] > 0)){
													plab = plist[i];
													break
											}
									}
									let clearLab;
									if (toClearList && toClearList.length > 0){
											clearLab = toClearList[0];
									}
									if (total == 0 && unBoostCont && unBoostCont.store.getUsedCapacity() > 0){
											creep.say('ub');
											for (let b in unBoostCont.store){
													creep.goAndWithdraw(unBoostCont, b);
											}
									} else if (clearLab){
											creep.say('clearlab');
											console.log('clear lab',creep.room.name,Game.time);
											creep.goAndWithdraw(clearLab, clearLab.mineralType);
									} else if (total == 0 && (boostlab && boostmin && ((boostlab.mineralType == boostmin && boostlab.store[boostlab.mineralType] < 2700) || !boostlab.mineralType
													|| !boostlab.store[boostlab.mineralType])) && homeRoom.total(boostmin) > 0
											&& ((term && term.store[boostmin] > 0) || (stores && stores.store[boostmin] > 0))){
											creep.say('boostmin');
											if (term && term.store[boostmin] > 0){
													creep.goAndWithdraw(term, boostmin);
											} else if (stores && stores.store[boostmin] > 0){
													creep.goAndWithdraw(stores, boostmin);
											}
									} else if (symbolType && term && creep.home.terminal && creep.home.terminal.store[symbolType] > creep.store.getCapacity()){
											creep.say('symbol');
											creep.goAndWithdraw(creep.home.terminal, symbolType, 1);
									} else if (total === 0 && needMoreSafeMode && term && term.store['G'] >= SAFE_MODE_COST){
											creep.say('G');
											creep.goAndWithdraw(term, 'G', 1);
									} else if (total == 0 && conts != null && conts.store[roommin] > 1300 && !room.memory.armedHostiles){
											if (creep.home.memory.labCycle){
													delete creep.home.memory.labCycle.ready;
													delete creep.home.memory.labCycle.react;
											}
											creep.say('min');
											creep.goAndWithdraw(conts, roommin);
									} else if (Memory.priority == 'power' && total == 0 && term && loadPS &&
											((ps && ps.store['power'] < ps.store.getCapacity('power') * 0.5)) && term.store[RESOURCE_POWER] && homeRoom.memory.defcon > 4){
											creep.say('term p');
											creep.goAndWithdraw(term, 'power');
									} else if (Memory.priority == 'power' && total == 0 && stores && loadPS &&
											((ps && ps.store['power'] < ps.store.getCapacity('power') * 0.5)) && stores.store[RESOURCE_POWER] && homeRoom.memory.defcon > 4){
											creep.say('stores p');
											creep.goAndWithdraw(stores, 'power');
									}else if (Memory.priority == 'power' && !homeRoom.memory.activeSiege && total == 0 && stores && ((ps && ps.store['energy'] < ps.store.getCapacity('energy') * 0.8))
											&& homeRoom.memory.reserve && stores.store['energy'] > homeRoom.memory.reserve * 0.8 && loadPS && homeRoom.memory.canLoadPowerSpawn){
											creep.say('stores e');
											creep.goAndWithdraw(stores, 'energy');
									} else if ((total == 0 || (plab && creep.store[plab.mineralType] > 0 && plab.store[plab.mineralType] > 0)) && (plab != null)){
											creep.say('plab');
											creep.goAndWithdraw(plab, plab.mineralType);
									} else if (tomb && !creep.room.memory.hostiles){
											creep.say('tomb');
											if (creep.pos.isNearTo(tomb)){
													for (let i in tomb.store){
															creep.withdraw(tomb, i);
													}
											} else {
													creep.moveTo(tomb);
											}

									} else if (total == 0 && r1lab && r1lab.mineralType != r1 && r1lab.store[r1lab.mineralType] > 0 && creep.room.controller.level > 6){
											creep.say('r1lab');
											creep.goAndWithdraw(r1lab, r1lab.mineralType);
									} else if (total == 0 && r2lab && r2lab.mineralType != r2 && r2lab.store[r2lab.mineralType] > 0 && creep.room.controller.level > 6){
											creep.say('r2lab');
											creep.goAndWithdraw(r2lab, r2lab.mineralType);
									} else if (term && homeRoom.controller.level == 8 && total == 0 && nuker && nuker.store['G'] < nuker.store.getCapacity('G') && term.store[RESOURCE_GHODIUM]){
											creep.say('G');
											creep.goAndWithdraw(term, 'G');
									} else if (total == 0 && (r1lab && (r1lab.mineralType == r1 && r1lab.store[r1lab.mineralType] < 2000 || !r1lab.store[r1lab.mineralType])) && homeRoom.total(r1) > 0
											&& ((term && term.store[r1] > 0) || (stores && stores.store[r1] > 0)) && creep.room.controller.level > 6){
											creep.say('r1');
											if (term && term.store[r1] > 0){
													creep.goAndWithdraw(term, r1);
											} else if (stores && stores.store[r1] > 0){
													creep.goAndWithdraw(stores, r1);
											}
									} else if (total == 0 && (r2lab && (r2lab.mineralType == r2 && r2lab.store[r2lab.mineralType] < 2000 || !r2lab.store[r2lab.mineralType])) && homeRoom.total(r2) > 0
											&& ((term && term.store[r2] > 0) || (stores && stores.store[r2] > 0)) && creep.room.controller.level > 6){
											creep.say('r2');
											if (term && term.store[r2] > 0){
													creep.goAndWithdraw(term, r2);
											} else if (stores && stores.store[r2] > 0){
													creep.goAndWithdraw(stores, r2);
											}
									} else if (total == 0 && term && ((ps && ps.store['power'] < ps.store.getCapacity('power') * 0.5)) && term.store[RESOURCE_POWER] && homeRoom.memory.defcon > 4){
											creep.say('term p');
											creep.goAndWithdraw(term, 'power');
									} else if (total == 0 && stores && (ps && ps.store['power'] < ps.store.getCapacity('power') * 0.5) && stores.store[RESOURCE_POWER] && homeRoom.memory.defcon > 4){
											creep.say('stores p');
											creep.goAndWithdraw(stores, 'power');
									} else if (total == 0 && drops && !room.memory.hostiles){
											creep.say('drops');
											creep.goAndPickup(drops);
									} else if (total > 0){
											creep.say('drop');
											creep.memory.dropping = true;
									} else if (!room.memory.product && !room.memory.boostingRequired){
											creep.memory.runAsPuller = Game.time+10;
									} else {
											creep.say('z');
											creep.startNap(5);
									}
							}
					}
			}
	}


	let spawnCode$g = {
			priority: (room, countFunction) => {
					let priority = 55;
					if (room.memory.boostingRequired || room.memory.defcon < 4 || room.class === 'restructuring' || Game.flags['defend' + room.name]){
							priority = 15;
					} else if ((config.season && config.season === 'power' && !room.memory.fixedBaseOrigin) || room.memory.product || room.memory.boostingRequired || (room.memory.resconts && Game.getObjectById(room.memory.resconts) && Game.getObjectById(room.memory.resconts).store.getFreeCapacity() < 500)){
							priority = 40;
					} else if (room.memory.product){
							priority = 45;
					}
					return priority
			},
			isRequired: (room, countFunction) => {
					let numberRequired = 0;
					if (room.terminal || (room.controller.level > 5 && room.memory.armedHostiles) || (room.controller.level > 4 && room.total('power') > 0 && config.season === 'power')){
							numberRequired = 1;
					}
					if (room.class === 'restructuring' || Game.flags['defend' + room.name]){
							numberRequired = 2;
					}
					if (!room.ecoStable && !Game.flags['defend' + room.name] && !room.memory.boostingRequired && (!room.memory.alert || room.memory.alert !== 'high')
							&& (!room.memory.armedHostiles || room.justInvader) && room.memory.defcon === 5){
							numberRequired = 0;
					}
					if (room.controller.level < 7 || !room.ecoStable){
							numberRequired = 0;
					}
					if (numberRequired === 0 && (room.memory.boostingRequired || room.memory.armedHostiles || room.memory.defcon < 5
					|| room.memory.product || countFunction('Mminer',room)>0)){
							numberRequired = 1;
					}
					return countFunction('mover', room) < numberRequired;
			},
			spawn: (room, role, body) => {
					//decide if we need any other options
					if (body){
							//options -> TTL, creepnumber
							room.spawnCreep(role, body);
					}
			},
			body: (room, countFunction) => {
					if (room.memory.roadsDown === undefined){
							room.memory.roadsDown = false;
					}
					let key = room.energyCapacityAvailable + ':' + room.memory.roadsDown +':'+room.memory.boostingRequired;
					if (getCachedBody('mover',key)){
							return getCachedBody('mover',key)
					}
					let bodyObject = {
							body: [],
							cost: 0
					};
					let max = 50;
					if (room.controller.level < 6){
							max = 5;
					} else if (room.controller.level === 6){
							max = 15;
					} else if (room.controller.level === 7){
							max = 20;
					} else if (room.controller.level === 8 || (config.season && config.season === 'power')){
							max = 30;
					}
					if (!Memory.emergency && !room.memory.boostingRequired && max > 20){
							max = 20;
					}
					//decide on what body to have
					bodyObject.body = room.makeBody([CARRY], true, {maxParts: max});

					if (bodyObject.body && bodyObject.body.length > 0){
							bodyObject.cost += Game.getBodyCost(bodyObject.body);
					}
					cacheBody('mover',key,bodyObject);
					return bodyObject
			}
	}

	;

	var mover = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$B,
		spawnCode: spawnCode$g
	});

	let generatedLists = {};
	function run$A(creep){
			//todo cheaper random room selection
			if (checkBlockLowPrioritySquads() && Game.cpu.bucket < 2000){
					return
			}
			let mem = creep.home.memory.observeStatus;
			let target = creep.home.memory.currentObserveRoom;
			if (config.mapVisual){
					let text = `obs ${creep.num}`;
					Game.map.visual.text(text, creep.pos, {fontSize: 5});
			}
			if (!creep.memory.enteredRoomTime || (Game.time - creep.memory.enteredRoomTime) > 100){
					delete creep.memory.target;
					delete creep.memory.room;
			}
			let farObserver = false;
			if (creep.num.length > 2){
					target = creep.num;
					if (!Memory.lastObserved){
							Memory.lastObserved = {};
					}
					mem = Memory.lastObserved;
					farObserver = true;
					if (creep.memory.room === target){
							creep.suicide();
					}
			} else if (creep.num > 1 || config.highwayWalls || config.conserveCpu){
					if (!creep.memory.target && creep.home.memory.observeStatus){
							if (config.conserveCpu){
									let roomOptions = Game.map.describeExits(creep.room.name);
									let memlist = [];
									//weight rooms we havent observed in a while to be picked more often
									for (let i in roomOptions){
											let time = Game.time - creep.home.memory.observeStatus[roomOptions[i]];
											let numberToInsert = Math.ceil(time/1000);
											if (numberToInsert > 5){
													numberToInsert = 5;
											}
											while (numberToInsert > 0){
													numberToInsert--;
													memlist.push(roomOptions[i]);
											}
									}
									let random = Math.floor(Math.random() * memlist.length);
									let newRoom = memlist[random];
									if (newRoom){
											if (config.highwayWalls){
													let sector = Game.map.getSector(newRoom);
													if (sector != Game.map.getSector(creep.home.name) && Game.map.getRoomType(newRoom) != 'highway'){
															newRoom = undefined;
													}
											}
											if (Game.map.getRoomStatus(newRoom) !== 'normal'){
													newRoom = undefined;
											}
											creep.memory.target = newRoom;
									}
							} else {
									let memlist = [];
									if (generatedLists[creep.home.name] && generatedLists[creep.home.name].expiry> Game.time){
											memlist = generatedLists[creep.home.name].list;
									} else {
											//weight rooms we havent observed in a while to be picked more often
											for (let i in creep.home.memory.observeStatus){
													let time = Game.time - creep.home.memory.observeStatus[i];
													let numberToInsert = Math.ceil(time/1000);
													if (numberToInsert > 5){
															numberToInsert = 5;
													}
													while (numberToInsert > 0){
															numberToInsert--;
															memlist.push(i);
													}
											}
											generatedLists[creep.home.name] = {expiry: Game.time + 200,list:memlist};
									}
									let random = Math.floor(Math.random() * memlist.length);
									let newRoom = memlist[random];
									if (newRoom){
											if (config.highwayWalls){
													let sector = Game.map.getSector(newRoom);
													if (sector != Game.map.getSector(creep.home.name) && Game.map.getRoomType(newRoom) != 'highway'){
															newRoom = undefined;
													}
											}
											creep.memory.target = newRoom;
									}
							}
					}
					if (creep.memory.target){
							target = creep.memory.target;
					}
			}
			if (!target){
					if (creep.room.name === creep.home.name){
							creep.rally(1, 5);
					} else {
							creep.startNap(10);
					}
					return
			} else {
					creep.say(target);
			}
			if (creep.room.name != target){
					creep.goTo(target, {SK: true});
			} else if (creep.memory.target){
					delete creep.memory.target;
					delete creep.memory.move;
			}
			if (!creep.memory.room){
					creep.memory.room = creep.room.name;
					creep.memory.enteredRoomTime = Game.time;
			}
			if (!mem){
					return
			}
			if (creep.memory.room != creep.room.name && (!mem[creep.room.name] || (Game.time - mem[creep.room.name])>500)){
					if (!farObserver){
							evaluateRoom(creep.room, creep.home);
					}
					mem[creep.room.name] = Game.time;
					creep.memory.room = creep.room.name;
					creep.memory.enteredRoomTime = Game.time;
			}
	}



	let spawnCode$f = {
			priority: (room, countFunction) => {
					let priority = 30;
					if ((config.scouts === false) || config.official || room.controller.level > 7){
							return false
					}
					return priority
			},
			isRequired: (room, countFunction) => {
					let numberRequired = 2;
					if (Memory.myRooms.length < 3){
							numberRequired = 3;
					} else if (config.conserveCpu){
							numberRequired = 1;
					}
					if (room.controller.level === 8){
							return false
					}
					return countFunction('observer', room) < numberRequired;
			},
			spawn: (room, role, body) => {
					//decide if we need any other options
					if (body){
							//options -> TTL, creepnumber
							room.spawnCreep(role, body);
					}
			},
			body: (room, countFunction) => {
					if (room.memory.roadsDown === undefined){
							room.memory.roadsDown = false;
					}
					let bodyObject = {
							body: [],
							cost: 0
					};
					//decide on what body to have
					bodyObject.body = ['move'];

					if (bodyObject.body && bodyObject.body.length > 0){
							bodyObject.cost += Game.getBodyCost(bodyObject.body);
					}
					return bodyObject
			}
	};

	var observer = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$A,
		spawnCode: spawnCode$f
	});

	function run$z(creep){
			var homeRoom = Game.rooms[creep.name.split(' ')[2]];
			var homeRoomName = homeRoom.name;
			var targetflag = Game.flags['PM' + homeRoomName];
			let targetRoomName;
			if (targetflag && targetflag.pos){
					targetRoomName = targetflag.pos.roomName;
			}
			var lab = undefined;
			let path;
			if (homeRoomName && targetRoomName && Memory.powerPaths[homeRoomName] && Memory.powerPaths[homeRoomName][targetRoomName]){
					path = Memory.powerPaths[homeRoomName][targetRoomName].path;
			}
			if (!creep.memory.boosted && lab && lab.store[lab.mineralType] > 550){
					if (lab.boostCreep(creep) != 0){
							creep.moveTo(lab);
					} else {
							creep.memory.boosted = true;
					}
			} else {
					if (targetflag && !creep.store[RESOURCE_POWER]){
							if (creep.room.name != targetflag.pos.roomName || creep.pos.onEdge()){
									if (path){
											creep.moveUsingSavedPath(path.sPath, path.start.toPos(), targetflag.pos);
									} else {
											creep.goTo(targetflag.pos.roomName);
									}
							} else {
									let PB;
									if (!PB){
											PB = creep.room.find(FIND_STRUCTURES, {filter: (s) => s.structureType === STRUCTURE_POWER_BANK})[0];
									}
									if (PB && PB.structureType == STRUCTURE_POWER_BANK){
											if (creep.pos.getRangeTo(PB) > 6){
													creep.moveTo(PB, {range: 5});
											} else {
													PB.hits / 750;
											}
									} else {
											let power = creep.room.find(FIND_DROPPED_RESOURCES, {filter: (r) => r.resourceType == RESOURCE_POWER})[0];
											if (!power){
													power = creep.room.find(FIND_RUINS, {filter: (r) => r.store[RESOURCE_POWER] > 0})[0];
													//console.log('PM', creep.room.find(FIND_RUINS, {filter: (r) => r.store[RESOURCE_POWER] > 0})[0])
													if (!power){
															creep.startNap();
													}
											}
											if (power && creep.pickup(power, RESOURCE_POWER) == ERR_NOT_IN_RANGE){
													creep.moveTo(power, {range: 1});
											}
											if (targetflag && targetflag.room && targetflag.room == creep.room && !power && ((creep.room.find(FIND_STRUCTURES, {filter: (s) => s.structureType == STRUCTURE_POWER_BANK}).length) == 0)){
													targetflag.remove();
											}
									}
							}
					} else {
							if (targetflag && targetflag.room && targetflag.room.name == creep.room.name){
									let power = creep.room.find(FIND_DROPPED_RESOURCES, {filter: (r) => r.resourceType == RESOURCE_POWER})[0];
									if (!power){
											power = creep.room.find(FIND_RUINS, {filter: (r) => r.store[RESOURCE_POWER] > 0})[0];
									}
									if (!power && ((creep.room.find(FIND_STRUCTURES, {filter: (s) => s.structureType == STRUCTURE_POWER_BANK}).length) == 0)){
											targetflag.remove();
									}
							}
							let stores = homeRoom.terminal;
							if (!stores){
									stores = homeRoom.storage;
							}
							if (creep.room.name != homeRoomName){
									if (path && targetflag && targetflag.pos){
											creep.moveUsingSavedPath(PathFinder.reverseSerializedPath(path.sPath), targetflag.pos, path.start.toPos());
									} else {
											creep.goTo(homeRoomName);
									}
							} else if (stores != null){
									if (creep.transfer(stores, RESOURCE_POWER) == ERR_NOT_IN_RANGE){
											creep.moveTo(stores, {range: 1});
									}
									if (creep.room.name == homeRoomName && !creep.store[RESOURCE_POWER]){
											creep.memory.role = 'yak';
									}
							}
					}
			}

	}


	let spawnCode$e = {
			priority: (room, countFunction) => {
					let priority = 20;
					return priority
			},
			isRequired: (room, countFunction) => {
					let numberRequired = 0;
					if (!room.ecoStable || room.armedHostiles || room.memory.defcon < 5){
							return false
					}
					if (Game.flags['PM' + room.name]){
							if (room.memory.powernum){
									numberRequired = room.memory.powernum;
							} else {
									numberRequired = 2;
							}
					} else {
							numberRequired = 0;
					}
					return countFunction('powermover', room) < numberRequired;
			},
			spawn: (room, role, body) => {
					//decide if we need any other options
					if (body){
							//options -> TTL, creepnumber
							room.spawnCreep(role, body);
					}
			},
			body: (room, countFunction) => {
					if (room.memory.roadsDown === undefined){
							room.memory.roadsDown = false;
					}
					let key = room.energyCapacityAvailable + ':' + room.memory.roadsDown;
					if (getCachedBody('powermover',key)){
							return getCachedBody('powermover',key)
					}
					let bodyObject = {
							body: [],
							cost: 0
					};
					//decide on what body to have
					bodyObject.body = room.makeBody([CARRY], false);

					if (bodyObject.body && bodyObject.body.length > 0){
							bodyObject.cost += Game.getBodyCost(bodyObject.body);
					}
					cacheBody('powermover', key, bodyObject);
					return bodyObject
			}
	};

	var powermover = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$z,
		spawnCode: spawnCode$e
	});

	function run$y(creep){
		var homeRoom = Game.rooms[creep.name.split(' ')[2]];
		var homeRoomName = homeRoom.name;
		var pSpawn = Game.spawns['pray' + homeRoomName];
		pSpawn.name.slice(5);
		var targetflag = Game.flags['pray' + pSpawn.room.name];
		var stores = Game.getObjectById(homeRoom.memory.stores);
		var flag = Game.flags['PT' + creep.home.name];
		if (pSpawn && flag){
			var pStore = Game.getObjectById(pSpawn.room.memory.container);
			var pStores = pSpawn.room.storage;
		} else {
			console.log(creep.memory.role + ' no pSpawn || ptflag');
			delete homeRoom.memory.prayerRoom;
			creep.memory.role = 'recycle';
			return
		}
		if (_.sum(creep.store) == creep.store.getCapacity()){
			creep.memory.dropping = true;
		} else if (_.sum(creep.store) == 0){
			delete creep.memory.dropping;
		}
		let pos = flag.pos;
		let path;
		if (pos){
			path = loadPath(creep.home);
		}
		if (!path || (Game.time + 13) % 10000 == 0){
			savePath(creep.home, pos);
			return
		}
		if (creep.memory.dropping){
			let pTrans = null;
			if (pSpawn && pSpawn.room.memory.pTrans && Game.getObjectById(pSpawn.room.memory.pTrans)){
				pTrans = Game.getObjectById(pSpawn.room.memory.pTrans);
			}
			if (creep.pos.inRangeTo(pos, 4)){
				if (pTrans && pTrans.store['energy'] < 300){
					if (creep.transfer(pTrans, RESOURCE_ENERGY) != 0){
						creep.moveTo(pTrans);
					}
				} else if (pSpawn.store['energy'] < 50){
					creep.say(pSpawn);
					if (creep.transfer(pSpawn, RESOURCE_ENERGY) != 0){
						creep.moveTo(pSpawn);
					}
				} else if (pStores && pStores.my && pSpawn.room.controller.level > 3){
					creep.say('store');
					if (creep.transfer(pStores, RESOURCE_ENERGY) != 0){
						creep.moveTo(pStores);
					}
				} else if (pStore){
					creep.say('store1');
					if (creep.transfer(pStore, RESOURCE_ENERGY) != 0){
						creep.moveTo(pStore);
					}
				} else {
					creep.say('monk');
					let monk = creep.pos.findClosestByRange(FIND_MY_CREEPS, {filter: (c) => c.name.split(' ')[0] == 'monk' && c.store['energy'] == 0});
					if (monk){
						if (creep.transfer(monk, 'energy') == ERR_NOT_IN_RANGE){
							creep.moveTo(monk);
						} else {
							creep.moveTo(targetflag, {range: 1});
						}
					} else {
						creep.moveTo(targetflag, {range: 1});
					}
				}
			} else {
				if (creep.pos.isNearTo(pos)){
					creep.move(creep.pos.getDirectionTo(pos));
				} else {
					let test = creep.moveUsingSavedPath(path.sPath, path.start.toPos(), pos);
					if (test === 'delete'){
						delete creep.home.memory.prayerPath;
						creep.wipePath();
					}
				}
			}
		} else {
			if (stores && homeRoom.memory.reserve && stores.store['energy'] > homeRoom.memory.reserve){
				if (creep.pos.isNearTo(stores)){
					if (creep.withdraw(stores, RESOURCE_ENERGY) != 0){
						creep.moveTo(stores);
					}
				} else {
					let sPath = PathFinder.reverseSerializedPath(path.sPath);
					let test = creep.moveUsingSavedPath(sPath, path.end.toPos(), path.start.toPos());
					if (test === 'delete'){
						delete creep.home.memory.prayerPath;
						creep.wipePath();
					}
				}
			}
		}

		function loadPath(room, sourcepos){
			let mem = room.memory.prayerPath;
			if (mem && mem.path && mem.expiry > Game.time){
				return mem.path
			} else {
				return null
			}
		}

		function savePath(room, sourcepos){
			if (!room.storage){
				return
			}
			if (creep.room.name != room.name){
				return
			}
			let start = room.getPositionAt(room.storage.pos.x, room.storage.pos.y + 1);
			if (room.memory.storageWithdawPos){
				start = room.memory.storageWithdawPos.toPos();
			}
			//find path if loadPath return null and creep is near container (as this means the path will no be on the unwalkable mining spot)
			let path = PathFinder.search(start, {pos: sourcepos, range: 1}, {
				plainCost: 1,
				swampCost: 10,
				roomCallback: function (roomName){
					if (Game.map.getRoomType(roomName) == 'SK'){
						return false
					}
					let room = Game.rooms[roomName];
					if (!room) return;
					let costs = new PathFinder.CostMatrix;
					room.find(FIND_STRUCTURES).forEach(function (struct){
						if (struct.structureType === STRUCTURE_ROAD){
							// Don't roads over plain tiles
							costs.set(struct.pos.x, struct.pos.y, 3);
						} else if (struct.structureType !== STRUCTURE_RAMPART ||
							!struct.my){
							// Can't walk through non-walkable buildings
							costs.set(struct.pos.x, struct.pos.y, 0xff);
						}
					});
						costs = blockKeyPositions(costs,room);
					return costs;
				},
			});
			if (path.incomplete){
				return null
			}
			//serialize
			let sPath = PathFinder.serializePath(start, path);
			//save, with an expiry in order to ensure fresh paths
			room.memory.prayerPath = {
				path: {
					sPath: sPath,
					start: start.toString(),
					end: path.path[path.path.length - 1].toString()
				},
				expiry: Game.time + 10000
			};
			//path obj needs serialized path as well as a start pos and end pos
			//return pathObj
		}
	}

	var prayerSupport = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$y
	});

	//prayer room transfer

	function run$x(creep){
			var homeRoom = Game.rooms[creep.name.split(' ')[2]];
			homeRoom.name;
			var pSpawn = Game.spawns['pray' + creep.home.name];
			var stores = pSpawn.room.storage;
			var term = pSpawn.room.terminal;
			var flag = Game.flags['PT' + creep.home.name];
			var lab = Game.getObjectById(pSpawn.room.memory.lab);
			let factory;
			if (pSpawn && pSpawn.room && pSpawn.room.controller.level > 6 && pSpawn.room.memory.factory){
				if (Game.getObjectById(pSpawn.room.memory.factory)){
					factory = Game.getObjectById(pSpawn.room.memory.factory);
				}
			}
			if (pSpawn && creep.ticksToLive < 1300 && pSpawn.store['energy'] > 0){
				pSpawn.renewCreep(creep);
			}
			if (!creep.memory.trans || Game.time % 1000 === 0){
				if (creep.pos.isEqualTo(flag.pos)){
					creep.memory.trans = true;
					pSpawn.room.memory.pTrans = creep.id;
				} else {
					delete creep.memory.trans;
					creep.moveTo(flag);
					if (Game.time % 100 == 0){
						if (flag.pos.creepAtPosition){
							let ptcreep = flag.pos.creepAtPosition;
							if (ptcreep.role == 'pTransfer'){
								creep.suicide();
							}
						}
					}
				}
			} else {
				/*
				if (creep.store['XGH2O']){
						if (lab && lab.store[lab.mineralType] < 1500){
								creep.transfer(lab,'XGH2O')
						} else {
								creep.transfer(term,'XGH2O')
						}
				}
				if (creep.store['energy']>0 && term){
						creep.transfer(term,'energy')
				} else if (stores){
						creep.withdraw(stores,'energy')
				}*/
				if (creep.store['battery'] > 0 && factory && factory.store.getUsedCapacity() < factory.store.getFreeCapacity() * 0.9){
					creep.transfer(factory, 'battery');
				} else if (creep.store['battery'] > 0 && term){
					creep.transfer(term, 'battery');
				} else if (term && term.store['battery'] && factory && factory.store.getUsedCapacity() < factory.store.getFreeCapacity() * 0.9 && creep.store.getUsedCapacity() == 0){
					creep.withdraw(term, 'battery');
				} else if (factory && factory.store['energy'] > 0 && creep.store.getUsedCapacity() == 0){
					creep.withdraw(factory, 'energy');
				} else if (lab && lab.store[lab.mineralType] < 1500 && term && term.store['XGH2O'] && term.store['XGH2O'] > 1500 && _.sum(creep.store) == 0){
					creep.withdraw(term, 'XGH2O');
				} else if (term && creep.store['energy'] == 0 && _.sum(creep.store) == 0 && creep.room.controller.level > 5){
					creep.withdraw(term, 'energy');
				} else if (pSpawn.store['energy'] < 100 && creep.store['energy'] > 0){
					creep.say('spawn');
					creep.transfer(pSpawn, 'energy');
				} else if (lab && lab.store['energy'] < lab.store.getCapacity('energy') * 0.5 && creep.store['energy'] > 0){
					creep.say('lab');
					creep.transfer(lab, 'energy');
				} else if (stores && creep.room.controller.level < 6 && pSpawn.store['energy'] < 100 && stores){
					creep.say('store');
					creep.withdraw(stores, 'energy');
				} else {
					if (stores && term && (stores.store['energy'] / stores.store.getCapacity() < term.store['energy'] / term.store.getCapacity() || _.sum(term.store) > term.store.getCapacity() * 0.5)){
						creep.transfer(stores, 'energy');
					}
				}
			}

		}

	var pTransfer = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$x
	});

	function run$w(creep){
			var homeRoom = Game.rooms[creep.name.split(' ')[2]];
			var spawn = Game.spawns[homeRoom.memory.spawn];
			//console.log('killing '+ creep.name+' : '+reason)
			creep.say('recycling');
			if (spawn){
				if (!creep.pos.isNearTo(spawn) || spawn.recycleCreep(creep) == ERR_NOT_IN_RANGE){
					creep.goTo(spawn.pos, {range: 1});
				}
			} else {
				creep.suicide();
			}
		}

	var recycle = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$w
	});

	function run$v(creep){
				let mem = creep.home.memory.helpRoom;
				let target;
				if (mem){
					target = Game.rooms[mem];
				}
				if (!target){
					return
				}
				target = target.controller;
				if (creep.room.memory.hostiles || creep.hits < creep.hitsMax){
					creep.heal(creep);
				}
				if (creep.hits < creep.hitsMax * 0.8){
					creep.moveTo(creep.home.controller);
				} else if ((!creep.memory.WP || creep.memory.WP != 'fin')){
					waypoints(creep);
				} else if (target && (!target.room || creep.room.name != target.room.name || creep.pos.onEdge())){
					creep.moveTo(target);
				} else if (target){
					let hos = creep.pos.findClosestByRange(FIND_HOSTILE_CREEPS);
					if (hos){
						creep.skirmish(hos);
					} else {
						creep.moveTo(target, {range: 1});
					}
				}
			}

	var reinforcer = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$v
	});

	function run$u(creep){
			var homeRoom = Game.rooms[creep.name.split(' ')[2]];
			homeRoom.name;
			var stores = creep.room.storage;
			var terminal = creep.room.terminal;
			creep.name.split(' ')[1];
			var carry = _.sum(creep.store);
			let spawn = Game.spawns[homeRoom.memory.spawn];
			if (spawn && terminal && spawn.pos.getRangeTo(terminal) > 5){
				var target = terminal;
				var dest = stores;
			} else if (spawn && stores && spawn.pos.getRangeTo(stores) > 5){
				var target = stores;
				var dest = terminal;
			}
			if (carry == 0){
				delete creep.memory.dropping;
			}
			if (carry == creep.store.getCapacity()){
				creep.memory.dropping = true;
			}
			if (target && dest && (_.sum(target.store) == 0 || _.sum(dest.store) == dest.store.getCapacity())){
				target.destroy();
			}
			if (creep.memory.dropping == true && target && dest){
				if (creep.pos.isNearTo(dest)){
					for (var i in creep.store){
						creep.transfer(dest, i);
					}
				} else {
					creep.moveTo(dest);
				}
			} else if (target && dest){
				if (creep.pos.isNearTo(target)){
					for (var i in target.store){
						creep.withdraw(target, i);
					}
				} else {
					creep.moveTo(target);
				}
			} else if (creep.memory.dropping){
				if (stores){
					var dest = stores;
				} else {
					var dest = terminal;
				}
				if (creep.pos.isNearTo(dest)){
					for (var i in creep.store){
						creep.transfer(dest, i);
					}
				} else {
					creep.moveTo(dest);
				}
			}
		}

	var relocator = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$u
	});

	function run$t(creep){
		if (Game.time % 150 == 0){
			delete creep.memory.hostile;
		}
		let pos;
		if (creep.num){
				let spl = creep.num.split(',');
				if (spl && spl.length === 3){
						pos = new RoomPosition(spl[0],spl[1],spl[2]);
				}
		}
		if (!pos){
			// creep.memory.reason = 'redundant'
			// creep.memory.role = 'recycle'
			 return
		}
		if (creep.ticksToLive > 1490){
			if (!creep.home.checkRemoteIsAccessible(pos.roomName)){
				creep.memory.hostile = true;
			}
		}
		let hostile;
		if (creep.room.memory.hostiles){
			hostile = Game.getObjectById(Memory.rooms[creep.room.name].hostiles);
		}
		if (hostile){
				checkGuardNeeded(creep);
		} else if (pos && pos.roomName && creep.room.name === pos.roomName && creep.home.memory.remoteRooms && creep.home.memory.remoteRooms[creep.room.name]){
			delete creep.home.memory.remoteRooms[creep.room.name].guardNeeded;
			delete creep.home.memory.remoteRooms[creep.room.name].retreat;
		}
		if (creep.memory.hostile){
			creep.rally(1,10);
			if (Game.time % 10 === 0){
				if (pos && pos.roomName && creep.home.checkRemoteIsAccessible(pos.roomName)){
					creep.memory = {};
				}
			}
			return
		}
		if (creep.hits < creep.hitsMax){
			creep.towerHeal(creep.home);
		} else if (!creep.memory.hostile){
				if (!pos){
						return
				}
				if (!creep.room.name !== pos.roomName || creep.pos.inRangeTo(pos,3)){
						let container;
						let source;
						let sites;
						if (pos && pos.roomName && Game.rooms[pos.roomName]){
								container = pos.lookAround(LOOK_STRUCTURES,1,{filter: (s)=>s.structureType === 'container'})[0];
								source = pos.lookAround(LOOK_SOURCES,0)[0];
								sites = pos.lookAround(LOOK_CONSTRUCTION_SITES,1,{filter:(s)=>s.my})[0];
						}
						if ((creep.store['energy']<creep.store.getCapacity() || !creep.store.getCapacity()) && source){
								if (creep.pos.isNearTo(source)){
										creep.harvest(source);
								} else {
										creep.moveTo(source,{range:1});
								}
						} else if (sites){
								if (creep.pos.inRangeTo(sites,3)){
										creep.build(sites);
								} else {
										creep.moveTo(sites,{range:3});
								}
						} else if (container && container.store.getFreeCapacity()>0){
								if (creep.pos.isNearTo(container)){
										creep.transfer(container,'energy');
								} else {
										creep.moveTo(container,{range:1});
								}
						} else {
								creep.drop('energy');
						}
				}
		}
	}

	var remoteMinerDeputy = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$t
	});

	function run$s(creep){
		let cpu = Game.cpu.getUsed();
		let mem = creep.home.memory.symbolLocations;
		if (config.mapVisual){
			if (creep.store.getUsedCapacity() > 0){
				for (let i in creep.store){
					let type = i.slice(7, 9);
					if (type){
						Game.map.visual.text(type, creep.pos, {fontSize: 5});
						Game.map.visual.text('|_|', creep.pos, {fontSize: 8});
						break
					}
				}
			} else {
				Game.map.visual.text('|_|', creep.pos, {fontSize: 8});
			}
		}
		if (mem){
			if (!creep.memory.scoreTarget){
				let bestTarget;
				let bestRank;
				let targetSector;
				for (let i in mem){
					let symbolContainer = mem[i];
					let targetAmount = config.lowSymbolBound;
					let type = symbolContainer.type;
					if (Memory.decodersAvailable[type]){
						targetAmount = config.highSymbolBound;
					}
					if (symbolContainer && symbolContainer.expiry && symbolContainer.expiry > Game.time
						&& symbolContainer.amount > 0 && type && (creep.home.total(type) < targetAmount ||
							(creep.home.storage && creep.home.storage.store.getUsedCapacity() < creep.home.storage.store.getCapacity() * 0.8))){
						let pos = i.toPos();
						if (pos){
							let range = Game.map.getRoomLinearDistance(pos.roomName, creep.home.name);
							if ((!bestTarget || bestRank > range)){
								bestRank = range;
								bestTarget = i;
								targetSector = symbolContainer.sector;
							}
						}
					} else {
						let pos = i.toPos();
						Game.map.visual.text(`expired?`, pos);
					}
				}
				if (bestRank && bestRank * 100 > creep.ticksToLive && creep.store.getUsedCapacity() == 0){
					creep.suicide();
				}
				let symMem = Memory.symbolDecoders;
				symMem[creep.home.name].type;
				let symbolType, decoderPos;
				if (symMem && symMem[creep.home.name] && (creep.home.controller.level > 7 || (creep.home.total(symMem[creep.home.name].type) > config.highSymbolBound * 0.9 && creep.home.controller.level > 6 && creep.home.storage &&
					creep.home.storage.store.getUsedCapacity() > creep.home.storage.store.getCapacity() * 0.8))){
					symbolType = symMem[creep.home.name].type;
					decoderPos = symMem[creep.home.name].pos.toPos();
				}
				if (creep.ticksToLive < 300 && creep.store.getUsedCapacity() == 0){
					creep.suicide();
				} else if (bestTarget && creep.store.getUsedCapacity() == 0){
					creep.memory.scoreTarget = bestTarget;
					creep.memory.scoreTargetSector = targetSector;
				} else if (creep.store.getUsedCapacity() > 0){
					let res;
					for (let i in creep.store){
						if (creep.store[i] > 0){
							res = i;
							break
						}
					}
					if (symbolType && res === symbolType){
						let decoder = decoderPos.lookAround(LOOK_SYMBOL_DECODERS, 0)[0];
						if (decoder){
							creep.goAndTransfer(decoder, symbolType, 1);
						}
					} else if (res){
						creep.goAndTransfer(creep.home.storage, res, 1);
					}
				} else {
					if (symbolType && creep.home.terminal && creep.home.terminal.store[symbolType] > creep.store.getCapacity()){
						creep.goAndWithdraw(creep.home.terminal, symbolType, 1);
					}
				}
			} else {
				if (!creep.home.memory.symbolLocations[creep.memory.scoreTarget] && creep.store.getFreeCapacity() > 0){
					delete creep.memory.scoreTarget;
					return
				}
				if (creep.store.getFreeCapacity() > 0){
					let target = creep.memory.scoreTarget.toPos();
					if (target){
						let targetSector = creep.memory.scoreTargetSector;
						if (creep.room.name !== target.roomName || creep.pos.onEdge() &&
							(Game.map.getRoomType(creep.room.name) === 'highway' && targetSector && Game.map.getSideOfHighwayWall(creep.pos) !== targetSector)){
							creep.goTo(target, {targetSector: targetSector});
						} else if (creep.room.name === target.roomName && creep.pos.isNearTo(target)){
							let SC = target.lookAround(LOOK_SYMBOL_CONTAINERS, 0)[0];
							if (SC){
								creep.withdraw(SC, SC.resourceType);
							} else {
								delete creep.memory.scoreTarget;
							}
							if (SC && SC.store[SC.resourceType] === 0){
								delete creep.memory.scoreTarget;
							}
						} else {
							creep.moveTo(target, {range: 1, maxRooms: 1});
						}
					} else {
						delete creep.memory.scoreTarget;
					}
				} else {
					let res;
					for (let i in creep.store){
						if (creep.store[i] > 0){
							res = i;
							break
						}
					}
					if (res && creep.room.name == creep.home.name && !creep.pos.onEdge()){
						creep.goAndTransfer(creep.home.storage, res, 1);
					} else {
						creep.goTo(creep.home.storage.pos);
					}
				}
				let change = Game.cpu.getUsed() - cpu;
				if (change > 3){
					console.log(change, creep.name, creep.pos, creep.memory.scoreTarget);
				}
				if ((change > 10 && creep.memory.go == 'ERROR') || change > 30){
					//likely dodgy path, remove high intensity location
					console.log(creep.name, creep.memory.scoreTarget, creep.pos, 'dodgy path');
					delete creep.home.memory.symbolLocations[creep.memory.scoreTarget];
					delete Memory.symbolLocations[creep.memory.scoreTarget];
					delete creep.memory.scoreTarget;
					delete creep.memory.go;
					delete creep.memory.goError;
				}
			}
		}
	}


	//put this in the role under the runPCs function, to control the spawning for that role

	let spawnCode$d = {
		priority: (room, countFunction) => {
			let priority = 35;
			priority += countFunction('scoreCollector', room);
			if (!room.ecoStable){
				priority = 50;
			}
			return priority
		},
		isRequired: (room, countFunction) => {
			let numberRequired = 0;
			if (room.memory.armedHostiles || room.memory.underHarassment || room.memory.defcon < 4){
				return false
			}
			if (room.memory.scoreCollectorNeeded){
				numberRequired = 1;
				if (room.controller.level == 6){
					numberRequired = 2;
				} else if (room.controller.level > 7){
					numberRequired = 3;
					if (Memory.excessEnergy && Memory.excessEnergy > 0 && room.memory.scoreCollectorNeeded > numberRequired){
						numberRequired = room.memory.scoreCollectorNeeded;
						if (numberRequired > 10){
							numberRequired = 10;
						}
					}
				}
			}
			if (!room.ecoStable && numberRequired > 1){
				numberRequired = 1;
			}
			return countFunction('scoreCollector', room) < numberRequired;
		},
		spawn: (room, role, body) => {
			//decide if we need any other options
			if (body){
				//options -> TTL, creepnumber
				room.spawnCreep(role, body);
			}
		},
		body: (room, countFunction) => {
			if (room.memory.roadsDown === undefined){
				room.memory.roadsDown = false;
			}
			let key = room.energyCapacityAvailable + ':' + room.memory.roadsDown;
				if (getCachedBody('scoreCollector',key)){
						return getCachedBody('scoreCollector',key)
				}
			let bodyObject = {
				body: [],
				cost: 0
			};
			//decide on what body to have
			bodyObject.body = room.makeBody([CARRY], false);

			if (bodyObject.body && bodyObject.body.length > 0){
				bodyObject.cost += Game.getBodyCost(bodyObject.body);
			}
				cacheBody('scoreCollector', key, bodyObject);
			return bodyObject
		}
	};

	var scoreCollector = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$s,
		spawnCode: spawnCode$d
	});

	function run$r(creep){
		if (creep.home && creep.home.memory.scoreTargets){
			if (!creep.memory.dropping && creep.store.getUsedCapacity() > 0){
				creep.memory.dropping = true;
			} else if (creep.memory.dropping && creep.store.getUsedCapacity() == 0){
				delete creep.memory.dropping;
			}
			let memNum = creep.num % Object.keys(creep.home.memory.scoreTargets).length;
			let memPos = Object.keys(creep.home.memory.scoreTargets)[memNum];
			let pos = memPos.toPos();
			if (!pos){
				console.log('SD no pos');
				return
			}
			if (creep.hits < creep.hitsMax){
				if (!creep.home.memory.stopScoring){
					Game.notify(creep.room.name + ' ' + Game.time + ' scoredropper attacked');
				}
				creep.home.memory.stopScoring = true;
			}
			if (creep.memory.dropping){
				creep.say('dropping');
				if (pos.roomName && Game.rooms[pos.roomName] && creep.room.name === pos.roomName && !creep.pos.onEdge()){
					creep.say('room');
					let collector = creep.room.find(FIND_SCORE_COLLECTORS)[0];
					if (collector){
						creep.goAndTransfer(collector, 'score', 1, true);
					}
				} else {
					creep.say('move');
					creep.moveTo(pos, {range: 1});
				}
			} else if (!creep.home.memory.stopScoring){
				if (creep.ticksToLive < 300){
					creep.suicide();
				}
				if (creep.home.storage && creep.room.name == creep.home.name && !creep.pos.onEdge()){
					creep.goAndWithdraw(creep.home.storage, 'score');
				} else {
					creep.moveTo(creep.home.storage, {range: 1, ignoreCreeps: true});
				}
			}
		}
	}

	var scoreDropper = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$r
	});

	function run$q(creep){
		if (creep.home && config.breakHighwayWalls);
		if (creep.home && creep.home.memory.scoreTargets){
			let memNum = creep.num % Object.keys(creep.home.memory.scoreTargets).length;
			let memPos = Object.keys(creep.home.memory.scoreTargets)[memNum];
			let mem = creep.home.memory.scoreTargets[memPos];
			if (!mem){
				console.log('no mem scoreMiner', creep.name);
				return
			}
			let pos;
			if (mem && mem.route){
				if (memPos === mem.route[mem.route.length - 1]){
					creep.suicide();
					return
				}
				pos = mem.route[mem.route.length - 1].toPos();
			}
			if (pos && !creep.pos.isNearTo(pos) && !creep.memory.atCollector){
				creep.pullTo(pos);
			} else if (pos && pos.roomName && Game.rooms[pos.roomName]){
				creep.dismissPuller();
				if (!creep.pos.isNearTo(pos)){
					creep.moveTo(pos, {range: 1});
				}
				creep.memory.atCollector = true;
				let wall = pos.lookAround(LOOK_STRUCTURES, 0, {filter: (s) => s.structureType == STRUCTURE_WALL});
				if (wall && wall[0]){
					creep.dismantle(wall[0]);
				} else {
					mem.route.pop();
				}
			}
		}
	}

	var scoreMiner = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$q
	});

	function run$p(creep){
				var homeRoom = Game.rooms[creep.name.split(' ')[2]];
				homeRoom.name;
				var boostflag = Game.flags['boost' + homeRoomNum];
				var pFlag = Game.flags['portal' + homeRoomNum];
				var flag = Game.flags['SA' + homeRoomNum];

				var pExit = Game.flags['pExit' + homeRoomNum];
				if (Game.shard.name == 'shard1'){
					creep.memory.pFlag = true;
					var rally = pExit;
				} else if (pFlag && pFlag.room && creep.room.name == pFlag.room.name){
					delete creep.memory.pFlag;
				}
				var boost = false;
				if (homeRoom.memory.activeSiege){
					var boost = true;
				}

				if ((boost != null && boost === false) || creep.memory.boosted == 3){
					var partner = Game.getObjectById(creep.memory.paired);
					if (!partner && creep.memory.paired){
						delete creep.memory.paired;
					}
					if ((creep.memory.paired && partner && partner.memory.paired) || creep.memory.partnerDead){
						if ((!flag.room || (flag.room && flag.room.name != creep.room.name) || creep.pos.x == 0 || creep.pos.x == 49 || creep.pos.y == 0 || creep.pos.y == 49)){
							if (creep.pos.isNearTo(partner) || creep.pos.x == 0 || creep.pos.x == 49 || creep.pos.y == 0 || creep.pos.y == 49 || creep.memory.partnerDead){
								creep.moveTo(flag);
							}
						} else {
							var target = creep.pos.findClosestByRange(FIND_HOSTILE_CREEPS, {filter: (c) => c.hits > 0});
							if (target){
								if (creep.pos.getRangeTo(target) <= 3){
									creep.rangedMassAttack;
								}
								if (creep.attack(target) != 0 && (creep.pos.isNearTo(partner) || creep.memory.partnerDead || creep.pos.x == 0 || creep.pos.x == 49 || creep.pos.y == 0 || creep.pos.y == 49)){
									creep.moveTo(target);
								}
							}
						}
					} else {
						if (pFlag && !creep.memory.pFlag){
							creep.moveTo(pFlag);
						} else if (!creep.pos.isNearTo(rally)){
							creep.moveTo(rally);
						} else {
							var partner = creep.pos.findInRange(FIND_MY_CREEPS, 2, {filter: (c) => (!c.memory.paired || c.memory.paired == creep.id) && c.name.split(' ')[0] == 'shardMedic'})[0];
							if (partner){
								creep.memory.paired = partner.id;
							}
						}
					}

				} else {
					if (!creep.pos.isEqualTo(boostflag)){
						creep.moveTo(boostflag);
					} else {
						var labs = creep.pos.findInRange(FIND_STRUCTURES, 1, {filter: (s) => s.structureType == STRUCTURE_LAB});
						var lab1 = _.filter(labs, (l) => l.mineralType == 'XZHO2' && l.store[l.mineralType] > 500 && l.store['energy'] > 400)[0];
						var lab2 = _.filter(labs, (l) => l.mineralType == 'XUH2O' && l.store[l.mineralType] > 500 && l.store['energy'] > 400)[0];
						var lab3 = _.filter(labs, (l) => l.mineralType == 'XGHO2' && l.store[l.mineralType] > 500 && l.store['energy'] > 400)[0];
						if (lab1 && lab2 && lab3){
							if (!creep.memory.boosted){
								lab1.boostCreep(creep);
								creep.memory.boosted = 1;
							} else if (creep.memory.boosted == 1){
								lab2.boostCreep(creep);
								creep.memory.boosted = 2;
							} else if (creep.memory.boosted == 2){
								lab3.boostCreep(creep);
								creep.memory.boosted = 3;
							}
						}
					}

				}

			}

	var shardAttack = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$p
	});

	function run$o(creep){
				var homeRoom = Game.rooms[creep.name.split(' ')[2]];
				var homeRoomName = homeRoom.name;
				var boostflag = Game.flags['boost' + homeRoomName];
				var pFlag = Game.flags['portal' + homeRoomName];
				Game.flags['SA' + homeRoomName];

				var pExit = Game.flags['pExit' + homeRoomName];
				if (Game.shard.name == 'shard1'){
					creep.memory.pFlag = true;
					var rally = pExit;
				} else if (pFlag && pFlag.room && creep.room.name == pFlag.room.name){
					delete creep.memory.pFlag;
				}
				var boost = false;
				if (homeRoom.memory.activeSiege){
					var boost = true;
				}

				if ((boost != null && boost === false) || creep.memory.boosted == 3){
					var partner = Game.getObjectById(creep.memory.paired);
					if (!partner && creep.memory.paired){
						delete creep.memory.paired;
					}
					if (creep.memory.paired && partner && partner.memory.paired){
						var friend = creep.pos.findInRange(FIND_CREEPS, 3, {filter: (c) => (c.owner.username == Game.username || c.owner.username == 'Zeus' || c.owner.username == 'Kasami') && c.hits < c.hitsMax - 400})[0];
						if (partner && creep.pos.isNearTo(partner)){
							if (creep.pos.x == 0 || creep.pos.x == 49 || creep.pos.y == 0 || creep.pos.y == 49){
								var dir = creep.pos.getDirectionTo(partner);
								if (dir == 8){
									var numA = 7;
									var numB = 1;
								} else if (dir == 1){
									var numA = 2;
									var numB = 8;
								} else {
									var numA = dir + 1;
									var numB = dir - 1;
								}
								if (creep.move(dir) != 0){
									if (creep.move(numA) != 0){
										creep.move(numB);
									}
								}
							} else {
								creep.move(creep.pos.getDirectionTo(partner));
							}
						} else if (partner){
							creep.goTo(partner);
						}
						if (creep.hits < creep.hitsMax){
							creep.heal(creep);
						} else if (partner.hits < partner.hitsMax - 300 && creep.pos.isNearTo(partner)){
							creep.heal(partner);
						} else if (partner.hits < partner.hitsMax - 300 && creep.pos.inRangeTo(partner, 3)){
							creep.rangedHeal(partner);
						} else if (friend){
							if (creep.pos.isNearTo(friend)){
								creep.heal(friend);
							} else {
								creep.rangedHeal(friend);
							}
						} else {
							creep.heal(creep);
						}
					} else {
						if (pFlag && !creep.memory.pFlag){
							creep.goTo(pFlag);
						} else if (!creep.pos.isEqualTo(rally)){
							creep.goTo(rally);
						} else {
							var partner = creep.pos.findInRange(FIND_MY_CREEPS, 2, {filter: (c) => (!c.memory.paired || c.memory.paired == creep.id) && (c.name.split(' ')[0] == 'dozer' || c.name.split(' ')[0] == 'shardAttack' || c.name.split(' ')[0] == 'sniper')})[0];
							if (partner){
								creep.memory.paired = partner.id;
							}
						}
					}

				} else {
					if (!creep.pos.isEqualTo(boostflag)){
						creep.goTo(boostflag);
					} else {
						var labs = creep.pos.findInRange(FIND_STRUCTURES, 1, {filter: (s) => s.structureType == STRUCTURE_LAB});
						var lab1 = _.filter(labs, (l) => l.mineralType == 'XZHO2' && l.store[l.mineralType] > 500 && l.store['energy'] > 400)[0];
						var lab2 = _.filter(labs, (l) => l.mineralType == 'XLHO2' && l.store[l.mineralType] > 500 && l.store['energy'] > 400)[0];
						var lab3 = _.filter(labs, (l) => l.mineralType == 'XGHO2' && l.store[l.mineralType] > 500 && l.store['energy'] > 400)[0];
						if (lab1 && lab2 && lab3){
							if (!creep.memory.boosted){
								lab1.boostCreep(creep);
								creep.memory.boosted = 1;
							} else if (creep.memory.boosted == 1){
								lab2.boostCreep(creep);
								creep.memory.boosted = 2;
							} else if (creep.memory.boosted == 2){
								lab3.boostCreep(creep);
								creep.memory.boosted = 3;
							}
						}
					}

				}


			}

	var shardMedic = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$o
	});

	function run$n(creep){
			if (!config$1.official && Game.cpu.bucket < 9000){
					return
			}
		let targetRoom = creep.num;
		if (targetRoom && creep.room.name != targetRoom){
			creep.goTo(targetRoom, {SK: true});
		} else if (targetRoom && creep.pos.onEdge()){
			let pos = new RoomPosition(25, 25, targetRoom);
			if (creep.room.controller){
				pos = creep.room.controller.pos;
			}
			if (pos){
				creep._moveTo(pos, {range: 5});
			}
		} else {
			let sign = '👻 ghost territory - auto clearing is active 👻';
			if (creep.room.controller){
				if (creep.room.controller.sign && creep.room.controller.sign.text === sign){
					creep.suicide();
				}
				if (!creep.pos.isNearTo(creep.room.controller)){
					creep.moveTo(creep.room.controller,{range:1});
				} else {
					creep.signController(creep.room.controller,sign);
				}
			}
			//creep.startNap(creep.ticksToLive)
		}
	}

	var signer = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$n
	});

	function run$m(creep){
				let target = Game.flags['skirmish-' + creep.home.name];
				if (creep.home.memory.skirmishFlag){
					if (Game.flags[creep.home.memory.skirmishFlag]){
						target = Game.flags[creep.home.memory.skirmishFlag];
					} else {
						delete creep.home.memory.skirmishFlag;
					}
				}
				let leader;
				if (creep.home.memory.groupLeader){
					leader = Game.creeps[creep.home.memory.groupLeader];
				}


				if (creep.room.memory.hostiles || creep.hits < creep.hitsMax){
					let friends = creep.pos.lookAround(LOOK_CREEPS, 1, {filter: (c) => c.my && c.hits < c.hitsMax})[0];
					if (creep.hits < creep.hitsMax){
						creep.heal(creep);
					} else if (friends){
						creep.heal(friends);
					} else {
						let farFriends = creep.pos.lookAround(LOOK_CREEPS, 3, {filter: (c) => c.my && c.hits < c.hitsMax})[0];
						if (farFriends){
							creep.rangedHeal(farFriends);
						}
					}
				}
				if (leader == undefined && !creep.room.memory.hostiles){
					creep._goTo(Game.flags['rally' + creep.home.name], {range: 1});
					if (creep.room.find(FIND_CREEPS, {filter: (c) => c.role == 'skirmisher'}).length > 1){
						creep.home.memory.groupLeader = creep.name;
						creep.memory.leader = true;
					}
				} else if (creep.hits < creep.hitsMax * 0.8){
					creep.goTo(creep.home.controller);
				} else if ((!creep.memory.WP || creep.memory.WP != 'fin') && !creep.room.memory.hostiles){
					waypoints(creep);
				} else if (target && (!target.room || creep.room.name != target.room.name) && !creep.room.memory.hostiles && creep.memory.leader){
					creep.goTo(target);
				} else if (leader && creep.room.name != leader.room.name && !creep.room.memory.hostiles){
					creep.goTo(leader);
				} else if (target){
					let hos = creep.pos.findClosestByRange(FIND_HOSTILE_CREEPS, {filter: (c) => c.pos.lookFor(LOOK_STRUCTURES).filter((s) => s.structureType == STRUCTURE_RAMPART).length == 0});
					let structure = false;
					let site = creep.room.find(FIND_CONSTRUCTION_SITES, {filter: (s) => s.progress > 1000})[0];
					let tower = creep.pos.findClosestByRange(FIND_STRUCTURES, {filter: (s) => s.structureType == STRUCTURE_TOWER && s.store['energy'] == 0});
					if (hos){
						creep.skirmish(hos);
						if (tower){
							creep.moveTo(tower);
						}
					} else if (site){
						creep.moveTo(site);
					}
					if ((creep.pos.getRangeTo(hos) > 3 || !hos) && (creep.room.controller && (!creep.room.controller.my || (creep.room.controller.reservation && creep.room.controller.reservation.owner != Game.username)))){
						structure = creep.pos.findClosestByRange(FIND_STRUCTURES, {filter: (s) => s.structureType != STRUCTURE_CONTROLLER && !s.my});
					}
					if (structure){
						if (creep.rangedAttack(structure) == -9 && !hos){
							creep.moveTo(structure);
						}
					}
					if (!hos && !site && !structure && creep.pos.getRangeTo(target) > 4 && target){
						creep.moveTo(target, {range: 4});
					}
				}
			}

	var skirmisher = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$m
	});

	function run$l(creep){
			let rally = Game.flags['rally' + creep.home.name];
			if (creep.home && creep.home.memory.SKMineralTarget && rally && rally.pos){
					let pos = creep.home.memory.SKMineralTarget.pos.toPos();
					if (!pos){
							creep.say('no pos',true);
							return
					}
					if (Game.map.getSector(creep.room.name) && Memory.sectors[Game.map.getSector(creep.room.name)]
							&& Memory.sectors[Game.map.getSector(creep.room.name)].invaderCore === creep.room.name){
							delete creep.home.memory.SKMineralTarget;
							creep.suicide();
					}
					let needToAvoidSkGuard = avoidSKGuards(creep,pos);
					if (needToAvoidSkGuard){
							return
					}
					let needNewRoom = false;
					if (!creep.pos.isNearTo(pos)){
							if (creep.home.memory.SKMineralTarget.path && creep.home.memory.SKMineralTarget.end && creep.home.memory.SKMineralTarget.end.toPos()){
									let ret = creep.moveUsingSavedPath(creep.home.memory.SKMineralTarget.path, rally.pos, creep.home.memory.SKMineralTarget.end.toPos());
									if (ret === 'delete'){
											creep.say('del',true);
											creep.wipePath();
											console.log('pathing err with SKMineralMiner');
											//needNewRoom = true
									}
							} else {
									creep.goTo(pos,{range:1,SK:true});
									creep.say('go',true);
							}
					} else if (creep.store.getFreeCapacity() > 0){
							let min = pos.lookAround(LOOK_MINERALS, 0)[0];
							if (min){
									creep.harvest(min);
							}
					}
					if ((creep.hits < creep.hitsMax * 0.5 || needNewRoom) && pos && pos.roomName){
							if (!creep.home.memory.avoidSKMineral){
									creep.home.memory.avoidSKMineral = {};
							}
							creep.home.memory.avoidSKMineral[pos.roomName] = Game.time + 3000;
							delete creep.home.memory.SKMineralTarget;
					}
			}
	}



	let spawnCode$c = {
			priority: (room, countFunction) => {
					let priority = 46;
					return priority
			},
			isRequired: (room, countFunction) => {
					let numberRequired = 0;
					if (!room.ecoStable || Game.energyCrisis || Game.energyCaution){
							return false
					}
					if (room.storeFillRatio && room.storeFillRatio > 0.85){
							return false
					}
					if (config.mineralCollectionLevel && room.controller.level < config.mineralCollectionLevel){
							return false
					}
					if (room.memory.blockOptionalSpawning && room.memory.blockOptionalSpawning>Game.time){
							return false
					}
					if ((!room.memory.alert || room.memory.alert != 'high') && (!room.memory.defcon || room.memory.defcon == 5) && !room.memory.underHarassment && room.terminal && room.ecoStable && !room.memory.armedHostiles && config.mineralCollection && room.memory.SKMineralTarget && room.memory.SKMineralTarget.pos && room.memory.SKMineralTarget.pos.toPos()){
							numberRequired = 1;
							let roomName = room.memory.SKMineralTarget.pos.toPos().roomName;
							if (Game.map.getRoomType(roomName) == 'SK'){
									requestSquad(room, roomName, {
											type: 'SKM',attackers:1,medics:0
									});
							}
							if (Game.map.isCoreRoom(roomName)){
									delete room.memory.SKMineralTarget;
							}
							if (Memory.rooms[roomName] && Memory.rooms[roomName].SKMineral){
									if (Memory.rooms[roomName].SKMineral.type && room.total(Memory.rooms[roomName].SKMineral.type) > config.excess){
											delete room.memory.SKMineralTarget;
									}
									if (!Memory.rooms[roomName].SKMineral.amount || (Memory.rooms[roomName].SKMineral.amount && Memory.rooms[roomName].SKMineral.amount === 0)){
											delete room.memory.SKMineralTarget;
									}
							}
					}

					return countFunction('SKMineralMiner', room) < numberRequired;
			},
			spawn: (room, role, body) => {
					//decide if we need any other options
					if (body){
							//options -> TTL, creepnumber
							room.spawnCreep(role, body);
					}
			},
			body: (room, countFunction) => {
					if (room.memory.roadsDown === undefined){
							room.memory.roadsDown = false;
					}
					let key = room.energyCapacityAvailable + ':' + room.memory.roadsDown;
					if (getCachedBody('SKMineralMiner',key)){
							return getCachedBody('SKMineralMiner',key)
					}
					let bodyObject = {
							body: [],
							cost: 0
					};
					let maxParts = 50;
					if (room.controller.level < 7){
							maxParts = 25;
					}
					//decide on what body to have
					bodyObject.body = room.makeBody([WORK], false, {oneCarry: true, sort: true,maxParts:maxParts});
					if (bodyObject.body && bodyObject.body.length > 0){
							bodyObject.cost += Game.getBodyCost(bodyObject.body);
					}
					cacheBody('sKMineralMiner',key,bodyObject);
					return bodyObject
			}
	};

	var SKMineralMiner = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$l,
		spawnCode: spawnCode$c
	});

	function run$k(creep){
		let rally = Game.flags['rally' + creep.home.name];
		if (creep.home && creep.home.memory.SKMineralTarget && rally && rally.pos){
			let pos = creep.home.memory.SKMineralTarget.pos.toPos();
			creep.room;
			if (!pos){
				creep.wipePath();
				return
			}
			if (Game.map.isCoreRoom(creep.room.name)){
				delete creep.home.memory.SKMineralTarget;
			}
				let needToAvoidSkGuard = avoidSKGuards(creep,pos);
				if (needToAvoidSkGuard){
						return
				}
			if (creep.memory.dropping){
				creep.say('dropping');
				if (creep.room.name === creep.home.name){
						creep.goAndTransfer(creep.home.storage, creep.home.memory.SKMineralTarget.type);
					if (creep.store.getUsedCapacity() === 0){
						delete creep.memory.dropping;
					}
				} else {
					let revPath = PathFinder.reverseSerializedPath(creep.home.memory.SKMineralTarget.path);
					creep.moveUsingSavedPath(revPath, creep.home.memory.SKMineralTarget.end.toPos(), rally.pos);
				}
			} else if (!creep.pos.inRangeTo(pos, 3)){
					if (creep.home.memory.SKMineralTarget.path && creep.home.memory.SKMineralTarget.end && creep.home.memory.SKMineralTarget.end.toPos()){
							creep.moveUsingSavedPath(creep.home.memory.SKMineralTarget.path, rally.pos, creep.home.memory.SKMineralTarget.end.toPos());
					} else {
							creep.goTo(pos,{range:1,SK:true});
							creep.say('go',true);
					}
			} else {
				let miner,otherSKMineralMover;
					if (creep.home.roleList){
							if (creep.home.roleList['SKMineralMiner']){
									miner= creep.home.roleList['SKMineralMiner'].filter((c)=>c.room.name === pos.roomName)[0];
							}
							if (creep.home.roleList['SKMineralMover']){
									otherSKMineralMover = creep.home.roleList['SKMineralMover'].filter((c)=>c.name !== creep.name && c.store.getUsedCapacity() > creep.store.getUsedCapacity()
											&& c.room.name === pos.roomName && c.pos.inRangeTo(pos,5))[0];
							}
					}
				if (miner && !otherSKMineralMover && miner.store.getUsedCapacity() > 40){
					for (let i in miner.store){
						miner.transfer(creep, i);
					}
				}
				if (miner){
						let droppedEnergy = miner.pos.lookAround(LOOK_ENERGY,1)[0];
						if (droppedEnergy){
								if (creep.pos.isNearTo(droppedEnergy)){
										creep.pickup(droppedEnergy);
								} else {
										creep.moveTo(droppedEnergy,{range:1});
								}
						}
				}
				if (miner && !miner.pos.isNearTo(creep)){
						let range = 5;
						if (miner.store.getUsedCapacity()>0){
								range = 1;
						}
					creep._moveTo(miner, {range: range});
				}
				if ((!miner && creep.store.getUsedCapacity()>= 50) || creep.ticksToLive < 300 || creep.store.getFreeCapacity() === 0){
					creep.memory.dropping = true;
						creep.wipePath();
				} else if (otherSKMineralMover){
						creep.startNap(1);
				}
			}
		} else if (rally){
			creep.wipePath();
			creep.moveTo(rally, {range: 2});
		} else {
			creep.wipePath();
		}
	}



	let spawnCode$b = {
		priority: (room, countFunction) => {
			let priority = 46;
				priority += countFunction('SKMineralMover',room)*2;
			return priority
		},
		isRequired: (room, countFunction) => {
			if (!room.ecoStable || Memory.energyCrisis){
				return false
			}
				if (room.memory.blockOptionalSpawning && room.memory.blockOptionalSpawning>Game.time){
						return false
				}
			let SKMineralMoverNum = 0;
			if (room.terminal && countFunction('SKMineralMiner', room) > 0 && !room.memory.armedHostiles && room.memory.SKMineralTarget
					&& room.memory.SKMineralTarget.pos && room.memory.SKMineralTarget.pos.toPos()){
				SKMineralMoverNum = Math.round(room.memory.SKMineralTarget.path.length / 50);
				if (config.conserveCpu && SKMineralMoverNum>4){
					SKMineralMoverNum = 4;
				}
			}
			return countFunction('SKMineralMover', room) < SKMineralMoverNum;
		},
		spawn: (room, role, body) => {
			//decide if we need any other options
			if (body){
				//options -> TTL, creepnumber
				room.spawnCreep(role, body);
			}
		},
		body: (room, countFunction) => {
			if (room.memory.roadsDown === undefined){
				room.memory.roadsDown = false;
			}
			let key = room.energyCapacityAvailable + ':' + room.memory.roadsDown;
				if (getCachedBody('SKMineralMover',key)){
						return getCachedBody('SKMineralMover',key)
				}
			let bodyObject = {
				body: [],
				cost: 0
			};
			//decide on what body to have
			let maxParts = 30;
				if (room.controller.level < 7){
						maxParts = 15;
				}
			if (!config.conserveCpu){
				maxParts = 10;
			}
			bodyObject.body = room.makeBody([CARRY], false, {maxParts: maxParts});
			if (bodyObject.body && bodyObject.body.length > 0){
				bodyObject.cost += Game.getBodyCost(bodyObject.body);
			}
				cacheBody('SKMineralMover',key,bodyObject);
			return bodyObject
		}
	};

	var SKMineralMover = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$k,
		spawnCode: spawnCode$b
	});

	function run$j(creep){
			var homeRoom = Game.rooms[creep.name.split(' ')[2]];
			homeRoom.name;
			let targets;
			if (Memory.rooms[creep.room.name].hostiles){
					targets = creep.pos.findClosestByRange(FIND_HOSTILE_CREEPS, {
							filter: (creep) => creep.owner.username != "Source Keeper" && !creep.isWhiteListed && (creep.stats().attack || creep.stats().ranged_attack)
					});
					if (!targets){
							targets = creep.pos.findClosestByRange(FIND_HOSTILE_CREEPS, {
									filter: (creep) => creep.owner.username != "Source Keeper" && !creep.isWhiteListed
							});
					}
			} else {
					targets = null;
			}
			let dest;
			if (creep.home.memory.remoteRooms){
					for (let i in creep.home.memory.remoteRooms){
							if (config.ignoreRemotes && config.ignoreRemotes.includes(i)){
									delete creep.home.memory.remoteRooms[i];
									continue
							}
							if (Game.map.isCoreRoom(i)){
									delete creep.home.memory.remoteRooms[i];
									continue
							}
							let rRoom = creep.home.memory.remoteRooms[i];
							if (rRoom.guardNeeded){
									dest = new RoomPosition(25, 25, i);
							}
					}
			}

			if (creep.hits < creep.hitsMax && (!targets || (targets && (creep.pos.getRangeTo(targets) > 1 || !creep.stats().attack)))){
					creep.heal(creep);
			}
			if (!creep.room.hostiles && creep.hits < creep.hitsMax && !creep.stats().heal){
					creep.towerHeal(creep.home);
			}
			if (creep.home.memory.underHarassment && creep.home.memory.underHarassment < Game.time){
					delete creep.home.memory.underHarassment;
			}
			/*
			if (creep.hits < creep.hitsMax*0.5){
					creep.home.memory.escalate = true
			} else {
					creep.home.memory.escalate = false
			}*/
			let hostileRoom = undefined;
			if (creep.room.controller && dest && dest.roomName && dest.roomName == creep.room.name){
					//this is to control when rooms are owned by another player and not endlessly attack them and waste resources - provided they are not directly next to mine
					let controller = creep.room.controller;
					if (controller && !controller.my && ((controller.owner && controller.owner.username != Game.username) || (controller.reservation && controller.reservation.username != Game.username))){
							let range = Game.map.getRoomLinearDistance(creep.room.name, creep.home.name);
							if ((controller.level > 2 && range > 1) || (controller.owner && controller.owner.username != Game.username) || Game.flags['ignore' + creep.room.name]){
									hostileRoom = true;
									let sources = creep.room.find(FIND_SOURCES);
									for (let s in sources){
											let source = sources[s];
											if (Memory.sources && source.pos && Memory.sources[source.pos.toString()]){
													delete Memory.sources[source.pos.toString()];
											}
											if (creep.home.memory.remoteRooms){
													delete creep.home.memory.remoteRooms[creep.room.name];
											}
											if (creep.home.memory.finalSources){
													delete creep.home.memory.finalSources;
											}
									}
							}
					}
			}
			if (!creep.room.memory.armedHostiles && creep.home.memory.remoteRooms && creep.home.memory.remoteRooms[creep.room.name]){
					delete creep.home.memory.remoteRooms[creep.room.name].retreat;
			}
			if (targets != null && hostileRoom != true){
					let stats = targets.stats();
					if (creep.stats().attack == undefined){
							creep.skirmish(targets);
							if (creep.hits < creep.hitsMax * 0.8){
									creep.moveFrom(targets);
							}
					} else {
							let moved = false;
							if (creep.attack(targets) == ERR_NOT_IN_RANGE){
									creep.moveTo(targets, {range: 1});
									moved = true;
							}
							if (creep.rangedAttack(targets) == -9 && !moved){
									creep.moveTo(targets, {range: 3});
							}
					}
					if ((targets.owner.username != 'Invader' || creep.body.length < 15 || creep.home.energyCapacityAvailable < 1000) && ( (stats.attack + stats.ranged_attack)>150 || creep.hits < creep.hitsMax * 0.5)){
							let boosted = 0;
							let medics = 1;
							let attackers = 1;
							let snipers = 0;
							if (targets && (stats.attack+stats.ranged_attack)>300 && !config.swc && creep.room.hostileList && creep.room.hostileList.length < 3){
									boosted = 1;
							} else {
									medics = 2;
									attackers = 2;
							}
							if (Game.gcl.level < 3){
									requestSquad(creep.home, creep.room.name, {
											type: 'G',
											medics: medics,
											attackers: attackers,
											snipers:snipers,
											boosted: boosted
									});
							} else {
									requestSquadsViaCombatManager(creep.room.name,'G',{maxLevel:boosted});
							}
					}

			} else if (dest && dest.roomName && dest.roomName == creep.room.name){
					creep.home.memory.remoteRooms[dest.roomName].guardNeeded = false;
			} else if (dest && creep.room.name != dest.roomName){
					creep.moveTo(dest, {range: 10});
			} else {
					creep.rally(1, 5);
			}
	}



	let spawnCode$a = {
			priority: (room, countFunction) => {
					let priority = 35;
					return priority
			},
			isRequired: (room, countFunction) => {
					let soldierNum = 0;
					let guardNeeded = false;
					for (let i in room.memory.remoteRooms){
							if (room.memory.remoteRooms[i].guardNeeded){
									guardNeeded = true;
									if (room.controller.level < 4){
											console.log('request',requestSquad(room, room.name, {
															type: 'G',
															medics: 2,
															attackers: 2
													}));
									} else if (room.controller.level < 6) {
											requestSquad(room, room.name, {
													type: 'G',
													medics: 1,
													attackers: 1
											});
									}
							}
							if (!room.memory.remoteRooms[i].route || Game.time % 10000 == 0){
									room.memory.remoteRooms[i].route = [];
							}
					}
					if (room && room.memory.blockSoldiers && Game.time < room.memory.blockSoldiers){
							console.log('soldier blocked',room);
							return false
					} else if (room.memory.blockSoldiers){
							delete room.memory.blockSoldiers;
					}

					if (guardNeeded || room.memory.remoteHostiles || (room.memory.defcon < 5 && (!room.controller.safeMode || room.controller.safeMode < 500)) || room.memory.underHarassment){
							soldierNum = 1;
					}
					if (room.memory.alert && room.memory.alert == 'high' && room.memory.underHarassment){
							soldierNum = 2;
					}
					if (room.memory.faceClaimed || room.memory.boostingRequired){
							soldierNum = 0;
					}
					if (room.memory.defcon < 4){
							soldierNum = 0;
					}
					return countFunction('soldier', room) < soldierNum;
			},
			spawn: (room, role, body) => {
					//decide if we need any other options
					if (body){
							//options -> TTL, creepnumber
							room.spawnCreep(role, body);
					}
			},
			body: (room, countFunction) => {
					if (room.memory.roadsDown === undefined){
							room.memory.roadsDown = false;
					}
					let bodyObject = {
							body: [],
							cost: 0
					};
					//decide on what body to have
					if (room.energyCapacityAvailable > 700){
							let max = 15;
							if (room.controller.level > 6){
									max = 25;
							}
							bodyObject.body = room.makeBody([ATTACK], false, {
									sort: true,
									fixedSection: [HEAL, MOVE, RANGED_ATTACK, MOVE],
									maxParts: max
							});
					} else {
							bodyObject.body = room.makeBody([ATTACK], false);
					}
					if ((room.memory.alert && room.memory.alert == 'high' && room.energyCapacityAvailable > 5000) || room.memory.remoteHostiles || (room.memory.defcon < 5 && (!room.controller.safeMode || room.controller.safeMode < 500)) || room.memory.underHarassment
					|| (room.memory.lastSoldierDeath && Game.time-room.memory.lastSoldierDeath<5000)){
							bodyObject.body = room.makeBody([RANGED_ATTACK, HEAL], false, {sort: true});
					}

					if (bodyObject.body && bodyObject.body.length > 0){
							bodyObject.cost += Game.getBodyCost(bodyObject.body);
					}
					return bodyObject
			}
	};

	var soldier = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$j,
		spawnCode: spawnCode$a
	});

	function run$i (creep){
			creep.room.name;
			var homeRoom = Game.rooms[creep.name.split(' ')[2]];
			homeRoom.name;
			if (homeRoom.memory.uplink){
					var uplink = Game.getObjectById(homeRoom.memory.uplink);
			} else {
					var uplink = null;
			}
			if (homeRoom.memory.armedHostiles && !homeRoom.controller.safeMode == undefined){
					return
			}
			var stores = creep.room.storage;
			var num = creep.name.split(' ')[1];
			if (creep.home.memory.staticUpgradersHelpBuild
					&& creep.home.memory.sites && Game.getObjectById(creep.home.memory.sites)){
					let site = Game.getObjectById(creep.home.memory.sites);
					if (site && (site.structureType === 'storage' || site.structureType === 'tower' ||
							site.structureType === 'link' || site.structureType === 'extension')){
							if (creep.memory.upgrading){
									creep.memory.building = true;
									delete creep.memory.upgrading;
							}
							run$12(creep);
							return;
					}
			}
			if (creep){
					let upgradePos;
					if (creep.home.memory.upContPos){
							upgradePos = creep.home.memory.upContPos.toPos();
					}
					if (homeRoom.controller.ticksToDowngrade < 5000){
							var limit = 0;
					} else if (homeRoom.memory.reserve){
							var limit = homeRoom.memory.reserve;
					} else {
							var limit = 30000;
					}
					if (creep.memory.upgrading && creep.store['energy'] == 0){
							creep.memory.upgrading = false;
							creep.say('collecting');
					}
					if (!creep.memory.upgrading && creep.store['energy'] == creep.store.getCapacity()){
							creep.memory.upgrading = true;
							creep.say('upgrading');
					}
					if (creep.memory.boost != true && creep.home.controller.level < 8 && creep.memory.boost != false && !Memory.emergency && creep.ticksToLive > 1400 && homeRoom.controller && homeRoom.controller.level >= 6 && stores && stores.store['energy'] > limit){
							var lab = creep.room.find(FIND_STRUCTURES, {filter: (structure) => structure.structureType == STRUCTURE_LAB && structure.mineralType == 'XGH2O' && structure.store[structure.mineralType] > 500 && structure.store['energy'] > 400})[0];
							if (lab && creep.ticksToLive > 1400){
									if (!creep.pos.isNearTo(lab)){
											creep.moveTo(lab);
									} else if (lab.boostCreep(creep) == 0){
											creep.memory.boost = true;
									}
							} else {
									creep.memory.boost = false;
							}
					} else if (creep.memory.upgrading){
							let targetCarry = 15;
							if (creep.home.controller.level < 8){
									targetCarry = creep.countParts('work')*2;
							}
							let ret;
							if (creep.home.memory.upLoadContDrop){
									ret = withdrawFromUpLoadContainer();
							}
							creep.upgradeController(homeRoom.controller);
							if (upgradePos){
									moveToPos(upgradePos);
							} else if (!upgradePos && creep.pos.getRangeTo(homeRoom.controller) > 3){
									creep.moveTo(homeRoom.controller, {range: 2});
							}
							if (!ret && stores && uplink && uplink.store[RESOURCE_ENERGY] > 0 &&
									creep.pos.isNearTo(uplink) && (creep.store.getUsedCapacity()<= targetCarry || Game.cpu.bucket > 7000)){
									creep.withdraw(uplink, RESOURCE_ENERGY);
							}
							if (homeRoom.controller.level > 4){
									if (!uplink && num == 1 && stores && creep.room.controller.pos.lookAround(LOOK_CONSTRUCTION_SITES, 4, {filter: (s) => s.structureType == STRUCTURE_LINK}).length == 0
											&& creep.room.controller.pos.lookAround(LOOK_STRUCTURES, 4, {filter: (s) => s.structureType == STRUCTURE_LINK}).length == 0){
											if (creep.pos.getRangeTo(creep.room.controller) < 4){
													if (creep.home.memory.upContPos){
															let pos = creep.home.memory.upContPos.toPos();
															if (creep.home.memory.upCont){
																	let upCont = Game.getObjectById(homeRoom.memory.upCont);
																	creep.say(upCont);
																	if (upCont){
																			upCont.destroy();
																	}
															}
															pos.createConstructionSite(STRUCTURE_LINK);
													} else {
															creep.pos.createConstructionSite(STRUCTURE_LINK);
													}
											} else {
													creep._moveTo(creep.room.controller, {range: 3});
											}
									}
									if (creep.home.controller.level === 5 && creep.home.controller.progress < 50000 && creep.home.memory.upContPos){
											let pos = creep.home.memory.upContPos.toPos();
											let drop =pos.lookAround(LOOK_RESOURCES,0,{filter:(r)=>r.resourceType === 'energy'})[0];
											if (drop){
													creep.pickup(drop);
											}
									}
							} else {
									let upCont;
									if (creep.home.memory.upCont){
											upCont = Game.getObjectById(creep.home.memory.upCont);
									}
									if (upCont){
											let drop = upCont.pos.lookAround(LOOK_RESOURCES,0,{filter:(r)=>r.resourceType === 'energy'})[0];
											if (drop){
													creep.pickup(drop);
											} else if (upCont.store['energy']>0){
													creep.withdraw(upCont,'energy');
											}
									} else if (creep.home.memory.upContPos){
											let pos = creep.home.memory.upContPos.toPos();
											let drop =pos.lookAround(LOOK_RESOURCES,0,{filter:(r)=>r.resourceType === 'energy'})[0];
											if (drop){
													creep.pickup(drop);
											}
									}
							}
					} else if (stores != null && uplink && creep.home && !creep.home.controller.isAtReducedLevel()){
							withdrawFromUpLoadContainer();
							if (uplink && (!creep.pos.isNearTo(uplink) || (upgradePos && !creep.pos.isNearTo(upgradePos)))){
									if (upgradePos){
											moveToPos(uplink);
											if (creep.pos.isNearTo(uplink)){
													creep.withdraw(uplink,'energy');
											}
									} else {
											creep.moveTo(uplink, {range: 1});
									}
							} else if (uplink && uplink.store['energy'] > 0){
									creep.withdraw(uplink, 'energy');
							} else if (config.conserveCpu && !creep.home.memory.priorityEnergyRoom){
									creep.startNap(2);
							}
					} else {
							let upCont = null;
							if (homeRoom.memory.storeCont){
									Game.getObjectById(homeRoom.memory.storeCont);
							}
							if (!uplink){
									if (homeRoom.memory.upCont){
											upCont = Game.getObjectById(homeRoom.memory.upCont);
											if (!upCont){
													delete homeRoom.memory.upCont;
											}
									} else if (creep.home.energyCapacityAvailable >= 550){
											delete creep.memory.container;
											if (creep.home.memory.upContPos){
													let position = creep.home.memory.upContPos.toPos();
													let container = position.lookAround(LOOK_STRUCTURES, 0, {filter: (s) => s.structureType == STRUCTURE_CONTAINER})[0];
													if (container){
															homeRoom.memory.upCont = container.id;
													} else {
															if (creep.room.controller.level > 4){
																	position.createConstructionSite(STRUCTURE_LINK);
															} else {
																	position.createConstructionSite(STRUCTURE_CONTAINER);
															}
													}
											} else if (creep.num == 1){
													creep.findContainer(homeRoom.controller, 3, true);
													if (creep.memory.container){
															homeRoom.memory.upCont = creep.memory.container;
													}
											}
									}
							} else if (uplink && uplink.store['energy'] > 0){
									if (upgradePos){
											moveToPos(uplink);
									} else {
											creep.say('no pos');
											creep.goAndWithdraw(uplink, 'energy', 1);
									}
									return
							}
							withdrawFromUpLoadContainer();
							let conts;
							if (upCont){
									conts = upCont;
							}
							if (upgradePos && conts){
									moveToPos(conts);
							} else if (conts && creep.withdraw(conts, RESOURCE_ENERGY) == -9){
									creep.moveTo(conts, {range: 1});
							} else if (conts && conts.store['energy'] === 0){
									creep.startNap(2);
							}

					}
					function withdrawFromUpLoadContainer(){
							if (creep.home.memory.upLoadCont){
									let upLoadCont = Game.getObjectById(creep.home.memory.upLoadCont);
									if (upLoadCont && creep.pos.isNearTo(upLoadCont)){
											let energy = upLoadCont.pos.lookAround(LOOK_RESOURCES,0,{filter:(r)=>r.resourceType === 'energy'})[0];
											if (energy){
													creep.pickup(energy);
													return true
											} else if (upLoadCont && upLoadCont.store['energy']>0){
													creep.withdraw(upLoadCont,'energy');
													return true
											}
									} else if (Game.cpu.bucket > 9500 && creep.store['energy'] < 50) {
											let feeder = creep.pos.lookAround(LOOK_CREEPS,1,{filter:(c)=>c.my && c.role !== 'harvester' && c.store['energy']>=100})[0];
											if (feeder){
													feeder.transfer(creep,'energy',50);
													return true
											}
									}
							} else if (!uplink){
									if (creep.home.memory.upContPos){
											let pos = creep.home.memory.upContPos.toPos();
											let drop =pos.lookAround(LOOK_RESOURCES,0,{filter:(r)=>r.resourceType === 'energy'})[0];
											if (drop){
													creep.pickup(drop);
											}
									}
							}
					}
					function moveToPos(target){
							let range = creep.pos.getRangeTo(upgradePos);
							if (range === 1){
									if (Game.cpu.bucket > 9000 && creep.home.controller.level < 6){
											let pos;
											if (target.pos){
													pos = target.pos;
											} else {
													pos = target;
											}
											let energy = pos.lookAround(LOOK_RESOURCES,0,{filter:(r)=>r.resourceType === 'energy'})[0];
											if (energy){
													let ret = creep.pickup(energy);
													if (ret === 0){
															return
													}
											}
									}
									if (target && !target.roomName){
											creep.withdraw(target, RESOURCE_ENERGY);
									}
									creep.isMoving = true;
									let loadingPos;
									if (creep.home.memory.upgraderLoadingPosition){
											loadingPos = creep.home.memory.upgraderLoadingPosition.toPos();
									}
									if (loadingPos && creep.pos.isEqualTo(loadingPos)){
											shiftRoundLoadingPos(creep,upgradePos);
									}
							} else {
									creep.say('pos');
									let entryPoint;
									if (creep.home.memory.upgraderLoadingPosition){
											entryPoint = creep.home.memory.upgraderLoadingPosition.toPos();
									}
									if (!entryPoint){
											creep.pullTo(upgradePos);
									} else {
											creep.pullTo(entryPoint, true);
									}
							}
							new RoomVisual(creep.room.name).line(creep.pos,upgradePos);
					}


			}
	}
	function shiftRoundLoadingPos(creep,centre){
			if (!creep || creep.fatigue || !centre || !centre.roomName || (creep.memory.blockLoadingShift && creep.memory.blockLoadingShift>Game.time)){
					return false
			}
			delete creep.memory.blockLoadingShift;
			let chain = recurseRound(creep.pos,centre);
			if (!chain){
					let number  = 5;
					if (Game.cpu.bucket < 1000){
							number = 30;
					}
					creep.memory.blockLoadingShift = Game.time + number;
			} else {
					for (let i in chain){
							let pos = chain[i].pos;
							let dir = chain[i].dir;
							let creep = pos.lookAround(LOOK_CREEPS,0)[0];
							if (creep){
									creep.move(dir);
									creep.pos.displayDirection(dir);
							}
					}
			}
			function recurseRound(currentPos,centre,visited,currentChain){
					if (!visited){
							visited = {};
							currentChain = [];
					}
					visited[currentPos.toString()] = true;
					let dir = currentPos.getDirectionTo(centre);
					let nearPositions;
					if (dir % 2 !== 0){
							nearPositions = [currentPos.movePos(dir.map8(1)),currentPos.movePos(dir.map8(2)),
									currentPos.movePos(dir.map8(-1)),currentPos.movePos(dir.map8(-2))];
					} else {
							nearPositions = [currentPos.movePos(dir.map8(1)), currentPos.movePos(dir.map8(-1))];
					}
					for (let i in nearPositions){
							let nearPosition = nearPositions[i];
							if (nearPosition.getTerrain() !== 'wall' && nearPosition.isWalkable() && !visited[nearPosition.toString()]){
									nearPosition.highlight('yellow');
									let newChain = currentChain.concat([{pos:currentPos,dir:currentPos.getDirectionTo(nearPosition)}]);
									if (!nearPosition.lookAround(LOOK_CREEPS,0)[0]){
											return newChain
									} else {
											let ret =  recurseRound(nearPosition,centre,visited,newChain);
											if (ret){
													return ret
											}
									}
							}
					}
			}
	}

	let spawnCode$9 = {
			priority: (room, countFunction) => {
					countFunction('upgrader',room)+countFunction('staticUpgrader',room);
					let priority = 45;
					if (!room.memory.staticUpgradersHelpBuild && (room.memory.bigSites || (room.memory.upCont && Game.getObjectById(room.memory.upCont)
							&& Game.getObjectById(room.memory.upCont).store['energy'] == 0))){
							priority += 10;
					} else if (room.storage && room.memory.reserve && room.total('energy') > room.memory.reserve * 1.1){
							priority -= 20;
					} else if ((room.memory.upCont && Game.getObjectById(room.memory.upCont)
							&& Game.getObjectById(room.memory.upCont).store.getFreeCapacity() < 200)){
							priority -= 20;
					}
					if (room.storage && room.total('energy') > room.memory.reserve){
							priority -= 20;
					}
					if (room.memory.upContEnergy && room.memory.upContEnergy > 0){
							priority = 30;
							if (room.memory.upContEnergy > 500){
									priority = 25;
							}
					}
					if(room.controller && room.controller.level > 1 && room.controller.level < 8 && (room.controller.progressTotal-room.controller.progress)<5000){
							//spawn builders instead
							priority += 20;
					}
					if (room.memory.priorityEnergyRoom && !room.memory.thoriumMineSupportRoom && room.total('energy') > room.memory.reserve * 1.1){
							priority = 30;
					}
					if (config.requestEnergyRoom && config.requestEnergyRoom.includes(room.name)){
							priority = 30;
					}
					return priority
			},
			isRequired: (room, countFunction,idleSpawn,returnPartsNeeded) => {
					let numberRequired = 1;
					if (room.memory.bigSites){
							numberRequired = 0;
					}
					let upgraderCount = countFunction('upgrader',room)+countFunction('staticUpgrader',room);
					if ((!room.memory.upCont || !Game.getObjectById(room.memory.upCont))&&(!room.memory.uplink || !Game.getObjectById(room.memory.uplink))){
							return false
					}
					if (room.class === 'bunker' && room.controller.level >= 6 &&(!room.memory.adjustedLowWallHits || room.memory.adjustedLowWallHits < config.minWalls[7])){
							return false
					}
					if (config.fastFill && config.fastFill === room.name && room.controller.level === 6 && !room.terminal){
							return false
					}
					if (room.controller.level == 8 && ((room.memory.adjustedLowWallHits < config.minWalls[8]) || Memory.emergency || ((Game.gcl.level > 50 || Game.energyCaution) && Memory.energyNeeded && Memory.energyNeeded.length > 0))){
							numberRequired = 0;
					}
					if (room.controller.level === 8 && config.conserveCpu){
							numberRequired = 0;
					}
					if (room.terminal && room.total('energy') < room.memory.reserve * 1.5 && (Memory.emergency || Memory.energyCrisis)){
							return upgraderCount < numberRequired
					}
					let workerParts = 20;
					if (room.memory.assignedSourceData && room.memory.assignedSourceData.currentWorkerParts){
							workerParts = Math.round(Number.parseInt(room.memory.assignedSourceData.currentWorkerParts)*0.8);
					}
					let upgradePrio = room.memory.priorityEnergyRoom && !room.memory.thoriumMineSupportRoom;
					if (((config.requestEnergyRoom && config.requestEnergyRoom.includes(room.name)) || upgradePrio) && room.storage && room.total('energy') > room.memory.reserve * 2.5){
							workerParts += 100;
					} else if (((config.requestEnergyRoom && config.requestEnergyRoom.includes(room.name)) || upgradePrio) && room.storage && room.total('energy') > room.memory.reserve * 2){
							workerParts += 50;
							if (room.controller.level === 7){
									workerParts += 20;
							}
					} else if ((((config.requestEnergyRoom && config.requestEnergyRoom.includes(room.name)) || upgradePrio) && room.storage && room.total('energy') > room.memory.reserve * 1.5) || room.total('energy') > room.memory.reserve * 2){
							workerParts += 40;
							if (room.controller.level === 7){
									workerParts += 20;
							}
					} else if (((config.requestEnergyRoom && config.requestEnergyRoom.includes(room.name)) || upgradePrio) && room.storage && room.total('energy') > room.memory.reserve * 1.3){
							workerParts += 30;
							if (room.controller.level === 7){
									workerParts += 20;
							}
					} else if (room.storage && room.total('energy') > room.memory.reserve * 2){
							workerParts += 40;
					} else if (room.storage && room.total('energy') > room.memory.reserve * 1.8){
							workerParts += 30;
					} else if (room.storage && room.total('energy') > room.memory.reserve * 1.4){
							workerParts += 20;
					} else if (room.storage && (room.total('energy') > room.memory.reserve * 1.2)){
							workerParts += 15;
					} else if (room.storage && (room.total('energy') > room.memory.reserve * 1.05)){
							workerParts += 10;
					} else if (numberRequired > 1 && room.storage && room.total('energy') < room.memory.reserve + 3000 && room.total('energy') > room.memory.reserve){
							workerParts -= 10;
					} else if (numberRequired > 1 && room.storage && room.total('energy') < room.memory.reserve){
							workerParts = 5;
					}
					if (Game.flags['upgrade'+room.name] && room.controller.level < 6){
							workerParts += 30;
					}
					if (upgradePrio && Memory.excessEnergy && Memory.excessEnergy > 0){
							let mod = 1000;
							if ((!activeMines || !config.season) && Memory.excessEnergy > 50000){
									mod = 750;
									if (Memory.excessEnergy > 100000){
											mod = 500;
									} else if (Memory.excessEnergy > 150000){
											mod = 300;
									}
							}
							if (!room.memory.priorityEnergyRoomPrimary){
									mod += 500;
							} else if (activeMines){
									mod += (500*activeMines);
							}
							if (Memory.myRooms.length < 3){
									mod = 2000;
							}
							let add = Number.parseInt(Memory.excessEnergy/mod);
							if (add > 50 && room.controller.level === 6){
									add = 50;
							} else if (add > 200){
									add = 200;
							}
							workerParts += add;
					}

					if (room.memory.upContEnergy && room.memory.upContEnergy > 500){
							workerParts += 10;
							if (room.memory.upContEnergy > 5000){
									workerParts += 20;
							} else if (room.memory.upContEnergy > 4000){
									workerParts += 15;
							} else if (room.memory.upContEnergy > 2500){
									workerParts += 10;
							} else if (room.memory.upContEnergy > 1500){
									workerParts += 7;
							} else if (room.memory.upContEnergy > 1000){
									workerParts += 4;
							}
					} else if (room.memory.staticUpgradersHelpBuild){
							workerParts += 10;
					}
					if (room.controller && room.controller.level > 1 && room.controller.level < 8 && (room.controller.progressTotal-room.controller.progress)<7000){
							//spawn builders instead
							let change = 30;
							if ((room.controller.progressTotal-room.controller.progress) < 5000){
									change = 20;
							} else if ((room.controller.progressTotal-room.controller.progress) < 3000){
									change = 15;
							} else if ((room.controller.progressTotal-room.controller.progress) < 2000){
									change = 10;
							}
							if (change && workerParts > change){
									workerParts = change;
							}
					}
					if (countFunction('colonist',room)>0){
							workerParts -= 10;
					}
					if (config.level7max && room.controller.level > 6){
							workerParts = 5;
					}
					if (room.memory.thoriumMineSupportRoom){
							return false
					}

					if (returnPartsNeeded){
							return workerParts
					}
					if (room.controller.level < 8){
							let body = spawnCode$9.body(room, countFunction).body;
							if (room.memory.bigSites && !room.memory.staticUpgradersHelpBuild){
									numberRequired = Game.bodySizeToNumberNeeded(workerParts / 2, body, WORK);
							} else {
									numberRequired = Game.bodySizeToNumberNeeded(workerParts, body, WORK);
							}
					}
					if (numberRequired > 0 && room.storage && room.total('energy') < room.memory.reserve){
							numberRequired = 0;
					}
					if (room.memory.upgraderPositions && numberRequired > room.memory.upgraderPositions.length){
							numberRequired = room.memory.upgraderPositions.length;
					}
					if (numberRequired > 1 && room.terminal && (room.isEnergyDonor || (config.requestEnergyRoom && config.requestEnergyRoom.length > 0 && !config.requestEnergyRoom.includes(room.name)))){
							if (room.controller.ticksToDowngrade < CONTROLLER_DOWNGRADE[room.controller.level] * 0.7){
									numberRequired = 1;
							} else {
									numberRequired = 0;
							}
					}
					if (room.memory.armedHostiles && room.controller.safeMode == undefined){
							numberRequired = 0;
					}
					if (numberRequired >= upgraderCount && upgraderCount > 0 && room.storage && room.total('energy') < room.memory.reserve){
							return false
					}
					if (numberRequired > 1 && (!config.requestEnergyRoom || !config.requestEnergyRoom.includes(room.name)) && config.blockPraise){
							numberRequired = 1;
					}
					if (config.level7max && room.controller.level > 6 && numberRequired > 1){
							numberRequired = 1;
					}
					if (!room.memory.fillUpLink && numberRequired > 1 && room.memory.uplink && Game.getObjectById(room.memory.uplink)){
							numberRequired = 1;
					}
					let count = countFunction('staticUpgrader', room);
					if (Game.cpu.bucket > 9000 && !config.conserveCpu && room.controller.level < 6){
							let newCount = countRoleAdjustingForParts('staticUpgrader',room,spawnCode$9.body(room,countFunction),'work');
							if (newCount !== undefined){
									count = newCount;
							}
					}
					return count < numberRequired;
			},
			spawn: (room, role, body) => {
					//decide if we need any other options
					if (body){
							//options -> TTL, creepnumber
							room.spawnCreep(role, body);
					}
			},
			body: (room, countFunction) => {
					if (room.memory.roadsDown === undefined){
							room.memory.roadsDown = false;
					}
					let upgradePrio = room.memory.priorityEnergyRoom && !room.memory.thoriumMineSupportRoom;
					let bodyObject = {
							body: [],
							cost: 0
					};
					let body;
					//decide on what body to have
					if (room.energyCapacityAvailable < 900){
							body = room.makeBody([WORK], false, {oneMove: true, oneCarry:true, maxParts: 17});
					} else if (room.controller.level < 8){
							let max = 12;
							if (!room.storage){
									max = 7;
							}
							let upContEnergy = room.memory.upContEnergy;
							if (upContEnergy && upContEnergy > 5000){
									max += 5;
							} else if (upContEnergy && upContEnergy > 2000){
									max += 2;
							}
							if (room.storage && room.total('energy')>room.memory.reserve*1.5){
									max = 25;
							} else if (room.storage && room.total('energy')>room.memory.reserve*1.3){
									max = 16;
							}

							if (upgradePrio){
									if (Memory.excessEnergy > Game.myRooms.length*2000){
											max += 10;
									}
									if (Memory.excessEnergy > Game.myRooms.length*3000){
											max += 10;
									}
							}
							if (!room.memory.fillUpLink && room.memory.uplink && Game.getObjectById(room.memory.uplink)){
									max = 6;
							}
							if (config.level7max && room.controller.level === 7){
									max = 6;
							}
							if (max > 50){
									max = 50;
							}
							body = room.makeBody([WORK], false, {oneMove: true, fixedSection:[CARRY,CARRY], maxParts: max});
							if (upgradePrio){
									body = room.makeBody([WORK, WORK, WORK, WORK, WORK], false, {oneMove: true, fixedSection:[CARRY,CARRY,CARRY],maxParts:max});
							}
					} else {
							body = room.makeBody([WORK], false, {oneMove: true, fixedSection:[CARRY,CARRY], maxParts: 18});
					}
					if ((!config.requestEnergyRoom || !config.requestEnergyRoom.includes(room.name)) && config.blockPraise){
							body = [WORK,CARRY,MOVE];
					}

					bodyObject.body = body;
					if (bodyObject.body && bodyObject.body.length > 0){
							bodyObject.cost += Game.getBodyCost(bodyObject.body);
					}
					return bodyObject
			}
	};

	var staticUpgrader = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$i,
		spawnCode: spawnCode$9
	});

	function run$h(creep){
		let targetRoom = creep.num;
		let mem = Memory.symbolDecoders[targetRoom];
		if (mem && mem.canDecode === false){
			mem = false;
		}
		let SK = false;
		if (config.manualDecode && config.manualDecode[targetRoom]){
			SK = true;
		}
		if (config.mapVisual){
			if (creep.store.getUsedCapacity() > 0){
				for (let i in creep.store){
					let type = i.slice(7, 9);
					if (type){
						Game.map.visual.text(type, creep.pos, {fontSize: 5});
						Game.map.visual.text('{_}', creep.pos, {fontSize: 8});
						break
					}
				}
			} else {
				if (mem.canDecode === undefined){
					Game.map.visual.text('<_>', creep.pos, {fontSize: 8});
				} else {
					Game.map.visual.text('{_}', creep.pos, {fontSize: 8});
				}
			}
		}
		if (!mem && creep.store.getUsedCapacity() == 0){
			creep.suicide();
		} else if (!mem){
			creep.goAndTransfer(creep.home.storage);
			return
		}
		if (creep.hits < creep.hitsMax || (creep.ticksToLive < 10 && (creep.store.getUsedCapacity() > 0 || mem.canDecode === undefined))){
			setAsCannotDecode(targetRoom);
			return
		}
		let type = mem.type;
		if (creep.ticksToLive > 1450 && mem.canDecode && creep.store.getUsedCapacity() === 0){
			//not a test runPCs, pick up resource
			creep.goAndWithdraw(creep.home.terminal, type);
		} else if (mem && mem.pos && (creep.store.getUsedCapacity() > 0 || mem.canDecode == undefined)){
			let pos = mem.pos.toPos();
			if (pos){
				//creep.say(pos)
				creep.goTo(pos, {SK: SK});
			}
			if (creep.room.name == pos.roomName){
				if (creep.pos.isNearTo(pos)){
					let decoder = pos.lookAround(LOOK_SYMBOL_DECODERS, 0)[0];
					if (decoder){
						let transfer = creep.transfer(decoder, decoder.resourceType);
						if (transfer == 0 || (creep.store.getUsedCapacity() == 0 && creep.ticksToLive > 100)){
							creep.memory.hasDecoded = true;
						}
					}
				}
			}
		} else {
			//creep.suicide()
			let pos = mem.pos.toPos();
			if (pos && creep.pos.isNearTo(pos)){
				creep.memory.hasDecoded = true;
				undefined(creep);
			}
		}
	}


	//spawned on request so does not have normal spawn code

	var symbolDecoder = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$h
	});

	function run$g(creep){
			console.log(creep.pos, 'testTrader');
			let targetShard = creep.num;
			var flag = Game.flags['ShardTrade'];
			let portalRoomFlag = Game.flags['PortalRoom'];
			if (_.sum(creep.store) == creep.store.getCapacity() && creep.memory.target){
					creep.memory.dropping = true;
			}
			if (creep.hits < creep.hitsMax*0.8){
					Memory.blockTraders = Game.time+5000;
			}
			if (Game.shard.name != targetShard){
					if (creep.room.terminal && !creep.memory.readyToDepart){
							if (creep.store.getUsedCapacity() === 0){
									let ret = creep.withdraw(creep.room.terminal, 'energy',1);
									if (ret == -9){
											creep.moveTo(creep.room.terminal, {range: 1, maxRooms: 1});
									}
							} else {
									creep.memory.readyToDepart = true;
							}
					} else if (targetShard && Game.shard.name != targetShard){
							//goTo portalRoom
							if (portalRoomFlag && portalRoomFlag.pos && creep.room.name != portalRoomFlag.pos.roomName){
									creep.goTo(portalRoomFlag.pos);
							} else {
									let goalNum = Number.parseInt(targetShard.slice(5));
									let currentNum = Number.parseInt(Game.shard.name.slice(5));
									let targetPortalNum = Number.parseInt(Game.shard.name.slice(5));
									goalNum > currentNum ? targetPortalNum++ : targetPortalNum--;
									if (!creep.room.memory.portals){
											let portals = creep.room.find(FIND_STRUCTURES, {filter: (s) => s.structureType == STRUCTURE_PORTAL});
											creep.room.memory.portals = {};
											for (let i in portals){
													let portal = portals[i];
													if (portal.destination.shard && portal.destination.shard === 'shard0' && portal.pos.lookAround(LOOK_FLAGS,0).length === 0){
															continue
													}
													creep.room.memory.portals[portal.destination.shard] = portal.pos.toString();
											}
									}
									let portal = creep.room.memory.portals['shard' + targetPortalNum];
									if (portal){
											if (creep.pos.isNearTo(portal.toPos())){
													creep.move(creep.pos.getDirectionTo(portal.toPos()));
											} else {
													creep.goTo(portal.toPos(),{range:1});
											}
									}
							}
					}
			} else if (flag && flag.room){
					if (flag.room.terminal){
							if (creep.store.getUsedCapacity() > 0){
									if (creep.room.name !== flag.room.name){
											creep.goTo(flag.room.terminal);
									} else if (!creep.pos.isNearTo(flag.room.terminal)){
											creep.moveTo(flag.room.terminal,{range:1});
									}
									for (let i in creep.store){
											let ret = creep.transfer(flag.room.terminal, i);
											if (ret === 0){
													if ((Memory.mineralsNeeded && Memory.mineralsNeeded[i]) ||
															(Memory.mineralsNeeded && decompressDictionary[i] && Memory.mineralsNeeded[decompressDictionary[i]]) ||
															(Memory.productionMandate && Memory.productionMandate[i]) ||
															(Memory.productionMandate && compressDictionary[i] && Memory.productionMandate[compressDictionary[i]])){
															//dont want to sell this imported item as it will either be used, compressed or decompressed
															return
													}
													if (!Memory.importsToSell){
															Memory.importsToSell = {};
													}
													if (!Memory.importsToSell[i]){
															Memory.importsToSell[i] = creep.store[i];
													} else {
															Memory.importsToSell[i] += creep.store[i];
													}
											}
									}
							} else if (flag.room.memory.boostflag){
									let unb = creep.unboost(flag.room);
									if (unb == -5 || !creep.isBoosted()){
											creep.suicide();
									}
							} else {
									creep.suicide();
							}
					}
			} else if (Game.shard.name == targetShard);
	}

	let spawnCode$8 = {
			priority: (room, countFunction) => {
					let priority = 15;
					return priority
			},
			isRequired: (room, countFunction) => {
					if (!room.ecoStable || room.memory.armedHostiles || room.memory.defcon < 5 || room.energyCapacityAvailable < 5000){
							return false
					}
					let traderNum = 0;
					if (spawnCode$8.traderRequired(room)){
							traderNum = 1;
					} else {
							traderNum = 0;
					}
					return countFunction('testTrader', room) < traderNum;
			},
			traderRequired: (room) => {
					if (Memory.blockTraders && Memory.blockTraders > Game.time){
							return false
					}
					// if (Game.shard.name === 'shard0' && Game.flags['ShardTrade'] &&  Game.flags['ShardTrade'].pos.roomName && Game.flags['ShardTrade'].pos.roomName == room.name && room.terminal){
					// 		return true
					// }
					return false
			},
			spawn: (room, role, body) => {
					//decide if we need any other options
					if (body){
							//options -> TTL, creepnumber
							room.spawnCreep(role, body,{creepnumber:'shard3'});
					}
			},
			body: (room, countFunction) => {
					if (room.memory.roadsDown === undefined){
							room.memory.roadsDown = false;
					}
					let key = room.energyCapacityAvailable + ':' + room.memory.roadsDown;
					if (getCachedBody('testTrader',key)){
							return getCachedBody('testTrader',key)
					}
					let bodyObject = {
							body: [],
							cost: 0
					};
					//decide on what body to have
					bodyObject.body = room.makeBody([CARRY],false,{maxParts:4});

					if (bodyObject.body && bodyObject.body.length > 0){
							bodyObject.cost += Game.getBodyCost(bodyObject.body);
					}
					cacheBody('testTrader',key,bodyObject);
					return bodyObject
			}
	};

	var testTrader = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$g,
		spawnCode: spawnCode$8
	});

	function run$f(creep){
			let room = creep.home;
			if (typeof creep.num === 'string' && creep.num.isRoomName()){
					room = Game.rooms[creep.num];
			}
			if (!room){
					return
			}
			let thorium = room.find(FIND_MINERALS,{filter: (m)=> m.mineralType === 'T'})[0];
			if (creep.ticksToLive<300 && creep.store.getUsedCapacity() === 0){
					creep.suicide();
					return
			}
			if (thorium){
					let miners = thorium.pos.lookAround(LOOK_CREEPS,1,{filter:(c)=>c.my && c.role === 'thoriumMiner'});
					let miner = miners.filter((c)=>c.store['T'] && c.store['T']>0)[0];
					if (!miner && miners.length > 0){
							miner = miners[0];
					}
					if (miner && (thorium.pos.lookAround(LOOK_CONSTRUCTION_SITES,0)[0] || creep.store['energy'])){
							let newMiner = miners.filter((c)=>!c.store['energy'])[0];
							if (newMiner){
									if (newMiner.store['T'] && creep.store['energy'] && creep.pos.isNearTo(newMiner)){
											creep.drop('energy');
									}
									if (creep.store['energy']){
											creep.goAndTransfer(newMiner,'energy');
									} else {
											creep.goAndWithdraw(creep.home.storage,'energy');
									}
							} else {
									if (creep.store['energy']){
											creep.moveTo(miner,{range:5});
									} else {
											creep.goAndWithdraw(creep.home.storage,'energy');
									}
							}
							return
					}
					if (creep.store.getUsedCapacity() === 0){
							delete creep.memory.drop;
							delete creep.memory.idleTime;
					} else {
							if (!creep.memory.idleTime){
									creep.memory.idleTime = 0;
							}
							if (creep.memory.idleTime>10){
									creep.memory.drop = true;
							} else {
									creep.memory.idleTime++;
							}
					}
					if (creep.store.getUsedCapacity()>= 99 || !creep.store.getFreeCapacity() || creep.memory.drop){
							let terminal = creep.home.terminal;
							if (creep.room.terminal && creep.room.terminal.my){
									terminal = creep.room.terminal;
							}
							if (creep.pos.roomName !== terminal.room.name|| !creep.pos.isNearTo(terminal)){
									creep.moveTo(terminal,{range:1});
							} else {
									for (let i in creep.store){
											if (creep.store[i] > 0){
													creep.transfer(terminal,i);
											}
									}
							}
							return
					}

					if (miner && thorium.room.terminal){
							if (creep.pos.isNearTo(miner)){
								if (miner.store['T']>0){
										let amount = miner.store['T'];
										let cap = 99;
										if (creep.store.getCapacity()< cap){
												cap = creep.store.getCapacity();
										}
										if (amount > cap){
												amount = cap;
										}
										if (creep.store['T'] && (amount+creep.store['T'])>cap){
												amount = cap-creep.store['T'];
										}
										miner.transfer(creep,'T',amount);
								}
							} else {
									creep.moveTo(miner,{range:1});
							}
					} else {
							if (creep.pos.getRangeTo(thorium.room.controller)>3){
									creep.moveTo(thorium.room.controller,{range:3});
							}
					}
			} else if (creep.store.getUsedCapacity()> 0){
					if (creep.num % 2 === 0){
							creep.goAndTransfer(creep.home.terminal);
					} else {
							creep.goAndTransfer(creep.home.storage);
					}
					return
			} else {
					creep.suicide();
			}
	}



	let spawnCode$7 = {
			priority: (room, countFunction) => {
					let priority = 30;
					return priority
			},
			isRequired: (room, countFunction) => {
					if (!config$1.season || config$1.season !== 'thorium'){
							return false
					}
					let num = 0;
					if (countFunction('thoriumMiner',room)>0){
							num = 5;
					}
					return countFunction('thoriumBaseHauler', room) < num;
			},
			spawn: (room, role, body) => {
					//decide if we need any other options
					if (body){
							//options -> TTL, creepnumber
							room.spawnCreep(role, body);
					}
			},
			body: (room, countFunction) => {
					let key = room.energyCapacityAvailable;
					if (getCachedBody('thoriumBaseHauler',key)){
							return getCachedBody('thoriumBaseHauler',key)
					}
					let bodyObject = {
							body: [],
							cost: 0
					};
					let max = 4;
					//decide on what body to have
					bodyObject.body = room.makeBody([CARRY], false, {maxParts: max});
					if (bodyObject.body && bodyObject.body.length > 0){
							bodyObject.cost += Game.getBodyCost(bodyObject.body);
					}
					cacheBody('thoriumBaseHauler',key,bodyObject);
					return bodyObject
			}
	};

	var thoriumBaseHauler = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$f,
		spawnCode: spawnCode$7
	});

	function run$e(creep){
			var home = Game.rooms[creep.name.split(' ')[2]];
			creep.name.split(' ')[2];
			if (creep.home && creep.hits < creep.hitsMax*0.7){
					creep.home.memory.fillerBlock = Game.time + 500;
			}
			let pos;
			let path,inPath;
			if (creep.home.memory.thoriumSupportFillPos){
					pos = creep.home.memory.thoriumSupportFillPos.toPos();
					if (pos){
							path = loadPath(creep.home,pos);
							if (!path && !config$1.highwayWalls){
									path = savePath(creep.home, pos);
							}
							inPath = loadInPath(creep.home);
							if (!inPath && !config$1.highwayWalls){
									inPath = saveInPath(creep.home, pos);
							}
					}
			}
			if (_.sum(creep.store) == creep.store.getCapacity()){
					creep.memory.dropping = true;
			}
			if (pos && Game.rooms[pos.roomName]){
					let targetRoom = Game.rooms[pos.roomName];
					if (targetRoom.controller.level >= 6){
							if (!targetRoom.terminal){
									let thorium = Game.getObjectById(targetRoom.memory.thorium);
									if (thorium && creep.store['energy']){
											let miners = thorium.pos.lookAround(LOOK_CREEPS, 1, {filter: (c) => c.my && c.role === 'thoriumMiner'});
											let num = Number.parseInt(creep.num%3);
											let miner = miners[num];
											if (!miner){
													miner = miners[0];
											}
											if (miner && !creep.pos.isNearTo(miner)){
													creep.moveTo(miner,{range:1});
											} else if (!creep.pos.inRangeTo(thorium.pos,4)){
													creep.moveTo(thorium,{range:4});
											}
									} else if (targetRoom.storage && targetRoom.storage.store['energy']>0){
											if (!creep.pos.isNearTo(targetRoom.storage)){
													creep.moveTo(targetRoom.storage,{range:1});
											} else {
													creep.withdraw(targetRoom.storage,'energy');
											}
									} else {
											if (!creep.pos.isNearTo(creep.home.storage)){
													creep.moveTo(creep.home.storage,{range:1});
											} else {
													creep.withdraw(creep.home.storage,'energy');
											}
									}
							} else {
									retire();
							}
							return
					}
			} else if (!pos){
					retire();
			}
			function retire(){
					if (creep.store['energy']){
							creep.goAndTransfer(creep.home.storage);
					} else {
							creep.suicide();
					}
			}
			if (creep.memory.dropping || Game.shard.name != creep.name.split(' ')[3]){
					if (pos && pos.roomName && pos.roomName === creep.room.name && creep.pos.inRangeTo(pos,2)){
							let cont;
							if (creep.room.storage && creep.room.storage.my){
									cont = creep.room.storage;
									let storeTarget = 100000;
									if (creep.room.controller.level === 5){
											storeTarget = creep.room.controller.progressTotal - creep.room.controller.progress;
											if (storeTarget < 100000){
													storeTarget = 100000;
											}
									}
									if (creep.room.storage.store['energy'] > storeTarget){
											creep.startNap(5);
											return
									}
							}
							if (!cont){
									cont = pos.lookAround(LOOK_STRUCTURES, 0, {
											filter: (s) => (s.structureType === STRUCTURE_STORAGE ||
													s.structureType === STRUCTURE_CONTAINER) &&  s.store.getFreeCapacity()>0
									})[0];
							}
							if (!cont && creep.room.name === pos.roomName && creep.room.memory.tPos){
									pos = creep.room.memory.tPos.toPos();
							}
							if (creep.num === 1 && creep.room.memory.towerID){
									let tower = Game.getObjectById(creep.room.memory.towerID);
									if (tower && tower.store['energy']< 500){
											cont = tower;
									}
							}
							if (creep.store.getUsedCapacity() > 0){
									if (cont){
											if (!creep.pos.isNearTo(cont)){
													if (cont.structureType == 'storage'){
															if (path){
																	let room = creep.home;
																	let startPos = room.getPositionAt(room.storage.pos.x, room.storage.pos.y + 1);
																	if (room.memory.storageWithdawPos){
																			startPos = room.memory.storageWithdawPos.toPos();
																	}
																	moveAlongOutPath(path,startPos);
																	return
															}
													}
													creep.moveTo(cont,{range:1});
											} else {
													creep.transfer(cont,'energy');
											}
									} else if (pos && (!pos.roomName || creep.room.name !== pos.roomName)){
											creep.say('here1');
											creep.goTo(pos);
									} else if (pos && !creep.pos.isNearTo(pos)){
											creep.say('here2');
											creep.moveTo(pos,{range:0});
									} else if (!creep.room.memory.lotsOfDroppedEnergy){
											creep.drop('energy');
													//reuse filler if distance is low
													delete  creep.memory.dropping;
													return
									} else {
											creep.startNap(3);
									}
							} else if (creep.room.controller && creep.room.controller.my || true){
											//reuse filler if distance is low
											delete  creep.memory.dropping;
											if (creep.memory.roadsToRepairCount && Number.parseInt(creep.memory.roadsToRepairCount)>4){
													creep.home.memory.thoriumMineRepairRoads = Game.time+1500;
											}
											if (creep.memory.roadsToBuildCount && Number.parseInt(creep.memory.roadsToBuildCount)>4){
													creep.home.memory.thoriumMineBuildRoads = Game.time+1500;
											}
											delete creep.memory.roadsToBuildCount;
											if (creep.ticksToLive<400){
													if (path && path.sPath && path.sPath.length > (creep.ticksToLive-30)/2){
															creep.suicide();
													}
											}
											return

							}
					} else if (path){
							let room = creep.home;
							let startPos = room.getPositionAt(room.storage.pos.x, room.storage.pos.y + 1);
							if (room.memory.storageWithdawPos){
									startPos = room.memory.storageWithdawPos.toPos();
							}
							moveAlongOutPath(path,startPos);
					} else if (!path && pos && pos.roomName && creep.roomName != pos.roomName){
							creep.goTo(pos);
					} else {
							if (creep.store['energy']===0){
									creep.memory.role = 'recycle';
									return
							}
							console.log(creep.name + ' no target flag');
							creep.goAndTransfer(creep.home.storage,'energy');
					}
			} else {
					let stores = home.storage;
					if (stores && stores.store['energy'] > creep.home.memory.reserve*0.6){
							if (inPath && creep.countParts('work') === 0 && (creep.pos.roomName !== home.name || !creep.pos.isNearTo(stores))){
									let test = creep.moveUsingSavedPath(inPath.sPath, inPath.start.toPos(), stores);
									if (test !== 'delete'); else {
											delete creep.home.memory.tFillInPath;
											creep.wipePath();
											creep.moveTo(stores,{range:1});
									}
							} else if (path && (creep.pos.roomName !== home.name || !creep.pos.isNearTo(stores))){
									let sPath = PathFinder.reverseSerializedPath(path.sPath);
									let test = creep.moveUsingSavedPath(sPath, path.end.toPos(), stores);
									if (test !== 'delete'); else {
											creep.moveTo(stores,{range:1});
									}
							} else if (!path){
									creep.goAndWithdraw(stores,'energy',1);
							} else {
									creep.withdraw(stores, RESOURCE_ENERGY);
							}
					} else {
							creep.memory.role = 'yak';
					}
			}
			function moveAlongOutPath(path,startPos){
					let ret = creep.moveUsingSavedPath(path.sPath, startPos, pos);
					if (ret !== 'delete'){
							if (creep.countParts('work')>0 || creep.num < 3){
									let road = creep.pos.lookAround(LOOK_STRUCTURES, 0, {filter: (s) => s.structureType == STRUCTURE_ROAD})[0];
									let onPath;
									if (road){
											onPath = true;
									} else {
											onPath = creep.pos.isOnPath(startPos, path.sPath);
									}
									if (onPath && !creep.pos.onEdge()){
											if (!road){
													creep.pos.createConstructionSite('road');
													let site = creep.pos.lookAround(LOOK_CONSTRUCTION_SITES, 0, {filter: (s) => s.structureType == STRUCTURE_ROAD})[0];
													if (site){
															creep.build(site);
													}
													if (!creep.memory.roadsToBuildCount){
															creep.memory.roadsToBuildCount = 0;
													}
													creep.memory.roadsToBuildCount++;
											} else if (road.hits < road.hitsMax*0.7){
													creep.repair(road);
													if (road.hits < road.hitsMax*0.5){
															if (!creep.memory.roadsToRepairCount){
																	creep.memory.roadsToRepairCount = 0;
															}
															creep.memory.roadsToRepairCount++;
													}
											}
									}
							}
							return
					} else if (ret === 'delete' && creep.blockedByStructure){
							console.log('filler del', creep,creep.pos, Game.time);
							creep.wipePath();
							delete creep.home.memory.tFillPath;
					}
			}

			function loadPath(room, pos){
					if (config$1.highwayWalls || !room || !room.memory.tFillPath ||
							(creep.memory.sPath && creep.memory.sPath.pos && creep.memory.sPath.error && creep.memory.sPath.error == 'structure')){
							creep.wipePath();
							return
					}
					let mem = room.memory.tFillPath;
					if (mem && mem.path && mem.expiry > Game.time && mem.pos == pos.toString()){
							return mem.path
					} else {
							return null
					}
			}

			function savePath(room, pos){
					if (!pos || !room || !Game.rooms[pos.roomName] || (Game.cpu.bucket < 1000 && Game.time % 30 !== 0)){
							return
					}
					let startPos = room.getPositionAt(room.storage.pos.x, room.storage.pos.y + 1);
					if (room.memory.storageWithdawPos){
							startPos = room.memory.storageWithdawPos.toPos();
					}
					//find path if loadPath return null and creep is near container (as this means the path will no be on the unwalkable mining spot)
					let path = PathFinder.search(startPos, {pos: pos, range: 1}, {
							plainCost: 3,
							swampCost: 5,
							maxOps: 20000,
							maxRooms: 50,
							roomCallback: function (roomName){
									let room = Game.rooms[roomName];
									if (Memory.ownedRooms[roomName]){
											return
									}
									if (Game.map.isCoreRoom(roomName)){
											return false
									}
									let costs = new PathFinder.CostMatrix;
									if (ready() && access(home.name) && access(home.name).roadPositions){
											let positions = getRoadPositions(home.name,roomName);
											if (positions){
													for (let i in positions){
															let positionObj = positions[i];
															costs.set(positionObj.x, positionObj.y, 1);
													}
											}
									}
									if (Game.map.getRoomType(roomName) == 'SK'){
											let newM = Game.map.getSKMatrix(roomName);
											if (!newM) {
													costs = PathFinder.applySKMatrix(roomName,newM);
											}
											if (!costs){
													return
											}
									}
									if (!room) return costs;
									if (room.structureMatrix){
											costs = PathFinder.mergeMatrix(costs,room.structureMatrix);
									}
									if (room && room.memory.upgraderPositions){
											for (let i in room.memory.upgraderPositions){
													let pos = room.memory.upgraderPositions[i].toPos();
													if (pos){
															costs.set(pos.x,pos.y,20);
													}
											}
									}
									room.find(FIND_STRUCTURES).forEach(function (struct){
											if (struct.structureType === STRUCTURE_ROAD){
													// Favor roads over plain tiles
													costs.set(struct.pos.x, struct.pos.y, 1);
											} else if (struct.structureType === STRUCTURE_CONTAINER){
													// Favor roads over plain tiles
													costs.set(struct.pos.x, struct.pos.y, 5);
											} else if (struct.structureType !== STRUCTURE_RAMPART ||
													!struct.my){
													// Can't walk through non-walkable buildings
													costs.set(struct.pos.x, struct.pos.y, 0xff);
											}
									});
									let sources;
									if (Game.rooms[roomName] && Game.map.getRoomType(roomName) != 'SK'){
											sources = Game.rooms[roomName].find(FIND_SOURCES);
									}
									costs = blockKeyPositions(costs,room);
									if (sources && sources.length > 0){
											for (let s in sources){
													let neighbours = sources[s].pos.neighbours(1);
													let neighbours2 = sources[s].pos.neighbours(2);
													for (let n in neighbours){
															let neighbour = neighbours[n];
															if (costs.get(neighbour.x, neighbour.y) < 5 && neighbour.getTerrain() !== 'wall'){
																	costs.set(neighbour.x, neighbour.y, 10);
															}
													}
													for (let n in neighbours2){
															let neighbour = neighbours2[n];
															if (costs.get(neighbour.x, neighbour.y) < 5 && neighbour.getTerrain() !== 'wall'){
																	costs.set(neighbour.x, neighbour.y, 10);
															}
													}
											}
									}
									room.find(FIND_EXIT).forEach((e) => {
											if (e.oppositeEdge() && Memory.ownedRooms[e.oppositeEdge().roomName]){
													costs.set(e.x, e.y, 0xff);
											}
									});
									room.find(FIND_CONSTRUCTION_SITES).forEach((s) => {
											if (s.my && s.structureType != STRUCTURE_ROAD && s.structureType != STRUCTURE_CONTAINER && s.structureType != STRUCTURE_RAMPART){
													costs.set(s.pos.x, s.pos.y, 0xff);
											}
									});
									return costs;
							},
					});
					if (path.path){
							for (let i in path.path){
									//path.path[i].highlight('blue')
							}
					}
					//serialize
					if (path.incomplete){
							console.log('path incomplete for filler', pos, path.ops);
							return null
					}
					let sPath = PathFinder.serializePath(startPos, path);
					//save, with an expiry in order to ensure fresh paths
					room.memory.tFillPath = {
							pos: pos.toString(),
							path: {
									sPath: sPath,
									start: startPos.toString(),
									end: path.path[path.path.length - 1].toString()
							},
							expiry: Game.time + 100000
					};
					//path obj needs serialized path as well as a start pos and end pos
					return room.memory.tFillPath.path
					//return pathObj
			}
			function loadInPath(room){
					let mem = room.memory.tFillInPath;
					if (mem && mem.path && mem.expiry > Game.time){
							return mem.path
					} else {
							return null
					}
			}

			function saveInPath(room, pos){
					if (creep.room.name != room.name || !pos){
							return
					}
					let target;
					if (room.storage){
							target = room.getPositionAt(room.storage.pos.x, room.storage.pos.y + 1);
					} else if (room.memory.storeCont){
							let storeCont = Game.getObjectById(room.memory.storeCont);
							if (storeCont){
									target = storeCont.pos;
							}
					} else if (room.memory.fixedBaseOrigin){
							target = room.memory.fixedBaseOrigin.toPos();
					}
					if (!target){
							return
					}
					let needSKmatrix = false;
					//find path if loadPath return null and creep is near container (as this means the path will no be on the unwalkable mining spot)
					let path = PathFinder.search(pos, {pos: target, range: 0}, {
							plainCost: 1,
							swampCost: 1,
							maxOps:20000,
							roomCallback: function (roomName){
									let room = Game.rooms[roomName];
									if (Memory.ownedRooms[roomName]){
											return false
									}
									if (Game.map.isCoreRoom(roomName)){
											return false
									}
									let costs = new PathFinder.CostMatrix;
									if (room && room.memory.upgraderPositions){
											for (let i in room.memory.upgraderPositions){
													let pos = room.memory.upgraderPositions[i].toPos();
													if (pos){
															costs.set(pos.x,pos.y,20);
													}
											}
									}
									if (Game.map.getRoomType(roomName) == 'SK'){
											let newM = Game.map.getSKMatrix(roomName);
											if (!newM){
													needSKmatrix = true;
													return false
											} else {
													costs = PathFinder.mergeMatrix(costs,newM);
													if (!costs){
															return
													}
											}
											//allow near end
											if (roomName === pos.roomName){
													let neighbours = pos.neighbours(6);
													for (let i in neighbours){
															let cost = costs.get(neighbours[i].x,neighbours[i].y);
															if (cost > 20){
																	costs.set(neighbours[i].x,neighbours[i].y,20);
															}
													}
											}
									}
									if (ready() && access(creep.home.name) && access(creep.home.name).roadPositions){
											let positions = access(creep.home.name).roadPositions;
											for (let i in positions){
													let posString = i;
													let positionObj = positions[i];
													let get = costs.get(positionObj.x, positionObj.y);
													if (get > 40){
															continue
													}
													if (posString.includes(roomName)){
															costs.set(positionObj.x, positionObj.y, 3);
													}
											}
											if (!room){
													return costs
											}
									}
									if (!room) return costs;
									if (room.structureMatrix){
											costs = PathFinder.mergeMatrix(costs,room.structureMatrix);
									}
									room.find(FIND_STRUCTURES).forEach(function (struct){
											if (struct.structureType === STRUCTURE_ROAD){
													// Don't roads over plain tiles
													costs.set(struct.pos.x, struct.pos.y, 2);
											} else if (struct.structureType !== STRUCTURE_RAMPART ||
													!struct.my){
													// Can't walk through non-walkable buildings
													costs.set(struct.pos.x, struct.pos.y, 0xff);
											}
									});
									if (room.memory.fixedBaseOrigin){
											let origin = room.memory.fixedBaseOrigin.toPos();
											if (origin){
													costs.set(origin.x, origin.y, 1);
											}
									}

									room.find(FIND_CONSTRUCTION_SITES).forEach((s) => {
											if (s.my && s.structureType != STRUCTURE_ROAD && s.structureType != STRUCTURE_CONTAINER && s.structureType != STRUCTURE_RAMPART){
													costs.set(s.pos.x, s.pos.y, 0xff);
											}
									});
									room.find(FIND_EXIT).forEach((e) => {
											if (e.oppositeEdge() && (Memory.ownedRooms[e.oppositeEdge().roomName] || Game.map.isCoreRoom(e.oppositeEdge().roomName))){
													costs.set(e.x, e.y, 0xff);
											}
									});
									costs = blockKeyPositions(costs,room);
									return costs;
							},
					});
					if (path.incomplete || needSKmatrix){
							return null
					} else {
							for (let i in path.path){
									path.path[i].highlight('blue');
							}
					}
					//serialize
					let sPath = PathFinder.serializePath(pos, path);
					//save, with an expiry in order to ensure fresh paths
					let expiry = 100000;
					if (!config$1.conserveCpu){
							expiry = 10000;
					}
					room.memory.tFillInPath = {
							path: {
									sPath: sPath,
									start: pos.toString(),
									end: path.path[path.path.length - 1].toString()
							},
							expiry: Game.time + expiry
					};
					//path obj needs serialized path as well as a start pos and end pos
					//return pathObj
					return room.memory.tFillInPath.path
			}
	}
	let spawnCode$6 = {
			priority: (room, countFunction) => {
					let priority = 50;
					let minesPresent = activeMines;
					if (!minesPresent){
							return false
					}
					if (room.total('energy')>room.memory.reserve){
							priority = 45;
					}
					if (room.total('energy')>room.memory.reserve*1.2){
							priority = 40;
					}
					if (room.total('energy')> room.memory.reserve*1.2 && Memory.excessEnergy > (3000*Memory.myRooms.length*activeMines)){
							priority = 30;
					}
					if (room.total('energy')> room.memory.reserve*1.5 && Memory.excessEnergy > (5000*Memory.myRooms.length*activeMines)){
							priority = 20;
					}
					if (Memory.noLowLevelTerminals && room.total('energy')> room.memory.reserve*1.2){
							priority = 30;
					}
					if (Game.shard.name === 'shard1'){
							priority = 30;
					}
					if (config$1.official && Game.market.credits > config$1.maxCredits*2 && !Game.energyCrisis){
							priority = 21;
					}
					if (Memory.excessEnergy < 50000){
							priority += Math.round(countFunction('thoriumMineFiller', room) / 3);
					}
					return priority
			},
			isRequired: (room, countFunction) => {
					if (!config$1.season || config$1.season !== 'thorium'){
							return false
					}
					let numberRequired = 0;
					if (!room.ecoStable  || Game.energyCrisis || room.total('energy')<room.memory.reserve*0.7){
							//console.log(`eco filler block ${room.name}`)
							return false
					}
					if (Memory.emergency || room.memory.armedHostiles || room.memory.defcon < 5
							|| room.class == 'restructuring' || room.squadSpawningBlockCivs){
							//console.log(`emergency filler block ${room.name}`)
							return false
					}
					if (room.memory.fillerBlock && room.memory.fillerBlock > Game.time){
							//console.log('T filler block')
							return false
					}
					if (!room.memory.thoriumMineSupportRoom || !Game.rooms[room.memory.thoriumMineSupportRoom]
							|| room.memory.thoriumSupportLinkPos || !room.memory.thoriumSupportFillPos){
							return false
					}
					numberRequired = Memory.rooms[room.memory.thoriumMineSupportRoom].fillerNum;
					if (numberRequired > 5 && Memory.energyCaution){
							numberRequired = 5;
					}
					return countFunction('thoriumMineFiller', room) < numberRequired;
			},
			spawn: (room, role, body) => {
					//decide if we need any other options
					if (body){
							//options -> TTL, creepnumber
							room.spawnCreep(role, body);
					}
			},
			body: (room, countFunction) => {
					if (room.memory.roadsDown === undefined){
							room.memory.roadsDown = false;
					}
					let workCreep = room.memory.thoriumMineRepairRoads && room.memory.thoriumMineRepairRoads > Game.time;
					if (workCreep && getRequiredCreepNum(room,'thoriumMineFiller') > 3){
							workCreep = false;
					}
					if (!workCreep){
							workCreep = room.memory.thoriumMineBuildRoads && room.memory.thoriumMineBuildRoads > Game.time;
					}
					let key = room.energyCapacityAvailable + ':' + room.memory.roadsDown+','+workCreep;
					if (getCachedBody('thoriumMineFiller',key)){
							return getCachedBody('thoriumMineFiller',key)
					}
					let bodyObject = {
							body: [],
							cost: 0
					};
					//decide on what body to have
					bodyObject.body = room.makeBody([CARRY], true);
					if (workCreep){
							bodyObject.body = room.makeBody([CARRY,WORK], true);
					}
					if (bodyObject.body && bodyObject.body.length > 0){
							bodyObject.cost += Game.getBodyCost(bodyObject.body);
					}
					cacheBody('thoriumMineFiller',key,bodyObject);
					return bodyObject
			}
	};

	var thoriumMineFiller = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$e,
		spawnCode: spawnCode$6
	});

	function run$d(creep){
			if (creep.home.memory.tPos){
					let tPos = creep.home.memory.tPos.toPos();
					if (!creep.pos.isEqualTo(tPos)){
							creep.moveTo(tPos,{range:0});
					} else {
							let room = creep.home;
							let spawn = Game.spawns[room.memory.spawn];
							let transferred = false;
							if (creep.store['energy'] > 0){
									let ret = creep.transfer(spawn,'energy');
									if (ret === 0){
											transferred = true;
									} else {
											let nearUpgrader = creep.pos.lookAround(LOOK_CREEPS,1,{filter:(c)=>c.role === 'thoriumMineWorker'});
											if (nearUpgrader[0]){
													creep.transfer(nearUpgrader[0],'energy');
													transferred = true;
											}
									}
							}
							if (creep.store['energy']<creep.store.getCapacity()||transferred){
									let storage = room.storage;
									if (storage && storage.store['energy'] > 0){
											creep.withdraw(storage,'energy');
											return
									}
									let drop = creep.pos.lookAround(LOOK_RESOURCES,1,{filter:(r)=>r.resourceType === 'energy'})[0];
									if (drop){
											creep.pickup(drop);
											return
									}
									let cont = creep.pos.lookAround(LOOK_STRUCTURES,1,{filter:(s)=>s.structureType === 'container' && s.store['energy']})[0];
									if (cont){
											creep.withdraw(cont,'energy');
											return
									}
							}
					}
			}
	}

	let spawnCode$5 = {
			priority: (room, countFunction) => {
					let priority = 24;
					return priority
			},
			isRequired: (room, countFunction) => {
					if (!config$1.season || config$1.season !== 'thorium'){
							return false
					}
					if (!room.memory.thoriumMineSupportRoom || !Game.rooms[room.memory.thoriumMineSupportRoom]
					|| !room.memory.thoriumSupportFillPos){
							return false
					}
					room = Game.rooms[room.memory.thoriumMineSupportRoom];
					if (room.class !== 'thoriumMine'){
							return
					}
					let num = 1;
					if (room.controller.level === 6){
							num = 0;
					}
					if (!num){
							return
					}
					return countFunction('thoriumMineOverseer', room) < num;
			},
			spawn: (room, role, body) => {
					//decide if we need any other options
					if (!room.memory.thoriumMineSupportRoom || !Game.rooms[room.memory.thoriumMineSupportRoom]){
							return
					}
					let requestingRoomName = room.memory.thoriumMineSupportRoom;
					if (body){
							//options -> TTL, creepnumber
							room.spawnCreep(role, body,{assignedHomeName:requestingRoomName});
					}
			},
			body: (room, countFunction) => {
					let key = room.energyCapacityAvailable;
					if (getCachedBody(null, key)){
							return getCachedBody(null, key)
					}
					let bodyObject = {
							body: [],
							cost: 0
					};
					let max = 13;

					//decide on what body to have
					bodyObject.body = room.makeBody([CARRY], false, {maxParts: max, oneMove: true});
					if (bodyObject.body && bodyObject.body.length > 0){
							bodyObject.cost += Game.getBodyCost(bodyObject.body);
					}
					cacheBody('thoriumMineOverseer',key, bodyObject);
					return bodyObject
			}
	};

	var thoriumMineOverseer = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$d,
		spawnCode: spawnCode$5
	});

	function run$c(creep){
			let room = creep.home;
			if (typeof creep.num === 'string' && creep.num.isRoomName()){
					room = Game.rooms[creep.num];
			}
			if (!room){
					return
			}
			let thorium = room.find(FIND_MINERALS,{filter: (m)=> m.mineralType === 'T'})[0];
			if (creep.ticksToLive<100 && creep.store.getUsedCapacity() === 0){
					creep.suicide();
					return
			}
			if (!thorium){
					creep.suicide();
			}
			let termPos;
			if (creep.room.class === 'thoriumMine' && room.memory.terminalPos){
					termPos = room.memory.terminalPos.toPos();
			}
			if (room.memory.thoriumMinePositions && (!creep.memory.assignedSpotsFull || Game.time > creep.memory.assignedSpotsFull)){
					if (creep.memory.assignedSpot && Game.time %30 !== 0){
							let pos = creep.memory.assignedSpot.toPos();
							if (pos && !creep.pos.isEqualTo(pos)){
									creep.moveTo(pos,{range:0});
							} else {
									creep.isMoving = true;
							}
					} else {
							delete creep.memory.assignedSpot;
							for (let i in room.memory.thoriumMinePositions){
									let myPos = room.memory.thoriumMinePositions[i].toPos();
									let creepInSpot = myPos.lookAround(LOOK_CREEPS,0)[0];
									if (creepInSpot && creepInSpot.role === creep.role && creep.id !== creepInSpot.id){
											continue
									}
									if (myPos && !creep.pos.isEqualTo(myPos)){
											creep.moveTo(myPos,{range:0});
											creep.memory.assignedSpot = myPos.toString();
									} else if (myPos) {
											creep.isMoving = true;
											creep.memory.assignedSpot = myPos.toString();
											break
									}
							}
							if (!creep.memory.assignedSpot){
									//assignedSpots are full - fill another spot that is not near the term
									creep.memory.assignedSpotsFull = Game.time + 100;
							}
					}
			}
			if (thorium && !creep.pos.isNearTo(thorium) && (!room.memory.thoriumMinePositions ||
					(creep.memory.assignedSpotsFull && creep.memory.assignedSpotsFull>Game.time))){
					creep.moveTo(thorium, {range: 1});
			} else if (thorium.pos.lookAround(LOOK_CONSTRUCTION_SITES,0)[0]){
					creep.build(thorium.pos.lookAround(LOOK_CONSTRUCTION_SITES,0)[0]);
					let nearFiller = creep.pos.lookAround(LOOK_CREEPS,1,{filter:(c)=>c.role === 'thoriumMineFiller' && !c.hasTransfered && c.store['energy']>0})[0];
					if (nearFiller){
							nearFiller.transfer(creep,'energy');
							nearFiller.hasTransfered = true;
					}
					creep.isMoving = true;
			} else if (room.class === 'thoriumMine' && termPos && termPos.lookAround(LOOK_CONSTRUCTION_SITES,0)[0]){
					creep.build(termPos.lookAround(LOOK_CONSTRUCTION_SITES,0)[0]);
					let nearFiller = creep.pos.lookAround(LOOK_CREEPS,1,{filter:(c)=>c.role === 'thoriumMineFiller' && !c.hasTransfered && c.store['energy']>0})[0];
					if (nearFiller){
							nearFiller.transfer(creep,'energy');
							nearFiller.hasTransfered = true;
					}
					creep.isMoving = true;
			} else if (room.class === 'thoriumMine' && room.terminal && creep.memory.assignedSpot){
					if (creep.store['energy']){
							creep.drop('energy');
					}
			} else if (thorium && (thorium.mineralAmount > 100 ||
					(thorium.room.class && thorium.room.class === 'thoriumMine'))){
					if (creep.store['energy']){
							creep.drop('energy');
					}
					let drop = creep.pos.lookAround(LOOK_RESOURCES,0,{filter:(r)=>r.resourceType === 'T'})[0];
					creep.isMoving = true;
					let hauler = creep.pos.lookAround(LOOK_CREEPS,1,{filter:(c)=>c.my && (c.role === 'thoriumBaseHauler' || c.memory.role === 'thoriumBaseHauler')})[0];
					if (hauler && drop && creep.store.getFreeCapacity()>0){
							creep.pickup(drop);
					}
					if (hauler && !drop && creep.store.getUsedCapacity() === 0 && creep.store.getFreeCapacity() > 40){
							creep.harvest(thorium);
							let friends = thorium.pos.lookAround(LOOK_CREEPS,1,{filter:(c)=>c.role === creep.role && c.store.getUsedCapacity() === 0 && c.store.getFreeCapacity() > 40});
							if (friends && friends.length > 0){
									friends.forEach((c)=>c.harvest(thorium));
							}
					}
			}
	}



	let spawnCode$4 = {
			priority: (room, countFunction) => {
					let priority = 25;
					return priority
			},
			isRequired: (room, countFunction) => {
					if (!config$1.season || config$1.season !== 'thorium'){
							return false
					}
					let num = 0;
					if ((room.ecoStable || room.controller.level === 6) && room.memory.mineThorium && room.memory.defcon === 5 && !room.memory.armedHostiles){
							num = 1;
					}
					return countFunction('thoriumMiner', room) < num;
			},
			spawn: (room, role, body) => {
					//decide if we need any other options
					if (body){
							//options -> TTL, creepnumber
							room.spawnCreep(role, body);
					}
			},
			body: (room, countFunction) => {
					let key = room.energyCapacityAvailable;
					if (getCachedBody('thoriumMiner',key)){
							return getCachedBody('thoriumMiner',key)
					}
					let bodyObject = {
							body: [],
							cost: 0
					};
					let max = 50;
					//decide on what body to have
					let fixed = [CARRY];
					if (room.memory.thoriumMineSupportRoom){
							let thoriumRoom = Game.rooms[room.memory.thoriumMineSupportRoom];
							if (thoriumRoom && !thoriumRoom.terminal){
									fixed = [CARRY,CARRY,CARRY,CARRY,CARRY];
							}
					}
					bodyObject.body = room.makeBody([WORK,WORK,WORK,WORK,MOVE], false, {noMove: true, fixedSection:fixed, maxParts: max});
					if (bodyObject.body && bodyObject.body.length > 0){
							bodyObject.cost += Game.getBodyCost(bodyObject.body);
					}
					cacheBody('thoriumMiner',key,bodyObject);
					return bodyObject
			}
	};

	var thoriumMiner = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$c,
		spawnCode: spawnCode$4
	});

	let checkedRoom = {};
	function run$b(creep){
			let home = creep.home;
			if ((creep.ticksToLive<300 || creep.room.name !== creep.home.name) && creep.store.getUsedCapacity() === 0){
					creep.suicide();
					return
			}
			let reactor;
			if (creep.memory.reactor){
					reactor = Game.getObjectById(creep.memory.reactor);
			} else if (creep.home.memory.reactor){
					reactor = Game.getObjectById(creep.home.memory.reactor);
					creep.memory.reactor = creep.home.memory.reactor;
					if (reactor){
							creep.memory.reactorPos = reactor.pos.toString();
					}
			} else {
					creep.goAndTransfer(creep.home.terminal,'T');
					if (!creep.store['T']){
							creep.suicide();
					}
			}
			// if (reactor && reactor.continuousWork) {
			// 		let dif = 1000000-reactor.continuousWork
			// 		if (dif < 100 && dif > 0){
			// 				creep.say(dif,true)
			// 		} else if (dif < 1 && dif > -100){
			// 				creep.say('🥳',true)
			// 		}
			// }
			if (!reactor && creep.memory.reactor && creep.memory.reactorPos){
					let pos = creep.memory.reactorPos.toPos();
					creep.moveTo(pos,{range:1});
					return
			}
			let outPath = loadOutPath(creep.home);
			if (reactor && !outPath && (Game.time + Number.parseInt(creep.num)) % 10 == 0){
					outPath = saveOutPath(creep.home, reactor.pos);
			} else if (!reactor) {
					return
			}
			if (!checkedRoom[creep.room.name] || checkedRoom[creep.room.name]<Game.time){
					let type = Game.map.getRoomType(creep.room.name);
					if (type === 'SK'){
							let core = creep.room.findStructures('invaderCore')[0];
							if (core && core.level > 0){
									Memory.sectors[creep.room.sector].invaderCore = creep.room.name;
									delete home.memory.reactorPath;
							}
					}
					checkedRoom[creep.room.name] = Game.time + 100;
			}

			if (creep.store.getUsedCapacity()>0){
					let inRange;
					if (creep.room.name === reactor.room.name){
							inRange = creep.pos.inRangeTo(reactor,4);
							if (inRange){
									creep.memory.nearReactor = true;
							}
					}
					if (outPath && outPath.sPath && creep.ticksToLive > 500 && !creep.memory.nearReactor &&
							(creep.room.name !== reactor.room.name || !inRange)){
							let test = creep.moveUsingSavedPath(outPath.sPath, outPath.start.toPos(), reactor.pos);
							if (test === 'delete'){
									delete creep.home.memory.yakOutPaths[reactor.toString()];
									creep.wipePath();
							} else {
									return
							}
					}
					if (creep.room.name !== reactor.room.name){
							creep.goTo(reactor, {SK: true,freshRoute:true});
					} else {
							if (creep.pos.isNearTo(reactor)){
									if (!reactor.my || reactor.store['T']< 900){
											creep.transfer(reactor,'T');
									}
									creep.isMoving = true;
							} else {
									creep.moveTo(reactor,{range:1});
							}
					}
			} else if (home.terminal){
					if (creep.pos.isNearTo(home.terminal)){
							let ret = creep.withdraw(home.terminal,'T',99);
							if (ret === -6 && creep.home.total('T') < 99){
									creep.suicide();
							}
					} else {
							creep.moveTo(home.terminal,{range:1});
					}
			}
	}
	function loadOutPath(room){
			let mem = room.memory.reactorPath;
			if (mem && mem.path && mem.expiry > Game.time){
					return mem.path
			} else {
					return null
			}
	}

	function saveOutPath(room,reactorPosition){
			if (!reactorPosition){
					return
			}
			console.log('finding out path', reactorPosition);
			let start;
			if (room.memory.fixedBaseOrigin){
					start = room.memory.fixedBaseOrigin.toPos();
			} else if (room.storage){
					start = room.getPositionAt(room.storage.pos.x, room.storage.pos.y + 1);
			}else if (room.memory.storeCont){
					let storeCont = Game.getObjectById(room.memory.storeCont);
					if (storeCont){
							start = storeCont.pos;
					}
			}
			if (!start){
					return
			}
			let needSKmatrix = false;
			//find path if loadPath return null and creep is near container (as this means the path will no be on the unwalkable mining spot)
			let path = PathFinder.search(start, {pos: reactorPosition, range: 1}, {
					plainCost: 1,
					swampCost: 5,
					maxOps:20000,
					roomCallback: function (roomName){
							let room = Game.rooms[roomName];
							if (Memory.ownedRooms[roomName]){
									return false
							}
							if (Game.map.isCoreRoom(roomName)){
									return false
							}
							let costs = new PathFinder.CostMatrix;
							if (room && room.memory.upgraderPositions){
									for (let i in room.memory.upgraderPositions){
											let pos = room.memory.upgraderPositions[i].toPos();
											if (pos){
													costs.set(pos.x,pos.y,20);
											}
									}
							}
							if (Game.map.getRoomType(roomName) == 'SK'){
									let newM = Game.map.getSKMatrix(roomName);
									if (!newM){
											needSKmatrix = true;
											return false
									} else {
											costs = PathFinder.mergeMatrix(costs,newM);
											if (!costs){
													return
											}
									}
							}
							if (!room) return costs;
							room.find(FIND_STRUCTURES).forEach(function (struct){
									if (struct.structureType === STRUCTURE_ROAD){
											// Don't roads over plain tiles
											costs.set(struct.pos.x, struct.pos.y, 1);
									} else if (struct.structureType !== STRUCTURE_RAMPART ||
											!struct.my){
											// Can't walk through non-walkable buildings
											costs.set(struct.pos.x, struct.pos.y, 0xff);
									}
							});
							if (room.memory.fixedBaseOrigin){
									let origin = room.memory.fixedBaseOrigin.toPos();
									if (origin){
											costs.set(origin.x, origin.y, 1);
									}
							}

							room.find(FIND_CONSTRUCTION_SITES).forEach((s) => {
									if (s.my && s.structureType != STRUCTURE_ROAD && s.structureType != STRUCTURE_CONTAINER && s.structureType != STRUCTURE_RAMPART){
											costs.set(s.pos.x, s.pos.y, 0xff);
									}
							});
							room.find(FIND_EXIT).forEach((e) => {
									if (e.oppositeEdge() && (Memory.ownedRooms[e.oppositeEdge().roomName] || Game.map.isCoreRoom(e.oppositeEdge().roomName))){
											costs.set(e.x, e.y, 0xff);
									}
							});
							costs = blockKeyPositions(costs,room);
							return costs;
					},
			});
			if (path.incomplete || needSKmatrix){
					return null
			} else {
					for (let i in path.path){
							path.path[i].highlight('orange');
					}
			}
			//serialize
			let sPath = PathFinder.serializePath(start, path);
			//save, with an expiry in order to ensure fresh paths
			let expiry = 10000;

			room.memory.reactorPath= {
					path: {
							sPath: sPath,
							start: start.toString(),
							end: path.path[path.path.length - 1].toString()
					},
					expiry: Game.time + expiry
			};
			//path obj needs serialized path as well as a start pos and end pos
			//return pathObj
			return room.memory.reactorPath.path
	}


	let spawnCode$3 = {
			priority: (room, countFunction) => {
					let priority = 20;
					return priority
			},
			isRequired: (room, countFunction) => {
					if (!config$1.season || config$1.season !== 'thorium'){
							return false
					}
					let num = 0;
					let reactor;
					if (room.memory.reactor){
							reactor = Game.getObjectById(room.memory.reactor);
					}
					if (reactor && room.memory.reactorHaulers){
							num = room.memory.reactorHaulers;
							if (num > 14){
									num = 14;
							}
					}
					if (!room.total('T') || room.total('T') < 99){
							return false
					}
					return countFunction('thoriumReactorHauler', room) < num;
			},
			spawn: (room, role, body) => {
					//decide if we need any other options
					if (body){
							//options -> TTL, creepnumber
							room.spawnCreep(role, body);
					}
			},
			body: (room, countFunction) => {
					let key = room.energyCapacityAvailable;
					if (getCachedBody('thoriumReactorHauler',key)){
							return getCachedBody('thoriumReactorHauler',key)
					}
					let bodyObject = {
							body: [],
							cost: 0
					};
					let max = 4;
					//decide on what body to have
					bodyObject.body = room.makeBody([CARRY], false, {maxParts: max});
					if (bodyObject.body && bodyObject.body.length > 0){
							bodyObject.cost += Game.getBodyCost(bodyObject.body);
					}
					cacheBody('thoriumReactorHauler',key,bodyObject);
					return bodyObject
			}
	};

	var thoriumReactorHauler = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$b,
		spawnCode: spawnCode$3
	});

	let blocksAll = {};
	let termVal = config$1.levels.termVal;
	let resourceList = {expiry: Game.time + 5000};
	function run$a(creep){
			if (!blocksAll[creep.room.name]){
					blocksAll[creep.room.name] = {
					};
			}
			let blocks = blocksAll[creep.room.name];
			var homeRoom = creep.home;
			if (homeRoom.class === 'restructuring'){
					if (!Memory.toMoveStore || Memory.toMoveStore != creep.home.name){
							creep.suicide();
					}
			}
			let factoryList = roomInputs[homeRoom.name];
			var homeRoomName = homeRoom.name;
			if (homeRoom.memory.reserve){
					var limit = homeRoom.memory.reserve;
			} else {
					var limit = 30000;
			}
			var stores = creep.home.storage;
			var link = Game.getObjectById(homeRoom.memory.linkstore);
			let extraLinks = [];
			if (creep.home.memory.extraLinks){
					for (let l in creep.home.memory.extraLinks){
							let thisLink = Game.getObjectById(l);
							if (thisLink){
									extraLinks.push(thisLink);
							} else {
									delete creep.home.memory.extraLinks[l];
							}
					}
			}
			let link2;
			for (let i in extraLinks){
					let eL = extraLinks[i];
					if (eL && eL.pos.isNearTo(creep) && eL.store.getFreeCapacity('energy') > 0){
							link2 = eL;
							break
					}
			}
			let term = creep.room.terminal;
			var uplink = Game.getObjectById(homeRoom.memory.uplink);
			Game.getObjectById(homeRoom.memory.repairLink);
			let storeCont;
			if (creep.room.memory.staticFillerSpots && creep.room.memory.storeCont){
					storeCont = Game.getObjectById(creep.room.memory.storeCont);
			}
			if (term && term.effects){
					for (let i in term.effects){
							if (term.effects[i].effect === 15){
									//terminal disrupted
									term = undefined;
									break
							}
					}
			}
			let termlist = [];
			if (resourceList.expiry < Game.time){
					resourceList = {expiry: Game.time + 5000};
			}
			if (!resourceList[creep.home.name]){
					for (let i in RESOURCES_ALL){
							if (RESOURCES_ALL[i] != 'energy'){
									termlist.push([RESOURCES_ALL[i], Game.time]);
							}
					}
					termlist.reverse();
					resourceList[creep.home.name] = termlist;
			} else {
					termlist = resourceList[creep.home.name];
			}
			let factory;
			if (homeRoom.memory.factory){
					factory = homeRoom.activeFactory;
			}
			var flag = Game.flags['T' + homeRoomName];
			let sit;
			if (flag && stores){
					/*if (!flag.pos.isNearTo(stores)){
												flag.remove()
								}*/
					sit = flag.pos;
			} else if (!creep.memory.atPos && stores){
					sit = creep.home.getPositionAt(stores.pos.x, stores.pos.y - 1);
			}
			if (creep.home.memory.transferPos){
					sit = creep.home.memory.transferPos.toPos();
			}
			if (creep.home.memory.bunker && creep.home.memory.bunkerOrigin){
					sit = creep.home.memory.bunkerOrigin.toPos();
			}
			if (creep.ticksToLive < 5){
					if (creep.store.getUsedCapacity() > 0){
							for (let i in creep.store){
									creep.transfer(stores, i);
							}
					} else {
							creep.suicide();
					}
					return
			}
			let creepSizeAdj = creep.store.getCapacity() + 1;
			if (!creep.memory.clear){
					if (term && (term.pos.lookFor(LOOK_FLAGS).length > 0 || creep.home.memory.hostileNear)){
							creep.memory.clear = true;
					} else {
							creep.memory.clear = false;
					}
			}
			if (creep.home.class === 'bunker'){
					if (sit && !creep.pos.isEqualTo(sit)){
							if (creep.pos.isNearTo(sit)){
									creep.move(creep.pos.getDirectionTo(sit));
							} else {
									creep.moveTo(sit,{range:0});
							}
							return
					}
					let storage = creep.home.storage;
					let energySource;
					let towers = creep.pos.lookAround(LOOK_STRUCTURES,1,{filter:(s)=>s.structureType === 'tower' && s.store.getFreeCapacity('energy')>100});
					let terminal = creep.home.terminal;
					let spawn = creep.pos.lookAround(LOOK_STRUCTURES,1,{filter:(s)=>s.structureType === 'spawn'})[0];
					let link;
					if (creep.home.memory.linkstore){
							link = Game.getObjectById(creep.home.memory.linkstore);
					}
					if (terminal && terminal.store['energy'] > 5000){
							energySource = terminal;
					} else if (storage && storage.store['energy'] > 0){
							energySource = storage;
					}
					if (creep.store.getUsedCapacity() > 0 && creep.store['energy']===0){
							let dest = creep.home.storage;
							if (creep.home.terminal){
									dest = creep.home.terminal;
							}
							for (let i in creep.store){
									creep.transfer(dest,i);
							}
					} else if (creep.home.memory.armedHostiles && towers && towers[0]){
							moveRes('energy',energySource,towers[0]);
					} else if (spawn && spawn.store.getFreeCapacity('energy')>0 &&
							(creep.home.energyCapacityAvailable < 600|| creep.home.energyAvailable < creep.home.energyCapacityAvailable*0.7 || spawn.store.getFreeCapacity('energy')>50)){
							moveRes('energy',energySource,spawn);
					} else if (towers && towers[0]){
							moveRes('energy',energySource,towers[0]);
					} else if (terminal && storage && storage.store.getFreeCapacity()>5000 && (terminal.store['energy']+creep.store.getCapacity())>5000){
							moveRes('energy',terminal,storage);
					} else if (terminal && storage && (terminal.store['energy']+creep.store.getCapacity())<2000){
							moveRes('energy',storage,terminal);
					} else if (link && link.store.getFreeCapacity('energy') > 0  && creep.home.memory.fillUpLink && countRole('staticUpgrader',creep.home)>0){
							moveRes('energy',energySource,link);
					} else if (storage && creep.store['energy'] > 0){
							creep.transfer(storage,'energy');
					} else if (creep.home.storage && creep.home.terminal && creep.home.terminal.store.getFreeCapacity()> 20000){
							let done = false;
							for (let i in termlist){
									let res = termlist[i][0];
									if (res !== 'energy'){
											if (creep.home.storage.store[res] && creep.home.storage.store[res]>0){
													moveRes(res,creep.home.storage,creep.home.terminal);
													done = true;
											}
									}
							}
							if (!done && spawn && spawn.store.getFreeCapacity('energy')>0){
									moveRes('energy',energySource,spawn);
							}
					}
					if (creep.ticksToLive < 1000 && spawn && !spawn.spawning){
							spawn.renewCreep(creep);
					}
					return
			}
			if (stores && (link || creep.home.terminal || storeCont)){
					if (sit && (!creep.memory.atPos || !creep.pos.isEqualTo(sit))){
							creep._moveTo(sit, {range: 0});
							if (creep.pos.isEqualTo(sit)){
									creep.memory.atPos = true;
							}
					} else if (creep.memory.clear){
							/*energy
											transfer to spawn link,
											withdraw from link
											deposit in term
											withdraw from term
											deposit in store
											*/
							if (_.sum(creep.store) === 0 && stores && _.sum(stores.store) > 0){
									if (term && (term.store['energy'] < 15000 ||
													(term.store.getUsedCapacity() > term.store.getCapacity() * 0.95 && term.store['energy'] < 20000))
											&& stores && stores.store['energy'] > 0){
											creep.withdraw(stores, 'energy');
									} else {
											for (var r in stores.store){
													creep.withdraw(stores, r);
											}
									}
							} else {
									for (var r in creep.store){
											creep.transfer(term, r);
									}
							}
					} else {
							let emergency = false;
							let room = creep.home;
							if (Memory.emergency || Game.energyCrisis || !room.ecoStable || room.memory.defcon < 5 || room.memory.armedHostiles){
									emergency = true;
							}
							if (room.memory.dump){
									if (room.terminal && room.terminal.store[room.memory.dump] && creep.store.getUsedCapacity() == 0){
											creep.withdraw(room.terminal, room.memory.dump);
											return
									} else if (creep.store.getUsedCapacity() > 0){
											for (let i in creep.store){
													creep.drop(i);
													return
											}
									}
							}
							let powerMod = 0.8;
							if (room.controller.level < 7){
									powerMod = 0.9;
							}
							let ps = Game.getObjectById(homeRoom.memory.powerspawn);
							let powerSource = creep.home.terminal;
							if (!creep.home.terminal || !term){
									powerSource = creep.home.storage;
							}
							let upLinkTransferThreshold = 150;
							if (creep.home.total('energy') > creep.home.memory.reserve && creep.home.controller.level != 8){
									//likely need to transfer faster to praise quicker
									upLinkTransferThreshold = 300;
							}
							let fillStoreLink = room.memory.fillUpLink;
							if (room.memory.thoriumSupportLink){
									let tLink = Game.getObjectById(room.memory.thoriumSupportLink);
									if (tLink && tLink.store['energy']< tLink.store.getCapacity('energy')*0.6){
											fillStoreLink = true;
											uplink = tLink;
									}
							}
							if (stores && fillStoreLink && uplink && link &&
									(!link.cooldown || link.cooldown < 3) && link.store.getFreeCapacity('energy') > 0 && uplink.store['energy'] < upLinkTransferThreshold && (_.sum(creep.store) == 0 || creep.store['energy'] > 0)){
									if (_.sum(creep.store) == 0 && stores.store['energy'] > 30000){
											creep.withdraw(stores, 'energy');
									} else if (_.sum(creep.store) == 0 && term && term.store['energy'] > 1000){
											creep.withdraw(term, 'energy');
									} else {
											creep.transfer(link, RESOURCE_ENERGY);
									}
									creep.say('link');
							} else if (stores && uplink && fillStoreLink && link2 && link2.store.getFreeCapacity('energy')>0 && (_.sum(creep.store) == 0 || creep.store['energy'] > 0)){
									//safe to just add energy to link 2 and leave it as we don't withdraw from it
									if (_.sum(creep.store) == 0 && stores.store['energy'] > 30000){
											creep.withdraw(stores, 'energy');
									} else if (_.sum(creep.store) == 0 && term && term.store['energy'] > 1000){
											creep.withdraw(term, 'energy');
									} else {
											creep.transfer(link2, RESOURCE_ENERGY);
									}
									link2.pos.highlight('pink');
									//creep.say('extraLink')
							} else if (link && creep.store.getUsedCapacity() === 0 && room.total('energy') < room.memory.reserve * 2.5 && link.store['energy'] >= 50 && stores && (!fillStoreLink ||
									room.memory.sourceLinkFull)){
									creep.withdraw(link, RESOURCE_ENERGY);
									creep.say('linkW');
							} else if (stores && stores.store['energy'] > 0 && storeCont && storeCont.store['energy'] < 1500 && storeCont.store.getFreeCapacity()>0 && (creep.store.getUsedCapacity() === 0 || creep.store['energy'] > 0)){
									moveRes('energy', stores,storeCont);
							} else if (storeCont && storeCont.store['energy'] < storeCont.store.getUsedCapacity() && creep.store.getUsedCapacity() === 0){
									for (let i in storeCont.store){
											if (i !== 'energy'){
													creep.withdraw(storeCont,i);
													break
											}
									}
							} else if (stores && (stores.store[RESOURCE_ENERGY] + creep.store['energy']) > (limit + 5000) && term && term.store.getUsedCapacity() < term.store.getCapacity() * 0.9 && (term.store['energy'] < 15000) && (creep.store.getUsedCapacity() === 0 || creep.store['energy'] > 0)){
									moveRes('energy', stores, term);
							} else if (stores && stores.store[RESOURCE_ENERGY] + creep.store['energy'] > (limit +1000) && term && term.store.getUsedCapacity() < term.store.getCapacity() * 0.95 && (term.store['energy'] < 3000) && (creep.store.getUsedCapacity() === 0 || creep.store['energy'] > 0)){
									moveRes('energy', stores, term);
							} else if (stores && stores.store[RESOURCE_ENERGY] + creep.store['energy'] > (limit *0.7) && term && term.store.getUsedCapacity() < term.store.getCapacity() * 0.98 && (term.store['energy'] < 500) && (creep.store.getUsedCapacity() === 0 || creep.store['energy'] > 0)){
									moveRes('energy', stores, term,250);
							} else if (!Game.energyCrisis && stores && (creep.home.total('energy') + creep.store['energy']) > (limit * 0.8) && !emergency
									&& term && factory && factoryList && factoryList['energy'] && factory.store['energy'] < 200 && factory.store.getUsedCapacity() < factory.store.getCapacity() * 0.9 && (creep.store.getUsedCapacity() === 0 || creep.store['energy'] > 0)){
									moveRes('energy', stores, factory, 100);
							} else if (!emergency && stores && stores.store[RESOURCE_ENERGY] + creep.store['energy'] > (limit) && term && factory && factoryList && factoryList['energy'] && factoryList['energy'] > 0 && factory.store.getUsedCapacity() < factory.store.getCapacity() * 0.9 && (creep.store.getUsedCapacity() === 0 || creep.store['energy'] > 0)){
									let amount = factoryList['energy'];
									if (amount > creep.store.getCapacity()){
											amount = creep.store.getCapacity();
									}
									moveRes('energy', stores, factory, amount);
							} else if (ps && creep.pos.isNearTo(ps) && creep.home.memory.canLoadPowerSpawn && powerSource
									&& room.total('energy') + creep.store['energy'] > room.memory.reserve * powerMod && ps.store['energy'] < ps.store.getCapacity('energy') * 0.5 &&
									(creep.store['energy'] > 0 || creep.store.getUsedCapacity() == 0)){
									moveRes('energy', stores, ps);
							} else if (ps && (powerSource.store['power'] > 0 || creep.store['power'] > 0) && creep.pos.isNearTo(ps) && !creep.home.memory.armedHostiles && creep.home.memory.defcon === 5 && creep.home.ecoStable && ps.store['power'] < ps.store.getCapacity('power') * 0.5 &&
									(creep.store['power'] > 0 || creep.store.getUsedCapacity() == 0)){
									moveRes('power', powerSource, ps);
							} else if (stores && term && factory && factoryList && factory.store['energy'] > 500 + creep.store.getCapacity() && factoryList['energy'] && factoryList['energy'] < 0 && factory.store['energy'] > creep.store.getCapacity() && (creep.store.getUsedCapacity() === 0 || creep.store['energy'] > 0)){
									let amount = 0;
									amount -= factoryList['energy'];
									if (amount > creep.store.getCapacity()){
											amount = creep.store.getCapacity();
									}
									moveRes('energy', factory, stores, amount);
							} else if (stores && term && stores.store.getFreeCapacity()>5000 && (stores.store['energy'] < limit || creep.store['energy'] > 0 || term.store['energy'] > (25000 + creepSizeAdj)) && term && term.store['energy'] >= 500 && (term.store['energy'] > 5000 || creep.store['energy'] > 0) && (creep.store.getUsedCapacity() === 0 || creep.store['energy'] > 0)){
									moveRes('energy', term, stores);
							} else if (creep.store['energy'] && stores&& stores.store.getFreeCapacity()>5000){
									creep.transfer(stores,'energy');
							} else if (term){
									//moving stored resources to term
									let keepInFactory;
									if (keepInFactoryAll[creep.home.name]){
											keepInFactory = keepInFactoryAll[creep.home.name];
									}
									for (let i in factoryList){
											if (creep.store.getUsedCapacity() > 0 && !creep.store[i]){
													continue
											}
											if (factoryList[i] < 0 && term && term.store.getFreeCapacity() > 5000 && factory && factory.store[i] && factory.store[i] > 0 && !transferBlocked()){
													creep.pos.highlight('yellow');
													let amount = creep.store.getCapacity();
													if (factoryList[i]){
															amount = Math.abs(factoryList[i]);
													}
													if (amount > creep.store.getCapacity()){
															amount = creep.store.getCapacity();
													}
													if (amount > factory.store[i]){
															amount = factory.store[i];
													}
													let ret = moveRes(i, factory, term, amount);
													if (ret === 0){
															return
													}
											} else if (term && !transferBlocked() && (term.store[i] || creep.store[i]) && factory && factoryList && factoryList[i] > 0 && i !== 'energy' && factory.store.getUsedCapacity() < factory.store.getCapacity() * 0.9){
													creep.pos.highlight('pink');
													let amount = creep.store.getCapacity();
													if (factoryList[i]){
															amount = Math.abs(factoryList[i]);
													}
													if (amount > creep.store.getCapacity()){
															amount = creep.store.getCapacity();
													}
													if (keepInFactory && keepInFactory[i]){
															amount = creep.store.getFreeCapacity();
													}
													if (amount > term.store[i]){
															amount = term.store[i];
													}
													let ret = moveRes(i, term, factory,amount);
													if (ret === 0){
															return
													}
											}
									}
									for (let i = 0; i < termlist.length; i++){
											creep.pos.highlight('blue');
											let res = termlist[i][0];
											let localTermVal = termVal;
											if (config$1.season && config$1.season === 'thorium' && res === 'T'){
													localTermVal = 50000;
											}
											if ((termlist[i][1] > Game.time && !creep.store[res]) || (creep.store.getUsedCapacity() > 0 && !creep.store[res])){
													continue
											}
											if (term && term.store[res] && !transferBlocked() && stores.store.getFreeCapacity() > 5000 && (term.store[res] + creep.store[res]) > (localTermVal + creep.store.getCapacity() + 1)){
													let ret = moveRes(res, term, stores);
													stores.pos.highlight('purple');
													if (ret === 0){
															termlist[i][1] = Game.time+20;
															return
													}
											} else if (term && term.store.getFreeCapacity() > 5000 && !transferBlocked() && stores.store[res] && (((term.store[res] + creep.store[res]) <= localTermVal) || creep.store[res] > 0)){
													let ret = moveRes(res, stores, term);
													if (ret === 0){
															termlist[i][1] = Game.time+20;
															return
													}
											} else if (creep.store.getUsedCapacity(res)>0){
													creep.transfer(stores,res);
											}
											termlist[i][1] = Game.time + 200;
									}
									if (creep.store.getUsedCapacity()>0 && term){
											for (let i in creep.store){
													creep.transfer(term,i);
											}
									} else if (creep.home.memory.defcon === 5 && !creep.home.memory.armedHostiles && config$1.conserveCpu && creep.room.controller.level === 8
									&& !creep.home.memory.thoriumMineSupportRoom) {
											let sleepDuration = 10;
											if (creep.home.memory.factoryOperator){
													sleepDuration = 3;
											}
											creep.startNap(sleepDuration);
									}
							} else if (creep.store['energy'] > 0 && stores){
									creep.transfer(stores, 'energy');
							} else if (creep.store.getUsedCapacity() > 0 && stores){
									for (let i in creep.store){
											creep.transfer(stores, i);
									}
							} else {
									creep.say('hmm');
									//creep.startNap(2)
							}


					}
			}
			function transferBlocked(to,res){
					return false
			}
			function moveRes(res, from, to, quantity){
					if (!from || !to){
							creep.say('bad moveRes');
							return false
					}
					creep.say(res + ' ' + creep.pos.getDirectionTo(to));
					if (!quantity || quantity > creep.store.getCapacity()){
							quantity = creep.store.getCapacity();
					}
					if (creep.store[res] && creep.store[res] > 0){
							new RoomVisual(creep.room.name).poly([to.pos, creep.pos], {
									stroke: 'green',
									opacity: 1,
									strokeWidth: 0.2
							});
							to.pos.highlight('orange');
							if (quantity > creep.store[res]){
									quantity = creep.store[res];
							}
							let cap = to.store.getFreeCapacity();
							if (quantity > cap){
									quantity = cap;
							}
							return creep.transfer(to, res, quantity)
					} else if (creep.store.getUsedCapacity() == 0){
							if (from.store && from.store[res]){
									if (quantity > from.store[res]){
											quantity = from.store[res];
									}
									new RoomVisual(creep.room.name).poly([from.pos, creep.pos], {
											stroke: 'green',
											opacity: 1,
											strokeWidth: 0.2
									});
									if (!blocks[from.structureType]){
											blocks[from.structureType] = {};
									}
									blocks[from.structureType][res] = Game.time+50;
									return creep.withdraw(from, res, quantity)
							}
					}
			}
	}


	let spawnCode$2 = {
			priority: (room, countFunction) => {
					let priority = 6;
					return priority
			},
			isRequired: (room, countFunction) => {
					let numberRequired = 0;
					if ((room.terminal || room.memory.linkstore || room.class === 'bunker'||  room.memory.staticFillerSpots) && room.storage && room.controller.level > 3){
							numberRequired = 1;
					}
					if (room.class === 'bunker' && room.storage && room.controller.level > 3){
							numberRequired = 1;
					}
					let body = spawnCode$2.body(room, countFunction).body;
					if (room.nukeTime && room.nukeTime > 0 && body && room.nukeTime < body.length * 3){
							numberRequired++;
					}
					if (room.class == 'restructuring'){
							numberRequired = 0;
					}
					return countFunction('transfer', room) < numberRequired;
			},
			spawn: (room, role, body) => {
					//decide if we need any other options
					if (body){
							//options -> TTL, creepnumber
							room.spawnCreep(role, body);
					}
			},
			body: (room, countFunction) => {
					if (room.memory.roadsDown === undefined){
							room.memory.roadsDown = false;
					}
					let key = room.energyCapacityAvailable + ':' + room.memory.roadsDown;
					if (getCachedBody('tranfer',key)){
							return getCachedBody('tranfer',key)
					}
					let bodyObject = {
							body: [],
							cost: 0
					};
					//decide on what body to have
					let maxParts = 30;
					if (room.controller.level < 7 || Memory.myRooms.length < 3){
							maxParts = 17;
					}
					if (room.controller.level < 5){
							maxParts = 5;
					}
					if (room.memory.priorityEnergyRoom && Memory.myRooms.length > 5){
							maxParts = 50;
					}
					bodyObject.body = room.makeBody([CARRY], false, {oneMove: true, maxParts: maxParts});

					if (bodyObject.body && bodyObject.body.length > 0){
							bodyObject.cost += Game.getBodyCost(bodyObject.body);
					}
					cacheBody('transfer',key,bodyObject);
					return bodyObject
			}
	};

	var transfer = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$a,
		spawnCode: spawnCode$2
	});

	function run$9(creep){
			let stores = creep.home.storage;
			let upCont = null;
			let storeCont = null;
			let drops = Game.getObjectById(creep.home.memory.drops);
			new RoomVisual(creep.room.name).text('U', creep.pos);
			if (creep.home.memory.upCont){
					upCont = Game.getObjectById(creep.home.memory.upCont);
			}
			if (creep.home.memory.storeCont){
					storeCont = Game.getObjectById(creep.home.memory.storeCont);
			}
			if (upCont && creep.home.storage && creep.home.storage.my && creep.home.memory.uplink){
					upCont.destroy();
			}
			let upLink;
			if (creep.home.memory.uplink){
					upLink = Game.getObjectById(creep.home.memory.uplink);
			}
			if (creep.store.getUsedCapacity()===0){
					delete creep.memory.dropping;
			}
			if (creep.memory.dropping){
					let target = null;
					if (creep.home.storage && creep.store.getUsedCapacity()>creep.store.getUsedCapacity('energy')){
							creep.goAndTransfer(creep.home.storage);
							return
					}
					if (Game.cpu.bucket > 9000 || !creep.home.memory.uplink){
							findEnergyDropTarget(creep.home,creep);
							if (Game.cpu.bucket > 9000){
									let nearUpgraders = creep.pos.lookAround(LOOK_CREEPS, 1, {filter: (c) => c.my && (c.role == 'upgrader' || c.role == 'builder' || c.role == 'harvester') && c.store.getFreeCapacity() > 0});
									if (nearUpgraders && nearUpgraders[0]){
											creep.transfer(nearUpgraders[0], 'energy');
									}
							}
							return
					}
					if (creep.memory.dropTarget){
							target = Game.getObjectById(creep.memory.dropTarget);
					}
					if (!target){
							if (upCont && (creep.home.memory.brigade || creep.home.controller.ticksToDowngrade < CONTROLLER_DOWNGRADE[creep.home.controller.level] * 0.7)){
									target = upCont;
							} else if (upLink && creep.home.memory.manualLoadUpLink && creep.home.total('energy')>creep.home.memory.reserve){
									target = upLink;
							} else if (storeCont && creep.home.memory.sites && creep.home.memory.bigSites && Game.cpu.bucket > 9000 && creep.home.controller.level < 5 && creep.num % 2 === 0){
									let builder = creep.pos.findClosestByRange(FIND_MY_CREEPS,{filter:(c)=>c.role === 'builder' && c.store.getFreeCapacity()>0});
									if (builder){
											target = builder;
									} else {
											target = storeCont;
									}
							} else if (storeCont && upCont && upCont.store['energy'] < 1500 && creep.num % 2 === 0){
									target = storeCont;
							} else if (upCont && (!stores || !stores.my || (stores && stores.store['energy'] >= creep.home.memory.reserve) ||
									(storeCont && storeCont.store.getUsedCapacity() > 500)) && upCont.store['energy'] < 1700){
									target = upCont;
							} else if (storeCont){
									target = storeCont;
							} else if (stores && stores.my){
									target = stores;
							}
					}
					if (creep.home.storage && creep.store.getUsedCapacity() > creep.store.getUsedCapacity('energy')){
							if (creep.pos.isNearTo(creep.home.storage)){
									for (let i in creep.store){
											if (creep.store[i]>0){
													creep.transfer(creep.home.storage,i);
													break
											}
									}
							} else {
									flowPath(creep,creep.home.storage,1);
							}
							return
					}
					if (target && target.store.getFreeCapacity() === 0){
							delete creep.memory.dropTarget;
							if (Game.flags['rally' + creep.home.name]){
									creep.moveTo(Game.flags['rally' + creep.home.name], {range: 2});
									if (creep.pos.inRangeTo(Game.flags['rally' + creep.home.name], 3)){
											creep.startNap(3);
									}
							}
							return
					}
					if (target){
							if (!creep.memory.dropTarget){
									creep.memory.dropTarget = target.id;
							}
							if (creep.pos.isNearTo(target)){
									creep.transfer(target, 'energy');
							} else {
									flowPath(creep,target,1);
									if (Game.cpu.bucket > 9000 && creep.pos.inRangeTo(target,3)){
											let nearUpgraders = creep.pos.lookAround(LOOK_CREEPS, 1, {filter: (c) => c.my && (c.role == 'upgrader' || c.role == 'builder' || c.role == 'harvester') && c.store.getFreeCapacity() >= 50});
											if (nearUpgraders && nearUpgraders[0]){
													creep.transfer(nearUpgraders[0], 'energy');
											}
									}
							}
					}
			} else if (!creep.memory.dropping){
					if (creep.store.getUsedCapacity() === creep.store.getCapacity()){
							creep.memory.dropping = true;
							delete creep.memory.useStore;
					}
					let stores = creep.home.storage;
					delete creep.memory.dropTarget;
					if (creep.home.controller.level < 7 || !config.conserveCpu){
							let room = creep.home;
							if ((creep.num < 3 || room.memory.brigade || creep.memory.useStore) && (upCont|| upLink) && room.storage && !room.memory.lotsOfDroppedEnergy && room.storage.store['energy'] > room.memory.reserve
							&& (room.memory.manualLoadUpLink ||
											(room.memory.upCont && Game.getObjectById(room.memory.upCont) && (!room.memory.upContEnergy || room.memory.upContEnergy < 500)))){
									creep.goAndWithdraw(room.storage, 'energy');
									creep.memory.useStore = true;
							} else {
									creep.findEnergyTarget();
							}
							return
					}
					var conts = Game.getObjectById(creep.home.memory.conts);
					var conts1 = Game.getObjectById(creep.home.memory.conts1);
					let resCont = Game.getObjectById(creep.home.memory.resconts);
					if (drops){
							let cont = drops.pos.lookAround(LOOK_STRUCTURES, 0, {filter: (s) => s.structureType == STRUCTURE_CONTAINER})[0];
							if (creep.pickup(drops, 'energy') == ERR_NOT_IN_RANGE){
									creep.moveTo(drops, {range: 1});
							}
							if (cont){
									creep.withdraw(cont, 'energy', creep.store.getCapacity() - drops.amount);
							}
					} else if (conts && conts.store['energy'] > 1000 && creep.num % 2 == 0){
							if (creep.withdraw(conts, 'energy') == ERR_NOT_IN_RANGE){
									creep.moveTo(conts, {range: 1});
							}
					} else if (conts1 && conts1.store['energy'] > 1000){
							if (creep.withdraw(conts1, 'energy') == ERR_NOT_IN_RANGE){
									creep.moveTo(conts1, {range: 1});
							}
					} else if (conts && conts.store['energy'] > 1000){
							if (creep.withdraw(conts, 'energy') == ERR_NOT_IN_RANGE){
									creep.moveTo(conts, {range: 1});
							}
					} else if (stores && stores.my && creep.home.total('energy')>= (creep.home.memory.reserve + (creep.store.getCapacity()*2)) && (upCont || (upLink && upLink.store['energy'] < 300))){
							if (creep.withdraw(stores, 'energy') == ERR_NOT_IN_RANGE){
									creep.moveTo(stores, {range: 1});
							}
					} else if (resCont && resCont.store.getUsedCapacity()>100){
							creep.goAndWithdraw(resCont);
					} else if (creep.store.getUsedCapacity() === 0){
							creep.rally(2, 2);
					}
			}
	}



	let spawnCode$1 = {
			priority: (room, countFunction) => {
					let priority = 35;
					if (room.memory.upCont && Game.getObjectById(room.memory.upCont)
							&& Game.getObjectById(room.memory.upCont).store.getFreeCapacity() < 200){
							priority += 20;
					} else if (room.memory.upCont && Game.getObjectById(room.memory.upCont)
							&& Game.getObjectById(room.memory.upCont).store.getUsedCapacity() < 200 && room.total('energy') > room.memory.reserve*1.1){
							priority = 23;
					}
					if (room.memory.lotsOfDroppedEnergy || room.manualLoadUpLink){
							priority = 23;
					}
					if (room.memory.someDroppedEnergy){
							priority = 28;
					}
					if (!room.storage && room.controller.level === 4){
							priority = 40;
					}
					if (room.storage && room.storage['energy'] < room.memory.reserve * 0.5){
							priority -= 10;
					} else if (room.controller.level < 5 && room.total('energy')>room.memory.reserve*1.5){
							priority -= 10;
					}
					if (countFunction('upHauler', room) > 1){
							priority += (countFunction('upHauler', room) * 2);
					}
					if (countFunction('upHauler', room) > 4 && countFunction('staticUpgrader', room)<1){
							priority = 50;
					}
					if (priority < 20){
							priority = 20;
					}
					return priority
			},
			isRequired: (room, countFunction,idleSpawn,partsNeeded) => {
					let upHaulerBodyParts = 10;
					let numberRequired = 0;
					if (room.memory.armedHostiles || (room.memory.defcon < 5 && (Game.time-room.memory.lastAttacked )< 500 && !room.controller.safeMode)){
							return false
					}
					if (!room.memory.upCont || !Game.getObjectById(room.memory.upCont) || room.memory.manualLoadUpLink){
							upHaulerBodyParts = 9;
					}
					if ((room.memory.lotsOfDroppedEnergy && (room.storage || (room.memory.upCont && Game.getObjectById(room.memory.upCont) && room.controller.level !== 4)))
							|| (room.total('energy')>room.memory.reserve*1.3 && room.memory.manualLoadUpLink)){
							upHaulerBodyParts = 18;
							if (room.memory.droppedEnergyCount){
									upHaulerBodyParts += Math.round(room.memory.droppedEnergyCount/150);
							}
							if (room.total('energy')>room.memory.reserve*1.5){
									upHaulerBodyParts += 20;
							}
							if (room.total('energy')>room.memory.reserve*1.8 &&  room.memory.upCont
									&& Game.getObjectById(room.memory.upCont) && Game.getObjectById(room.memory.upCont).store.getUsedCapacity() < 200){
									upHaulerBodyParts += 20;
							}
					}
					if (room.memory.manualLoadUpLinkParts && room.total('energy') > room.memory.reserve*1.5){
							upHaulerBodyParts += (room.memory.manualLoadUpLinkParts*1.5);
					}
					if (partsNeeded){
							return upHaulerBodyParts
					}
					if ((room.memory.upCont && Game.getObjectById(room.memory.upCont) || !room.memory.brigade || room.memory.lotsOfDroppedEnergy || room.memory.manualLoadUpLink) &&
							(room.memory.manualLoadUpLink || room.controller.level < 5 || (room.memory.someDroppedEnergy && room.controller.level < 6) || room.memory.lotsOfDroppedEnergy || !room.memory.uplink || !Game.getObjectById(room.memory.uplink))
							&& (room.storage || room.memory.storeCont)){
							numberRequired = Game.bodySizeToNumberNeeded(upHaulerBodyParts, spawnCode$1.body(room, countFunction,upHaulerBodyParts).body);
					}
					if (idleSpawn && room.memory.upCont && Game.getObjectById(room.memory.upCont) && numberRequired){
							numberRequired = Math.round(numberRequired*1.5);
					}
					if (numberRequired > 10 && !room.controller.storage){
							numberRequired = 10;
					}
					room.display(`manual load uplink ${room.memory.manualLoadUpLink}`);
					room.display('uphauler', numberRequired);
					let count = countFunction('upHauler', room);
					if (Game.cpu.bucket > 9000 && !config.conserveCpu && room.controller.level < 6){
							let newCount = countRoleAdjustingForParts('upHauler',room,spawnCode$1.body(room,countFunction,upHaulerBodyParts));
							if (newCount !== undefined){
									count = newCount;
							}
					}
					if (room.controller.level > 7 && numberRequired > 1){
							numberRequired = 1;
					}
					return count < numberRequired;
			},
			spawn: (room, role, body) => {
					//decide if we need any other options
					if (body){
							//options -> TTL, creepnumber
							room.spawnCreep(role, body);
					}
			},
			body: (room, countFunction,partsNeeded) => {
					if (room.memory.roadsDown === undefined){
							room.memory.roadsDown = false;
					}
					if (!partsNeeded){
							//ensure to declare in isRequired to reduce looping
							partsNeeded = spawnCode$1.isRequired(room,countFunction,undefined,true);
					}
					let key = room.energyCapacityAvailable + ':' + room.memory.roadsDown+':'+room.memory.manualLoadUpLink+':'+partsNeeded;
					if (getCachedBody('upHauler',key)){
							return getCachedBody('upHauler',key)
					}
					let bodyObject = {
							body: [],
							cost: 0
					};
					//decide on what body to have
					if (config && config.conserveCpu && partsNeeded > 10){
							if (partsNeeded > 50){
									partsNeeded = 50;
							}
							bodyObject.body = room.makeBody([CARRY], true, {maxParts: partsNeeded});
					} else {
							bodyObject.body = room.makeBody([CARRY], true, {maxParts: 10});
					}

					if (bodyObject.body && bodyObject.body.length > 0){
							bodyObject.cost += Game.getBodyCost(bodyObject.body);
					}
					cacheBody('upHauler',key,bodyObject);
					return bodyObject
			}
	};

	var upHauler = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$9,
		spawnCode: spawnCode$1
	});

	function run$8(creep){
		let targetRoom = creep.num;
		if (targetRoom && creep.room.name != targetRoom){
			creep.goTo(targetRoom, {SK: true});
		} else if (targetRoom && creep.pos.onEdge()){
				if (creep.room.controller && creep.room.controller.owner){
						getIntel(creep.room);
						//try not to get shot by staying on edge
						return
				}
			let pos = new RoomPosition(25, 25, targetRoom);
			if (creep.room.controller){
				pos = creep.room.controller.pos;
			}
			if (pos){
				creep._moveTo(pos, {range: 5});
			}
		} else {
			evaluateRoom(creep.room, creep.home);
			creep.startNap(creep.ticksToLive);
		}
	}

	var vision = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$8
	});

	function run$7(creep){
			let room = creep.home;
			if (!creep.memory.boosted && room.memory.sboostlab){
					let needBoost = false;
					for (let i in creep.body){
							let part = creep.body[i];
							if (part.boost){
									continue
							}
							if (part.type == 'work'){
									needBoost = true;
									break
							}
					}
					let sblab = Game.getObjectById(room.memory.sboostlab['LH']);
					if (sblab && sblab.boostCreep(creep) == -9){
							creep.moveTo(sblab, {range: 1});
					}
					if (!sblab || !sblab.store['LH'] || sblab.mineral || !needBoost){
							creep.memory.boosted = true;
					}
					if (sblab && sblab.store['LH'] > 600){
							return
					}
			}
			if (room.memory.repairLinkLocation && room.memory.repairLink && Game.getObjectById(room.memory.repairLink)){
					let loc = room.memory.repairLinkLocation.toPos();
					if (!creep.pos.isNearTo(loc) && creep.memory.spot === undefined){
							creep.say('to loc');
							creep.moveTo(loc, {range: 1});
					} else if (!creep.memory.target){
							setTarget(loc, creep);
					} else {
							let link = Game.getObjectById(room.memory.repairLink);
							let target = Game.getObjectById(creep.memory.target);
							if (creep.memory.spot != undefined && link){
									if (!creep.memory.spot){
											if (creep.store['energy'] < 40 && link.energy > 0){
													creep.say('withdraw');
													if (creep.withdraw(link, 'energy') == -9){
															creep.moveTo(link, {range: 1});
													}
											} else {
													creep.say('repair');
													if (creep.repair(target) == -9){
															creep.moveTo(target, {range: 3});
													}
											}
											return
									}
									let spot = creep.memory.spot.toPos();
									if (creep.pos.isEqualTo(spot)){
											if (creep.store['energy'] < 40 && link.energy > 0){
													creep.withdraw(link, 'energy');
											}
											creep.repair(target);
									} else {
											creep.say('to spot');
											creep.moveTo(spot);
									}
							} else if (link && creep.pos.isNearTo(link) && creep.pos.inRangeTo(target, 3)){
									creep.memory.spot = creep.pos.toString();
							} else {
									let spots = loc.neighbours(1);
									for (let i in spots){
											if (spots[i].isWalkable(true) && spots[i].inRangeTo(target, 3)){
													creep.memory.spot = spots[i].toString();
													break
											}
									}
									{
											creep.memory.spot = false;
									}
							}
					}
			}
	}

	function setTarget(loc, creep){
			let plannedRamps = creep.home.plannedRamparts;
			let ramps = loc.lookAround(LOOK_STRUCTURES, 4, {
					filter: (s) => s.structureType == STRUCTURE_RAMPART && (!plannedRamps|| plannedRamps.includes(s.pos.toString()))
							&& creep.home.memory.walls && s.hits < creep.home.memory.walls + 1000000
			});
			let ramp;
			if (ramps && ramps.length > 0){
					ramp = ramps.sort((a, b) => a.hits - b.hits)[0];
			} else if (!ramps || ramps.length === 0){
					if (creep.home.memory.repairLink && Game.getObjectById(creep.home.memory.repairLink)){
							Game.getObjectById(creep.home.memory.repairLink).destroy();
					}
					delete creep.home.memory.repairLink;
					delete creep.home.memory.repairLinkLocation;
					delete creep.memory.target;
					delete creep.memory.spot;
			}
			if (ramp){
					creep.memory.target = ramp.id;
			}
	}

	let spawnCode = {
			priority: (room, countFunction) => {
					let priority = 50;
					return priority
			},
			ableToAfford :(room) => {
					if (!Game.energyCrisis && !Game.energyCaution && room.controller.level > 7 && room.storage && room.memory.limit && room.storage.store['energy'] > room.memory.limit + 5000 && room.ecoStable && !room.armedHostiles){
							return true;
					}
					return false
			},
			isRequired: (room, countFunction) => {
					if (!room.ecoStable || room.armedHostiles || room.memory.defcon < 5){
							return false
					}
					let wallBuilderNum = 0;
					if (spawnCode.ableToAfford(room) &&  room.memory.repairLink &&
							room.memory.repairLinkLocation){
							wallBuilderNum = 1;
							if (room.storage.store['energy'] > limit * 2){
									wallBuilderNum = 2;
							}
							if (room.storage.store['energy'] > limit * 2){
									wallBuilderNum = 3;
							}

					}
					return countFunction('wallBuilder', room) < wallBuilderNum;
			},
			spawn: (room, role, body) => {
					//decide if we need any other options
					if (body){
							//options -> TTL, creepnumber
							room.spawnCreep(role, body);
					}
			},
			body: (room, countFunction) => {
					if (room.memory.roadsDown === undefined){
							room.memory.roadsDown = false;
					}
					let key = room.energyCapacityAvailable + ':' + room.memory.roadsDown;
					if (getCachedBody('wallBuilder',key)){
							return getCachedBody('wallBuilder',key)
					}
					let bodyObject = {
							body: [],
							cost: 0
					};
					//decide on what body to have
					getBody$5(room.energyCapacityAvailable,room, room.memory.roadsDown, 'wallBuilder');

					if (bodyObject.body && bodyObject.body.length > 0){
							bodyObject.cost += Game.getBodyCost(bodyObject.body);
					}
					cacheBody('wallBuilder', key, bodyObject);
					return bodyObject
			}
	};

	var wallBuilder = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$7,
		spawnCode: spawnCode
	});

	function run$6(creep){
		let targetRoom = creep.num;
		if (creep.hits < creep.hitsMax){
			creep.home.memory.wallRemoverBlocked = Game.time + 1000;
		}
		if (targetRoom && creep.room.name != targetRoom && !Game.rooms[targetRoom]){
			let pos = new RoomPosition(25, 25, targetRoom);
			creep.pullTo(pos);
		} else if (targetRoom && Game.rooms[targetRoom] && Game.rooms[targetRoom].structureMatrix){
			let sector = Game.map.getSector(targetRoom);
			let side = Game.map.getHighwaySide(targetRoom);
			let COs = /\w(\d+)\w(\d+)/.exec(targetRoom);
			let roomNum = COs[1];
			if (side == 'y'){
				roomNum = COs[2];
			}
			let mem = Memory.highwayWalls;
			let wallData;
			if (mem && sector && side && roomNum && mem[sector] &&
				mem[sector][side] && mem[sector][side][roomNum]){
				wallData = mem[sector][side][roomNum];
			} else {
				evaluateRoom(Game.rooms[targetRoom], creep.home);
			}
			if (wallData && (!creep.memory.pos || !creep.memory.target)){
				let route = wallData.route;
				let homeSector = Game.map.getSector(creep.home.name);
				let highwaySectors = Game.map.getHighwaySectors(targetRoom);
				let dir, exit;
				for (let i in highwaySectors){
					if (highwaySectors[i] == homeSector){
						//i is direction the sector is in, ie if we can path to this exit we can collect this symbol
						dir = i;
						break
					}
				}
				if (dir){
					exit = Game.rooms[targetRoom].find(Number.parseInt(dir))[0];
				}
				let foundWall = false;
				routeLoop:
					for (let i in route){
						let pos = route[i].toPos();
						let wall = pos.lookAround(LOOK_STRUCTURES, 0, {filter: (s) => s.structureType == STRUCTURE_WALL})[0];
						if (pos && wall){
							foundWall = true;
							let neighbours = pos.neighbours();
							for (let n in neighbours){
								let neighbour = neighbours[n];
								if (neighbour.isWalkable()){
									if (exit){
										//dir also corresponds to constant for room find exit side
										let path = PathFinder.search(neighbour, {pos: exit, range: 1}, {
											roomCallback: function (roomName){
												if (Game.rooms[roomName]){
													let matrix = Game.rooms[roomName].structureMatrix;
													if (matrix){
														return matrix
													}
												}
											},
											maxRooms: 1, maxOps: 1000
										});
										console.log(path.path);
										if (path && !path.incomplete){
											//can destroy this wall
											creep.memory.pos = neighbour.toString();
											creep.memory.target = wall.id;
											break routeLoop
										}
									}
								}
							}
						}
					}
				if (!foundWall){
					logHighwayAsOpen(targetRoom);
				}
			}
			if (creep.memory.pos && creep.memory.target){
				let pos = creep.memory.pos.toPos();
				if (pos){
					if (creep.room.name == pos.roomName && creep.pos.isEqualTo(pos)){
						let target = Game.getObjectById(creep.memory.target);
						if (target){
							creep.dismantle(target);
						} else {
							delete creep.memory.target;
						}
					} else {
						creep.pullTo(pos, true);
					}
				} else {
					delete creep.memory.pos;
				}
			}
		}
	}

	var wallRemover = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$6
	});

	for (let i in RoleModules){
			console.log('initialise role',i);
	}
	const controlledSuicide = {
			'yak':30,
			'fixer':30,
			'builder':30,
			'harvester':15,
			'upHauler':30,
			'mover':15
	};
	const recoverBucket = false;
	let lastFrozen = {};
	let lastClearedFrozen;
	let freezeToBuild;
	function setFreezeToBuild(timeToFreeze){
			console.log(`announcement|${Game.shard.name}|freezing creeps to allow build`);
			freezeToBuild = Game.time+timeToFreeze;
	}
	function runCreeps(){
			if (!lastClearedFrozen || Game.time-lastClearedFrozen>1000){
					for (let i in lastFrozen){
							if (!Game.getObjectById(i)){
									delete lastFrozen[i];
							}
					}
					lastClearedFrozen = Game.time;
			}
			let cpuMemory = {}, roleCounter = {},cpuMemoryExcludingIdle = {},roleCounterExcludingIdle = {};
			let date = new Date();
			let christmas,newYearsDay,newYearsEve;
			if (date.getDate() === 25 && date.getMonth() === 11){
					christmas = true;
			}
			if (date.getDate() === 1 && date.getMonth() === 0){
					newYearsDay = true;
			}
			if (date.getDate() === 31 && date.getMonth() === 11 && date.getHours() === 23 && date.getMinutes() === 59){
					newYearsEve = 60 - date.getSeconds();
					newYearsEve = newYearsEve+'!';
			}
			for (let name in Game.creeps){
					let creep = Game.creeps[name];
					if (creep.num !== 1 && creep.home && creep.home.controller.level < 6 && creep.home.class === 'normal' && !creep.home.memory.build && Game.cpu.bucket < 2000){
							console.log(`announcement|${Game.shard.name}|freezing creeps in ${creep.home.name} to allow build`);
							freezeToBuild = Game.time + 5;
							continue
					}
					if (christmas){
							if (Game.time % 2 === 0){
									creep.say('🎅',{public:true});
							} else {
									creep.say('🎁',{public:true});
							}
					}
					if (newYearsDay){
							if (Game.time % 4 === 0){
									creep.say('HAPPY',{public:true});
							} else if (Game.time % 4 === 1){
									creep.say('NEW',{public:true});
							} else if (Game.time % 4 === 2){
									creep.say('YEAR!',{public:true});
							} else {
									creep.say('🥳',{public:true});
							}
					}
					if (newYearsEve){
							creep.say(newYearsEve,{public:true});
					}
					if (creep.role === 'yak' || creep.role === 'remoteminer' || creep.role === 'remotefixer' || creep.role === 'observer');
					if (controlledSuicide[creep.role] && creep.ticksToLive < controlledSuicide[creep.role]){
							if (creep.home.storage && creep.store.getUsedCapacity()>0){
									creep.goAndTransfer(creep.home.storage);
							} else if (creep.home.memory.fixedBaseOrigin){
									let pos = creep.home.memory.fixedBaseOrigin.toPos();
									if (pos && !creep.pos.isEqualTo(pos)){
											creep.moveTo(pos,{range:0});
									} else {
											creep.suicide();
									}
							}
					}
					if (creep.role == 'attacker' || creep.role == 'medic' || creep.role == 'sniper' ||
							creep.role == 'dozer' || creep.role == 'guard' || creep.role == 'soldier' || creep.role == 'ambusher' || creep.role == 'skirmisher'){
							creep.notifyWhenAttacked(false);
					}
					let homeRoom = Game.rooms[creep.name.split(' ')[2]];
					if (!homeRoom && creep.role != 'trader' && creep.role != 'bulkTrader' && creep.role != 'colonist' && creep.role != 'claimer' && creep.role != 'attacker' && creep.role != 'filler'
							&& creep.role != 'medic' && creep.role != 'sniper' && creep.role != 'dozer');
					if (creep.memory.wakeUpTime != undefined){
							try {
									let role = 'role.' + name.split(' ')[0];
									let a = Game.cpu.getUsed();
									creep.nap();
									let cpuUsed =Game.cpu.getUsed() - a;
									if (cpuUsed > 5){
											console.log(creep.name,creep.pos.hyperlink,'high cpu',cpuUsed);
									}
									if (cpuMemory[role]){
											cpuMemory[role] += cpuUsed;
											roleCounter[role] ++;
									} else {
											cpuMemory[role] = cpuUsed;
											roleCounter[role] = 1;
									}

									continue
							} catch (err){
									console.log(err);
							}
					}
					let module;
					let role;
					try {
							if (creep.memory.role == undefined || creep.role == 'trader'){
									role = name.split(' ')[0];
									module = RoleModules[role];
							} else {
									role = creep.memory.role;
									module = RoleModules[role];
							}
					} catch (err){
							console.log(creep.name, creep.pos, err);
					}
					if (creep.spawning == false && role && module){
							try {
									if (Game.cpu.bucket < 1000
											&& (creep.role == 'yak' || creep.role == 'remoteminer' || creep.role == 'uphauler' || creep.role == 'observer'
											|| creep.role == 'SKMineralMiner' || creep.role === 'SKMineralMover')
											&& Game.cpu.getUsed() > Game.cpu.limit){
											continue
									}
									if (Game.cpu.bucket < 300 && Game.time % 3 !== 0 && (creep.role == 'observer')){
											continue
									}
									if (config$1 && config$1.lowCPU && Game.cpu.bucket < 1000){
											let offRoles = ['remoteFixer', 'fixer', 'wallBuilder', 'upgrader','staticUpgrader'];
											let numRoles = ['remoteMiner', 'yak'];
											if (offRoles.includes(creep.role) || (numRoles.includes(creep.role) && creep.num > 3)){
													continue
											}
									}
									let a = Game.cpu.getUsed();
									if ((!lastFrozen[creep.id] || lastFrozen[creep.id] !== Game.time-Math.round(Math.random())) && (a > ((Game.cpu.limit*0.8)+Game.cpu.bucket) || a > 400 || (a>Game.cpu.bucket) || recoverBucket || (freezeToBuild && freezeToBuild>Game.time)) && creep.role !== 'harvester' && (creep.role !== 'transfer' || Game.time % 2 ===0)
									&& creep.home && !creep.home.memory.armedHostiles && creep.home.memory.defcon === 5 &&
											creep.role !== 'remoteminer' && creep.role !== 'miner1'&& creep.role !== 'harvester' && (creep.role !== 'yak' || Memory.excessEnergy > 0) && creep.role !== 'reserve' && creep.role !== 'coreHauler'
											&& creep.home.ecoStable && role !== 'staticFiller' && role !== 'powermover' && creep.role !== 'thoriumMineFiller'
											&& creep.role !== 'thoriumMiner' && creep.role !== 'claimer'  && creep.role !== 'soldier' && creep.role !== 'thoriumBaseHauler' && creep.role !== 'thoriumReactorHauler'){
											Memory.redLining = Game.time;
											lastFrozen[creep.id] = Game.time;
											new RoomVisual(creep.room.name).text('🧊', creep.pos);
											continue
									}
									if (creep.skipTurn){
											continue
									}
									module.run(creep);
									let cpuUsed =Game.cpu.getUsed() - a;
									if (false && cpuUsed > 5);
									if (config$1.private){
											new RoomVisual(creep.pos.roomName).text(cpuUsed.toFixed(2),creep.pos);
											if (cpuUsed>6){
													console.log('high cpu',creep.name,creep.pos,cpuUsed);
													creep.memory.highCPU = true;
											}
									}
									role = 'role.'+role;
									if (cpuMemory[role]){
											cpuMemory[role] += cpuUsed;
											roleCounter[role] ++;
											cpuMemoryExcludingIdle[role] += cpuUsed;
											roleCounterExcludingIdle[role] ++;
									} else {
											cpuMemory[role] = cpuUsed;
											roleCounter[role] = 1;
											cpuMemoryExcludingIdle[role] = cpuUsed;
											roleCounterExcludingIdle[role] = 1;
									}
							} catch (err){
									console.log('err with ' + creep.pos + role + ' : ' + err.stack.split("at"));
									console.log(err);
									Game.notify('err with ' + creep.pos + role + ' : ' + err.stack.split("at"), 30);
							}
					} else if (!module){
							console.log('ERROR - Cannot locate ' + role + ' module');
							/*creep.memory.reason = 'corruption'
							creep.memory.role = 'recycle'*/
					}
			}
			for (let r in cpuMemory){
					if (!Memory.stats.rolemem){
							Memory.stats.rolemem = {};
					}
					Memory.stats.rolemem['roleCpuExcludingIdle.'+r] = cpuMemoryExcludingIdle[r] / roleCounterExcludingIdle[r];
					Memory.stats.rolemem['rolecpu.' + r] = cpuMemory[r];
					Memory.stats.rolemem['rolecount.' + r] = roleCounter[r];
					Memory.stats.rolemem['roleavgcpu.' + r] = cpuMemory[r] / roleCounter[r];
			}

	}

	let wallAdjust = config$1.wallAdjust;
	let rampartAdjust = config$1.rampartAdjust;
	if (!wallAdjust){
			wallAdjust = 3;
	}
	if (!rampartAdjust){
			rampartAdjust = 1.5;
	}
	playerHeap.sectorMemory = {};
	let decoders = {};
	playerHeap.structureRampartCacheAll = {};
	playerHeap.blockRoadCheckAll = {};
	let wallCheckDue = {};
	let towerCheckDue = {};
	let upLinkCheck = {};
	function setUp(){
			// create list of creep per home
			for (let i in Game.creeps){
					let creep = Game.creeps[i];
					let home = creep.home;
					if (home && !home.creepList){
							home.creepList = [];
							home.civList = [];
							home.roleList = {};
					}
					if (home){
							home.creepList.push(creep);
							let role = creep.role;
							if (role !== 'medic' && role !== 'attacker' && role !== 'dozer' && role !== 'sniper'){
									home.civList.push(creep);
							}
							if (!home.roleList[role]){
									home.roleList[role] = [];
							}
							home.roleList[role].push(creep);
					}
			}
			if (!Memory.stats){
					Memory.stats = {};
			}
			if (!Memory.ownedRooms){
					Memory.ownedRooms = {};
			}
			if (!Memory.toleratedRooms){
					Memory.toleratedRooms = {};
			}
			if (!Memory.powerPaths){
					Memory.powerPaths = {};
			}
			if (!Memory.powerBanks){
					Memory.powerBanks = {};
			}
			if (!Memory.productionMandate){
					Memory.productionMandate = {};
			}
			if (!Memory.contestedTerritory){
					Memory.contestedTerritory = {};
			}
			if (!Memory.commodities){
					Memory.commodities = {};
			}
			if (!Memory.forceReserveRooms){
					Memory.forceReserveRooms = {};
			}
			//making the stats 0 so they don't cumulate across ticks
			Memory.stats['average8Energy'] = 0;
			Memory.stats['idle'] = {};
			Memory.stats['remote.EnergyGained'] = 0;
			Memory.stats['remote.EnergyLost'] = 0;
			Memory.stats['extensionsCPU.searchMap'] = 0;
			Memory.stats['extensionsCPU.searchMapTotal'] = 0;
			Memory.stats['extensionsCPU.formPath'] = 0;
			Memory.stats['extensionsCPU.formPathTotal'] = 0;
			Memory.stats['roomEnergy'] = {};
			Memory.stats.squads = {
					cpu:{},
					number:{}
			};
			Memory.stats.squadsSpawning = {
					cpu:{},
					number:{}
			};
			Memory.stats.rolemem = {};
			Memory.stats.creepSpawningCPU = {};
			Memory.myRooms = [];
			if (!Memory.homeRooms){
					Memory.homeRooms = [];
			}
			if (Memory.visited == undefined){
					Memory.visited = {};
			}
			if (Memory.rooms == undefined){
					Memory.rooms = {};
			}
			if (!Memory.sectors){
					Memory.sectors = {};
			}
			if (!Memory.prayerRooms){
					Memory.prayerRooms = {};
			}
			if (!Memory.hostiles){
					Memory.hostiles = {};
			}
	}
	function garbageCollection(){
			for (let i in Game.flags){
					let split = Game.flags[i].name.split('-');
					if (split && split[0] === 'WP'){
							console.log(Game.flags[i].name);
					}
			}
			//deleting old memory
			for (let name in Memory.creeps){
					if (!Game.creeps[name]){
							delete Memory.creeps[name];
					}
			}
			if (Memory.powerPaths &&  (Game.time % 100 === 0 || Game.cpu.bucket > 9000)){
					for (let homeRoomName in Memory.powerPaths){
							let obj = Memory.powerPaths[homeRoomName];
							for (let targetRoomName in obj){
									let pathData = obj[targetRoomName];
									if (!pathData || !pathData.expiry || pathData.expiry>Game.time){
											delete Memory.powerPaths[homeRoomName][targetRoomName];
									}
							}
					}
			}
			if (Memory.deposits &&  (Game.time % 1000 === 0 || Game.cpu.bucket > 9000)){
					for (let i in Memory.rooms){
							if (!Memory.rooms[i].depositTargets){
									continue
							}
							for (let j = Memory.rooms[i].depositTargets.length-1;j > 0;j--){
									let pos = Memory.rooms[i].depositTargets[j];
									if (!Memory.deposits[pos]){
											Memory.rooms[i].depositTargets.splice(j,1);
									}
							}
					}
			}
			if ((Game.time % 1000 === 0 || Game.cpu.bucket > 9000)){
					for (let i in Memory.rooms){
							if (!Memory.rooms[i].optimalWallMatrixExp || Game.time > Memory.rooms[i].optimalWallMatrixExp){
									delete Memory.rooms[i].optimalWallMatrix;
							}
					}
			}
			if (Memory.toleratedRooms && Game.time % 100000 === 0){
					for (let i in Memory.toleratedRooms){
							if (Memory.toleratedRooms[i] === 'MarvinTMB'){
									continue
							}
							if (!Memory.ownedRooms || !Memory.ownedRooms[i]){
									delete Memory.toleratedRooms[i];
							}
					}
			}
			if (Game.time % 1000 === 0){
					for (let i in Memory.rooms){
							delete Memory.rooms[i].territoryAdded;
							if (Memory.rooms[i].sourcePaths){
									for (let j in Memory.rooms[i].sourcePaths){
											let path = Memory.rooms[i].sourcePaths[j];
											if (path.expiry && Game.time > path.expiry){
													delete  Memory.rooms[i].sourcePaths[j];
											}
									}
							}
							if (Memory.rooms[i].yakOutPaths){
									for (let j in Memory.rooms[i].yakOutPaths){
											let path = Memory.rooms[i].yakOutPaths[j];
											if (path.expiry && Game.time > path.expiry){
													delete  Memory.rooms[i].yakOutPaths[j];
											}
									}
							}
							if (Memory.rooms[i].minerPaths){
									for (let j in Memory.rooms[i].minerPaths){
											let path = Memory.rooms[i].minerPaths[j];
											if (path.expiry && Game.time > path.expiry){
													delete  Memory.rooms[i].minerPaths[j];
											}
									}
							}
							if (Memory.rooms[i].routes){
									for (let j in Memory.rooms[i].routes){
											let path = Memory.rooms[i].routes[j];
											if (path.expiry && Game.time > path.expiry){
													delete  Memory.rooms[i].routes[j];
											}
									}
							}
					}
					delete Memory.territory;
			}
			if (Memory.powerBanks &&  (Game.time % 100 === 0 || Game.cpu.bucket > 9000)){
					for (let id in Memory.powerBanks){
							let obj = Memory.powerBanks[id];
							if (obj.time && Game.time > (obj.time+20000)){
									delete Memory.powerBanks[id];
							}
					}
			}
			if (Game.time % 500 == 0){
					Memory.mineralsWithAccess = {
							"H": 0, "O": 0, "L": 0, "K": 0, "Z": 0, "U": 0, "X": 0
					};
			}
			if (Memory.colonistEscort){
					for (let i in Memory.colonistEscort){
							if (Memory.colonistEscort[i] < Game.time){
									delete Memory.colonistEscort[i];
							}
					}
			}
			if (!Memory.contestedRooms){
					Memory.contestedRooms = {};
			} else if (Game.time % 1000 == 0){
					for (let i in Memory.contestedRooms){
							if (Memory.contestedRooms[i].expiry <= Game.time){
									delete Memory.contestedRooms[i];
							}
					}
					for (let i in Memory.sources){
							if (!Memory.sources[i].expiry || Game.time > Memory.sources[i].expiry){
									delete Memory.sources[i];
							}
					}
			}
			if (Memory.energyNeeded){
					for (let i in Memory.energyNeeded){
							let roomName = Memory.energyNeeded[i];
							if (!Game.rooms[roomName] || !Game.rooms[roomName].controller || !Game.rooms[roomName].controller.my){
									delete Memory.energyNeeded;
									break
							}
					}
			}
			if (Memory.prayerRooms){
					for (let i in Memory.prayerRooms){
							if (!Game.rooms[i] || !Game.rooms[i].class || Game.rooms[i].class != 'prayer'){
									delete Memory.prayerRooms[i];
							}
					}
			}
			for (let hos in Memory.hostiles){
					let hostile = Memory.hostiles[hos];
					if (!hostile.deleteAt || hostile.deleteAt == null || (hostile.deleteAt < Game.time)){
							delete Memory.hostiles[hos];
					}
			}
			if (Memory){
					let sites = [];
					let sroom = {};
					if (Game.time % 10 === 0){
							for (var si in Game.constructionSites){
									if (Game.constructionSites[si].progress == 0){
											if (Game.constructionSites[si].room){
													delete Game.constructionSites[si].room.memory.plannedSites;
											}
											//Game.constructionSites[si].remove()
									}
									sites.push('');

									if (Game.constructionSites[si].room){
											// if (Game.constructionSites[si].structureType == STRUCTURE_ROAD && Game.constructionSites[si].progress == 0){
											// 		Game.constructionSites[si].remove()
											// }
											let room = Game.constructionSites[si].room.name;
											if (!sroom[room]){
													sroom[room] = 1;
											} else {
													sroom[room] = sroom[room] + 1;
											}
									} else {
											//Game.constructionSites[si].remove()
											if (!sroom['?']){
													sroom['?'] = 1;
											} else {
													sroom['?'] = sroom['?'] + 1;
											}
									}
							}
					}
					Memory.sites = sites.length;
					for (let si in sroom){
							//to find where sites are
							//console.log(si + '  :  ' + sroom[si])
							if (Game.rooms[si]){
									Game.rooms[si].siteNumber = sroom[si];
							}
					}
			}
	}
	function mainMemorise(room){
			if (!room){
					return
			}
			if (!room.memory.siegeBlock){
					room.memory.siegeBlock = {};
			}
			if (!room.memory.spawnPartsWasted){
					room.memory.spawnPartsWasted = {
							logStart:Game.time,
							partsWasted:0
					};
			}
			if (room && room.memory.finalSources && room.memory.finalSources.length < 7 && room.controller.level > 7);
			var name = room.name;
			let targetReserve = 0;
			if (room.controller.level > 4 && room.controller.level < 7){
					targetReserve = config$1.energyReserve/2;
			} else if (room.controller.level == 7){
					targetReserve = (config$1.energyReserve/3)*2;
			} else if (room.controller.level == 8){
					targetReserve = config$1.energyReserve;
			} else {
					targetReserve = config$1.energyReserve/10;
			}
			let canChangeReserve = false;
			if (!room.memory.lastEnergyReserveChange || room.memory.lastEnergyReserveChange+500 < Game.time){
					canChangeReserve = true;
			}
			if (targetReserve && canChangeReserve){
					if (room.memory.reserve === undefined){
							room.memory.reserve = 3000;
					} else if (room.memory.reserve < targetReserve){
							room.memory.reserve += 500;
					} else {
							room.memory.reserve = targetReserve;
					}
					room.memory.lastEnergyReserveChange = Game.time;
			}
			if (Game.flags['defend' + room.name]){
					room.memory.reserve = room.memory.reserve * 1.5;
			}
			if ((room.memory.alert && room.memory.alert == 'high') || room.isShardTradeRoom ){
					room.memory.reserve = 300000;
			}
			if (config$1.alwaysGuard && config$1.alwaysGuard.includes(room.name)){
					room.memory.reserve = 300000;
			}
			if (!room.storage && !room.terminal){
					room.memory.reserve = 0;
			}
			if (room.class === 'bunker' && room.memory.adjustedLowWallHits > config$1.minWalls[7]-30000){
					room.memory.reserve = 300000;
			}
			if (((room.controller.level === 4 && !room.storage)
					|| (room.controller.level === 5 && (!room.memory.uplink || !Game.getObjectById(room.memory.uplink)))
					|| (room.controller.level === 3 && !canSpawnReserves(room)))){
					room.memory.staticUpgradersHelpBuild = true;
			} else {
					delete room.memory.staticUpgradersHelpBuild;
			}
			//dropped energy
			let droppedResources = room.find(FIND_DROPPED_RESOURCES);
			let energyList = [];
			let otherResourceList = [];
			for (let i in droppedResources){
					if (droppedResources[i].resourceType === 'energy'){
							energyList.push(droppedResources[i]);
					} else {
							otherResourceList.push(droppedResources[i]);
					}
			}
			if (room && room.controller && room.controller.level > 2 && !room.memory.sites){
					var resAm = 200;
			} else {
					var resAm = 50;
			}
			room.memory.level = room.controller.level;
			delete room.memory.upLoadContDrop;
			function findenergy(res){
					if (room.memory.upContPos && res.pos.toString()=== room.memory.upContPos){
							return false
					}
					if (room.memory.upgraderLoadingPosition && room.memory.manualLoadUpLink && res.pos.toString() === room.memory.upgraderLoadingPosition){
							room.memory.upLoadContDrop = true;
							return false
					}
					return (res.amount > resAm);
			}

			let drops = energyList.filter(findenergy);
			if (room.memory.armedHostiles && room.memory.fixedBaseOrigin){
					let origin = room.memory.fixedBaseOrigin.toPos();
					if (origin){
							drops = drops.filter((d) => d.pos.getRangeTo(origin) < 7);
					}
			} else if (room.memory.armedHostiles){
					drops = [];
			}
			let count = 0;
			let nonStoreCount = 0;
			for (let i in drops){
					count += drops[i].amount;
					if (room.memory.storeContPosition && drops[i].pos.toString() !== room.memory.storeContPosition){
							nonStoreCount += drops[i].amount;
					}
			}
			room.memory.homePeripheralDropsCount = nonStoreCount;
			if (count > 0){
					room.memory.droppedEnergyCount = count;
			} else {
					delete room.memory.droppedEnergyCount;
			}
			if (count > 1000){
					room.memory.lotsOfDroppedEnergy = true;
			} else {
					delete room.memory.lotsOfDroppedEnergy;
			}
			if (Game.time % 300){
					if (count > 1000){
							room.memory.lotsOfDroppedEnergySlowChange = true;
					} else {
							delete room.memory.lotsOfDroppedEnergySlowChange;
					}
			}
			if (count > 300){
					room.memory.someDroppedEnergy = true;
			} else {
					delete room.memory.someDroppedEnergy;
			}
			if ((drops[0] != null || drops[0] != undefined) && !room.memory.hostiles){
					room.memory.drops = drops[0].id;
			} else {
					delete room.memory.drops;
					delete room.memory.lotsOfDroppedEnergy;
					delete room.memory.someDroppedEnergy;
			}
			let upContEnergy;
			if (room.memory.upContPos){
					let upContPos = room.memory.upContPos.toPos();
					if (upContPos){
							let energy = upContPos.lookAround(LOOK_RESOURCES,0,{filter:(r)=>r.resourceType === 'energy'})[0];
							if (energy){
									upContEnergy = energy.amount;
							}
					}
					if (upContPos && room.memory.upCont && room.controller.level > 4 && Game.time % 500 === 0 &&
							(!room.memory.thoriumSupportLink || room.controller.level === 8)){
							let upCont = Game.getObjectById(room.memory.upCont);
							if (upCont){
									upCont.destroy();
							}
							upContPos.createConstructionSite('link');
					}
			}
			if (upContEnergy){
					room.memory.upContEnergy = upContEnergy;
			} else {
					delete room.memory.upContEnergy;
			}
			if ((otherResourceList != null || otherResourceList != undefined) && !room.memory.armedHostiles){
					room.memory.dropres = otherResourceList.id;
			} else {
					delete room.memory.dropres;
			}
			if (room.controller.level > 7 && Game.time % 100 == 0){
					if (room.storage && (!room.memory.factory || !Game.getObjectById(room.memory.factory))){
							room.getPositionAt(room.storage.pos.x + 0, room.storage.pos.y - 1);
							if (room.memory.transferPos){
									room.memory.transferPos.toPos();
							}
							let factory = room.findStructures('factory')[0];
							if (factory){
									room.memory.factory = factory.id;
							}
					}
			}
			if (Game.time%1000 === 0 && room.memory.remoteRooms && (!Memory.sectors || !room.sector || !Memory.sectors[room.sector] || !Memory.sectors[room.sector].invaderCore)){
					for (let r in room.memory.remoteRooms){
							delete room.memory.remoteRooms[r].smallReserve;
					}
			}
			if (Game.time % 500 === 0){
					for (let i in room.memory.remoteRooms){
							delete room.memory.remoteRooms[i].reserveNeeded;
					}
			}

			//sources
			if (!room.memory.sources || room.memory.sources == null){
					let sources = room.find(FIND_SOURCES);
					let slist = [];
					for (let i = 0; i < sources.length; i++){
							slist.push(sources[i].id);
					}
					room.memory.sources = slist;
			}
			let sources = [];
			if (room.memory.sources){
					let slist = room.memory.sources;
					for (let i = 0; i < slist.length; i++){
							sources.push(Game.getObjectById(slist[i]));
					}
			}
			let s1 = sources[0];
			if (s1 != null || s1 != undefined){
					room.memory.s1 = s1.id;
			} else {
					room.memory.s1 = null;
			}
			let s2 = sources[1];
			if (s2 != null || s2 != undefined){
					room.memory.s2 = s2.id;
			} else {
					delete room.memory.s2;
			}
			let spawn;
			if (!room.memory.spawn){
					let spawnPos = undefined;
					if (room.memory.spawnPos){
							spawnPos = room.memory.spawnPos.toPos();
					}
					let checkSpawnPos = undefined;
					if (spawnPos){
							checkSpawnPos = spawnPos.lookFor(LOOK_STRUCTURES).filter((s) => s.structureType == STRUCTURE_SPAWN && s.my)[0];
					}
					if (checkSpawnPos){
							room.memory.spawn = checkSpawnPos.name;
					} else {
							if (!room.memory.spawnPos){
									spawn = room.findStructures('spawn',(s)=>s.my)[0];
									if (spawn){
											room.memory.spawn = spawn.name;
									}
							} else if (spawnPos){
									spawnPos.createConstructionSite(STRUCTURE_SPAWN);
							}
					}
					spawn = Game.spawns[room.memory.spawn];
			} else {
					spawn = Game.spawns[room.memory.spawn];
					if (spawn){
							room.memory.spawnPos = spawn.pos.toString();
					}
			}
			if (room.memory.fixedBaseOrigin && room.memory.fixedBaseDir && (!room.memory.rally || Game.time % 60 === 0)){
					let originPos = room.memory.fixedBaseOrigin.toPos();
					let pos = findRelativePosition(originPos, -4, 7, room.memory.fixedBaseDir);
					room.memory.rally = pos.toString();
					let tPos = findRelativePosition(originPos, 0, 2, room.memory.fixedBaseDir);
					room.memory.transferPos = tPos.toString();
					let sPos = findRelativePosition(originPos, 0, 0, room.memory.fixedBaseDir);
					room.memory.storageWithdawPos = sPos.toString();
					let labPos = findRelativePosition(originPos, 2, 7, room.memory.fixedBaseDir);
					if (room.controller.level == 7){
							labPos = findRelativePosition(originPos, 3, 7, room.memory.fixedBaseDir);
					}
					room.memory.labPoint = labPos.toString();
					if (room.memory.labPointOverRide){
							room.memory.labPoint = room.memory.labPointOverRide;
					}
					if (Game.cpu.bucket > 9000 && (Game.time % 3000 === 0 || (room.memory.rallyNearSources === undefined && room.memory.s2))){
							let rallyNearSources = findRallyNearSources();
							if (rallyNearSources){
									room.memory.rallyNearSources = rallyNearSources;
							} else {
									room.memory.rallyNearSources = false;
							}
					}
					function findRallyNearSources(){
							let s1 = Game.getObjectById(room.memory.s1);
							let s2 = Game.getObjectById(room.memory.s2);
							let pathObj;
							if (s1 && s2){
									pathObj = getPath(s1.pos,s2.pos);
							}
							if (pathObj && !pathObj.incomplete){
									let bestPos,bestDistance;
									for (let p in pathObj.path){
											let pos = pathObj.path[p];
											if (!pos.isWalkable()){
													continue
											}
											let path = getPath(pos,originPos);
											if (path && (!bestPos || path.path.length < bestDistance)){
													bestPos = pos;
													bestDistance = path.path.length;
											}
									}
									if (bestPos){
											return bestPos.toString()
									}
							}
							function getPath(a,b){
									return PathFinder.search(a, {pos: b, range: 1}, {
											maxOps: 10000,
											plainCost: 1,
											swampCost: 5,
											maxRooms: 1,
											roomCallback: function (roomName){
													let room = Game.rooms[roomName];
													if (!room) return;
													let costs = room.structureMatrix;
													if (costs){
															return costs
													}
											}
									})
							}
					}
			} else if (!room.memory.fixedBaseOrigin || !room.memory.fixedBaseDir) {
					delete room.memory.transferPos;
					delete room.memory.storageWithdawPos;
					delete room.memory.labPoint;
					delete room.memory.rallyNearSources;
			}

			if (!room.memory.fixedBaseOrigin && spawn && spawn.pos && !room.memory.rally && spawn.pos.x > 7){
					let list = [new RoomPosition(spawn.pos.x, spawn.pos.y - 6, room.name), new RoomPosition(spawn.pos.x + 2, spawn.pos.y - 2, room.name), new RoomPosition(spawn.pos.x - 2, spawn.pos.y - 2, room.name), new RoomPosition(spawn.pos.x, spawn.pos.y - 2, room.name)];
					let rally;
					if (list && list.length > 0){
							for (let i in list){
									let point = list[i];
									if (point.isWalkable()){
											let walkables = 0;
											let ns = point.neighbours(1);
											if (ns && ns.length > 0){
													for (let j in ns){
															if (ns[j] && ns[j].isWalkable()){
																	walkables++;
															}
													}
											}
											if (walkables > 5){
													rally = point;
													break
											}
									}
							}
					}
					if (!rally){
							console.log('no rally', room.name);
					}
					if (rally){
							room.memory.rally = rally.toString();
					}
			}

			if (room.memory.rally && (!Game.flags['rally' + room.name] || (Game.time % 1000 === 0 && room.memory.fixedBaseOrigin))){
					let pos = room.memory.rally.toPos();
					if (Game.flags['rally' + room.name]); else {
							pos.createFlag('rally' + room.name);
					}
			}
			if (!spawn || spawn.room.name != room.name){
					delete room.memory.spawn;
					delete room.memory.spawnPos;
			}
			for (let i in sources){
					let source = sources[i];
					if (Memory.sources && spawn && source && !Memory.sources[source.pos.toString()]){
							let pos = room.getPositionAt(spawn.pos.x, spawn.pos.y - 2);
							if (room.memory.fixedBaseOrigin){
									pos = room.memory.fixedBaseOrigin.toPos();
							}
							let pathObj = PathFinder.search(pos, {pos: source.pos, range: 1});
							if (pathObj && pathObj.path){
									let distance = pathObj.path.length;
									Memory.sources[source.pos.toString()] = {
											rooms: [room.name],
											distance: distance,
											sourceRoom: source.pos.roomName,
											closestRoom: room.name,
											expiry:Game.time + 10000
									};
							}
					}
			}
			if (room.controller.level > 1 && staticFillingIsOn(room)){
					let origin = room.memory.fixedBaseOrigin.toPos();
					if (!room.memory.staticFillerContainer || !Game.getObjectById(room.memory.staticFillerContainer)){
							let pos = findRelativePosition(origin,3,1,room.memory.fixedBaseDir);
							let cont = pos.lookAround(LOOK_STRUCTURES, 1, {filter: (s) => s.structureType == STRUCTURE_CONTAINER})[0];
							let sites = pos.lookAround(LOOK_CONSTRUCTION_SITES, 0, {filter: (s) => s.structureType == STRUCTURE_CONTAINER})[0];
							if (cont){
									room.memory.staticFillerContainer = cont.id;
							} else if (!sites){
									pos.createConstructionSite(STRUCTURE_CONTAINER);
									delete room.memory.sites;
							}
					}
			}
			if (room.controller.level > 1 && room.class === 'normal' && (!room.storage || room.controller.level < 4 || room.memory.staticFillerSpots) && spawn && !room.memory.prayerRoom){
					if (!room.memory.storeCont || !Game.getObjectById(room.memory.storeCont)){
							let pos = room.getPositionAt(spawn.pos.x, spawn.pos.y - 1);
							if (room.memory.fixedBaseOrigin){
									pos = room.memory.fixedBaseOrigin.toPos();
									if (room.memory.staticFillerSpots){
											pos = findRelativePosition(pos,1,1,room.memory.fixedBaseDir);
									}
							}
							room.memory.storeContPosition = pos.toString();
							let cont = pos.lookAround(LOOK_STRUCTURES, 1, {filter: (s) => s.structureType == STRUCTURE_CONTAINER})[0];
							let sites = pos.lookAround(LOOK_CONSTRUCTION_SITES, 0, {filter: (s) => s.structureType == STRUCTURE_CONTAINER})[0];
							if (cont){
									room.memory.storeCont = cont.id;
							} else if (!sites){
									pos.createConstructionSite(STRUCTURE_CONTAINER);
									delete room.memory.sites;
							}
					}
			} else if (room.storage && room.storage.my && room.memory.storeCont){
					if (Game.getObjectById(room.memory.storeCont)){
							Game.getObjectById(room.memory.storeCont).destroy();
					}
					delete room.memory.storeCont;
			}
			if (room.controller.level > 2 && room.memory.staticFillerTowerPosition && (!room.memory.staticFillerTower || !Game.getObjectById(room.memory.staticFillerTower))){
					let pos = room.memory.staticFillerTowerPosition.toPos();
					if (pos){
							let tower = pos.lookAround(LOOK_STRUCTURES,0,{filter:(s)=>s.my && s.structureType === 'tower'})[0];
							if (tower){
									room.memory.staticFillerTower = tower.id;
							}
					}
			}

			if ((!room.memory.conts || room.memory.conts == null || !Game.getObjectById(room.memory.conts) ||
					(!room.memory.cont1 || !Game.getObjectById(room.memory.conts1))) && spawn && (spawn.room.controller.level < 7 || spawn.room.energyAvailable == spawn.room.energyCapacityAvailable) && Game.time % (20*room.controller.level) == 0){

					let contlist = room.findStructures('container');
					let conts = contlist[0];
					let conts1 = contlist[1];

					if (conts != null || conts != undefined){
							room.memory.conts = conts.id;
					} else {
							delete room.memory.conts;
					}
					if (conts1 != null || conts1 != undefined){
							room.memory.conts1 = conts1.id;
					} else {
							delete room.memory.conts1;
					}
			}
			//resource type
			if (!room.memory.mineral){
					room.memory.mineral = room.mineral.id;
			}
			var min = Game.getObjectById(room.memory.mineral);
			if (min){
					var mintype = min.mineralType;
					if (min.mineralAmount > 0){
							room.memory.minactive = true;
					} else {
							delete room.memory.minactive;
					}
					if (mintype != undefined){
							room.memory.min = mintype;
					} else {
							delete room.memory.min;
					}
			}
			if (min && room.controller.level > 5 && (!room.memory.resconts || room.memory.resconts == null || !Game.getObjectById(room.memory.resconts))){
					let resourceContainer;
					if (min){
							resourceContainer = room.findStructures('container',(s)=>s.pos.isNearTo(min))[0];
					}
					if (resourceContainer != null || resourceContainer != undefined){
							room.memory.resconts = resourceContainer.id;
					} else {
							delete room.memory.resconts;
							if (room.controller.level >= 6 && Game.time % 1000 == 0){
									console.log('WARNING - no resource container in ' + name);
							}
					}
			}
			//lab
			if (((!room.memory.boostingRequired && (!room.memory.r1lab || !room.memory.r2lab || !Game.getObjectById(room.memory.r1lab) || !Game.getObjectById(room.memory.r1lab)))
					|| Game.time % 300 === 0 || (room.memory.boostingRequired && !room.memory.blabs) || room.memory.defcon < 5 || room.controller.level < 7) && spawn){
					let r1lab, r2lab, defBoostsOn;
					if ((room.memory.defcon && room.memory.defcon < 5 && room.controller.level > 6) || Game.flags['defend' + room.name] ||
							(room.memory.alert && room.memory.alert == 'high') ||
							(Game.flags['ShardTrade'] && Game.flags['ShardTrade'].room && Game.flags['ShardTrade'].room.name == room.name)){
							defBoostsOn = true;
					}
					let labCentralPostition = room.getPositionAt(spawn.pos.x, spawn.pos.y + 2);
					if (room.memory.labPoint){
							labCentralPostition = room.memory.labPoint.toPos();
					} else if (!room.memory.fixedBaseDir && room.storage){
							labCentralPostition = room.getPositionAt(room.storage.pos.x, room.storage.pos.y + 5);
					}
					if (labCentralPostition){
							room.memory.boostflag = labCentralPostition.toString();
							if (Game.flags['ShardTrade'] && Game.flags['ShardTrade'].room && Game.flags['ShardTrade'].room.name == room.name){
									labCentralPostition.createConstructionSite(STRUCTURE_CONTAINER);
							}
					}
					if (!room.memory.boostingRequired){
							if (room.controller.level > 6){
									var r1flag = room.getPositionAt(spawn.pos.x, spawn.pos.y + 1);
									var r2flag = room.getPositionAt(spawn.pos.x, spawn.pos.y + 3);
									if (room.memory.fixedBaseDir && !room.memory.labPointOverRide){
											r1flag = findRelativePosition(room.memory.fixedBaseOrigin.toPos(), 2, 6, room.memory.fixedBaseDir);
											r2flag = findRelativePosition(room.memory.fixedBaseOrigin.toPos(), 2, 8, room.memory.fixedBaseDir);
									}
									if (room.memory.labPointOverRide && labCentralPostition){
											let labs = labCentralPostition.lookAround(LOOK_STRUCTURES,1,{filter:(s)=>s.structureType === STRUCTURE_LAB});
											if (labs.length > 2){
													r1lab = labs[0];
													r2lab = labs[1];
											}
											if (room.memory.fixedBaseOrigin){
													let origin = room.memory.fixedBaseOrigin.toPos();
													let dir = labCentralPostition.getDirectionTo(origin);
													let r1temp,r2temp;
													if (dir){
															r1temp = labCentralPostition.movePos(dir).lookAround(LOOK_STRUCTURES,0,{filter:(s)=>s.structureType === STRUCTURE_LAB})[0];
															r2temp = labCentralPostition.movePos(dir.map8(4)).lookAround(LOOK_STRUCTURES,0,{filter:(s)=>s.structureType === STRUCTURE_LAB})[0];
															if (r1temp && r2temp){
																	//making sure we select the labs that can react with the most other labs
																	r1lab = r1temp;
																	r2lab = r2temp;
															}
													}
											}

									} else {
											r1lab = r1flag.lookFor(LOOK_STRUCTURES).filter((s) => s.structureType === STRUCTURE_LAB)[0];
											r2lab = r2flag.lookFor(LOOK_STRUCTURES).filter((s) => s.structureType === STRUCTURE_LAB)[0];
									}
							} else {
									let labList = room.findStructures('lab');
									let sorted = labList.sort((a, b) => a.cooldown - b.cooldown);
									if ((labList.length > 1 && !defBoostsOn) || labList.length > 5){
											let labtaken = {};
											labtaken[sorted[0].id] = true;
											if (room.memory.r1){
													for (let l in labList){
															if (!labtaken[labList[l].id] && labList[l].mineralType && labList[l].mineralType === room.memory.r1 && (!labCentralPostition || labList[l].pos.isNearTo(labCentralPostition))){
																	r1lab = labList[l];
																	labtaken[r1lab.id] = true;
																	break
															}
													}
											}
											if (room.memory.r2){
													for (let l in labList){
															if (!labtaken[labList[l].id] && labList[l].mineralType && labList[l].mineralType === room.memory.r2 && (!labCentralPostition || labList[l].pos.isNearTo(labCentralPostition))){
																	r2lab = labList[l];
																	labtaken[r2lab.id] = true;
																	break
															}
													}
											}
											if (!r1lab){
													for (let l in labList){
															if (!labtaken[labList[l].id] && (!labCentralPostition || labList[l].pos.isNearTo(labCentralPostition))){
																	r1lab = labList[l];
																	labtaken[r1lab.id] = true;
																	break
															}
													}
											}
											if (!r2lab){
													for (let l in labList){
															if (!labtaken[labList[l].id] && (!labCentralPostition || labList[l].pos.isNearTo(labCentralPostition))){
																	r2lab = labList[l];
																	labtaken[r2lab.id] = true;
																	break
															}
													}
											}
									}
							}
					}
					if (r1lab != null || r1lab != undefined){
							new RoomVisual(room.name).text('R1', r1lab.pos);
							room.memory.r1lab = r1lab.id;
					} else {
							delete room.memory.r1lab;
					}
					if (r2lab != null || r2lab != undefined){
							new RoomVisual(room.name).text('R2', r2lab.pos);
							room.memory.r2lab = r2lab.id;
					} else {
							delete room.memory.r2lab;
					}
					let labList;
					if (r1lab && r2lab){
							labList = room.findStructures('lab',(s)=>s.id !== r1lab.id && s.id !== r2lab.id);
					} else {
							labList = room.findStructures('lab');
					}
					let plabs = [];
					let blabs = [];
					let sblabs = [];
					let sbNum = 0;
					if (!room.memory.defcon){
							room.memory.defcon = 5;
					}
					if (defBoostsOn && (room.controller.level > 7 || !room.memory.boostingRequired
					|| (config$1.official && room.memory.colNeeded && Game.time - room.memory.colNeeded < 1000)
					)){
							//if defcon is raised we need to have defence boosts ready as these rooms could be attacked
							sbNum = 3;
					} else if ((room.controller.level > 6 || !room.memory.boostingRequired) && (room.memory.defcon < 5 || room.memory.armedHostiles || (room.memory.adjustedLowWallHits && room.memory.adjustedLowWallHits < config$1.minWalls[6]))
							&& (room.total('XLH2O') > 5000 || room.total('LH')>5000 || room.total('UH')>3000 || room.total('XGH2O') > 5000 || (room.memory.sblabs && room.memory.sblabs[0] && Game.getObjectById(room.memory.sblabs[0]) && Game.getObjectById(room.memory.sblabs[0]).store[Game.getObjectById(room.memory.sblabs[0]).mineralType] > 300))){
							sbNum = 2;
					}
					if (room.memory.sboostlab){
							if (sbNum > Object.keys(room.memory.sboostlab).length){
									sbNum = Object.keys(room.memory.sboostlab).length;
							}
					}
					if (room.class === 'bunker'){
							sbNum = 1;
					}
					if (!labList || labList.length < 2){
							room.memory.labsUp = false;
					} else {
							room.memory.labsUp = true;
					}
					for (let i = 0; i < labList.length; i++){
							if (!labList[i] || !labList[i].pos){
									console.log('no lab',labList[i]);
									continue
							}
							if (sblabs.length < sbNum && (!labList[i].pos.isNearTo(labCentralPostition) || room.controller.level < 8)){
									new RoomVisual(room.name).text('SB', labList[i].pos);
									sblabs.push(labList[i].id);
							} else if (r1lab && labList[i].pos.inRangeTo(r1lab, 2)){
									new RoomVisual(room.name).text('P', labList[i].pos);
									plabs.push(labList[i].id);
							} else if (labCentralPostition && labList[i].pos.inRangeTo(labCentralPostition, 1) && (room.memory.boostingRequired)){
									blabs.push(labList[i].id);
									new RoomVisual(room.name).text('B', labList[i].pos);
							}
					}
					if (plabs.length > 0){
							room.memory.plabs = plabs;
					} else {
							delete room.memory.plabs;
					}
					if (blabs.length > 0){
							room.memory.blabs = blabs;
					} else {
							delete room.memory.blabs;
					}
					if (sblabs.length > 0){
							room.memory.sblabs = sblabs;
					} else {
							delete room.memory.sblabs;
					}
			}

			if (Game.time % 300 === 0 || room.memory.armedHostiles || room.memory.defcon < 5 || room.memory.boostingRequired){
					let lowEnergyLab = room.findStructures('lab',(s) => s.structureType == STRUCTURE_LAB && s.store['energy'] < LAB_ENERGY_CAPACITY * 0.8)[0];
					if (lowEnergyLab){
							room.memory.lab = lowEnergyLab.id;
					} else {
							delete room.memory.lab;
					}
			}

			//links

			var stores = room.storage;
			if (room.memory.linkstore && !Game.getObjectById(room.memory.linkstore)){
					delete room.memory.linkstore;
			}
			if (room.controller.level < 5){
					delete room.memory.linkstore;
					delete room.memory.uplink;
			}
			if (Game.time % 100 == 0 || (!room.memory.linkstore && room.controller.level > 4 && Game.time % 30 == 0)){
					let links = room.findStructures('link');
					var importlinks = [];
					let sourcePositions;
					if (room.memory.sourcePositions){
							sourcePositions = room.memory.sourcePositions;
					}
					let upLink,upLinkId;
					let storeLink,storeLinkID;
					if (room.memory.storeLinkPos){
							let linkPosStr = room.memory.storeLinkPos;
							let linkPos;
							if (linkPosStr){
									linkPos = linkPosStr.toPos();
							}
							let link = linkPos.lookAround(LOOK_STRUCTURES, 0, {filter: (s) => s.structureType == STRUCTURE_LINK})[0];
							if (linkPos){
									linkPos.highlight('red');
							}
							if (room.class === 'bunker' && room.storage){
									link = room.storage.pos.lookAround(LOOK_STRUCTURES, 1, {filter: (s) => s.structureType == STRUCTURE_LINK})[0];
							}
							if (link){
									storeLinkID = link.id;
									storeLink = Game.getObjectById(storeLinkID);
									room.memory.linkstore = link.id;
							}
					}
					if (room.memory.uplink && Game.getObjectById(room.memory.uplink)){
							upLinkId = room.memory.uplink;
							upLink = Game.getObjectById(room.memory.uplink);
					}
					for (let i = 0; i < links.length; i++){
							if (links[i] && (room.controller.level === 8 || links.length <= CONTROLLER_STRUCTURES['link'][room.controller.level] || links[i].isActive())){
									if (!storeLink && stores && links[i].pos.inRangeTo(stores, 1)){
											room.memory.linkstore = links[i].id;
									} else if (!upLink && links[i].pos.inRangeTo(room.controller, 4) && !links[i].pos.inRangeTo(s1, 2) && (!s2 || !links[i].pos.inRangeTo(s2, 2))
											&& (!room.memory.repairLink || links[i].id != room.memory.repairLink)){
											room.memory.uplink = links[i].id;
											upLinkId = links[i].id;
									} else {
											if (upLinkId && upLinkId === links[i].id){
													continue
											}
											if (storeLinkID && storeLinkID === links[i].id){
													continue
											}
											if (room.memory.repairLink && room.memory.repairLink == links[i].id){
													continue
											}
											if (room.memory.repairLinkLocation && links[i].pos.toString() === room.memory.repairLinkLocation){
													continue
											}
											if (room.memory.extraLinks && room.memory.extraLinks[links[i].id]){
													continue
											}
											if (room.memory.thoriumSupportLinkPos && links[i].pos.toString()===room.memory.thoriumSupportLinkPos){
													continue
											}
											if (room.memory.thoriumSupportLink && links[i].id ===room.memory.thoriumSupportLink){
													continue
											}
											if (room.memory.transferPos){
													let tPos = room.memory.transferPos.toPos();
													if (tPos && links[i].pos.isNearTo(tPos)){
															continue
													}
											}
											importlinks.push(links[i].id);
											if (sourcePositions && sourcePositions[s1.id] && sourcePositions[s1.id].link && sourcePositions[s1.id].link === links[i].pos.toString()){
													room.memory.linksource1 = links[i].id;
											} else if (s2 && sourcePositions && sourcePositions[s2.id] && sourcePositions[s2.id].link && sourcePositions[s2.id].link === links[i].pos.toString()){
													room.memory.linksource2 = links[i].id;
											} else if (Game.time % 1000 == 0){
													links[i].destroy();
											}
									}
							}
					}
					delete room.memory.manualLoadUpLink;
					delete room.memory.manualLoadUpLinkParts;
					if (upLink && storeLink){
							let maxThroughPutPerTick = 0;
							//adjust because we often do not send full packets
							let adjust = 0.8;
							maxThroughPutPerTick += Number.parseInt(((LINK_CAPACITY*adjust)/upLink.pos.getRangeTo(storeLink)));
							if (room.memory.extraLinks){
									for (let l in room.memory.extraLinks){
											let link = Game.getObjectById(l);
											if (link && upLink.pos.getRangeTo(link)){
													maxThroughPutPerTick += Number.parseInt((LINK_CAPACITY*adjust)/upLink.pos.getRangeTo(link));
											}
									}
							}
							let upgraderCount = countRole('staticUpgrader',room);
							let body = spawnCode$9.body(room,countRole).body;
							if (body){
									let workParts = 0;
									for (let p in body){
											if (body[p]=== 'work'){
													workParts++;
											}
									}
									let upgraderPower = workParts*upgraderCount;
									if (upgraderPower>maxThroughPutPerTick){
											//need to load upLink manually
											room.memory.manualLoadUpLink = true;
											room.memory.manualLoadUpLinkParts = upgraderPower-maxThroughPutPerTick;
									}
							}
					} else if (upLink && countRole('staticUpgrader',room)>0){
							room.memory.manualLoadUpLink = true;
					}
					if (room.memory.manualLoadUpLink);
					if (importlinks && importlinks.length > 0){
							room.memory.importlinks = importlinks;
					} else {
							delete room.memory.importlinks;
					}
			}
			if (room.memory.uplink && !Game.getObjectById(room.memory.uplink)){
					delete room.memory.uplink;
					delete room.memory.fillUpLink;
			} else if (room.memory.uplink){
					if (!upLinkCheck[room.name] || (Game.time - upLinkCheck[room.name]) > 10){
							upLinkCheck[room.name] = Game.time;
							let upLink = Game.getObjectById(room.memory.uplink);
							if (upLink && (
									room.controller.ticksToDowngrade < CONTROLLER_DOWNGRADE[room.controller.level] * 0.8 ||
									(room.total('energy') > room.memory.reserve && room.controller.level < 8 && (!Memory.emergency || !room.terminal))
							)){
									room.memory.fillUpLink = true;
							} else {
									delete  room.memory.fillUpLink;
							}
					}
			} else {
					delete room.memory.fillUpLink;
			}
			if (room.memory.manualLoadUpLink && room.memory.upgraderLoadingPosition){
					let cont = room.memory.upgraderLoadingPosition.toPos().lookAround(LOOK_STRUCTURES,0,{filter:(s)=>s.structureType === 'container'})[0];
					if (!cont){
							room.memory.upgraderLoadingPosition.toPos().createConstructionSite('container');
					} else {
							room.memory.upLoadCont = cont.id;
					}
			} else if (Game.time % 10000 === 0 && room.memory.upgraderLoadingPosition && (!room.memory.priorityEnergyTimer || room.memory.priorityEnergyTimer<Game.time)
					&& (room.controller.level === 8 || room.isEnergyDonor || !Memory.priorityEnergyRoomName) && Memory.myRooms.length > 2){
					let cont = room.memory.upgraderLoadingPosition.toPos().lookAround(LOOK_STRUCTURES,0,{filter:(s)=>s.structureType === 'container'})[0];
					if (cont){
							cont.destroy();
					}
					delete room.memory.upLoadCont;
			}

			//store
			var stores = room.storage;
			if ((stores != null || stores != undefined) && stores.owner.username == Game.username){
					room.memory.stores = stores.id;
			} else {
					delete room.memory.stores;
			}

			//terminal
			var terminal = room.terminal;
			if ((terminal != null || terminal != undefined) && terminal.owner.username == Game.username){
					room.memory.terminal = terminal.id;
			} else {
					room.memory.terminal = null;
			}
			if (Game.time % 200 == 0){
					if (room.controller.level == 8 || config$1.season === 'power'){
							//powerspawn and nuker
							if (!room.memory.powerspawn || room.memory.powerspawn == null || !Game.getObjectById(room.memory.powerspawn)){
									let powerSpawn = room.findStructures('powerSpawn')[0];
									if (powerSpawn){
											room.memory.powerspawn = powerSpawn.id;
									} else {
											delete room.memory.powerspawn;
									}
							}
							if (!room.memory.nuker || room.memory.nuker == null || !Game.getObjectById(room.memory.nuker)){
									let nuker = room.findStructures('nuker')[0];
									if (nuker){
											room.memory.nuker = nuker.id;
									} else {
											delete room.memory.nuker;
									}
							}
							if (!room.memory.observer || room.memory.observer == null || !Game.getObjectById(room.memory.observer)){
									let observer = room.findStructures('observer')[0];
									if (observer){
											room.memory.observer = observer.id;
									} else {
											delete room.memory.observer;
									}
							}
					}
			}
			//spawnrampart
			if (spawn && room.class === 'normal' && (!room.memory.spawnRampart || room.memory.spawnRampart == null || !Game.getObjectById(room.memory.spawnRampart))){
					let sr = spawn.pos.lookAround(LOOK_STRUCTURES,0,{filter:(s) => s.structureType == STRUCTURE_RAMPART})[0];
					if (sr){
							room.memory.spawnRampart = sr.id;
					} else if (spawn.room.controller.level > 4 && !Game.flags['pray' + room.name]){
							spawn.pos.createConstructionSite(STRUCTURE_RAMPART);
					}
			}
			let roomSegment = access(room.name);
			if (roomSegment && roomSegment.roadPositions && roomSegment.roadPositions[room.name] && room.memory.upContPos &&
					(!room.memory.upgraderPositions || (room.memory.upgraderPositions.length === 0 && Game.time % 100 === 0) || Game.time % 1000 == 0)){
					let upContPos = room.memory.upContPos.toPos();
					let neighbours = upContPos.neighbours(1);
					let roadPos = roomSegment.roadPositions[room.name];
					let loadingPos = undefined;
					let loadingPosition;
					console.log(room.name,roomSegment.roadPositions[room.name]);
					for (let i in neighbours){
							let key = neighbours[i].x+','+neighbours[i].y;
							if (roadPos.includes(key)){
									loadingPos = neighbours[i].toString();
									loadingPosition = neighbours[i];
									break
							}
					}
					let positions = [];
					for (let i in neighbours){
							let str = neighbours[i].toString();
							if (str && neighbours[i].isWalkable() && loadingPos && loadingPos != str){
									positions.push(str);
							}
					}
					if (positions && loadingPosition){
							positions.sort((a,b)=> a.toPos().getRangeTo(loadingPosition)-b.toPos().getRangeTo(loadingPosition));
					}
					room.memory.upgraderLoadingPosition = loadingPos;
					room.memory.upgraderPositions = positions;
			}
			if (Game.time % 1000 == 0 || room.memory.armedHostiles){
					//repairs
					let repairTargets = room.findStructures(['extension','spawn','tower','storage','lab','factory','powerSpawn','link','terminal','nuker'],(s)=>s.my && s.hits < s.hitsMax);
					let repairTarget;
					if (repairTargets && repairTargets.length > 0){
							repairTarget = repairTargets.reduce((accumulator, current) => {
									if (!accumulator || current.hits < accumulator.hits){
											return current
									} else {
											return accumulator
									}
							});
					}
					if (repairTarget){
							room.memory.repairs = repairTarget.id;
					} else {
							delete room.memory.repairs;
					}
			}

			//roads
			let plannedRoads;
			if (roomSegment){
					plannedRoads = roomSegment.roadIDs;
			}
			let roadTarget;
			if (!playerHeap.blockRoadCheckAll[room.name]){
					playerHeap.blockRoadCheckAll[room.name] = Game.time+(room.index*3);
			}
			if (Game.time > playerHeap.blockRoadCheckAll[room.name] ){
					//console.log('roadCheck',room.name)
					let roads = room.findStructures('road',(s)=> s.structureType == STRUCTURE_ROAD && s.hits < s.hitsMax * 0.5 && (!plannedRoads || plannedRoads.includes(s.id)));
					if (roads && roads.length > 0){
							roadTarget = roads.reduce((accumulator, current) => {
									if (!accumulator || current.hits < accumulator.hits){
											return current
									} else {
											return accumulator
									}
							});
					} else {
							playerHeap.blockRoadCheckAll[room.name]=Game.time+100;
					}
			}
			if (roadTarget){
					room.memory.roads = roadTarget.id;
			} else {
					delete room.memory.roads;
			}
			//containers
			if (Game.time % 300 == 0){
					let containerToRepair = room.findStructures('container',(s) => s.structureType == STRUCTURE_CONTAINER && s.hits < s.hitsMax*0.4)[0];
					if (containerToRepair){
							room.memory.contrep = containerToRepair.id;
					} else {
							delete room.memory.contrep;
					}
			}

			let nukeDamage = undefined;
			if (Game.time % 300 === 0 || room.memory.nukeDefence){
					let nukes = room.find(FIND_NUKES);
					if (nukes && nukes.length > 0){
							nukeDamage = {};
							let nukeDefence;
							for (let i in nukes){
									let nuke = nukes[i];
									if (!nuke.pos.onEdge()){
											nukeDefence = true;
									}
									let str = nuke.pos.toString();
									if (nukeDamage[str]){
											nukeDamage[str] += NUKE_DAMAGE[0];
									} else {
											nukeDamage[str] = NUKE_DAMAGE[0];
									}
									let ns = nuke.pos.neighbours(1);
									for (let n in ns){
											let str = ns[n].toString();
											if (nukeDamage[str]){
													nukeDamage[str] += NUKE_DAMAGE[2];
											} else {
													nukeDamage[str] = NUKE_DAMAGE[2];
											}
									}
							}
							nukes.sort((a, b) => a.timeToLand - b.timeToLand);
							if (nukes[0]){
									room.nukeTime = nukes[0].timeToLand;
							}
							if (nukeDefence){
									room.memory.nukeDefence = true;
							} else {
									delete room.memory.nukeDefence;
							}
					} else {
							if (room.memory.nukeDefence){
									delete room.memory.nukeDefence;
							}
					}
			}
			let roomHealthy = (room.storage && room.terminal && room.total('energy') > room.memory.reserve * 0.7 && !room.memory.bigSites);
			if (!room.memory.lastAttacked || (room.memory.lastAttacked < Game.time - 1000 && room.memory.adjustedLowWallHits && room.memory.adjustedLowWallHits > config$1.minWalls[room.controller.level]
					&& roomHealthy) || (roomHealthy && room.memory.lastAttacked < Game.time - 5000) || room.memory.lastAttacked < Game.time - 20000){
					room.memory.defcon = 5;
			}

			if (!wallCheckDue[room.name]){
					//even out the wall checks
					wallCheckDue[room.name] = Game.time+(room.index*3);
			}
			if (Game.time > wallCheckDue[room.name] || Game.flags['fort' + room.name] || room.memory.defcon < 4 || room.memory.armedHostiles ||
					room.memory.hostileParts || (room.memory.walls && room.memory.walls <= 10000) || Game.flags['defend' + room.name]
					|| (room.memory.lowWall && Game.getObjectById(room.memory.lowWall) && Game.getObjectById(room.memory.lowWall).hits < 10000)){
					wallCheckDue[room.name] = Game.time+(Memory.myRooms.length)*3;
					let structureRampartPositions;
					let adjustedHits = {};
					if (playerHeap.structureRampartCacheAll[room.name] && playerHeap.structureRampartCacheAll[room.name].expiry > Game.time){
							structureRampartPositions = playerHeap.structureRampartCacheAll[room.name].list;
					} else if (ready() && access(room.name) && access(room.name).structures){
							structureRampartPositions = {};
							let structureCache = access(room.name).structures;
							let tryCache = [
									structureCache['spawn'],
									structureCache['lab'],
									structureCache['powerSpawn'],
									structureCache['tower'],
									structureCache['terminal'],
									structureCache['nuker'],
									structureCache['storage'],
									structureCache['factory']
							];
							for (let i in tryCache){
									setRampPos(tryCache[i]);
							}
							function setRampPos(cache){
									if (!cache){
											return
									}
									for (let i in cache){
											let pos = cache[i].toPos();
											if (pos){
													structureRampartPositions[cache[i]] = true;
											}
									}
							}
					}
					let wallArray = ['rampart','constructedWall'];
					if (room.memory.armedHostiles || room.controller.safeMode){
							//don't repair walls if hostile in room as likely outside safe area, also not as important during safemode
							wallArray = ['rampart'];
					}
					let walls = room.findStructures(wallArray);
					let wallWithLeastHits = wallSort(walls);
					if (structureRampartPositions){
							playerHeap.structureRampartCacheAll[room.name] = {
									list:structureRampartPositions,
									expiry:Game.time+5000
							};
					}
					if (wallWithLeastHits && wallWithLeastHits.hits < wallWithLeastHits.hitsMax-5000){
							wallWithLeastHits.pos.highlight('blue');
							let otherStructures = checkStructureAtRamp(wallWithLeastHits);
							room.memory.lowWallType = wallWithLeastHits.structureType;
							if (room.class === 'bunker'){
									wallAdjust = 10;
							}
							if (wallWithLeastHits.structureType === STRUCTURE_WALL){
									room.memory.adjustedLowWallHits =  wallWithLeastHits.hits*wallAdjust;
							}  else if (otherStructures){
									room.memory.adjustedLowWallHits =  wallWithLeastHits.hits/rampartAdjust;
							} else {
									room.memory.adjustedLowWallHits = wallWithLeastHits.hits;
							}
							if (room.memory.armedHostiles || room.memory.adjustedLowWallHits <  config$1.minWalls[room.controller.level]
									|| (room.class === 'bunker') || (room.class === 'outpost')
									|| (room.controller.level === 8 && room.memory.adjustedLowWallHits <  config$1.wallTarget)){
									room.memory.lowWall = wallWithLeastHits.id;
							} else {
									delete room.memory.lowWall;
							}
							let hostile = Game.getObjectById(room.memory.hostiles);
							let hostileEvent;
							if (hostile){
									let events = room.getEvents();
									if (events){
											for (let e in events){
													let eventObj = events[e];
													if (eventObj.event === EVENT_ATTACK){
															let agent = Game.getObjectById(eventObj.objectId);
															let target = Game.getObjectById(eventObj.data.targetId);
															if (agent && target && !agent.my && (target.my || !target.owner) && agent.owner.username != 'Invader'){
																	hostileEvent = true;
															}
													}
											}
									}
							}

							if (room.memory.hostiles && Game.getObjectById(room.memory.hostiles) && hostile && hostile.owner.username != "Invader" && hostileEvent &&
									((wallWithLeastHits && hostile.pos.inRangeTo(wallWithLeastHits, 5)) || room.controller.level < 7 || hostile.isBoosted())){
									if (wallWithLeastHits.hits < room.memory.walls * 0.2 && room.controller.level > 7){
											room.setDefcon(1);
									} else if (wallWithLeastHits.hits < room.memory.walls * 0.5 && room.controller.level > 6){
											room.setDefcon(2);
									} else if ((wallWithLeastHits.hits < room.memory.walls * 0.8 || (hostile.isBoosted() && room.hostileList.length > 0)) && room.controller.level > 6){
											room.setDefcon(3);
									} else if (hostile.getType() != 'scout' && hostile.body && hostile.body.length > room.controller.level * 5){
											room.setDefcon(4);
									}
							}
					} else {
							delete room.memory.lowWall;
					}
					function getAdjustedHits(ramp){
							if (adjustedHits[ramp.id]){
									return adjustedHits[ramp.id]
							}
							let ret;
							if (ramp.structureType === 'constructedWall'){
									ret = ramp.hits * wallAdjust;
									adjustedHits[ramp.id] = ret;
									return ret
							}
							let otherStructures = checkStructureAtRamp(ramp);
							if (otherStructures){
									ret = ramp.hits / rampartAdjust;
							} else {
									ret = ramp.hits;
							}
							if (nukeDamage){
									if (nukeDamage[ramp.pos]){
											room.memory.nukeDefence = true;
											ret = ret - nukeDamage[ramp.pos];
									}
							}
							adjustedHits[ramp.id] = ret;
							return ret
					}
					function checkStructureAtRamp(rampart){
							if (!rampart || !rampart.structureType || rampart.structureType !== 'rampart'){
									return
							}
							if (structureRampartPositions && structureRampartPositions[rampart.pos.toString()]){
									if (structureRampartPositions[rampart.pos.toString()]){
											return true
									}
							} else {
									let structure = rampart.pos.lookAround(LOOK_STRUCTURES, 0, {filter: (s) => s.structureType == STRUCTURE_SPAWN ||
													s.structureType == STRUCTURE_STORAGE || s.structureType == STRUCTURE_LAB || s.structureType == STRUCTURE_TERMINAL
													|| s.structureType === 'powerSpawn' || s.structureType === 'tower'|| s.structureType === 'factory'
													|| s.structureType === 'nuker'})[0];

									if (structure){
											if (structureRampartPositions){
													structureRampartPositions[rampart.pos.toString()] = true;
											}
											return true
									}
							}
					}
					function wallSort(arr){
							if (!arr || arr.length == 0){
									return
							}
							return arr.reduce((accumulator, current, i) => {
									if (!accumulator){
											return current
									}
									if (current.hits > current.hitsMax-5000){
											return accumulator
									} else if (accumulator.hits > accumulator.hitsMax - 5000){
											return current
									}
									let retA = getAdjustedHits(accumulator);
									let retB = getAdjustedHits(current);
									if (retB < retA){
											return current
									} else {
											return accumulator
									}
							})
					}

					let ramparts = room.findStructures('rampart');
					room.memory.rampartAmount = ramparts.length;
					let totalRampsHits = 0;
					if (ramparts && (config$1.allPublicRamps || (config$1.publicRamps && config$1.publicRamps.length > 0))){
							let publicRamps = false;
							if ((config$1.allPublicRamps || (config$1.publicRamps && config$1.publicRamps.includes(room.name))) && !room.memory.hostiles && !room.memory.hostileParts){
									publicRamps = true;
							}
							for (let ramp in ramparts){
									let sMatrix = room.structureMatrix;
									if (publicRamps && !ramparts[ramp].isPublic && sMatrix && sMatrix.get(ramparts[ramp].pos.x, ramparts[ramp].pos.y) != 255){
											ramparts[ramp].setPublic(true);
									} else if ((room.memory.hostiles || room.memory.hostileParts) && ramparts[ramp].isPublic){
											ramparts[ramp].setPublic(false);
									}
									totalRampsHits += ramparts[ramp].hits;
									ramparts[ramp].pos;
							}
							room.memory.averageRamparts = totalRampsHits / ramparts.length;
					}
					let avhits;
					let sRamp = room.memory.spawnRampart;
					if (adjustedHits){
							//use adjusted hits that we calculated early when finding lowwall
							let total = 0;
							let count = 0;
							for (let i in adjustedHits){
									if (sRamp && i === sRamp){
											//including spawn ramp will distort av hits
											continue
									}
									let struc = Game.getObjectById(i);
									if (!struc || struc.structureType !== 'rampart'){
											continue
									}
									count++;
									total += adjustedHits[i];
							}
							if (count > 0){
									avhits = total/count;
							}
					}
					room.display(`avhits ${avhits}`);
					if (!avhits && !room.memory.walls){
							let wallhits = [];
							for (let i = 0; i < ramparts.length; i++){
									if (sRamp){
											if (ramparts[i].id != sRamp){
													wallhits.push(ramparts[i].hits);
											}
									} else {
											wallhits.push(ramparts[i].hits);
									}
							}
							avhits = getAvg(wallhits);
					}

					function getAvg(arr){
							if (arr.length > 0){
									return arr.reduce(function (p, c){
											return p + c;
									}) / arr.length;
							} else {
									return null
							}
					}

					if (avhits && avhits < config$1.wallTarget){
							room.memory.walls = avhits;
					} else if (avhits){
							room.memory.walls = config$1.wallTarget;
					}
					if (ramparts && (!room.memory.repairLinkLocation || Game.time % 3000 == 0) && avhits < (config$1.wallTarget - 1000000) && room.controller.level == 8){
							let currentHits = avhits;
							let currentLoc;
							for (let r in ramparts){
									if (ramparts[r].pos.lookFor(LOOK_STRUCTURES).length === 1 && (ramparts[r].hits < currentHits) && !ramparts[r].pos.nearEdge()){
											currentHits = ramparts[r].hits;
											currentLoc = ramparts[r].pos.toString();
									}
							}
							if (currentLoc){
									room.memory.repairLinkLocation = currentLoc;
							} else {
									delete room.memory.repairLinkLocation;
							}
					}

			}
			if (room.memory.hibernate){
					room.display('hibernating');
			}

			//hibernate trade rooms on separate shards to reduce cpu usage
			if (config$1.official){
					if (Game.shard.name != 'shard2' && Game.flags['ShardTrade'] && Game.flags['ShardTrade'].pos && Game.flags['ShardTrade'].pos.roomName == room.name){
							room.memory.hibernate = true;
					} else if (Game.flags['hibernate' + room.name]){
							room.memory.hibernate = true;
					} else {
							delete room.memory.hibernate;
					}
			}

			//deleting remote hostile (has a game.time of when hostile creeps will be in a remote room)
			if (room.memory.remoteHostile && room.memory.remoteHostile < Game.time){
					delete room.memory.remoteHostile;
			}
			//tower - used for finding which tower to fill
			if (!towerCheckDue[room.name]){
					towerCheckDue[room.name] = Game.time+room.index;
			}
			if (room.memory.armedHostiles || Game.cpu.bucket > 9000 || towerCheckDue[room.name]<Game.time){
					let orderedTowers;
					let towers = room.findStructures('tower',(s) => s.my && s.store['energy'] <= TOWER_CAPACITY * 0.8);
					if (towers.length > 0){
							if (room.memory.target){
									let target = Game.getObjectById(room.memory.target);
									orderedTowers = towers.sort(function (a, b){
											return a.pos.getRangeTo(target) - b.pos.getRangeTo(target)
									})[0];
							} else {
									orderedTowers = towers.sort(function (a, b){
											return a.store['energy'] - b.store['energy']
									})[0];
							}
					} else {
							towerCheckDue[room.name] = Game.time+250;
					}
					if (orderedTowers != null || orderedTowers != undefined){
							room.memory.towers = orderedTowers.id;
					} else {
							delete room.memory.towers;
					}
			}

	}

	function rMemorise(room){
			if (room.controller && room.controller.owner && !room.controller.my){
					Memory.ownedRooms[room.name] = {
							owner: room.controller.owner.username,
							level: room.controller.level
					};
					if (Memory.toleratedRooms[room.name] && Memory.toleratedRooms[room.name] !== room.controller.owner.username){
							delete Memory.toleratedRooms[room.name];
					}
			} else if (room.controller && Memory.ownedRooms[room.name]){
					delete Memory.ownedRooms[room.name];
			} else if (room.controller && !room.controller.reservation && !room.controller.owner){
					delete Memory.contestedTerritory[room.name];
			}
			//construction sites
			let sites;
			if (room.memory.sites){
					sites = Game.getObjectById(room.memory.sites);
					if (!sites ||
							(room.controller && room.controller.level ===  4 && !room.storage && sites.structureType !== 'storage' && sites.structureType !== 'spawn')){
							delete room.memory.sites;
					}
			} else {
					sites = room.find(FIND_MY_CONSTRUCTION_SITES);
					let sitesLength = sites.length;
					if (sites && sites.length > 0 && room.controller && room.controller.my && (room.controller.level < 8 || room.class == 'restructuring')){
							let tower = sites.filter((s) => s.structureType === STRUCTURE_TOWER)[0];
							let spawn = sites.filter((s) => s.structureType === STRUCTURE_SPAWN)[0];
							let terminal = sites.filter((s) => s.structureType === STRUCTURE_TERMINAL)[0];
							let storage = sites.filter((s) => s.structureType === STRUCTURE_STORAGE)[0];
							let link = sites.filter((s) => s.structureType === STRUCTURE_LINK)[0];
							let ramp = sites.filter((s) => s.structureType === STRUCTURE_RAMPART)[0];
							let extensions = sites.filter((s) => s.structureType === STRUCTURE_EXTENSION && !canSpawnReserves(room));
							let lab = sites.filter((s) => s.structureType === STRUCTURE_LAB)[0];
							let upCont = sites.filter((s) => s.structureType === STRUCTURE_CONTAINER && s.pos.getRangeTo(room.controller)<=3)[0];
							let cont = sites.filter((s) => s.structureType === STRUCTURE_CONTAINER)[0];
							let extractor;
							if (config$1.season && config$1.season === 'thorium'){
									extractor = sites.filter((s) => s.structureType === STRUCTURE_EXTRACTOR)[0];
							}
							let storeCont,extension;
							if (room.controller.level < 4 && extensions[0] && room.memory.storeContPosition){
									let storeContPos = room.memory.storeContPosition.toPos();
									extension = extensions.sort((a,b)=>a.pos.getRangeTo(storeContPos)-b.pos.getRangeTo(storeContPos) )[0];
							} else if (extensions[0]){
									extension = extensions[0];
							}
							if (room.memory.storeContPosition){
									let pos = room.memory.storeContPosition.toPos();
									if (pos){
											if (room.memory.staticFillerContainer && !Game.getObjectById(room.memory.staticFillerContainer)
													&& staticFillingIsOn(room)){
													pos = findRelativePosition(pos,3,1,room.memory.fixedBaseDir);
											}
											let site = pos.lookAround(LOOK_CONSTRUCTION_SITES, 0)[0];
											if (site){
													storeCont = site;
											}
									}
							}
							let bigSites = true;
							if (tower && (!room.controller.safeMode || room.controller.safeMode < 5000)){
									sites = tower;
							} else if (room.memory.defcon < 5 && ramp && (!room.controller.safeMode || room.controller.safeMode < 15000)){
									sites = ramp;
							} else if (spawn){
									sites = spawn;
							} else if (storeCont && room.controller.level < 4){
									sites = storeCont;
							} else if (upCont && room.controller.level < 4){
									sites = upCont;
							} else if (extension && room.energyCapacityAvailable < 800){
									sites = extension;
							} else if (tower && (!room.controller.safeMode || room.controller.safeMode < 5000 || room.controller.level > 3 || Memory.myRooms.length > 1)){
									sites = tower;
							} else if (terminal){
									if (Memory.myRooms.length < 3){
											bigSites = false;
									}
									sites = terminal;
							} else if (extractor){
									sites = extractor;
							} else if (storage){
									sites = storage;
							} else if (link){
									bigSites = false;
									sites = link;
							} else if (extension && room.energyCapacityAvailable < 5000){
									sites = extension;
							} else if (room.memory.defcon < 5 && ramp){
									sites = ramp;
							} else if (lab && !room.memory.labsUp){
									if (Memory.myRooms.length < 3){
											bigSites = false;
									}
									sites = lab;
							}  else if (extension){
									bigSites = false;
									sites = extension;
							}  else if (upCont){
									sites = upCont;
							} else if (cont){
									bigSites = false;
									sites = cont;
							}else {
									bigSites = false;
									if (Game.cpu.bucket > 9000 || room.memory.defcon < 5){
											sites.sort((a, b) => ((b.progress + 1) / b.progressTotal) - ((a.progress + 1) / a.progressTotal));
									}
									sites = sites[0];
							}
							if (bigSites || (sitesLength && sitesLength > 10)){
									room.memory.bigSites =true;
							} else {
									delete room.memory.bigSites;
							}
					} else {
							if (Game.cpu.bucket > 9000 || room.memory.defcon < 5){
									sites.sort((a, b) => ((b.progress + 1) / b.progressTotal) - ((a.progress + 1) / a.progressTotal));
							}
							let sitesLength = sites.length;
							sites = sites[0];
							if (sites && (sites.progressTotal > 10000 || sitesLength>10)){
									room.memory.bigSites =true;
							} else {
									delete room.memory.bigSites;
							}
					}
			}
			if (sites != null || sites != undefined){
					room.memory.sites = sites.id;
			} else {
					delete room.memory.sites;
					delete room.memory.bigSites;
			}
			if (room.type === 'highway' && config$1.season && config$1.season === 'caravan'){
					logCaravans(room);
			}
			if (Game.time % 30 == 0){
					if (room.type == 'centre' || room.type == 'SK'){

							//SK lair
							let lairs = room.findStructures('keeperLair');
							if (lairs.length > 0){
									let lairList = [];
									for (let l in lairs){
											lairList.push(lairs[l].id);
									}
									room.memory.lairs = lairList;
							} else {
									delete room.memory.lairs;
							}
							if(lairs.length > 0){
									let filtered = lairs.filter((s)=>s.ticksToSpawn > 0 && s.ticksToSpawn != null);
									if (filtered.length > 0){
											room.memory.lair = filtered.sort(function (a, b){
													return a.ticksToSpawn - b.ticksToSpawn
											})[0].id;
									} else {
											delete room.memory.lair;
									}
							} else {
									delete room.memory.lair;
							}
							var min = room.mineral;
							if (min && min.mineralAmount > 0){
									room.memory.min = min.id;
							} else {
									delete room.memory.min;
							}
					}
			}
			//safeMode
			if (room.controller && room.controller.safeMode && room.controller.my){
					if (!Memory.avoidRooms){
							Memory.avoidRooms = {};
					}
					Memory.avoidRooms[room.name] = Game.time + room.controller.safemode;
			}
			//hostiles
			var hostilelist = room.find(FIND_HOSTILE_CREEPS);
			let hostiles;
			let hostile;
			let sklist = [];
			if (hostilelist.length > 0){
					if (room.type && Game.map.getRoomType(room.name) == 'SK'){
							sklist = [];
							let sk = _.filter(hostilelist, (c) => c.owner.username == 'Source Keeper');
							let old = true;
							let positions = [];
							if (sk.length > 0){
									for (let i = 0; i < sk.length; i++){
											sklist.push(sk[i].id);
											if (sk[i].ticksToLive > 1400){
													//possibly not in position
													old = false;
											}
											positions.push(sk[i].pos.toString());
									}
							}
							if (sklist.length === 4 && old){
									room.memory.SKSitPositions = positions;
							}
					} else {
							sklist = [];
					}
					if (room && room.controller && room.controller.my){
							let hostileParts = false;
							for (let h in hostilelist){
									//turn off public ramparts if hostile parts
									let stats = hostilelist[h].stats();
									if ((!config$1.allies || !config$1.allies.includes(hostilelist[h].owner.username)) &&
											(stats.attack || stats.work || stats.ranged_attack)){
											hostileParts = true;
											break
									}
							}
							room.memory.hostileParts = hostileParts;
							let whiteListed = _.filter(hostilelist, (c) => c.isWhiteListed);
							if (whiteListed && whiteListed.length > 0){
									let events = room.getEvents();
									let filteredEvents = events.filter((e) => e.event == EVENT_ATTACK || e.event == EVENT_ATTACK_CONTROLLER);
									for (let i in filteredEvents){
											let eventObj = filteredEvents[i];
											if (eventObj.event === EVENT_ATTACK_CONTROLLER ||
													(eventObj.data && eventObj.data.targetId && Game.getObjectById(eventObj.data.targetId) && (Game.getObjectById(eventObj.data.targetId).my
															|| (Game.getObjectById(eventObj.data.targetId).structureType && Game.getObjectById(eventObj.data.targetId).structureType == STRUCTURE_WALL)))){
													let traitor = Game.getObjectById(eventObj.objectId);
													if (traitor && traitor.owner && traitor.owner.username){
															if (!Memory.whiteListRevoked){
																	Memory.whiteListRevoked = [];
															}
															if (!Memory.whiteListRevoked.includes(traitor.owner.username)){
																	Memory.whiteListRevoked.push(traitor.owner.username);
															}
													}
											}
									}
							}
					}

					hostiles = _.filter(hostilelist, (c) => c.owner.username != 'Source Keeper' && !c.isWhiteListed && c.body != [MOVE]);
					if (hostiles.length > 0){
							hostile = hostiles[0];
					}

			} else {
					room.memory.hostileParts = false;
			}
			if (sklist && sklist.length > 0){
					room.memory.sk = sklist;
			} else {
					delete room.memory.sk;
			}
			if (hostile != null || hostile != undefined){
					room.memory.hostiles = hostile.id;
			} else {
					delete room.memory.hostiles;
			}
			if (room && (Game.map.getRoomType(room.name) == 'SK')){
					let mineral = room.mineral;
					room.memory.SKMineral = {pos: mineral.pos.toString(), type: mineral.mineralType, amount: mineral.mineralAmount};
					if (!room.memory.avoidLoci){
							let sources = room.find(FIND_SOURCES);
							let lairs = room.find(FIND_STRUCTURES, {filter: (s) => s.structureType == STRUCTURE_KEEPER_LAIR});
							let allAvoid = sources.concat([mineral], lairs);
							let arr = [];
							for (let a in allAvoid){
									arr.push(allAvoid[a].pos.toString());
							}
							room.memory.avoidLoci = arr;
					}
			} else if (room && Game.map.getRoomType(room.name) === 'centre'){
					let mineral = room.mineral;
					room.memory.SKMineral = {pos: mineral.pos.toString(), type: mineral.mineralType, amount: mineral.mineralAmount};
			}

			if (hostiles && hostiles.length > 0){
					let hosList = [];
					let noDamageDealers = true;
					for (let i = 0; i < hostiles.length; i++){
							let hostile = hostiles[i];
							hosList.push(hostile.id);
							let stats = hostile.stats();
							if (stats.attack > 0 || stats.ranged_attack > 0 || (stats.work > 0 && room.controller && room.controller.my && (room.memory.defcon < 5 ||
									hostile.owner.username.isEnemy))){
									noDamageDealers = false;
							}
							if (Memory.combatLog && Memory.combatLog[room.name] && !Memory.combatLog[room.name].secondary && (!room.controller || !room.controller.my) && !hostile.isWhiteListed && hostile.pos.onEdge()){
									//identifying the direction reinforcements are coming from a room to help allow us to drain a safemoded rooms rebuild attempt
									if (!Memory.combatLog[room.name].reinforcementDir){
											Memory.combatLog[room.name].reinforcementDir = {};
									}
									let oppEdge = hostile.pos.oppositeEdge();
									if (oppEdge && oppEdge.roomName && !Memory.myRooms.includes(oppEdge) && !Memory.combatLog[room.name].reinforcementDir[oppEdge.roomName]){
											Memory.combatLog[room.name].reinforcementDir[oppEdge.roomName] = true;
									}
							} else if (Memory.combatLog && Memory.combatLog[room.name] && !hostile.isWhiteListed && !hostile.pos.onEdge()){
									Memory.combatLog[room.name].lastHostilePosition = hostile.pos.toString();
							}
					}
					if (hosList.length > 0){
							if (!noDamageDealers && (!room.controller || !room.controller.owner || !room.controller.my || (room.controller.my && !room.controller.safeMode))){
									room.memory.armedHostiles = true;
							} else {
									delete room.memory.armedHostiles;
							}
					} else {
							delete room.memory.armedHostiles;
					}
			} else {
					delete room.memory.armedHostiles;
			}
			let symbolContainers;
			if (config$1.symbolCollection){
					if ((!room.controller || room.controller.my || !room.controller.owner) &&
							(!room.controller || !room.controller.reservation || room.controller.reservation.username == Game.username)){
							symbolContainers = room.find(FIND_SYMBOL_CONTAINERS);
					}
					if (!Memory.symbolDecoders){
							Memory.symbolDecoders = {};
					}
					let decoder = room.find(FIND_SYMBOL_DECODERS)[0];
					if (decoder && !decoders[room.name]){
							decoders[room.name] = decoder.resourceType;
					}
					if (room.controller && room.controller.owner && room.controller.level){
							if (decoder){
									if (Memory.symbolDecoders[room.name]){
											Memory.symbolDecoders[room.name].owner = room.controller.owner.username;
											Memory.symbolDecoders[room.name].level = room.controller.level;
									} else {
											Memory.symbolDecoders[room.name] = {
													type: decoder.resourceType,
													level: room.controller.level,
													owner: room.controller.owner.username,
													pos: decoder.pos.toString()
											};
									}
							}
					} else if (Memory.symbolDecoders[room.name]){
							delete Memory.symbolDecoders[room.name];
					}
			}
			if (symbolContainers && symbolContainers.length > 0 && (!room.controller || !room.controller.owner || room.controller.my)){
					for (let i in symbolContainers){
							let symbolContainer = symbolContainers[i];
							if (!symbolContainer || !symbolContainer.pos){
									continue
							}
							let homeRoom = findClosestOfMyRooms(symbolContainer.pos, 'symbol');
							if (!homeRoom){
									continue
							}
							if (!homeRoom.memory.symbolLocations){
									homeRoom.memory.symbolLocations = {};
							}
							if (!Memory.symbolLocations){
									Memory.symbolLocations = {};
							}
							if (symbolContainer && !Memory.symbolLocations[symbolContainer.pos.toString()] && (!homeRoom.memory.symbolLocations[symbolContainer.pos.toString()] || Game.time % 10 == 0)){
									let targetAmount = config$1.lowSymbolBound;
									let type = symbolContainer.type;
									if (Memory.decodersAvailable[type]){
											targetAmount = config$1.highSymbolBound;
									}
									let targetSector = getTargetSector(symbolContainer.pos);
									if (homeRoom.total(type) < targetAmount || (homeRoom.storage && homeRoom.storage.store.getUsedCapacity() < homeRoom.storage.store.getCapacity() * 0.8)){
											homeRoom.memory.symbolLocations[symbolContainer.pos.toString()] = {
													expiry: Game.time + symbolContainer.ticksToDecay - 300,
													amount: symbolContainer.store[symbolContainer.resourceType],
													type: symbolContainer.resourceType,
													id: symbolContainer.id,
													sector: targetSector
											};
											Memory.symbolLocations[symbolContainer.pos.toString()] = Game.time + symbolContainer.ticksToDecay - 300;
									}
							}
					}
			}

			function findClosestOfMyRooms(position, type){
					let range;
					let homeRoom;
					let backUp;
					let backUpRange;
					for (let r in Game.myRooms){
							let room = Game.myRooms[r];
							let nearRoomName = room.name;
							let newRange = guessDistanceAroundHighwayWalls(nearRoomName, position);
							if (newRange !== undefined && newRange !== null && (!range || range > newRange)
									&& newRange < 11){
									if (type == 'symbol' && room.memory.symbolLocations && Object.keys(room.memory.symbolLocations).length > 4){
											if (!backUpRange || backUpRange > newRange){
													backUp = room;
													backUpRange = newRange;
											}
									} else {
											range = newRange;
											homeRoom = room;
									}
							}
					}
					if (homeRoom){
							return homeRoom
					} else if (backUp){
							return backUp
					}
			}

			function getTargetSector(pos){
					let targetSector;
					if (playerHeap.sectorMemory[pos.roomName]){
							return playerHeap.sectorMemory[pos.roomName]
					}
					if (Game.map.getRoomType(pos.roomName) == 'highway'){
							targetSector = Game.map.getSideOfHighwayWall(pos);
							if (targetSector == 'open'){
									let sectors = Game.map.getHighwaySectors(pos.roomName);
									for (let i in sectors){
											if (Memory.reachableSectors[sectors[i]]){
													targetSector = sectors[i];
													break
											}
									}
							}
					}
					if (!targetSector){
							targetSector = Game.map.getSector(pos.roomName);
					}
					if (targetSector){
							playerHeap.sectorMemory[pos.roomName] = targetSector;
							return targetSector
					}
			}

			function guessDistanceAroundHighwayWalls(homeRoomName, position){
					//work out if room is in a neighbouring sector and if so the linear range to the gap in the wall and then the position
					let targetSector = getTargetSector(position);
					if (targetSector && Memory.reachableSectors[targetSector]){
							//we have access to this sector, first check if sector is next to homeRoom sector
							let homeSector = Game.map.getSector(homeRoomName);
							if (targetSector == homeSector){
									return Game.map.getRoomLinearDistance(homeRoomName, position.roomName)
							}
							if (Memory.openHighwayWalls && Memory.openHighwayWalls.sectors && Memory.openHighwayWalls.sectors[targetSector] && Memory.openHighwayWalls.sectors[targetSector][homeSector]){
									//neighbouring sector
									let highwayWallBreak = Memory.openHighwayWalls.sectors[targetSector][homeSector][0];
									let range1 = Game.map.getRoomLinearDistance(homeRoomName, highwayWallBreak);
									let range2 = Game.map.getRoomLinearDistance(highwayWallBreak, position.roomName);
									return range1 + range2
							}
					}
			}
	}

	function runRestructurer(){
		if (!Memory.toRestructure || Memory.toRestructure.length === 0){
			return
		}
		if (ready() === false){
			return
		}
		for (let i = Memory.toRestructure.length - 1; i > -1; i--){
			let roomName = Memory.toRestructure[i];
			let room = Game.rooms[roomName];
			if (!room){
				Memory.toRestructure.splice(i, 1);
				continue
			}
			mainMemorise(room);
			if (!access(roomName) || !access(roomName).structures || !access(roomName).baseLocation){
				console.log('restructurer segment error', roomName);
				if (!access(roomName).baseLocation || !access(roomName).baseLocation){
					Memory.toRestructure.splice(i, 1);
				}
				continue
			}
			if (room){
				if (room.memory.fixedBaseDir){
					room.memory.tempFixedDir = room.memory.fixedBaseDir;
					room.memory.tempOrigin = room.memory.fixedBaseOrigin;
					delete room.memory.fixedBaseDir;
					delete room.memory.fixedBaseOrigin;
				}
				delete room.memory.activeSiege;
				let structures = access(roomName).structures;
				if (access(room.name).baseLocation && access(room.name).baseLocation != 'none'){
					access(room.name).baseLocation[0].toPos();
					access(room.name).baseLocation[1];
				}
				let emptyRestruct, fillRestruct;
				//move store
				let storeInPos = validatePos(STRUCTURE_STORAGE, structures);
				if (!storeInPos){
					//console.log('restruct no store',roomName)
					if (!Memory.toMoveStore){
						Memory.toMoveStore = room.name;
					} else if (Memory.toMoveStore == room.name){
						console.log('moving store', room.name);
						room.memory.restructuring = true;
						if (room.terminal && !Game.flags['moveStore' + room.name] && room.storage){
							room.terminal.pos.createFlag('moveStore' + room.name);
						} else if ((!room.terminal || !room.storage) && Game.flags['moveStore' + room.name]){
							Game.flags['moveStore' + room.name].remove();
						}
						if (room.storage && (room.storage.store.getUsedCapacity() == 0 ||
							(room.storage.store['energy'] == room.storage.store.getUsedCapacity() && room.terminal
								&& room.terminal.store['energy'] > 40000))){
							room.storage.destroy();
						} else if (!room.storage){
							let pos = structures['storage'][0].toPos();
							pos.highlight('blue');
							pos.createConstructionSite(STRUCTURE_STORAGE);
						}
					}
					continue
					//empty room and then move
				} else if (Memory.toMoveStore && Memory.toMoveStore == room.name){
					delete Memory.toMoveStore;
					delete room.memory.restructuring;
				}
				if (Game.flags['moveStore' + room.name]){
					Game.flags['moveStore' + room.name].remove();
				}
				runSupportManager(room);
				console.log('restructuring', roomName);
				clearSpace(structures);
				let placedStructures = room.find(FIND_STRUCTURES);
				let factory = placedStructures.filter((s) => s.structureType == STRUCTURE_FACTORY)[0];
				let powerSpawn = placedStructures.filter((s) => s.structureType == STRUCTURE_POWER_SPAWN)[0];
				let labs = placedStructures.filter((s) => s.structureType == STRUCTURE_LAB);
				let towers = placedStructures.filter((s) => s.structureType == STRUCTURE_TOWER);
				if (!validatePos(STRUCTURE_SPAWN, structures)){
					let spawns = placedStructures.filter((s) => s.structureType == STRUCTURE_SPAWN);
					if (spawns.length === 3 || (room.controller.level == 7 && spawns.length > 1)){
						let spawnPositions = structures['spawn'];
						for (let i in spawns){
							if (spawns[i] && !spawnPositions.includes(spawns[i].pos.toString())){
								spawns[i].destroy();
								break
							}
						}
					}
				}
				if (!validatePos('extension', structures)){
					let extensions = placedStructures.filter((s) => s.structureType == STRUCTURE_EXTENSION);
					if (extensions.length > 15){
						let extPos = structures['extension'];
						for (let i in extensions){
							if (extensions[i] && !extPos.includes(extensions[i].pos.toString())){
								extensions[i].destroy();
								break
							}
						}
					}
				}
				if (!validatePos('terminal', structures) && room.storage && room.terminal && room.terminal.store.getUsedCapacity() > 0){
					emptyRestruct = room.terminal.id;
					fillRestruct = room.storage.id;
				} else if (!validatePos('terminal', structures) && room.storage && room.terminal && room.terminal.store.getUsedCapacity() === 0){
					room.terminal.destroy();
				} else if (!validatePos('factory', structures) && room.controller.level > 7 && room.storage && factory && factory.store.getUsedCapacity() > 0){
					emptyRestruct = factory.id;
					fillRestruct = room.storage.id;
				} else if (!validatePos('factory', structures) && room.storage && factory && factory.store.getUsedCapacity() === 0){
					factory.destroy();
				} else if (room.storage && room.controller.level > 7 && powerSpawn && (powerSpawn.store.getUsedCapacity('energy') > 0 || powerSpawn.store.getUsedCapacity('power') > 0)){
					emptyRestruct = powerSpawn.id;
					fillRestruct = room.storage.id;
				} else if (powerSpawn && room.controller.level > 7 && !validatePos(STRUCTURE_POWER_SPAWN, structures)){
					powerSpawn.destroy();
				} else {
					for (let i in labs){
						let lab = labs[i];
						if (!emptyRestruct && room.storage && lab && lab.mineralType){
							emptyRestruct = lab.id;
							fillRestruct = room.storage.id;
						}
						if (!lab.mineralType){
							lab.destroy();
						}
					}
					if (!emptyRestruct){
						for (let i in towers){
							let tower = towers[i];
							if (!emptyRestruct && room.storage && tower && tower.store['energy'] > 0){
								emptyRestruct = tower.id;
								fillRestruct = room.storage.id;
							}
							if (tower.store['energy'] === 0){
								tower.destroy();
							}
						}
					}
				}
				room.memory.restructuring = true;
				//move term
				//move other stuff
				//spawns (one by one)
				room.memory.emptyRestruct = emptyRestruct;
				room.memory.fillRestruct = fillRestruct;
				if (validatePos('spawn', structures) && validatePos('storage', structures)
					&& validatePos('terminal', structures)){
					delete room.memory.restructuring;
					Memory.toRestructure.splice(i, 1);
					if (!room.memory.fixedBaseDir && room.memory.tempFixedDir){
						room.memory.fixedBaseDir = room.memory.tempFixedDir;
						room.memory.fixedBaseOrigin = room.memory.tempOrigin;
					}
				}
			}

			function clearSpace(structures){
				for (let i in structures){
					let structureList = structures[i];
					if (i === 'extension' || i === 'storage' || i === 'lab' || i === 'terminal' || i === 'powerSpawn'
						|| i === 'factory' || i === 'link' || i === 'extension' || i === 'spawn' || i === 'road' || i === 'tower'){
						for (let s in structureList){
							let sPos = structureList[s].toPos();
							if (sPos){
								let structuresAtPos = sPos.lookAround(LOOK_STRUCTURES, 0);
								let correctStructure = false;
								for (let j in structuresAtPos){
									if (structuresAtPos[j].structureType === i){
										correctStructure = true;
									}
								}
								if (!correctStructure){
									for (let j in structuresAtPos){
										if ((!structuresAtPos[j].store || structuresAtPos[j].store.getUsedCapacity() === 0 ||
											(structuresAtPos[j].structureType === STRUCTURE_LAB && !structuresAtPos[j].mineralType) ||
											structuresAtPos[j].structureType === STRUCTURE_EXTENSION || structuresAtPos[j].structureType === STRUCTURE_NUKER
											|| structuresAtPos[j].structureType === STRUCTURE_LINK)
											&& structuresAtPos[j].structureType !== STRUCTURE_SPAWN
											&& structuresAtPos[j].structureType !== STRUCTURE_STORAGE
											&& structuresAtPos[j].structureType !== STRUCTURE_RAMPART){
											structuresAtPos[j].destroy();
										}
									}
									if (i == 'extension' || i == 'storage' || i == 'spawn' || i == 'terminal'){
										sPos.createConstructionSite(i);
									}
								}
							}
						}
					}
				}
			}

			function validatePos(structureType, structures){
				//return true if structure in correct pos
				let inPlace;
				let count = 0;
				if (structureType && structures && structures[structureType]){
					let structList = structures[structureType];
					for (let s in structList){
						let structurePos = structList[s].toPos();
						if (!structurePos){
							continue
						}
						//structurePos.highlight()
						let isStructureAtSpot = structurePos.lookAround(LOOK_STRUCTURES, 0, {filter: (s) => s.structureType == structureType}).length > 0;
						if (inPlace != false && !isStructureAtSpot){
							inPlace = false;
						} else if (isStructureAtSpot){
							count++;
						}
					}
				}
				if (count >= CONTROLLER_STRUCTURES[structureType][room.controller.level]){
					//enough for current level at needed spots
					return true
				}
				return inPlace
			}
		}
	}

	function runDisplay(){
			if (!config.display && Game.time % 30 !== 0){
					return
			}
			let defconList = ['Defcon:'];
			let lowEnergyList = ['Low energy:'];
			let harassedList = ['harassed:'];
			let highEnergyCount = 0;
			let allEnergy = 0;
			let roomCount = 0;
			let totalRemoteAdjust = 0;
			let factories = {};
			let levels = {};
			let excess = 0;
			for (let i in Game.myRooms){
					let room = Game.myRooms[i];
					if (room.controller && room.controller.my){
							if (room.memory.remoteAdjust){
									totalRemoteAdjust += room.memory.remoteAdjust;
							}
							if (room.storage && room.terminal && room.memory.reserve && room.class === 'normal'){
									excess += (room.total('energy') - room.memory.reserve);
							}
							if (room.memory.defcon && room.memory.defcon < 5){
									defconList.push(`${room.name}- def:${room.memory.defcon},lowHits:${Number.parseFloat(room.memory.adjustedLowWallHits/1000000).toFixed(1)}M,hostiles:${room.memory.armedHostiles}`);
							}
							if (room.memory.underHarassment){
									harassedList.push(room.name);
							}
							if (room.controller.level == 8 && room.total('energy') < room.memory.reserve * 0.7){
									lowEnergyList.push(`${room.name}:${room.total('energy')}`);
							} else if (room.controller.level == 8 && room.total('energy') > room.memory.reserve * 1.1){
									highEnergyCount++;
							}
							if (!levels[room.controller.level]){
									levels[room.controller.level] = 1;
							} else {
									levels[room.controller.level]++;
							}
							if (room.controller.level == 8 && room.class == 'normal'){
									allEnergy += room.total('energy');
									roomCount++;
							}
							if (room.memory.factory && Game.getObjectById(room.memory.factory)){
									let factory = Game.getObjectById(room.memory.factory);
									let level = 0;
									if (factory.level){
											level = factory.level;
									}
									if (!factories[level]){
											factories[level] = {idle: 0, boosted: 0,total:0};
									}
									factories[level].total++;
									if (level === 0 || (factory.effects && factory.effects.length > 0)){
											factories[level].boosted++;
											if (!factory.cooldown){
													factories[level].idle++;
											}
									}
							}
					}
			}
			if (levels && !levels[6] && !levels[7]){
					//only level 8 rooms - praise
					Memory.noLowLevelTerminals = true;
			} else {
					delete Memory.noLowLevelTerminals;
			}
			Memory.highEnergyCount = highEnergyCount;
			new RoomVisual().text('Sources:' + Memory.sourceLimit, 2, 1);
			let count = 2;
			let timeStr = 'time: ' + Game.time;
			let allList = [timeStr].concat(defconList, lowEnergyList, harassedList);
			let avEnergy = Math.round(allEnergy / roomCount);
			allList.push(['Av remote adjust: ' + (totalRemoteAdjust / roomCount)]);
			Memory.stats['average8Energy'] = avEnergy;
			allList.push(['High energy count: ' + highEnergyCount]);
			allList.push(['Av energy: ' + avEnergy]);
			allList.push('Excess energy: ' + excess);
			Memory.excessEnergy = excess;
			allList.push('Idle factories:');
			for (let i in factories){
					allList.push(`  Tier ${i} idle:${factories[i].idle}, boosted:${factories[i].boosted}, total:${factories[i].total}`);
			}
			allList.push('Levels (lvl/amount):');
			for (let i in levels){
					allList.push(`${i}:${levels[i]}`);
			}
			if (allList.length > 3){
					for (let i in allList){
							new RoomVisual().text(allList[i], 1, count, {align: 'left'});
							count++;
					}
			}
	}

	function runEnergyDistributionManager(){
			let roomsNeedingTransfers = [];
			let values = {};
			let terminals = 0;
			let myRooms = [];
			for (let i in Game.myRooms){
					let room = Game.myRooms[i];
					if (room.terminal && room.controller.level >= 6 && (room.class === 'normal' || room.class === 'bunker')){
							terminals++;
							myRooms.push(room);
					}
			}
			if (Memory.emergency || terminals < 2 || config.singleSpawn){
					delete Memory.priorityEnergyRoomName;
					for (let i in myRooms){
							let room = myRooms[i];
							delete room.memory.priorityEnergyRoom;
							delete room.memory.priorityEnergyTimer;
					}
					return
			}

			let thoriumSupportRooms = [];
			for (let i in myRooms){
					let room = myRooms[i];
					if (config.season && config.season === 'thorium'){
							if (room.memory.thoriumMineSupportRoom && Game.rooms[room.memory.thoriumMineSupportRoom]){
									thoriumSupportRooms.push(room.name);
									Game.map.visual.text('\u{1F4EE}', new RoomPosition(45, 45,room.name));
									//console.log(room.name,'\u{1F4EE}')
									continue
							} else {
									delete room.memory.thoriumMineSupportRoom;
							}
					}
					delete room.memory.priorityEnergyRoomPrimary;
					if (Memory.priorityEnergyRoomName && (!config.forceEnergyTarget || room.name !== config.forceEnergyTarget) && room.name != Memory.priorityEnergyRoomName && room.memory.priorityEnergyRoom &&
							(room.controller.level === 8 || (config.level7max && room.controller.level === 7) || !room.memory.priorityEnergyTimer || room.memory.priorityEnergyTimer < Game.time)){
							delete room.memory.priorityEnergyRoom;
							delete room.memory.priorityEnergyTimer;
					}
					if (room.memory.priorityEnergyRoom && (room.controller.level === 8 || (config.level7max && room.controller.level === 7))){
							delete room.memory.priorityEnergyRoom;
							delete room.memory.priorityEnergyTimer;
					}

					if (Memory.priorityEnergyRoomName && room.name === Memory.priorityEnergyRoomName){
							Game.map.visual.text('\u{1F4EE}', new RoomPosition(45, 45, room.name));
							//console.log(room.name,'\u{1F4EE}')
					} else if (room.memory.priorityEnergyRoom){
							//console.log(room.name,'\u{2709}','\u{274C}')
							Game.map.visual.text('\u{2709}', new RoomPosition(45, 45, room.name));
							Game.map.visual.text('\u{274C}', new RoomPosition(45, 45, room.name));
					} else if (room.terminal && room.controller.level > 6 && Memory.priorityEnergyRoomName &&
							(!config.energyDonorMinLevel || room.controller.level >= config.energyDonorMinLevel)){
							//console.log(room.name,'\u{2709}',)
							Game.map.visual.text('\u{2709}', new RoomPosition(45, 45, room.name));
					}
					if (room.terminal && room.controller.level > 5 && room.controller.level < 8){
							if (config.level7max && room.controller.level === 7){
									continue
							}
							let gap = room.controller.progressTotal - room.controller.progress;
							if ((config.requestEnergyRoom && config.requestEnergyRoom.includes(room.name)) ||
									(config.requestEnergyRoomLocal && config.requestEnergyRoomLocal.includes(room.name))){
									gap = 1;
							}
							values[room.name] = gap;
							roomsNeedingTransfers.push(room.name);
					}
			}
			roomsNeedingTransfers.sort((a, b) => values[a] - values[b]);
			if (thoriumSupportRooms && thoriumSupportRooms.length > 0){
					thoriumSupportRooms.sort((a,b)=> Game.rooms[a].total('energy')-Game.rooms[b].total('energy'));
					roomsNeedingTransfers = thoriumSupportRooms.concat(roomsNeedingTransfers);
			}
			let priorityRoomName;
			if (config.forceEnergyTarget){
					let room = Game.rooms[config.forceEnergyTarget];
					priorityRoomName = room.name;
					room.memory.priorityEnergyRoom = true;
					room.memory.priorityEnergyTimer = Game.time + 1500;
			} else if (roomsNeedingTransfers && roomsNeedingTransfers.length > 0){
					for (let i in roomsNeedingTransfers){
							let roomName = roomsNeedingTransfers[i];
							let room = Game.rooms[roomName];
							let upperLimit = room.memory.reserve * 2;
							if (room && room.total('energy') < upperLimit){
									priorityRoomName = roomName;
									room.memory.priorityEnergyRoom = true;
									room.memory.priorityEnergyTimer = Game.time + 1500;
									if (i > 0){
											room.memory.priorityEnergyRoomPrimary = false;
									} else {
											room.memory.priorityEnergyRoomPrimary = true;
									}
									break
							} else if (i == 0){
									room.memory.priorityEnergyRoom = true;
									room.memory.priorityEnergyTimer = Game.time + 1500;
									room.memory.priorityEnergyRoomPrimary = true;
							}
					}
			}
			if (priorityRoomName){
					Memory.priorityEnergyRoomName = priorityRoomName;
			} else {
					delete Memory.priorityEnergyRoomName;
			}
	}

	const expiry = 300;
	let lastCreeps = {};
	function runDeathDetection(){
			for (let i in lastCreeps){
					if (!Game.creeps[i] && lastCreeps[i].ticksToLive > 5){
							//creep has likely died - save the room it died in for a certain amount of ticks to reduce pathing through it and schedule defence
							flagRoom(lastCreeps[i].roomName);
							let split = i.split(' ');
							let homeRoom;
							if (split && split[2]){
									homeRoom = Game.rooms[split[2]];
							}
							if (split[0] && split[0] === 'soldier' && lastCreeps[i].bodySize && split[2] &&  Game.rooms[split[2]]){
									//larger soldier has been killed - block further sending to prevent drain
									if (Memory.rooms[split[2]] && (lastCreeps[i].bodySize > 30 || Game.rooms[split[2]].controller.level < 7)){
											if (homeRoom.total('energy')>homeRoom.memory.reserve || homeRoom.controller.level < 7);
											Memory.rooms[split[2]].blockSoldiers = Game.time+3000;
									}

									if (homeRoom && homeRoom.memory.reserve && homeRoom.total('energy') < homeRoom.memory.reserve * 0.9 && config.official){
											//being drained, stop making creeps
											homeRoom.memory.underHarassment = Game.time + 1000;
									}
									if (homeRoom){
											homeRoom.memory.lastSoldierDeath = Game.time;
											let deathRoom = Game.rooms[lastCreeps[i].roomName];
											if (deathRoom && deathRoom.armedHostileList){
													for (let h in deathRoom.armedHostileList){
															let hostile = deathRoom.armedHostileList[h];
															if (hostile && !hostile.isWhiteListed && hostile.username !== 'Invader'){
																	homeRoom.memory.dangerousHostileInRemotes = Game.time;
															}
													}
											}
									}
							}
							if (split[0] && split[0] === 'claimer'){
									delete Memory.expansionPath;
							}
							if (split[0] && split[0] === 'colonist'){
									if (!Memory.colonistEscort){
											Memory.colonistEscort = {};
									}
									Memory.colonistEscort[split[1]] = Game.time + 2000;
							}
							if (homeRoom && split[0] && split[0] === 'filler'){
									delete homeRoom.memory.fillPath;
									homeRoom.memory.fillerBlock = Game.time + 3000;
							}
							if (split[0] && split[0] === 'reserve' && homeRoom){
									delete homeRoom.memory.resPaths;
							}
							if (split[0] && (split[0] === 'yak' || split[0] === 'remotefixer' || split[0] === 'thoriumReactorHauler' || split[0] === 'vision' || split[0] === 'observer') && homeRoom){
									let room = Game.rooms[lastCreeps[i].roomName];
									if (split[0] === 'yak' || split[0] === 'remotefixer' ){
											delete homeRoom.memory.yakOutPaths;
											delete homeRoom.memory.sourcePaths;
									}
									if (room){
											let type = Game.map.getRoomType(room);
											if (type === 'SK' || type === 'centre'){
													let core = room.findStructures('invaderCore')[0];
													if (core && core.level > 0){
															Memory.sectors[room.sector].invaderCore = room.name;
													}
											}
											if (split[0] === 'thoriumReactorHauler' && type !== 'centre'){
													delete homeRoom.memory.reactorPath;
											}
									}
							}
							if (split[0] && split[0] === 'remoteminer' && homeRoom){
									delete homeRoom.memory.minerPaths;
									let room = Game.rooms[lastCreeps[i].roomName];
									if (room){
											let type = Game.map.getRoomType(room);
											if (type === 'SK' || type === 'centre'){
													let core = room.findStructures('invaderCore')[0];
													if (core && core.level > 0){
															Memory.sectors[room.sector].invaderCore = room.name;
													}
											}
									}
							}
					}
			}
			lastCreeps = {};
			for (let i in Game.creeps){
					let creep = Game.creeps[i];
					if (creep.ticksToLive && creep.room){
							lastCreeps[i] = {
									ticksToLive : creep.ticksToLive,
									roomName : creep.room.name
							};
							if (creep.role === 'soldier'){
									lastCreeps[i].bodySize = creep.body.length;
							}
					}
			}
			if (Game.time % 100){
					for (let i in Memory.dangerRooms){
							if (Game.time > Memory.dangerRooms[i].expiry){
									delete Memory.dangerRooms[i];
							}
					}
			}
	}
	function flagRoom(roomName){
			if (!Memory.dangerRooms){
					Memory.dangerRooms = {};
			}
			Memory.dangerRooms[roomName] = {expiry:Game.time+expiry,time:Game.time};
	}
	function removeCreepFromDeathDetection(name){
			delete lastCreeps[name];
	}

	//roughly 0.6 cpu per remote, each remote gives 10 energy a tick, 16.666, lets round to 16.5 energy per cpu per tick
	const cpuEnergyPerTick = 16.5;
	function setProfitablePowerThreshold(){
			let testRoom,highestRoom,highestLevel;
			for (let i in Game.myRooms){
					let room = Game.myRooms[i];
					if (room.controller.level === 8){
							testRoom = room;
					}
					if (!highestRoom || room.controller.level > highestLevel){
							highestLevel = room.controller.level;
							highestRoom = room;
					}
			}
			if (!testRoom && highestRoom){
					testRoom = highestRoom;
			}
			if (!Memory.market){
					return
			}
			//power
			if (Memory.market.resources['power'] && testRoom && testRoom.controller.level > 6){
					//power squads -> average 1 cpu/tick
					let cpuCost = 1;
					let attackerBody = getBody$6(testRoom,0,'P');
					let medicBody = getBody$2(testRoom,0,'P');
					let attackerBoostBody = getBody$6(testRoom,1,'P');
					let medicBoostBody = getBody$2(testRoom,1,'P');
					let energyCreditValue;
					if (Memory.market && Memory.market.resources && Memory.market.resources['energy']){
							energyCreditValue = Memory.market.resources['energy'].w;
					}
					let powerCost;
					if (energyCreditValue && Memory.market && Memory.market.resources && Memory.market.resources['power'] && Memory.market.resources['power'].w){
							powerCost = Memory.market.resources['power'].w + energyCreditValue;
					}
					if (!energyCreditValue){
							return
					}
					let moverBody = spawnCode$e.body(testRoom,countRole);
					//nonboosted - normally need 3x squads - 1 attacker and 2 medics
					let nonBoostedSquadCost = (Game.getBodyCost(attackerBody)*3)+(Game.getBodyCost(medicBody)*6 + (cpuCost*1*4500))*energyCreditValue;
					//boosted - normally need 2x squads - 1 attacker and 1 medic
					let boostedSquadCost = (Game.getBodyCost(attackerBoostBody)*2)+(Game.getBodyCost(medicBoostBody)*2+ (cpuCost*0.6*3000))*energyCreditValue;
					let boostCost = 0;
					let canBoost = false;
					if (Game.canBoost(config.boostLevels[1])){
							canBoost = true;
					}
					if (Memory.market && energyCreditValue && Memory.market.resources && Memory.market.resources['LO'] && Memory.market.resources['LO'].w){
							boostCost += 50*(Memory.market.resources['LO'].w+energyCreditValue);
					} else {
							canBoost = false;
					}
					if (Memory.market && energyCreditValue && Memory.market.resources && Memory.market.resources['UH'] && Memory.market.resources['UH'].w){
							boostCost += 50*(Memory.market.resources['UH'].w+energyCreditValue);
					} else {
							canBoost = false;
					}
					if (Memory.market && energyCreditValue && Memory.market.resources && Memory.market.resources['ZO'] && Memory.market.resources['ZO'].w){
							boostCost += 60*(Memory.market.resources['ZO'].w+energyCreditValue);
					} else {
							canBoost = false;
					}
					boostedSquadCost += boostCost;
					if (canBoost && boostedSquadCost > nonBoostedSquadCost){
							canBoost = false;
					}
					let squadCost = nonBoostedSquadCost;
					if (canBoost){
							squadCost = boostedSquadCost;
					}
					let powerCap = 0;
					for (let cap = 250;cap < 10000;cap +=250){
					    let powernum = Math.ceil(cap / 1250);
							let moverCost = (moverBody.cost+(cpuCost*0.3*1500))*powernum;
							if ((cap*powerCost)>(moverCost+squadCost)){
									powerCap = cap;
									break
							}
					}
					console.log(`power cost assessment, boosted:${boostedSquadCost}, unboosted:${nonBoostedSquadCost}, power cap: ${powerCap} (value ${powerCap*powerCost}), canBoost ${canBoost}`);
					if (powerCap && powerCap > 0){
							Memory.minimumPowerBankAmount = powerCap;
							Memory.boostPowerSquads = canBoost;
					}
			}
	}
	function getMaxDepositCooldown(homeRoom,deposit){
			let energyCost = getDepositMiningEnergyCostPerTick(homeRoom);
			if (!energyCost){
					return
			}
			let depositType = deposit.depositType;
			let energyCreditValue;
			if (Memory.market && Memory.market.resources && Memory.market.resources['energy']){
					energyCreditValue = Memory.market.resources['energy'].w;
			}
			let depositPurchaseValue;
			let energyValue = energyCost*energyCreditValue;
			if (Memory.market && Memory.market.resources && Memory.market.resources[depositType] && Memory.market.resources[depositType].w
					&& spawnCode$s){
					let minerBody = spawnCode$s.body(homeRoom,countRole).body;
					let minerParts = 0;
					let minerAmount = spawnCode$s.isRequired(homeRoom,countRole,undefined,undefined,true);
					for (let i in minerBody){
							if (minerBody[i] === 'work'){
									minerParts ++;
							}
					}
					minerParts *= minerAmount;
					depositPurchaseValue = (energyCreditValue+Memory.market.resources[depositType].w)*minerParts;
			}
			if (depositPurchaseValue){
					let cooldown = 1;
					while ((depositPurchaseValue/cooldown) > energyValue || cooldown > 200){
							cooldown++;
					}
					console.log(`cooldown for ${deposit.pos.hyperlink} (${depositType}) from ${homeRoom}: ${cooldown}. depositPurchaseValue: ${depositPurchaseValue}. energyValue: ${energyValue}`);
					if (cooldown < 5){
							return 0
					}
					return cooldown
			}
	}
	function energyPerCpu(cpu){
			return cpu*cpuEnergyPerTick
	}
	function getDepositMiningEnergyCostPerTick(room,deposit){
			let minerBodyObj = spawnCode$s.body(room,countRole);
			let carryBodyObj = spawnCode$t.body(room,countRole);
			if (minerBodyObj && carryBodyObj){
					let minerCost = 0;
					let minerAmount = spawnCode$s.isRequired(room,countRole,undefined,undefined,true);
					if (minerAmount){
							minerCost += ((minerBodyObj.cost/1500)+energyPerCpu(0.09))*minerAmount;
					}
					let carryCost = 0;
					let carryAmount = spawnCode$t.isRequired(room,countRole,undefined,undefined,true);
					if (carryAmount){
							carryCost += ((carryBodyObj.cost/1500)+energyPerCpu(0.125))*carryAmount;
					}
					//console.log(`depositCost for ${deposit.pos.hyperlink} from ${room}: ${minerCost+carryCost}`)
					return minerCost+carryCost
			}
	}

	let depositsBlockedPerHomeRoom = 1;
	function runDepositManager(){
			if (!config.depositMine){
					return
			}
			let roomsUsed = {};
			let amount = 0, totalCooldown = 0;
			for (let i in Memory.deposits){
					if (!Memory.deposits[i].expiry || Memory.deposits[i].expiry < Game.time){
							delete Memory.deposits[i];
							continue
					}
					let roomName = Memory.deposits[i].closestRoom;
					let room = Game.rooms[roomName];
					if (room && room.memory.blockingDeposits && Object.keys(room.memory.blockingDeposits).length > depositsBlockedPerHomeRoom){
							delete room.memory.blockingDeposits;
					}
					if (room){
							if (!room.memory.blockingDeposits){
									room.memory.blockingDeposits = {};
							}
							for (let d in room.memory.blockingDeposits){
									if (!Memory.deposits[d]){
											delete room.memory.blockingDeposits;
									}
							}
							if (Memory.deposits[i].id && Game.getObjectById(Memory.deposits[i].id) && !Memory.deposits[i].maxCooldown){
									let maxCooldown = getMaxDepositCooldown(room,Game.getObjectById(Memory.deposits[i].id));
									if (maxCooldown){
											Memory.deposits[i].maxCooldown = maxCooldown;
									}
							}
					}


					let cooldown = config.depositMaxCooldown;
					if (room && room.controller && room.controller.level< 8){
							cooldown*=0.5;
							cooldown = Math.round(cooldown);
					}
					if (Game.rooms[roomName] && Game.rooms[roomName].memory.sboostlab && Game.rooms[roomName].memory.sboostlab['UO']){
							cooldown = config.depositBoostedCooldown;
					}
					if (Memory.deposits[i].maxCooldown && Memory.deposits[i].maxCooldown<cooldown){
							cooldown = Memory.deposits[i].maxCooldown;
					} else if (Memory.deposits[i].maxCooldown){
							Memory.deposits[i].maxCooldown = cooldown;
					}
					if (Memory.deposits[i].lastCooldown){
							amount++;
							totalCooldown += Memory.deposits[i].lastCooldown;
					}
					let canMineRoom = Game.map.canHighwayMineRoom(i.toPos().roomName);
					if (Memory.rooms[roomName] && canMineRoom && (!Memory.deposits[i].lastCooldown || Memory.deposits[i].lastCooldown < cooldown)){
							roomsUsed[roomName] = true;
							if (!Memory.rooms[roomName].depositTargets){
									Memory.rooms[roomName].depositTargets = [i];
							} else if (!Memory.rooms[roomName].depositTargets.includes(i)){
									Memory.rooms[roomName].depositTargets.push(i);
							}
					} else if (roomName && Memory.rooms[roomName] && Memory.rooms[roomName].depositTargets){
							let index = Memory.rooms[roomName].depositTargets.indexOf(i);
							if (index && index === 0 && canMineRoom){
									let aliveMiner = countRole('depositMiner',Game.rooms[roomName]);
									if (aliveMiner && aliveMiner > 0){
											console.log('block deposit change while miner alive', room.name, i.toPos().hyperlink);
											continue
									}
							}
							if (index !== -1){
									Memory.rooms[roomName].depositTargets.splice(index, 1);
							}
					} else if (config.depositBlocking && room && canMineRoom && Memory.rooms[roomName] && Memory.deposits[i].lastCooldown > cooldown+50 && config.official && cooldown > 100) {
							//other player mining this deposit - try to block it
							let pos = i.toPos();
							if (pos){
									if (!Memory.dangerRooms || !Memory.dangerRooms[roomName]){
											if (room.memory.blockingDeposits[i] || Object.keys(room.memory.blockingDeposits).length < depositsBlockedPerHomeRoom){
													room.memory.blockingDeposits[i] = true;
													let freeSpaces = Memory.deposits[i].freeSpaces;
													if (freeSpaces === undefined){
															Memory.deposits[i].freeSpaces = pos.freeSpacesAround;
													}
													if (freeSpaces > 0){
															Game.rooms[roomName].sendDepositBlocker(i,freeSpaces);
													}
													if (Game.rooms[pos.roomName]){
															runBlockers(Game.rooms[pos.roomName],pos);
													}
											} else {
													//hopefully another room will be assigned
													delete Memory.deposits[i].closestRoom;
											}
									}
							}
					}
			}
			Memory.stats.deposits = {
					amount : amount,
					cooldownAverage : Math.round(totalCooldown/amount)
			};
			for (let i in Game.myRooms){
					delete Game.myRooms[i].memory.deposit;
					if (!roomsUsed[Game.myRooms[i].name]){
							delete Game.myRooms[i].memory.depositTargets;
					}
			}
	}
	let cachedBlockPositions = {};
	function runBlockers(room,pos){
			const replaceTime = 50;
			let blockers = room.find(FIND_MY_CREEPS,{filter:(c)=>c.role === 'depositBlocker' && c.memory.near});
			let assignedPosition = {};
			let blockPositions;
			let needsNewBlocker = [];
			if (cachedBlockPositions[pos.toString()]){
					blockPositions = cachedBlockPositions[pos.toString()];
			} else {
					blockPositions = {};
					let neighbours = pos.neighbours();
					for (let i in neighbours){
							if (neighbours[i].getTerrain() !== 'wall'){
									blockPositions[neighbours[i].toString()] = {
											occupied : false
									};
							}
					}
			}
			let usedId = {};
			for (let i in blockPositions){
					let blockPosObj = blockPositions[i];
					let blockPos = i.toPos();
					if (blockPosObj.reservationID){
							let creep = Game.getObjectById(blockPosObj.reservationID);
							assignedPosition[blockPosObj.reservationID] = true;
							if (!creep || creep.ticksToLive < replaceTime || usedId[creep.id]){
									//blockPos.highlight('red')
									delete blockPosObj.reservationID;
									blockPosObj.occupied = false;
									let inPos = blockPos.lookAround(LOOK_CREEPS,0,{filter:(c)=>c.my && c.role === 'depositBlocker' && c.ticksToLive > replaceTime})[0];
									if (inPos){
											blockPosObj.reservationID = inPos.id;
											blockPosObj.occupied = true;
									} else {
											needsNewBlocker.push(i);
									}
							} else if (!creep.pos.isEqualTo(blockPos)){
									usedId[creep.id] = true;
									//blockPos.highlight('orange')
									new RoomVisual(pos.roomName).line(blockPos,creep.pos);
									creep.moveTo(blockPos,{range:0});
									blockPosObj.occupied = false;
							} else {
									usedId[creep.id] = true;
									//blockPos.highlight('green')
									blockPosObj.occupied = true;
							}
					} else {
							//blockPos.highlight('red')
							let inPos = blockPos.lookAround(LOOK_CREEPS,0,{filter:(c)=>c.my && c.role === 'depositBlocker' && c.ticksToLive > replaceTime})[0];
							if (inPos){
									blockPosObj.reservationID = inPos.id;
									blockPosObj.occupied = true;
							} else {
									needsNewBlocker.push(i);
							}
					}
			}
		for (let i in blockers){
					let blocker  = blockers[i];
					if (blocker.ticksToLive > replaceTime+50 && !assignedPosition[blocker.id] && !usedId[blocker.id]){
							if (needsNewBlocker && needsNewBlocker.length > 0){
									let assigned = needsNewBlocker.pop();
									blockPositions[assigned].reservationID = blocker.id;
									blocker.moveTo(assigned.toPos(),{range:0});
							}
					}
			}
			cachedBlockPositions[pos.toString()] = blockPositions;
	}

	const globalCommodities = ['cpuUnlock','pixel','accessKey'];
	function runGlobalTrade(){
			if (!config.official || !Memory.market || !Memory.market.resources){
					return
			}
			let orders = Game.market.getAllCachedOrders(true);
			if (!orders){
					orders = Game.market.getAllOrders(order => order.type === ORDER_SELL && globalCommodities.includes(order.resourceType));
			} else {
					orders = orders.filter(order => globalCommodities.includes(order.resourceType));
			}
			let freeCash = Game.market.credits-(config.maxCredits*5);
			if (!Memory.globalResourcesToSell){
					Memory.globalResourcesToSell = [];
			}
			if (orders && orders.length > 0){
					//buy cheap orders
					for (let i in orders){
							let order = orders[i];
							if (order){
									let resourceType = order.resourceType;
									let price = order.price;
									let amount = order.amount;
									let marketPrices = Memory.market.resources[resourceType];
									if (marketPrices && marketPrices.sd > 10000 && marketPrices.d && marketPrices.w){
											let priceDiff = price/marketPrices.w;
											if (order.type === ORDER_SELL){
													if (freeCash < 0){
															continue
													}
													//buy if under price
													if (price < marketPrices.d && price < marketPrices.w && (marketPrices.d > marketPrices.w || priceDiff < 0.7)){
															//buy in a trough as prices begin to rise
															if (priceDiff < 0.7 || marketPrices.marketIsActive){
																	let maxPrice = price*amount;
																	let tradeAmount = amount;
																	if (maxPrice > freeCash){
																			tradeAmount = Math.floor(freeCash/price);
																	}
																	let ret = Game.market.deal(order.id,tradeAmount);
																	if (ret === OK){
																			console.log(`announcement|${Game.shard.name}|purchasing global resource ${tradeAmount} ${resourceType} for ${price} at ${Game.time}`);
																			freeCash -= tradeAmount*price;
																			if (price < marketPrices.w*0.7){
																					price = marketPrices.w*0.7;
																			}
																			//save this so we ensure we never under sell this resource
																			Memory.globalResourcesToSell.push({resource:resourceType,amount:tradeAmount,price:price});
																	}
															}
													}
											} else if (order.type === ORDER_BUY){
													let forceTradeId = undefined;
													if (Game.resources && Game.resources[resourceType] && price > marketPrices.d && (price > marketPrices.w || order.id === forceTradeId) && (order.id === forceTradeId|| marketPrices.d < marketPrices.w || priceDiff > 1.1)){
															//sell as the market starts to turn and prices start to drop
															if (Game.resources && order.resourceType === 'accessKey' && (!Game.resources['accessKey'] ||
																	Game.resources['accessKey'] < 10)){
																	continue
															}
															if (!Memory.globalResourcesToSell || Memory.globalResourcesToSell.length === 0){
																	continue
															}
															let saleObject,index;
															for (let q in Memory.globalResourcesToSell){
																	let requiredSale = Memory.globalResourcesToSell[q];
																	if (requiredSale && requiredSale.resource === resourceType && requiredSale.amount && requiredSale.price && (requiredSale.price*1.05) < price){
																			saleObject = requiredSale;
																			index = q;
																			break
																	}
															}
															if (saleObject){
																	let tradeAmount = amount;
																	if (tradeAmount > saleObject.amount){
																			tradeAmount = saleObject.amount;
																	}
																	if (Game.resources && resourceType === 'accessKey' &&  amount > Game.resources['accessKey']+10){
																			tradeAmount = Game.resources['accessKey']-10;
																	}
																	let ret = Game.market.deal(order.id,tradeAmount);
																	if (ret === OK){
																			console.log(`announcement|${Game.shard.name}|selling global resource ${tradeAmount} ${resourceType} for ${price} at ${Game.time}`);
																			Memory.globalResourcesToSell[index].amount -= tradeAmount;
																	} else {
																			console.log('global trade err',ret,resourceType,price,order.id,tradeAmount);
																	}
															}
													}
											}
									}
							}
					}
			}
			if (Memory.globalResourcesToSell && Game.time % 1000 === 0){
					//clear fully sold orders
					for (let i = Memory.globalResourcesToSell.length-1;i > -1; i--){
							if (!Memory.globalResourcesToSell[i].amount || Memory.globalResourcesToSell[i].amount < 0){
									Memory.globalResourcesToSell.splice(i,1);
							}
					}
			}
	}

	function requestBlockers(homeRoom,room,exitSides,healer){
			if (!room || !exitSides){
					return
			}
			if (!Array.isArray(exitSides)){
					exitSides = [exitSides];
			}
			if (!Memory.exitBlocks){
					Memory.exitBlocks = {};
			}
			if (!Memory.exitBlocks[room.name]){
					let exits = room.find(FIND_EXIT);
					let sources = [];
					let sinks = [];
					for (let i in exits){
							let exit = exits[i];
							let side = exit.getEdge();
							if (exitSides.includes(side)){
									sources.push(exit);
							} else {
									sinks.push(exit);
							}
					}
					let blockPositions = runMinCut(new RoomPosition(25,25,room.name),sources,sinks);
					if (blockPositions){
							for (let i in blockPositions){
									blockPositions[i] = blockPositions[i].toString();
							}
							Memory.exitBlocks[room.name] = {
									blockPositions:blockPositions
							};
					}
			} else if (Memory.exitBlocks[room.name].blockPositions){
					let blockPositions = Memory.exitBlocks[room.name].blockPositions;
					homeRoom.sendExitBlocker(room.name,blockPositions.length+3,healer);
			}
	}

	const tackedCommodities = ['machine','device','organism','essence'];
	function trackNPCPrices(){
			//NPC prices are based on NPC transcations rather than all transactions
			// helpful to know what average NPC prices are for better market understanding
			if (!config$1.marketActive || !Memory.market || !Memory.market.resources || true){
					return
			}
			let orders = Game.market.getAllCachedOrders(true);
			if (!orders){
					orders = Game.market.getAllOrders(order => order.type === ORDER_BUY && tackedCommodities.includes(order.resourceType));
			} else {
					orders = orders.filter(order => tackedCommodities.includes(order.resourceType));
			}
			if (!Memory.trackedNPCOrders){
					Memory.trackedNPCOrders = {};
			}
			if (!Memory.completeNPCOrders){
					Memory.completeNPCOrders = {};
			}
			let foundOrders = {};
			let averageListPrice;
			if (Game.time % 1000 === 0){
					averageListPrice = {};
			}
			for (let i in orders){
					//adding new orders
					let order = orders[i];
					if (order){
							if (!order.roomName || Game.map.getRoomType(order.roomName) !== 'highway'){
									continue
							}
							let resourceType = order.resourceType;
							if (!Memory.trackedNPCOrders[resourceType]){
									Memory.trackedNPCOrders[resourceType] = {};
							}
							if (averageListPrice){
									if (!averageListPrice[resourceType]){
											averageListPrice[resourceType] = {
													total:0,
													price:0
											};
									}
									averageListPrice[resourceType].total ++;
									averageListPrice[resourceType].price += order.price;
							}
							if (!Memory.trackedNPCOrders[resourceType][order.id]){
									Memory.trackedNPCOrders[resourceType][order.id] = {
											orderData:order,
											tickDetected:Game.time,
									};
							}
							foundOrders[order.id] = true;
					}
			}
			if (averageListPrice){
					for (let resource in averageListPrice){
							if (!Memory.averageNPCListPrice){
									Memory.averageNPCListPrice = {};
							}
							if (!Memory.averageNPCListPrice[resource]){
									Memory.averageNPCListPrice[resource] = [];
							}
							if (Memory.averageNPCListPrice[resource].length > 50){
									Memory.averageNPCListPrice[resource].shift();
							}
							let obj = {
									price: averageListPrice[resource].price/averageListPrice[resource].total,
									time: Game.time
							};
							Memory.averageNPCListPrice[resource].push(obj);
					}
			}
			let time = Date.now();
			for (let resource in Memory.trackedNPCOrders){
					//checking if orders have been processed
					if (!Memory.completeNPCOrders[resource]){
							Memory.completeNPCOrders[resource] = [];
					}
					let arr = Memory.completeNPCOrders[resource];
					if (arr.length >= 50){
							Memory.completeNPCOrders[resource].shift();
					}
					for (let id in Memory.trackedNPCOrders[resource]){
							let orderObject = Memory.trackedNPCOrders[resource][id];
							if (!foundOrders[id]){
									//this order is complete - need to add to complete list
									orderObject.timeComplete = time;
									orderObject.tickComplete = Game.time;
									arr.push(orderObject);
									//remove from tracked orders
									delete Memory.trackedNPCOrders[resource][id];
							}
					}
			}
	}

	function runCoreTargeter(){
			if (config.conserveCpu && Game.cpu.bucket < 8000 && Game.time % 20 !== 0){
					return
			}
			let sectors = {};
			for (let i in Game.myRooms){
					let sector = Game.myRooms[i].sector;
					if (!sectors[sector]){
							sectors[sector] = [Game.myRooms[i].name];
					} else {
							sectors[sector].push(Game.myRooms[i].name);
					}
			}
			for (let i in sectors){
					if (!Memory.sectors[i] || !Memory.sectors[i].needCoreKilling || Memory.sectors[i].needCoreKilling < Game.time){
							continue
					}
					if (Memory.sectors[i] && Memory.sectors[i].invaderCore){
							let coreRoom = Memory.sectors[i].invaderCore;
							let targetRoom,homeRoom;
							if (Memory.rooms[coreRoom] && Memory.rooms[coreRoom].invaderCoreSuppression
									&& Memory.rooms[coreRoom].invaderCoreSuppression.expiry > Game.time ){
									targetRoom = Memory.rooms[coreRoom].invaderCoreSuppression.targetRoom;
									homeRoom = Memory.rooms[coreRoom].invaderCoreSuppression.homeRoom;
							}
							if (targetRoom && !Game.rooms[targetRoom]){
									sendVisionCreep(targetRoom);
							} else if (targetRoom){
									let core = Game.rooms[targetRoom].findStructures('invaderCore')[0];
									if (core){
											Memory.sectors[i].needCoreKilling = Game.time + 5000;
											Game.rooms[homeRoom].sendCoreKiller(targetRoom);
									}
							} else {
									let exits = Game.map.describeExits(coreRoom);
									for (let j in exits){
											if (Memory.ownedRooms[exits[j]]){
													continue
											}
											if (Game.map.getRoomType(exits[j]) === 'normal'){
													//room next to core is always guaranteed to be the next invaded
													targetRoom = exits[j];
													break
											}
									}
									let closestRange;
									if (targetRoom){
											for (let j in sectors[i]){
													let homeRoomName = sectors[i][j];
													let route = getRoute(targetRoom,homeRoomName);
													if (route && (!homeRoom || closestRange > route.length)){
															homeRoom = homeRoomName;
															closestRange = route.length;
													}
											}
									}
									if (targetRoom && homeRoom){
											Memory.rooms[coreRoom].invaderCoreSuppression = {
													expiry:Game.time+10000,
													targetRoom:targetRoom,
													homeRoom:homeRoom
											};
									}
							}
					}
			}
	}

	function runEmpireManager(){
			Memory.stats.empireCPU = {};
			//assign sources
			let cpuAssign = Game.cpu.getUsed();
			if (Game.time % 500 === 0 && Memory.redLining && Memory.redLining > Game.time - 500){
					//need to force source assignment if we are redlining (low cpu)
					delete Memory.assignedSources;
			}
			if (Memory.myRooms && Game.cpu.bucket > 100 && ((Game.cpu.bucket > 5000 && !config$1.official && Game.time % 50 === 0) || Game.time % 300 === 0 || !Memory.assignedSources)){
					assignSources();
					Memory.assignedSources = true;
			}
			Memory.stats.empireCPU['assign'] = Game.cpu.getUsed()-cpuAssign;

			let cpuRestructure = Game.cpu.getUsed();
			runRestructurer();
			Memory.stats.empireCPU['restructure'] = Game.cpu.getUsed()-cpuRestructure;

			let cpuDesignerGenerators = Game.cpu.getUsed();
			pushDesignerGenerators();
			pushWallGenerators();
			Memory.stats.empireCPU['designerGenerators'] = Game.cpu.getUsed()-cpuDesignerGenerators;

			let cpuExtensionGenerators = Game.cpu.getUsed();
			pushExtensionGenerators();
			pushRemotesGenerator();
			Memory.stats.empireCPU['extensionGenerators'] = Game.cpu.getUsed()-cpuExtensionGenerators;

			let cpuDisplay = Game.cpu.getUsed();
			runDisplay();
			Memory.stats.empireCPU['display'] = Game.cpu.getUsed()-cpuDisplay;

			//territory
			let cpuTerritory = Game.cpu.getUsed();
			scanTerritory();
			contested();
			forceReserve();
			runBotIntelManager();
			runCoreTargeter();
			Memory.stats.empireCPU['territory'] = Game.cpu.getUsed()-cpuTerritory;
			if (Memory.myRooms && (Memory.myRooms.length < 10 || !config$1.official)){

					runEnergyDistributionManager();
			}
			let cpuCom = Game.cpu.getUsed();
			prioritise();
			Memory.stats.empireCPU['commodity'] = Game.cpu.getUsed()-cpuCom;
			//invader cores
			for (let i in Memory.sectors){
					let sector = Memory.sectors[i];
					let core = sector.invaderCore;
					if (core && Game.rooms[core]){
							let room = Game.rooms[core];
							if (room){
									let containers = room.find(FIND_STRUCTURES, {
											filter: (s) => s.structureType == STRUCTURE_CONTAINER
													&& s.store.getUsedCapacity() > 0 && s.effects && s.effects.length > 0
									});
									if (!containers || containers.length === 0){
											let ruins = room.find(FIND_RUINS,{filter:(s) => s.store.getUsedCapacity() > 0});
											if (!ruins || ruins.length === 0){
													sector.invaderCore = false;
											}
									}
							}
					}
			}
			let interShardCpu = Game.cpu.getUsed();
			if (config$1.official && InterShardMemory){
					if (!Memory.squads){
					  Memory.squads = {};
					}
					let interMem = JSON.parse(InterShardMemory.getLocal());
					if (interMem && !interMem.squads){
							interMem.squads = {};
					}
					try {
							if (interMem){
									for (let i in interMem.squads){
											let shardS = interMem.squads[i];
											if (shardS){
													for (let j in shardS){
															let s = shardS[j];
															if (s && (s.expiry <= Game.time || !s.homeShard)){
																	delete interMem.squads[i][j];
															}
													}
											}
									}
									InterShardMemory.setLocal(JSON.stringify(interMem));
									if (config$1.activeShards){
											for (let i in config$1.activeShards){
													let shardName = config$1.activeShards[i];
													let mem = InterShardMemory.getRemote(shardName);
													let parsedMem;
													if (mem){
															parsedMem = JSON.parse(mem);
													}
													if (parsedMem && parsedMem.squads){
															for (let s in parsedMem.squads){
																	let data = parsedMem.squads[s];
																	for (let i in data){
																			if (!Memory.squads[i] && data[i] && data[i].homeShard && data[i].homeShard !== Game.shard.name){
																					Memory.squads[i] = data[i];
																					Memory.squads[i].shardExpiryTime = Game.time +3000;
																			}
																	}
															}
													}
											}
									}
							} else {
									InterShardMemory.setLocal(JSON.stringify({active:true}));
							}
					} catch (err){
							console.log('intermem error',err);
					}

					for (let i in Memory.squads){
							if (Memory.squads[i] && (!Memory.squads[i].homeShard || (Memory.squads[i].shardExpiryTime && Game.time >  Memory.squads[i].shardExpiryTime))){
									delete Memory.squads[i];
							}
					}
			}
			Memory.stats.empireCPU['interShard'] = Game.cpu.getUsed()-interShardCpu;
			if (config$1 && config$1.exitBlocks){
					let exitBlocks = config$1.exitBlocks;
					for (let i in exitBlocks){
							let targetRoom = Game.rooms[i];
							let homeRoom = Game.rooms[exitBlocks[i].homeRoom];
							if (targetRoom && homeRoom && (config$1.private || (exitBlocks[i].shard && exitBlocks[i].shard === Game.shard.name))){
									requestBlockers(homeRoom,targetRoom,exitBlocks[i].sides,exitBlocks[i].healer);
							}
					}
			}
			if (ready() && Game.time % 30 === 0 && config$1.canShare){
					let publicData = access('public');
					console.log('public requests');
					for (let i in publicData){
							console.log('    ',JSON.stringify(publicData[i]));
					}
			}
			let operationCpu = Game.cpu.getUsed();
			if (config$1 && config$1.operations){
					for (let i in config$1.operations){
							let data = config$1.operations[i];
							let targetRoom = i.split('-')[0];
							//todo allow requests from multiple rooms on the same shard
							if (data && data.type && ((data.shard && data.shard === Game.shard.name) || !config$1.official) && (!data.startTime || Game.time > data.startTime) && (!data.endTime || Game.time < data.endTime)){
									if (data.homeRoom && data.options){
											if (!Game.rooms[data.homeRoom]){
													console.log(`operation has no home room`,JSON.stringify(data));
													continue
											}
											if (!data.options.type){
													data.options.type = data.type;
											}
											Game.rooms[data.homeRoom].display(`planned operation ${JSON.stringify(data.options)}`);
											if (data.options.type && data.options.type === 'response'){
													if (!Game.rooms[targetRoom]){
															sendVisionCreep(targetRoom);
															continue
													}
													if (Game.map.isCoreRoom(targetRoom)){
															continue
													}
													//send a D squad if enemy creeps
													let room = Game.rooms[targetRoom];
													if (room.controller && room.controller.my && room.controller.safeMode && room.controller.safeMode > 300){
															continue
													}
													let list = room.hostileList;
													if (!data.sensitive){
															list = room.armedHostileList;
													}
													if (list){
															let nonScout = false;
															for (let i in list){
																	let hos = list[i];
																	for (let i in hos.body){
																			if (hos.body[i].type !== 'move' && hos.owner && hos.owner.username !== 'Source Keeper'){
																					nonScout = true;
																					break
																			}
																	}
															}
															if (!nonScout){
																	//console.log('no hostiles for response squad',targetRoom)
																	continue
															}
															//there are enemies so we organise a defence squad
															data.options.type = 'D';
													} else {
															//console.log('no hostiles for response squad',targetRoom)
															continue
													}
											}
											if (!data.options.type !== 'Ca' || !Memory.combatLog[targetRoom] || !Memory.combatLog[targetRoom].safeMode || Game.time > Memory.combatLog[targetRoom].safeMode){
													let ret = requestSquad(Game.rooms[data.homeRoom],targetRoom,data.options);
													console.log(`planned operation squad request ${ret}`);
													Game.rooms[data.homeRoom].display(`planned operation squad request ${ret}`);
											}
									} else {
											console.log(`planned operation squad request`);
											requestSquadsViaCombatManager(targetRoom,data.type,data.options);
									}
							}
					}
			}
			Memory.stats.empireCPU['operations'] = Game.cpu.getUsed()-operationCpu;
			let seasonCPU = Game.cpu.getUsed();
			try {
					if (config$1.symbolCollection){
							runSymbolManager();
					}
					if (config$1.season && config$1.season === 'caravan'){
							runCaravanManager();
					}
					if (config$1.season && config$1.season === 'thorium'){
							runThoriumManager();
					}
			} catch (err){
					console.log('score target ' + err.stack.split("at"));
			}
			Memory.stats.empireCPU['season'] = Game.cpu.getUsed()-seasonCPU;
			let globalTradeCpu = Game.cpu.getUsed();
			try {
					runGlobalTrade();
			} catch (err){
					console.log('global trade err'+ err.stack.split("at"));
			}
			Memory.stats.empireCPU['globalTrade'] = Game.cpu.getUsed()-globalTradeCpu;
			let NPCPriceCpu = Game.cpu.getUsed();
			try {
					trackNPCPrices();
			} catch (err){
					console.log('global trade err'+ err.stack.split("at"));
			}
			Memory.stats.empireCPU['NPCPrice'] = Game.cpu.getUsed()-NPCPriceCpu;
			let expansionCpu = Game.cpu.getUsed();
			runExpansionManager();
			Memory.stats.empireCPU['expansion'] = Game.cpu.getUsed()-expansionCpu;
			let deathCpu = Game.cpu.getUsed();
			runDeathDetection();
			Memory.stats.empireCPU['death'] = Game.cpu.getUsed()-deathCpu;
			//must be after deleting creeps otherwise they don't spawn with mem
			let depositCpu = Game.cpu.getUsed();
			if (config$1.depositBlocking || Game.time % 12 === 0){
					runDepositManager();
			}
			Memory.stats.empireCPU['deposit'] = Game.cpu.getUsed()-depositCpu;
	}

	//not currently in use
	function runScoreManager(room){
		//put the flag on the collector
		let flagBase = 'scoreTarget-' + room.name + '-';
		let activeFlags = [];
		for (let i = 0; i < 5; i++){
			if (Game.flags[flagBase + i]){
				activeFlags.push(Game.flags[flagBase + i]);
			}
		}
		if (activeFlags.length > 0){
			if (!room.memory.scoreTargets){
				room.memory.scoreTargets = {};
			}
			for (let i in activeFlags){
				let targetFlag = activeFlags[i];
				if (targetFlag && targetFlag.pos){
					if (!room.memory.scoreTargets[targetFlag.pos.toString()]){
						room.memory.scoreTargets[targetFlag.pos.toString()] = {
							miners: 1,
							droppers: 0
						};
					}
					if (!room.memory.scoreTargets[targetFlag.pos.toString()].route && targetFlag.room){
						room.memory.scoreTargets[targetFlag.pos.toString()].route = findRoute(targetFlag.pos);
					}
					if (room.memory.scoreTargets[targetFlag.pos.toString()].route){
						let end = room.memory.scoreTargets[targetFlag.pos.toString()].route[room.memory.scoreTargets[targetFlag.pos.toString()].route.length - 1];
						let range = end.toPos().getRangeTo(targetFlag.pos);
						if (range === 5){
							room.memory.scoreTargets[targetFlag.pos.toString()].miners = 3;
						} else if (range > 0){
							room.memory.scoreTargets[targetFlag.pos.toString()].miners = 1;
						} else if (range === 0){
							room.memory.scoreTargets[targetFlag.pos.toString()].miners = 0;
							room.memory.scoreTargets[targetFlag.pos.toString()].depositReady = true;
						}
					}
				}
			}
		} else {
			delete room.memory.scoreTargets;
		}
	}

	function findRoute(targetPos){
		console.log('finding route for score collector', targetPos);
		if (!targetPos || !targetPos.roomName || !Game.rooms[targetPos.roomName]){
			return
		}
		let visited = {};
		let visitList = [];
		let neighbours = targetPos.neighbours(1);
		for (let i in neighbours){
			visitList.push(neighbours[i]);
			visited[id(neighbours[i])] = {hits: getWallHits(neighbours[i]), route: [targetPos.toString()]};
		}
		let foundRoute = false;
		visitList.sort((a, b) => visited[id(a)].hits - visited[id(b)].hits);
		while (visitList.length > 0 && !foundRoute){
			let current = visitList.shift();
			let neighbours = current.neighbours(1);
			let currentHits = visited[id(current)].hits;
			for (let i in neighbours){
				if (id(neighbours[i]) == id(targetPos)){
					continue
				}
				let neighbour = neighbours[i];
				let neighbourHits = getWallHits(neighbour, targetPos);
				if (neighbourHits === 0){
					//found the route
					visited[id(current)].route.push(current.toString());
					foundRoute = visited[id(current)].route;
					for (let i in foundRoute){
						if (typeof foundRoute[i] == 'string' && foundRoute[i].toPos()){
							foundRoute[i].toPos().highlight('green');
						}
					}
					return foundRoute
				}
				let newHits = neighbourHits + currentHits;
				if (!visited[id(neighbour)] || visited[id(neighbour)].hits > newHits){
					let newRoute = visited[id(current)].route;
					let copy = Array.from(newRoute);
					copy.push(current.toString());
					visited[id(neighbour)] = {hits: newHits, route: copy};
					let index = visitList.indexOf(neighbour);
					if (index && index > 0){
						visitList.splice(index, 1);
					}
					let newIndex = visitList.findIndex((item) => visited[id(item)].hits > newHits);
					if (newIndex === -1){
						visitList.push(neighbour);
					} else {
						visitList.splice(newIndex, 0, neighbour);
					}
				}
			}
		}

		function getWallHits(targetPos, start){
			let wall = targetPos.lookAround(LOOK_STRUCTURES, 0, {filter: (s) => s.structureType == STRUCTURE_WALL});
			let range = targetPos.getRangeTo(start);
			if (wall && wall[0]){
				let hits = wall[0].hits;
				if (range && range === 5){
					hits = hits / 3;
				}
				return Math.ceil(hits / 1000000)
			} else {
				return 0
			}
		}

		function id(pos){
			return pos.x + ',' + pos.y
		}
	}

	function ambush(homeRoom){
					if (!Memory.convoys){
							Memory.convoys = {};
					}
					if (homeRoom.controller.level < 7){
							return
					}
					let ambushers = 0;
					for (let i in Memory.convoys){
							if (i == undefined){
									continue
							}
							//deleting old convoys off the list so we don't ambush non existent convoys
							if (Memory.convoys[i][0] < Game.time - 1500){
									delete Memory.convoys[i];
									delete homeRoom.memory.ambush;
									continue
							}
							//find ambush rooms in range to the room to request ambushers to
							let range = Game.map.getRoomLinearDistance(i, homeRoom.name);
							let allowedRange = 5;
							if (range && range <= allowedRange){
									let mem = homeRoom.memory.ambush;
									if (mem && !mem.notify){
											//Game.notify(`ambush in ${i} at ${Game.time}`)
											mem.notify = true;
									}

									if (mem){
											if (mem.room != i && mem.time > Game.time + 1500){
													//overwrite old ambush room that has expired
													mem.room = i;
													mem.time = Game.time;
													delete mem.notify;
													delete mem.success;
											}
									} else {
											homeRoom.memory.ambush = {
													room: i,
													time: Game.time
											};
									}
									ambushers = 10;
							}
					}
					homeRoom.memory.ambushers = ambushers;
					if (homeRoom.memory.ambush && homeRoom.memory.ambush.time < Game.time + 1500){
							let mem = homeRoom.memory.ambush;
							if (mem.room && Game.rooms[mem.room]){
									let room = Game.rooms[mem.room];
									if (room.memory.hostile){
											let hos = room.find(FIND_HOSTILE_CREEPS, {filter: (c) => c.getType() == 'tougher'})[0];
											mem.hostile = hos;
									} else {
											delete mem.hostile;
									}
									if (Game.time % 10 == 0 && !mem.success){
											let tomb = room.find(FIND_TOMBSTONES, {filter: (s) => !s.creep.my && s.store['XGH2O']});
											if (tomb && !mem.success){
													homeRoom.memory.ambushCollection = room.name;
													Game.notify(`ambush in ${room.name} is a success`);
													mem.success = true;
											}
									}
							}
					} else if (homeRoom.memory.ambush){
							delete homeRoom.memory.ambush;
					}
			}

	let RECIPES;
	playerHeap.labs = {};
	playerHeap.labs.lastReacted = {};
	function chooseReaction(room){
			if (!RECIPES){
					RECIPES = {};
					for (let c1 in REACTIONS){
							for (let c2 in REACTIONS[c1]){
									let r = REACTIONS[c1][c2];
									if (!RECIPES[r]){
											RECIPES[r] = {R1: c1, R2: c2};
									}
							}
					}
			}
			if (room.controller && room.controller.level < 6){
					delete room.memory.product;
					delete room.memory.productQuota;
					return
			}
			if (room.memory.defcon < 5 || room.memory.faceClaimed){
					return
			}
			var terminal = room.terminal;
			if (terminal){
					var stores = room.storage;
					//deciding active reaction
					if (stores){
							var boosts = ['XLHO2','XUH2O', 'XZHO2', 'XZH2O', 'XGHO2', 'XKHO2'];
							var boostList0 = boosts.sort((a, b) => Math.floor(room.total(a)/1500) - Math.floor(room.total(b)/1500));
							var boostList = boostList0.concat(['XGH2O', 'XLH2O']);
							if (config$1.depositMine && config$1.official){
									boostList.concat('UO');
							}
							var finalList = boostList.concat(['LO','OH','LHO2', 'LH', 'UH', 'KO', 'ZO', 'ZH', 'G', 'UH2O', 'ZHO2', 'ZH2O', 'KHO2', 'GO', 'GHO2']);
							if (_.sum(terminal.store) < terminal.store.getCapacity() * 0.85 || _.sum(stores.store) < stores.store.getCapacity() * 0.85){
									//need to delete room.memory.product which will happen in labs module if no more reactant or here if we runPCs hit our target
									if (!room.memory.product){
											for (let i = 0; i < finalList.length; i++){
													let check = checkReactants(finalList[i], 500);
													if (config$1.season && config$1.season === 'caravan' &&
															((config$1.warboosts[finalList[i]] && Game.getResourceTotal(finalList[i]) > config$1.warboosts[finalList[i]]*4) || Game.getResourceTotal(finalList[i])> 30000)){
															continue
													}
													if (room.memory.blockedProducts && room.memory.blockedProducts[check]){
															if (room.memory.blockedProducts[check] > Game.time){
																	continue
															} else {
																	delete room.memory.blockedProducts[check];
															}
													}
													if (check != null){
															if (finalList[i] == 'XGH2O' && !config$1.official && Memory.energyNeeded && Memory.energyNeeded.length > 0){
																	//stop making upgrade boost as generally not worth doing, makes more sense to take the credits and buy energy
																	continue
															}
															room.memory.product = check;
															room.memory.r1 = RECIPES[room.memory.product]['R1'];
															room.memory.r2 = RECIPES[room.memory.product]['R2'];
															room.memory.productQuota = 500;
															if (!room.memory.blockedProducts){
																	room.memory.blockedProducts = {};
															}
															room.memory.blockedProducts[room.memory.product] = Game.time + 300;
															console.log('Setting new quota for ' + room.memory.product + ' in room ' + room.name);
															break
													}
											}
									} else if (room.memory.productQuota !== undefined){
											if (room.memory.productQuota <= 0){
													delete room.memory.product;
													delete room.memory.productQuota;
											}
									} else {
											delete room.memory.product;
									}
							}
							//pass in a desired product, this will return the needed reaction product to get this through iteration
							//returns null if no reaction needed or no reactions to progress available
							function checkReactants(product, amount){
									if (!RECIPES[product]){
											return null
									}
									let level = config$1.warboosts[product] * 1.5;
									if (!level){
											level = 15000;
											if (product === 'G' || product === 'ZK' || product === 'UL' || product === 'XGH2O'){
													level = 3000;
											}
									}
									if (Memory.boostProductionNeeded && Memory.boostProductionNeeded[product]){
											level = level * 2;
									}
									if ((product && room.total(product) > level) || stores.store.getUsedCapacity() > stores.store.getCapacity() * 0.9){
											return null
									}
									let R1 = RECIPES[product]['R1'];
									let R2 = RECIPES[product]['R2'];
									let R1Amount = room.total(R1);
									let R2Amount = room.total(R2);
									let R1AmountNeeded = amount;
									let R2AmountNeeded = amount;
									if (config$1.warboosts[R1]){
											R1AmountNeeded = config$1.warboosts[R1];
									}
									if (config$1.warboosts[R2]){
											R2AmountNeeded = config$1.warboosts[R2];
									}
									if (R1 && R2 && product){
											if (R1Amount >= R1AmountNeeded && R2Amount >= R2AmountNeeded){
													return product
											} else if (R1Amount < R1AmountNeeded){
													let R1check = checkReactants(R1, amount);
													if (R1check != null){
															return R1check
													} else {
															return checkReactants(R2, amount)
													}
											} else if (R2Amount < R2AmountNeeded){
													let R2check = checkReactants(R2, amount);
													if (R2check != null){
															return R2check
													} else {
															return checkReactants(R1, amount)
													}
											}
									} else {
											return null
									}
							}
					}
			} else if (Game.time % 50 === 0){
					for (let i in RESOURCES_ALL){
							removeResourceRequest(room, RESOURCES_ALL[i]);
					}
			}
	}
	function react(room){
			var product = room.memory.product;
			var r1 = room.memory.r1;
			var r2 = room.memory.r2;
			var plabs = room.memory.plabs;
			var plist = [];
			var r1lab = Game.getObjectById(room.memory.r1lab);
			var r2lab = Game.getObjectById(room.memory.r2lab);
			Game.getObjectById(room.memory.stores);
			Game.getObjectById(room.memory.terminal);
			if (!playerHeap.labs.lastReacted[room.name]){
					playerHeap.labs.lastReacted[room.name] = Game.time;
			}

			var quota = room.memory.productQuota;
			let cooldown = false;
			if (plabs != null){
					for (let i = 0; i < plabs.length; i++){
							if (plist[i] && plist[i].cooldown && plist[i].cooldown > 0 && (!cooldown || cooldown < plist[i].cooldown)){
									room.memory.labCooldownOver = Game.time + plist[i].cooldown;
									cooldown = plist[i].cooldown;
									continue
							}
							plist.push(Game.getObjectById(plabs[i]));
					}
					if (plist.length > 0 && product && r1lab && r2lab && quota && quota > 0 && (!blabs || blabs.length == 0)){
							for (let i = 0; i < plist.length; i++){
									if (plist[i] && (plist[i].mineralType == product || !plist[i].store[plist[i].mineralType]) && r1lab.mineralType == r1 && r2lab.mineralType == r2){
											if (plist[i].runReaction(r1lab, r2lab) === 0){
													playerHeap.labs.lastReacted[room.name] = Game.time;
													room.memory.labCooldownOver = Game.time + REACTION_TIME[room.memory.product];
													room.memory.productQuota = room.memory.productQuota - 5;
											}
									}
							}
							if (Game.time % 30 === 0 && ((r1lab.store[r1lab.mineralType] < 5 && room.total(r1) < 100) || (r2lab.store[r2lab.mineralType] < 5 && room.total(r2) < 100))){
									console.log('deleting lab product via lab manager',room.name);
									delete room.memory.product;
							}
					}
			}
			if (!cooldown && playerHeap.labs.lastReacted[room.name] < Game.time - 300 && room.memory.labCycle){
					//delete lab cycling if nothing is happening, error catch all
					console.log('remove lab cycle', room.name);
					delete room.memory.labCycle;
					playerHeap.labs.lastReacted[room.name] = Game.time;
			}
			if (!Memory.stats.labDataByRoom){
					Memory.stats.labDataByRoom = {};
			}
			if (!cooldown && Game.time % 30 === 0 &&((quota && quota <= 0) || product == undefined || !product || !quota || room.total(r1) < 100 || room.total(r2) < 100)){
					delete room.memory.product;
					chooseReaction(room);
			}
			if (room.memory.faceClaimed){
					delete room.memory.product;
					delete room.memory.r1;
					delete room.memory.r2;
					delete room.memory.labCycle;
			}
			var blabs = room.memory.blabs;
			var sblabs = room.memory.sblabs;
			let boostlist = config$1.boostLevels[4];
			if (room.memory.boostingRequired){
					boostlist = config$1.boostLevels[room.memory.boostingRequired];
					if (!boostlist){
							console.log('bad boost:', room.memory.boostingRequired);
					}
			}
			if (blabs && boostlist && blabs.length >= boostlist.length){
					room.memory.boostLabs = {};
					if (!Game.time % 100 === 0 || !room.memory.boostLabs || !room.memory.boostLabs.list || room.memory.boostLabs.list !== boostlist){
							assignBoostLabs(blabs,boostlist);
					}
					if (room.memory.boostLabs){
							//determine if siege labManager are full and therefore trigger spawning
							var labsFull = 0;
							for (let min in room.memory.boostLabs){
									if (min === 'list'){
											continue
									}
									let lab = Game.getObjectById(room.memory.boostLabs[min]);
									if (lab && min && lab.mineralType == min && lab.store[lab.mineralType] >= 1500 && lab.store['energy'] > 1000){
											labsFull += 1;
									}
							}
							if (labsFull == boostlist.length){
									room.memory.blabsFull = true;
							} else if (room.memory.blabsFull){
									delete room.memory.blabsFull;
							}
					}
			} else {
					delete room.memory.blabsFull;
					delete room.memory.boostLabs;
			}
			if (sblabs && sblabs.length > 0){
					room.memory.sboostlab = {};
					let LG;
					if ((room.memory.defcon < 5 || Game.flags['fort' + room.name]) && room.total('XLH2O') > 0){
							LG = 'XLH2O';
					} else if ((room.memory.defcon < 5 || Game.flags['fort' + room.name] || Game.gcl.level > 40) && room.memory.walls < config$1.wallTarget && room.total('LH') > 0){
							LG = 'LH';
					} else if (config$1.depositMine && config$1.official && room.total('UO') > 0){
							LG = 'UO';
					} else if (room.total('XGH2O')>3000){
							LG = 'XGH2O';
					}
					if (config$1.official && room.memory.defcon === 5 && room.memory.colNeeded && Game.time - room.memory.colNeeded < 1000
					&& room.total('XGH2O')>1000){
							LG = 'XGH2O';
					}
					let RB = 'KO';
					if (room.total('XKHO2') > 5000){
							RB = 'XKHO2';
					}
					let AB = 'UH';
					if (room.total('XUH2O') > 5000){
							AB = 'XUH2O';
					}
					let sboostlist = [AB, LG, RB];
					if ((!room.memory.defcon || room.memory.defcon == 5) && Game.flags['ShardTrade'] && Game.flags['ShardTrade'].room && Game.flags['ShardTrade'].room.name == room.name){
							sboostlist = ['LO', 'GO', 'ZO'];
					}
					if (room.class === 'bunker'){
							sboostlist = ['UH'];
							if (room.total('XUH2O')> 1000){
									sboostlist = ['XUH2O'];
							}
					}
					for (let i = 0; i < sblabs.length; i++){
							if (!sboostlist || !sboostlist[i] || room.total(sboostlist[i]) === 0){
									continue
							}
							room.memory.sboostlab[sboostlist[i]] = sblabs[i];
							if (sboostlist[i] === 'XLH2O'){
									room.memory.buildBoostLab = sblabs[i];
							}
					}
			}
			function assignBoostLabs(blabs,boostList){
					let unassignedBLabs = [];
					let boostLabs = {
							list:boostList
					};
					for (let j in blabs){
							unassignedBLabs.push(Game.getObjectById(blabs[j]));
					}
					for (let b in boostList){
							for (let i = unassignedBLabs.length-1;i > -1; i--){
									if (i === 0 || (unassignedBLabs[i].mineralType && unassignedBLabs[i].mineralType === boostList[b])){
											boostLabs[boostList[b]] = unassignedBLabs[i].id;
											unassignedBLabs.splice(i,1);
											break
									}
							}
					}
					room.memory.boostLabs = boostLabs;
			}
	}

	playerHeap.defence = {};
	playerHeap.defence.weakPointsAll = {};
	playerHeap.defence.attackIntents = [];

	function runDefenceManager(room){
			room.justInvader = false;
			delete room.memory.weakPointPos;
			if (ready() && !room.plannedRamparts){
					delete room.memory.defenceMatrix;
			}
			playerHeap.defence.attackIntents[room.name] = [];
			let defenceMatrixCache;
			let attacksMade = {};
			if (room.memory.defcon < 4){
					requestSupport(room);
			}
			// if (false && Game.shard.name == 'shard1' && room.memory.defenceMatrix){
			// 		let matrix = PathFinder.CostMatrix.deserialize(JSON.parse(room.memory.defenceMatrix.matrix))
			// 		for (let x = 0; x < 50; x++){
			// 				for (let y = 0; y < 50; y++){
			// 						let cost = matrix.get(x, y)
			// 						if (cost !== 1){
			// 								matrix.set(x, y, 0xff)
			// 						}
			// 				}
			// 		}
			// }
			let ready$1 = ready();
			let sections;
			if (!room.memory.hostiles && room.memory.defcon === 5 && room.memory.defenceMatrix && room.memory.sectionExits && room.memory.defenceMatrix.expiry >=  Game.time && (!room.memory.lastAttacked || room.memory.lastAttacked < Game.time - 100000)){
					delete room.memory.dangerSpots;
					delete room.memory.guardNum;
					return
			}
			if (ready$1){
					if (!access(room.name)){
							console.log(`${room} has no segment`);
							return
					} else if (!access(room.name).structures){
							delete room.memory.build;
							//console.log(`${room} has no segment structures`)
					}
					let structureCache = access(room.name).structures;
					if (structureCache){
							sections = structureCache['sections'];
					}
					if (room.memory.bunker && room.memory.bunkerRampartPositions){
							let arr = [];
							for (let i in room.memory.bunkerRampartPositions){
									arr.push(room.memory.bunkerRampartPositions[i].toPos());
							}
							sections = [{
									members:arr,
									roadIntersections: [room.memory.bunkerExit.toPos()]
							}];
					}
			}
			if (ready$1 && Game.cpu.bucket > 500 && (!room.memory.defenceMatrix || !room.memory.sectionExits || room.memory.defenceMatrix.expiry < Game.time)){

					if (room.memory.spawn && Game.spawns[room.memory.spawn] && room.plannedRamparts && sections){
							console.log(room.name, 'planning d matrix');
							room.memory.spawn;
							let exits = room.find(FIND_EXIT);
							let exitStrings = [];
							for (let i in exits){
									exitStrings.push(exits[i].toString());
							}
							let shortExits = [];
							let matrix = new PathFinder.CostMatrix;
							if (room.plannedRamparts && room.class === 'normal'){
									for (let i in room.plannedRamparts){
											let pos = room.plannedRamparts[i].toPos();
											if (pos){
													matrix.set(pos.x, pos.y, 0xFF);
											}
									}
							} else if (room.memory.bunkerRampartPositions){
									for (let i in room.memory.bunkerRampartPositions){
											let pos = room.memory.bunkerRampartPositions[i].toPos();
											if (pos){
													matrix.set(pos.x, pos.y, 0xFF);
											}
									}
							}
							//reduce the amount of exits that need to be processed by combining all exits that can be connected
							for (let i in exits){
									if (exitStrings.includes(exits[i].toString())){
											shortExits.push(exits[i]);
											checkNeighbours(exits[i]);
									}
							}
							let finalExits = [];
							for (let i in shortExits){
									let exit = shortExits[i];
									if (finalExits.length == 0){
											finalExits.push(exit);
									} else {
											let canAdd = true;
											for (let j in finalExits){
													let path = PathFinder.search(exit, finalExits[j], {
															maxRooms: 1, roomCallback: (roomName) => {
																	return matrix
															}
													});
													if (!path.incomplete){
															//can connect the two exits up so don't add this one
															canAdd = false;
															for (let p in path.path){
																	//new RoomVisual(room.name).circle(path.path[p])
															}
													}
											}
											if (canAdd){
													finalExits.push(exit);
											}
									}

							}
							let defenceMatrix = new PathFinder.CostMatrix;
							let visited = {};
							let sectionExits = {};
							if (sections){
									for (let s in sections){
											let section = sections[s];
											if (section){
													let exposedExits = [];
													//make this section walkable in matrix so that we can find all exits exposed to it
													for (let m in section.members){
															if (section.members[m].x){
																	let pos = new RoomPosition(section.members[m].x, section.members[m].y, section.members[m].roomName);
																	matrix.set(pos.x, pos.y, 0);
																	//placing defence matrix by forbidding area near walls
																	let n1 = pos.neighbours(1);
																	let n2 = pos.neighbours(2);
																	let neighbours = n1.concat(n2);
																	for (let n in neighbours){
																			let pos = neighbours[n];
																			visited[pos.toString()] = 1;
																	}
															}
													}
													let intersection = section.roadIntersections[0];
													if (intersection){
															for (let e in finalExits){
																	let exit = finalExits[e];
																	let path = PathFinder.search(exit, intersection, {
																			maxRooms: 1, roomCallback: (roomName) => {
																					return matrix
																			}
																	});
																	if (!path.incomplete){
																			//can connect the two exits up so push to exposed exits
																			exposedExits.push(exit.toString());
																			for (let p in path.path){
																					new RoomVisual(room.name).circle(path.path[p]);
																			}
																	}
															}
													}
													//make this section nonwalkable in matrix again
													for (let m in section.members){
															matrix.set(section.members[m].x, section.members[m].y, 0xFF);
													}
													for (let ex in exposedExits){
															let exit = exposedExits[ex];
															if (!sectionExits[exit]){
																	sectionExits[exit] = [];
															}
															if (!sectionExits[exit].includes(s)){
																	sectionExits[exit].push(s);
															}
													}
											}
									}
							}
							room.memory.sectionExits = sectionExits;

							function checkNeighbours(pos){
									let neighbours = pos.neighbours(1);
									if (exitStrings.includes(pos.toString())){
											let index = exitStrings.findIndex((p) => p === pos.toString());
											exitStrings.splice(index, 1);
									}
									for (let i in neighbours){
											if (exitStrings.includes(neighbours[i].toString())){
													let index = exitStrings.findIndex((p) => p === neighbours[i].toString());
													exitStrings.splice(index, 1);
													checkNeighbours(neighbours[i]);
											}
									}
							}

							//generate a cost matrix
							let structures = room.find(FIND_STRUCTURES);
							structures.forEach((s) => {
									if (s.structureType !== STRUCTURE_ROAD && s.structureType != STRUCTURE_CONTAINER && (s.structureType != STRUCTURE_RAMPART || !s.my)){
											visited[s.pos.toString()] = 2;
											defenceMatrix.set(s.pos.x, s.pos.y, 255);
									} else if (s.structureType == STRUCTURE_RAMPART && visited[s.pos.toString()] != 2){
											defenceMatrix.set(s.pos.x, s.pos.y, 5);
									}
							});
							if (room.storage){
									if (room.class === 'normal'){
											fill(room.storage.pos);
									}
									if (ready() && access(room.name) && access(room.name).roadPositions){
											let positions = getRoadPositions(room.name,room.name);
											for (let i in positions){
													let positionObj = positions[i];
													let cost = defenceMatrix.get(positionObj.x, positionObj.y);
													if (cost === 5){
															defenceMatrix.set(positionObj.x, positionObj.y, 1);
													}
											}
									}
									defenceMatrix = blockKeyPositions(defenceMatrix,room);
									for (let x = 0; x < 50; x++){
											for (let y = 0; y < 50; y++){
													let cost = defenceMatrix.get(x, y);
													if (cost > 0 && cost <= 5){
															new RoomVisual(room.name).circle(x, y, {radius: 0.6, fill: 'green'});
													} else {
															new RoomVisual(room.name).circle(x, y, {radius: 0.6, fill: 'red'});
															defenceMatrix.set(x,y,0xff);
													}
											}
									}
							}

							function fill(pos){
									if (visited[pos.toString()] === 1 || pos.getTerrain() == 'wall'){
											return
									}
									if (!visited[pos.toString()] || visited[pos.toString()] !== 2){
											defenceMatrix.set(pos.x, pos.y, 5);
									}
									visited[pos.toString()] = 1;
									let neighbours = pos.neighbours(1);
									for (let n in neighbours){
											fill(neighbours[n]);
									}
							}

							room.memory.defenceMatrix = {
									expiry: Game.time + 1000
							};
							save(room.name,'defenceMatrix',defenceMatrix.serialize());
					}
			}
			//find ramparts to defend

			//spawn a minimum of 1 attack guard if no weakpoints - the purpose of these guards is to give time to spawn a boosted squad
			//if not enough boosts for an attack squad -> spawn ranged (only if range boost available) and attack guards and station on every section that is exposed to the enemy
			let guardNum = 0;
			if (!playerHeap.defence.weakPointsAll[room.name]){
					playerHeap.defence.weakPointsAll[room.name] = [];
			}
			let weakPoints = playerHeap.defence.weakPointsAll[room.name];
			let exposedSections = [];
			let sectionExits = room.memory.sectionExits;
			let matrix;
			let needBoost = false;
			let users = [];
			if (room.memory.hostiles){
					let hostiles = room.armedHostileList;
					let justInvader = true;
					let checkForRangedGuards = false;
					if (Game.time % 25 === 0){
							checkForRangedGuards = true;
					}
					let nonRangedPower = 0;
					for (let i in hostiles){
							let hostile = hostiles[i];
							if (!needBoost && hostile.isBoosted()){
									needBoost = true;
									if (users && !users.includes(hostile.owner.username) && hostile.owner.username != 'Invader'){
											users.push(hostile.owner.username);
									}
							}
							if (hostile.pos.onEdge()){
									continue
							}
							if (hostile && (hostile.owner.username != 'Invader' || config$1.private) && hostile.body.length > 1){
									justInvader = false;
									weakPoints = [];
									if (checkForRangedGuards){
											if (hostile.stats()){
													if (hostile.stats().attack){
															nonRangedPower += hostile.stats().attack;
													}
													if (hostile.stats().work){
															nonRangedPower += hostile.stats().work;
													}
											}
									}
							} else {
									continue
							}
							if (!sectionExits){
									break
							}
							for (let e in sectionExits){
									let exit = e.toPos();
									let path = PathFinder.search(hostile.pos, exit, {
											maxRooms: 1, roomCallback: (roomName) => {
													return matrix
											}
									});
									if (!path.incomplete){
											//hostile can path to this exit so these sections are at risk
											for (let s in sectionExits[e]){
													if (!exposedSections.includes(sectionExits[e][s])){
															exposedSections.push(sectionExits[e][s]);
													}
											}
									}
							}
					}
					if (justInvader && false){
							return
					}
					if (justInvader){
							room.justInvader = true;
					}
					if (checkForRangedGuards && nonRangedPower < 1000 && (room.canBoost('KO') || room.canBoost('XKHO2'))){
							//likely no duos/close to wall attackers and need to field ranged guards instead
							room.memory.useRangedGuards = true;
					} else if (checkForRangedGuards){
							delete room.memory.useRangedGuards;
					}
					matrix = new PathFinder.CostMatrix;
					if (room.plannedRamparts){
							for (let i in room.plannedRamparts){
									let pos = room.plannedRamparts[i].toPos();
									if (pos){
											matrix.set(pos.x, pos.y, 0xFF);
									}
							}
					}
					if (!sections){
							return
					}
					let wallTotal = 0;
					let wallCount = 0;
					if (room.class === 'bunker'){
							if (room.memory.bunkerRampartPositions){
									for (let p in room.memory.bunkerRampartPositions){
											let pos = room.memory.bunkerRampartPositions[p].toPos();
											let rampart = pos.lookAround(LOOK_STRUCTURES, 0, {filter: (s) => s.structureType == STRUCTURE_RAMPART && s.my})[0];
											if (rampart){
													wallTotal += rampart.hits;
													wallCount++;
											} else if (room.controller && room.controller.level > 6){
													pos.createConstructionSite(STRUCTURE_RAMPART);
											}
									}
							}
					} else {
							for (let i in exposedSections){
									if (justInvader){
											break
									}
									let sectionNumber = exposedSections[i];
									let section = sections[sectionNumber];
									if (section){
											for (let p in section.members){
													let prePos = section.members[p];
													let pos = new RoomPosition(prePos.x, prePos.y, prePos.roomName);
													let rampart = pos.lookAround(LOOK_STRUCTURES, 0, {filter: (s) => s.structureType == STRUCTURE_RAMPART})[0];
													if (rampart){
															wallTotal += rampart.hits;
															wallCount++;
													} else if (room.controller && (room.controller.level > 6 || room.memory.activateRamparts)){
															pos.createConstructionSite(STRUCTURE_RAMPART);
													}

											}
									}
							}
					}

					for (let i in exposedSections){
							if (justInvader){
									break
							}
							let sectionNumber = exposedSections[i];
							let section = sections[sectionNumber];
							let wallAv = room.memory.walls;
							let increment = 50000;
							if (wallAv){
									increment = wallAv/100;
							}
							if (wallTotal){
									wallAv = wallTotal / wallCount;
									increment = wallAv/100;
							}
							if (section){
									for (let p in section.members){
											let prePos = section.members[p];
											let pos = new RoomPosition(prePos.x, prePos.y, prePos.roomName);
											let rampart = pos.lookAround(LOOK_STRUCTURES, 0, {filter: (s) => s.structureType == STRUCTURE_RAMPART && s.my})[0];
											if (!rampart){
													continue
											}
											let closestHostile = 50;
											for (let h in hostiles){
													let range = hostiles[h].pos.getRangeTo(rampart);
													if (range < closestHostile){
															closestHostile = range;
													}
											}
											if (rampart.hits < wallAv * 0.9 || rampart.hits < wallAv - 1000000 || closestHostile <= 10 || room.class === 'bunker'){
													if (rampart.hits < room.memory.walls * 0.5){
															pos.highlight('red');
													} else if (rampart.hits < room.memory.walls * 0.8){
															pos.highlight('orange');
													} else {
															pos.highlight('yellow');
													}
													let score = rampart.hits;
													let nearGuards = rampart.pos.lookAround(LOOK_CREEPS, 1, {filter: (c) => c.my && c.role == 'guard' && !c.pos.isEqualTo(rampart.pos)});
													if (nearGuards && nearGuards.length > 0){
															score += (increment/2);
													}
													if (closestHostile <= 5){
															let nearHostiles = rampart.pos.lookAround(LOOK_CREEPS,4,{filter:(c)=>!c.my && !c.isWhiteListed});
															if (nearHostiles.length > 0){
																	for (let i in nearHostiles){
																			score -= (increment*8)/rampart.pos.getRangeTo(nearHostiles[i]);
																	}
															} else {
																	score -= (increment*2);
															}
													} else {
															score -= increment;
													}
													weakPoints.push([pos.toString(), score]);
											}
									}
							}
					}
					if (!justInvader){
							if (room.memory.defcon < 5){
									if (room.controller.level > 4){
											room.memory.activateRamparts = true;
									}
									console.log(`defence alert|${Game.shard.name}|Users:${JSON.stringify(users)} ... ${room.name} ... ${Game.time.toString().slice(0,(Game.time.toString().length-3))}`);
							}
							console.log('hostile attacking',room.hyperlink);
							if (needBoost || !room.storage || !room.terminal ||
									room.energyCapacityAvailable < (EXTENSION_ENERGY_CAPACITY[room.controller.level] * CONTROLLER_STRUCTURES['extension'][room.controller.level] * 0.8)){
									try {
											let nonAlly = false;
											for (let i in users){
													let user = users[i];
													if (user && ((!config$1.whiteList || !config$1.whiteList.includes(user)) && (!config$1.allies || !config$1.allies.includes(user)))){
															nonAlly = true;
															break
													}
											}
											if (nonAlly){
													requestSupport(room, needBoost);
											}
									} catch (err){
											console.log('def man support error');
									}
							}
							if (needBoost && room.controller.level >= 6){
									requestSquad(room, room.name, {type: 'G', boosted: 4});
							} else {
									requestSquad(room, room.name, {type: 'G'});
							}
					}
			} else if (room.memory.defcon == 5){
					delete room.memory.guardNum;
					return
			}
			if (weakPoints && weakPoints.length > 0){
					guardNum = weakPoints.length + 1;
			} else if (exposedSections && exposedSections.length > 0){
					guardNum = 1;
					if (room.hostileList){
							guardNum = Math.ceil(room.hostileList.length / 3);
					}
			}
			if (room.level < 7 && guardNum > 5){
					guardNum = 5;
			}
			let dangerousHostiles = 0;
			for (let i in room.armedHostileList){
					if (room.armedHostileList[i].stats().attack > 200 || room.armedHostileList[i].stats().ranged_attack > 100 ||
							room.armedHostileList[i].stats().work > 300){
							dangerousHostiles++;
					} else if (room.armedHostileList[i].stats().attack > 0 || room.armedHostileList[i].stats().ranged_attack > 50 ||
							room.armedHostileList[i].stats().work > 0) {
							dangerousHostiles+=0.5;
					}
			}
			dangerousHostiles = Math.round(dangerousHostiles);
			if (guardNum > (dangerousHostiles+1)){
					guardNum = dangerousHostiles+1;
			} else if (room.armedHostileList.length === 0 && guardNum > 3){
					guardNum = 3;
			}
			if (room.memory.walls && room.memory.walls < 50000){
					return false
			}
			if (room.memory.defcon && room.memory.defcon < 5 && guardNum === 0){
					guardNum = 2;
					playerHeap.defence.weakPointsAll[room.name] = weakPoints;
			} else if (!room.memory.hostiles){
					//no defcon && no hstiles so can forget weakpoints
					playerHeap.defence.weakPointsAll[room.name] = {};
					guardNum = 0;
			} else {
					playerHeap.defence.weakPointsAll[room.name] = weakPoints;
			}
			if (!guardNum){
					delete room.memory.guardNum;
			} else {
					room.memory.guardNum = guardNum;
			}
			let guardIds = room.memory.activeGuards;
			let guards = [];
			if (guardIds){
					for (let i in guardIds){
							guards.push(Game.getObjectById(guardIds[i]));
					}
			}
			let weakPointsArr = [];
			let weakPointsOrdered = [];
			if (weakPoints && weakPoints.length > 0){
					weakPointsArr = weakPoints.sort((a, b) => a[1] - b[1]);
					for (let w in weakPointsArr){
							weakPointsOrdered.push(weakPointsArr[w][0]);
					}
			}
			if (weakPointsOrdered.length > 0){
					room.memory.weakPointPos = weakPointsOrdered[0];
			}
			if (!defenceMatrixCache && room.memory.defenceMatrix){
					defenceMatrixCache = room.defenceMatrix;
			}
			//runPCs the guard logic
			if (guards && guards.length > 0){
					//assign weakpoints to a guard id in weakPointObj
					let weakPointObj = {};
					let spareGuards = [];
					if (Game.time % 10 == 0){
							for (let i in guards){
									delete guards[i].memory.weakPoint;
							}
					}
					//assign weakPoints
					for (let i in guards){
							let creep = guards[i];
							if (creep.num === 1 && room.class === 'normal'){
									continue
							}
							if (creep.memory.weakPoint){
									weakPointObj[creep.memory.weakPoint] = creep.id;
							} else {
									spareGuards.push(creep.id);
							}
					}
					for (let i = 0; i < weakPointsOrdered.length; i++){
							let pos = weakPointsOrdered[i].toPos();
							if (weakPointObj[weakPointsOrdered[i]]); else if (spareGuards && spareGuards.length > 0){
									if (spareGuards.length > 1){
											spareGuards = spareGuards.sort((a, b) => Game.getObjectById(b).pos.getRangeTo(pos) - Game.getObjectById(a).pos.getRangeTo(pos));
									}
									let guard = spareGuards.pop();
									weakPointObj[weakPointsOrdered[i]] = guard;
									Game.getObjectById(guard).memory.weakPoint = weakPointsOrdered[i];
							}
					}
					for (let i in guards){
							let creep = guards[i];
							if (creep){
									if (room.class === 'bunker' && creep.memory.renewing){
											continue
									}
									if (!creep.memory.boosted && needBoost){
											let currentBoost;
											for (let i in creep.body){
													let part = creep.body[i];
													if (part.boost){
															continue
													}
													if (part.type == 'attack' && room.memory.sboostlab){
															if (room.memory.sboostlab['XUH2O']){
																	currentBoost = 'XUH2O';
															} else if (room.memory.sboostlab['UH2O']){
																	currentBoost = 'UH2O';
															} else {
																	currentBoost = 'UH';
															}
													}
													if (part.type == 'ranged_attack' && room.memory.sboostlab){
															if (room.memory.sboostlab['XKHO2']){
																	currentBoost = 'XKHO2';
															} else if (room.memory.sboostlab['KHO2']){
																	currentBoost = 'KHO2';
															} else {
																	currentBoost = 'KO';
															}
													}
											}
											if (!currentBoost){
													creep.memory.boosted = true;
											} else if (room.memory.sboostlab && room.memory.sboostlab[currentBoost] && Game.getObjectById(room.memory.sboostlab[currentBoost])
													&& Game.getObjectById(room.memory.sboostlab[currentBoost]).store[currentBoost] > 600 && Game.getObjectById(room.memory.sboostlab[currentBoost]).energy > 1000){
													let sblab = Game.getObjectById(room.memory.sboostlab[currentBoost]);
													if (sblab && sblab.boostCreep(creep) == -9){
															creep.wipePath();
															creep.moveTo(sblab, {
																	range: 1, costCallback: function (roomName, costMatrix){
																			if (room.name === roomName && defenceMatrixCache){
																					return defenceMatrixCache
																			}
																	}
															});
													} else {
															console.log('def', sblab.boostCreep(creep));
													}
													creep.say('boosting');
													continue
											}
									}
									let weakPoint;
									if (creep.memory.weakPoint){
											weakPoint = creep.memory.weakPoint.toPos();
									}
									if (weakPoint){
											new RoomVisual(creep.room.name).line(creep.pos, weakPoint);
									}
									if (room.memory.hostiles){
											let nearHostile = creep.pos.lookAround(LOOK_CREEPS, 1, {filter: (c) => !c.my && !c.isWhiteListed})[0];
											if (creep.stats().attack > 0){
													if (nearHostile){
															creep.attack(nearHostile);
															if (!attacksMade[nearHostile.id]){
																	attacksMade[nearHostile.id] = creep.stats().attack;
															} else {
																	attacksMade[nearHostile.id] += creep.stats().attack;
															}
													}
											} else if (nearHostile){
													if (nearHostile){
															creep.rangedMassAttack();
															if (!attacksMade[nearHostile.id]){
																	attacksMade[nearHostile.id] = creep.stats().ranged_attack;
															} else {
																	attacksMade[nearHostile.id] += creep.stats().ranged_attack;
															}
													}
											} else {
													let farHostiles = creep.pos.lookAround(LOOK_CREEPS, 3, {filter: (c) => !c.my && !c.isWhiteListed});
													farHostiles.sort((a, b) => a.hits - b.hits);
													let target;
													if (attacksMade){
															for (let i in farHostiles){
																	if (attacksMade[farHostiles[i]]){
																			target = farHostiles[i];
																			break
																	}
															}
													}
													if (target){
															creep.rangedAttack(target);
															if (!attacksMade[target.id]){
																	attacksMade[target.id] = creep.stats().ranged_attack;
															} else {
																	attacksMade[target.id] += creep.stats().ranged_attack;
															}
													} else if (farHostiles && farHostiles[0]){
															creep.rangedAttack(farHostiles[0]);
															if (!attacksMade[farHostiles[0]]){
																	attacksMade[farHostiles[0]] = creep.stats().ranged_attack;
															} else {
																	attacksMade[farHostiles[0]] += creep.stats().ranged_attack;
															}
													}
											}
									}
									if (weakPoint){
											if (!creep.pos.isEqualTo(weakPoint)){
													usePath(creep, weakPoint);
											} else {
													delete creep.memory.savedPath;
													creep.wipePath();
											}
									} else if (room.memory.hostiles){
											let hostile = creep.pos.findClosestByRange(FIND_HOSTILE_CREEPS, {filter: (c) => !c.isWhiteListed});
											if (hostile){
													let path = PathFinder.search(creep.pos, {pos: hostile.pos}, {
															roomCallback: (roomName) => {
																	if (roomName !== room.name){
																			return false
																	}
																	if (defenceMatrixCache){
																			return defenceMatrixCache
																	}
															}
													});
													//TODO make this so it lets us put lots them near the wall, not just on the path
													let targetPos = path.path.pop();
													if (targetPos && targetPos.lookAround(LOOK_STRUCTURES, 0, {filter: (s) => s.structureType === STRUCTURE_RAMPART && s.my}).length > 0){
															usePath(creep, targetPos);
													} else {
															console.log('failure to target hostile', hostile, path.incomplete, path.path);
													}
											}
									}
							} else {
									console.log('no guard def man');
							}
					}
			}

			function requestSupport(room, boosted){
					let supportRooms = room.memory.supportRooms;
					let hits = room.memory.adjustedLowWallHits;
					if (room.controller.safeMode && room.controller.safeMode > 1000){
							return
					}
					if (hits && hits > config$1.minWalls[8] && room.hostileList && room.hostileList.length < 6){
							return
					}
					if (supportRooms && supportRooms.rooms){
							let rooms = supportRooms.rooms;
							let sortList = [];
							for (let i in rooms){
									let index = sortList.findIndex((s) => rooms[s] > rooms[i]);
									if (index === -1){
											sortList.push(i);
									} else {
											sortList.splice(index, 0, i);
									}
							}
							console.log(room.name, ':', sortList);
							let numOfSupportSquads = 0;
							if (sortList.length > 4){
									numOfSupportSquads = 4;
							} else if (sortList){
									numOfSupportSquads = sortList.length;
							}
							if (numOfSupportSquads < 3 && config$1.official){
									numOfSupportSquads = 3;
							}
							let maxLevel = 4;
							if (config$1.swc){
									maxLevel = 1;
							}
							let minLevel = 0;
							if (boosted && Game.canBoost(config$1.boostLevels[5])){
									minLevel = 5;
							}
							let manualDefenceSquad = false;
							if (config$1.operations){
									for (let o in config$1.operations){
											if (o === room.name && config$1.operations[o].type === 'D'){
													console.log('blocking auto defence for manual override',room.name);
													manualDefenceSquad = true;
											}
									}
							}
							if (numOfSupportSquads && !manualDefenceSquad){
									requestSquadsViaCombatManager(room.name,'D',{count: numOfSupportSquads,maxLevel:maxLevel,minLevel:minLevel});
							}
					}
			}

			function usePath(creep, weakPoint){
					let pathObj;
					if (weakPoint){
							weakPoint.highlight('gold');
					}
					let matrix = defenceMatrixCache;
					let normalPath;
					if (matrix && matrix.get(creep.pos.x,creep.pos.y) > 10){
							//starting outside walls
							normalPath = true;
					}
					if (normalPath || room.class === 'bunker'){
							creep.moveTo(weakPoint,{range:0});
							return
					}
					if (creep.memory.savedPath && weakPoint && weakPoint.toString() && creep.memory.savedPath.end == weakPoint.toString()){
							pathObj = creep.memory.savedPath;
					} else {
							delete creep.memory.savedPath;
							pathObj = findPath(creep, weakPoint);
					}
					if (pathObj){
							creep.moveUsingSavedPath(pathObj.sPath, pathObj.start.toPos(), weakPoint);
					} else {
							creep.say('hmm', true);
							creep.moveTo(weakPoint);
					}
			}

			function findPath(creep, target){
					if (!target){
							return
					}
					//find path if loadPath return null and creep is near container (as this means the path will no be on the unwalkable mining spot)
					let path = PathFinder.search(creep.pos, {pos: target}, {
							roomCallback: (roomName) => {
									let room = Game.rooms[roomName];
									if (room && room.memory.defenceMatrix){
											if (roomName !== room.name){
													return false
											}
											if (defenceMatrixCache){
													return defenceMatrixCache
											}
									}
							}
					});
					new RoomVisual(creep.room.name).poly(path.path);
					//serialize
					if (path.incomplete);
					let sPath = PathFinder.serializePath(creep.pos, path);
					let pathObj = {
							sPath: sPath,
							start: creep.pos.toString(),
							end: path.path[path.path.length - 1].toString()
					};
					creep.memory.savedPath = pathObj;
					//path obj needs serialized path as well as a start pos and end pos
					return pathObj
					//return pathObj
			}
	}

	function findTargetHostileCreep(room, towers){
			let attacksMade;
			if (playerHeap.defence.attackIntents[room.name]){
					attacksMade = playerHeap.defence.attackIntents[room.name];
			}
			let events = room.getEvents();
			let hostiles = {};
			let hostileArr = [];
			if (room.hostileList){
					for (let i in room.hostileList){
							let hos = room.hostileList[i];
							if (hos.hits < hos.hitsMax || (hos.stats() && !hos.stats().heal)){
									hostileArr.push(hos);
							}
							if (hos){
									hostiles[hos.id] = {
											hostile: hos,
											receivedHeal: 0,
											receivedDamage: 0,
											hasHealed: false
									};
							}
					}
			}
			hostileArr.sort((a, b) => {
					a.hits - b.hits;
			});
			//check if a hostile creeps hits are lower than neighbours,
			//assume this creep will be healed and assign the heals of the neighbours to this creep
			// (don't over adjust, a dead creep is the best outcome)
			for (let i in hostileArr){
					let hostile = hostileArr[i];
					if (room.controller.safeMode == undefined && room.controller.safeModeAvailable && room.controller.safeModeCooldown == undefined){
							if (hostile.stats() && hostile.stats().claim && hostile.pos && hostile.pos.getRangeTo(room.controller.pos) < 3){
									room.controller.activateSafeMode();
							}
					}
					if (!hostile || !hostile.hits || !hostile.stats || !(hostile.stats().attack || hostile.stats().ranged_attack || hostile.stats().work || hostile.stats().claim)){
							continue
					}
					let neighbours = hostile.pos.neighbours(1);
					for (let n in neighbours){
							let neighbour = neighbours[n];
							if (neighbour && neighbour.toString() && hostiles[neighbour.toString()] && hostiles[hostile.pos.toString()] && !hostiles[neighbour.toString()].hasHealed){
									let hos2 = hostiles[neighbour.toString()].hostile;
									if (hos2 && hos2.stats() && hos2.stats().heal && hos2.stats().heal > 0 && (hos2.hits >= hostile.hits)){
											hostiles[neighbour.toString()].hasHealed = true;
											hostiles[hostile.pos.toString()].receivedHeal += hos2.stats().heal;
											//console.log(hos2,'healing',hostile)
									}
							}
					}
					if (room.controller.level < 7){
							let blockSafeMode = false;
							if (config$1.blockSafeMode && config$1.blockSafeMode.includes(room.name)){
									blockSafeMode = true;
							}
							//more likely to have a breach or incomplete walls
							if (!blockSafeMode && hostile.owner.username != 'Invader' && room.controller.safeMode == undefined && room.controller.safeModeAvailable && room.controller.safeModeCooldown == undefined){
									let nearStructs = hostile.pos.lookAround(LOOK_STRUCTURES, 1, {filter: (s) => s.my && s.structureType != STRUCTURE_RAMPART && s.structureType != STRUCTURE_EXTRACTOR});
									if (nearStructs && nearStructs.length > 0){
											room.controller.activateSafeMode();
									}
							}
					}

			}
			for (let e in events){
					let event = events[e];
					//check where hostile creeps have healed, and if they can still heal and how much by and then assume they will perform that heal
					if (event.event == EVENT_HEAL){
							let creep = Game.getObjectById(event.objectId);
							if (creep && creep.room.name == room.name){
									let hosInfo = hostiles[creep.pos.toString()];
									if (hosInfo && !hosInfo.hasHealed && creep.stats() && creep.stats().heal > 0){
											let target = event.data.targetId;
											if (target && Game.getObjectById(target)){
													target = Game.getObjectById(target);
													if (hostiles[target.pos.toString()] && event.data.healType === EVENT_HEAL_TYPE_MELEE){
															if (target.pos.isNearTo(creep.pos)){
																	hostiles[creep.pos.toString()].hasHealed = true;
																	hostiles[target.pos.toString()].receivedHeal += creep.stats().heal;
															}
													} else if (hostiles[target.pos.toString()] && event.data.healType === EVENT_HEAL_TYPE_RANGED){
															if (target.pos.isNearTo(creep.pos)){
																	hostiles[creep.pos.toString()].hasHealed = true;
																	hostiles[target.pos.toString()].receivedHeal += creep.stats().heal;
															} else if (target.pos.inRangeTo(creep.pos, 3)){
																	hostiles[creep.pos.toString()].hasHealed = true;
																	hostiles[target.pos.toString()].receivedHeal += (creep.stats().heal / (HEAL_POWER / RANGED_HEAL_POWER));
															}
													}
											}
											//console.log(creep,'healing',target)
									}
							}
					}
					//check where ally creeps have attacked, add this to damage calc if creep still in range to attack again
					if (event.event == EVENT_ATTACK){
							let creep = Game.getObjectById(event.objectId);
							let target;
							let range;
							if (event.targetId && Game.getObjectById(event.targetId)){
									target = Game.getObjectById(event.targetId);
									range = creep.pos.getRangeTo(target);
							}
							if (creep && creep.room.name == room.name && event.data && event.data.attackType && target
									&& !target.my && range && range < 4 && creep.stats()){
									let damage = 0;
									let distanceRate = {0: 1, 1: 1, 2: 0.4, 3: 0.1};
									switch (event.data.attackType){
											case EVENT_ATTACK_TYPE_MELEE :
													damage = creep.stats().attack;
													break
											case EVENT_ATTACK_TYPE_RANGED :
													damage = creep.stats().ranged_attack;
													break
											case EVENT_ATTACK_TYPE_RANGED_MASS :
													damage = creep.stats().ranged_attack * distanceRate[range];
													break
									}
									if (damage > 0 && hostiles[target.pos.toString()]){
											hostiles[target.pos.toString()].receivedDamage += damage;
									}
							} else if (target && target.my && room.memory.armedHostiles){
									room.memory.lastAttacked = Game.time;
							}
					}
			}
			for (let id in attacksMade){
					if (hostiles[id]){
							hostiles.receivedDamage += attacksMade[id];
					}
			}

			let target;
			let bestDamage = 0;
			let localGuardsToAttack = [];
			for (let i in hostiles){
					let hostile = hostiles[i].hostile;
					let nearStructures = hostile.pos.lookAround(LOOK_STRUCTURES, 3, {filter: (s) => s.my});
					let nearCreeps = hostile.pos.lookAround(LOOK_CREEPS, 3, {filter: (s) => s.my});
					if (nearCreeps.length == 0 && nearStructures.length == 0 && hostile.hits > hostile.hitsMax*0.7){
							continue
					}
					let stats = hostile.stats();
					let damage = hostiles[i].receivedDamage;
					if (towers.length > 0 && room.controller && room.controller.level > 0){
							for (let t in towers){
									let tower = towers[t];
									if (towers.length <= CONTROLLER_STRUCTURES['tower'][room.controller.level] || tower.isActive()){
											damage += effectiveness(TOWER_POWER_ATTACK, hostile.pos.getRangeTo(towers[t]));
									}
							}
					}
					if (stats && stats.toughParts){
							//*100 to get hits for the tough layer, /toughPower to get damage needed to get through tough layer
							let damageNeeded = (stats.toughParts * 100) / stats.toughPower;
							if (damageNeeded > damage){
									//damage if going to be less than tough layer so just x damage by the tough modifier
									damage = damage * stats.toughPower;
							} else {
									//take off damage needed to strip the layer and add the base hits of the layer back on
									damage -= damageNeeded;
									damage += (stats.toughParts * 100);
							}
					}
					//work out raw damage to make sure we are not being overhealed in an area and therefore being drained
					let rawDamage = damage;
					damage -= hostiles[i].receivedHeal;
					if (!hostiles[i].hasHealed && stats && stats.heal && stats.heal > 0){
							//console.log(hostile,'heal self')
							damage -= stats.heal;
							hostiles[i].hasHealed = true;
					}
					if (damage > bestDamage && damage > 0){
							//check neighbours as no point doing damage if the healing capacity is higher than the damage
							let nearHeal = 0;
							let range = 1;
							if (hostile.owner.username != 'Invader' || true){
									range = 2;
							}
							let neighbours = hostile.pos.lookAround(LOOK_CREEPS, range, {filter: (c) => !c.my});
							for (let i in neighbours){
									let neighbour = neighbours[i];
									if (neighbour && neighbour.stats().heal){
											nearHeal += neighbour.stats().heal;
									}
							}
							let localGuards = hostile.pos.lookAround(LOOK_CREEPS, 1, {filter: (c) => c.my && (c.role == 'attacker')});
							let nearGuards = hostile.pos.lookAround(LOOK_CREEPS, 3, {filter: (c) => c.my && (c.role == 'guard' || c.role == 'attacker' || c.role == 'sniper')});
							for (let i in localGuards){
									if (localGuards[i].stats().attack){
											nearHeal -= localGuards[i].stats().attack;
									}
									if (localGuards[i].stats().ranged_attack){
											nearHeal -= localGuards[i].stats().ranged_attack;
									}
							}
							//console.log(room.name,hostile,' expected damage:',rawDamage,' expected heal:',nearHeal)
							if ((!hostile.pos.nearEdge() || hostile.owner.username == 'Invader' || (localGuards && localGuards.length > 0)) && !hostile.pos.onEdge() && ((localGuards && localGuards.length > 0) || rawDamage > nearHeal || damage > hostile.hits
									|| ((Math.floor(Math.random() * 40) == 1 && nearGuards && nearGuards.length > 0) && (!Game.getObjectById(room.memory.towers)
											|| Game.getObjectById(room.memory.towers).store['energy'] > Game.getObjectById(room.memory.towers).store.getCapacity() * 0.6)))){
									target = hostile;
									bestDamage = damage;
									localGuardsToAttack = localGuards;
							}
					}
			}
			if (target && (((bestDamage > target.hitsMax * 0.25 || target.hits < target.hitsMax * 0.7) && room.memory.reserve && room.total('energy') > room.memory.reserve * 0.9)
					|| target.pos.lookAround(LOOK_STRUCTURES, 4, {filter: (s) => s.my || s.structureType == STRUCTURE_WALL}
							|| target.pos.lookAround(LOOK_CREEPS, 4, {filter: (c) => c.my})))){
					if (localGuardsToAttack){
							for (let g in localGuardsToAttack){
									localGuardsToAttack[g].attack(target);
							}
					}
					//console.log(room.name,target,'SELECTED TARGET')
					return target
			}
	}

	function effectiveness(power, range){
			let effect = power;
			if (range > TOWER_OPTIMAL_RANGE){
					if (range > TOWER_FALLOFF_RANGE){
							range = TOWER_FALLOFF_RANGE;
					}
					effect -= effect * TOWER_FALLOFF * (range - TOWER_OPTIMAL_RANGE) / (TOWER_FALLOFF_RANGE - TOWER_OPTIMAL_RANGE);
			}
			return Math.floor(effect);
	}

	playerHeap.towers = {};
	playerHeap.towers.rMatrixes = {};
	function runTowers(room){
			loadMatrix();
			//working out the base level for the walls
			Game.getObjectById(room.memory.stores);
			var repairs = Game.getObjectById(room.memory.repairs);
			var roads = Game.getObjectById(room.memory.roads);
			var cont = Game.getObjectById(room.memory.contrep);
			if (room.terminal && room.terminal.pos.lookFor(LOOK_FLAGS).length > 0); else {
					var lowwall = Game.getObjectById(room.memory.lowWall);
			}
			var economystable = room.memory.economystable;
			if (room.memory.reserve){
					var limit = room.memory.reserve;
			} else {
					var limit = 30000;
			}
			if (room.memory.hostiles != null || room.memory.fixeralive == false || Game.flags['defend' + room.name]
					|| (repairs && repairs.hits < 50000 && repairs.hits < (0.5 * repairs.hitsMax)) || roads){
					if (room.memory.walls && room.memory.walls < 10000){
							var walllevel = 10000;
					} else if (room.memory.walls && room.memory.walls < 10000000){
							var walllevel = room.memory.walls;
					} else {
							var walllevel = 10000000;
					}
					let towers = room.findStructures('tower');
					if (towers.length > CONTROLLER_STRUCTURES['tower'][room.controller.level]){
							towers = towers.filter((s)=>s.isActive());
					}
					if (towers){
							repairMatrix(room, towers);
					}

					//finding all the closest towers
					let repairtower = selectTower(repairs, towers,room);
					let walltower = selectTower(lowwall, towers,room);
					let conttower = selectTower(cont, towers,room);
					let roadtower = selectTower(roads, towers,room);
					let healCreeps;
					let healTower;
					if (room.memory.hostiles && (!Game.getObjectById(room.memory.towers)
							|| Game.getObjectById(room.memory.towers).store['energy'] > Game.getObjectById(room.memory.towers).store.getCapacity() * 0.6)){

							healCreeps = room.find(FIND_MY_CREEPS, {
									filter: (c) => c.hits < c.hitsMax * 0.9 && (c.role == 'attacker' || c.role == 'fixer'
											|| c.role == 'guard' || c.role == 'move' || c.role == 'sniper' || c.role == 'medic')
							});

					}
					if (healCreeps && healCreeps[0] && room.memory.spawn && Game.spawns[room.memory.spawn]){
							healTower = selectTower(healCreeps[0], towers,room);
							console.log('tower', healTower, healCreeps[0]);
					}
					let hostile;
					let inhibitFire = false;
					if (room.memory.hostiles != null){
							hostile = findTargetHostileCreep(room, towers);
					} else {
							delete room.memory.boostDefenders;
					}
					let towerlist = [];
					if (towers && towers.length > 0){
							for (let n in towers){
									towerlist.push(towers[n]);
							}
							for (let n in towers){
									let tower = towers[n];
									if (hostile && !inhibitFire){
											tower.attack(hostile);
									} else {
											//this code sorts towers by their distance to a repair, and gives the closest, so energy isnt wasted
											room.memory.defcon;
											if (towerlist.length > 0){
													if (healTower && healCreeps[0] && !hostile){
															healTower.heal(healCreeps[0]);
													} else if (repairtower && !hostile && tower.id == repairtower.id && repairtower.store['energy'] > 500 && repairs && repairs.hits < 0.7 * walllevel && economystable
															&& room.memory.fixeralive == false && room.memory.spawn && Game.spawns[room.memory.spawn]){
															repairtower.repair(repairs);
													} else if (!room.memory.armedHostiles && cont && conttower && tower.id == conttower.id && cont.hits < 100000 && room.memory.fixeralive == false){
															if (conttower && conttower.store['energy'] > 500){
																	conttower.repair(cont);
															}
													} else if (!room.memory.armedHostiles && roads && roadtower && tower.id == roadtower.id && roads.hits < roads.hitsMax * 0.5){
															if (roadtower && roadtower.store['energy'] > 500){
																	roadtower.repair(roads);
															}
													} else if (room.controller.level > 5 && (room.total('energy') > limit * 1.5 || room.memory.defcon < 5 || hostile || (room.total('energy') > 10000 && Game.flags['defend' + room.name])) && room.memory.walls && room.memory.walls < config.minWalls[room.controller.level]
															&& room.memory.spawn && Game.spawns[room.memory.spawn]){
															if ((Game.cpu.bucket > 8000 || Game.flags['defend' + room.name] != undefined) && walltower && lowwall && tower.id == walltower.id && walltower.store['energy'] > 500 && walltower.pos.getRangeTo(lowwall) <= 7){
																	walltower.repair(lowwall);
															} else if ((Game.cpu.bucket > 9000 || Game.flags['defend' + room.name] || hostile || room.memory.defcon < 5) && tower && tower.store['energy'] > 500){
																	let walls;
																	walls = tower.pos.lookAround(LOOK_STRUCTURES, 5, {filter: (s) => s.structureType == STRUCTURE_WALL || s.structureType == STRUCTURE_RAMPART && s.hits < 10000000});
																	if (walls){
																			let wall = walls.sort(function (a, b){
																					return a.hits - b.hits
																			})[0];
																			if (wall){
																					tower.repair(wall);
																			}
																	}
															}
													}
											}
									}
							}
					} else if (room.controller.level > 2 && room.class === 'normal' && Game.time % 103 == 0){
							buildRoom(room);
					}
			}

			function repairMatrix(room, towers){
					if (towers.length > 0){
							if (ready() === false || ((Game.time % 100 != 0 || Game.cpu.getUsed() > Game.cpu.limit) && !room.memory.hostiles && room.memory.towersLength)){
									return
							}
							if ((room.memory.towersLength != towers.length) || !room.memory.towersArr){
									delete room.memory.towersLength;
									let arr = [];
									for (let i in towers){
											arr.push(towers[i].id);
									}
									room.memory.towersArr = arr;
							}
							if (!access(room.name)){
									console.log('towers no segment');
									return
							}
							let matrix = access(room.name).repairMatrix;
							if ((!room.memory.towersLength || room.memory.towersLength != towers.length) || !matrix){
									save(room.name, 'repairMatrix', false);
									let cost = new PathFinder.CostMatrix;
									for (let i = 0; i <= 48; i++){
											for (let j = 0; j <= 48; j++){
													let arr = towers;
													let pos = new RoomPosition(i, j, room.name);
													let tower = arr.sort(function (a, b){
															return a.pos.getRangeTo(pos) - b.pos.getRangeTo(pos)
													})[0];
													let val = room.memory.towersArr.findIndex((a) => {
															return a === tower.id
													});
													let colours = ['red', 'green', 'blue', 'yellow', 'purple', 'orange'];
													room.visual.circle(pos, {fill: colours[val], radius: 1});
													if (val){
															cost.set(i, j, val);
													}
											}
									}
									save(room.name, 'repairMatrix', cost.serialize());
							}
							if (!room.memory.towersLength || room.memory.towersLength != towers.length){
									room.memory.towersLength = towers.length;
							}
					}
			}

			function loadMatrix(){
					if (playerHeap.towers.rMatrixes[room.name] === undefined && ready()){
							if (!access(room.name)){
									return
							}
							let serial = access(room.name).repairMatrix;
							if (serial){
									playerHeap.towers.rMatrixes[room.name] = PathFinder.CostMatrix.deserialize(serial);
									PathFinder.CostMatrix.deserialize(serial);
							}
					} else {
							playerHeap.towers.rMatrixes[room.name];
					}
			}

			//visualise the target selection
			/*
					if (rMatrix){
							let colours = ['red','green','blue','yellow','purple','orange']
							for (i = 0;i <= 48;i++){
									for (j = 0;j <= 48;j++){
											let val = rMatrix.get(i,j)
											let pos = new RoomPosition(i,j,room.name)
											room.visual.circle(pos,{fill:colours[val],radius:0.3})
									}
							}
							for (let i in room.memory.towersArr){
									let tow = Game.getObjectById(room.memory.towersArr[i])
									if (tow){
											room.visual.circle(tow.pos,{fill:colours[i],radius:0.7})
									}
							}
					}
			*/

	}
	function selectTower(obj, towers,room){
			if (!playerHeap.towers.rMatrixes || !playerHeap.towers.rMatrixes[room.name]){
					return
			}
			let rMatrix = playerHeap.towers.rMatrixes[room.name];
			if (!rMatrix){
					return
			}
			if (towers && towers.length > 0 && obj && room.memory.towersArr && rMatrix){
					let val = rMatrix.get(obj.pos.x, obj.pos.y);
					let id = room.memory.towersArr[val];
					let tow = Game.getObjectById(id);
					if (tow){
							tow.room.visual.line(tow.pos, obj.pos);
					}
					return tow
			}
	}

	function runRepairLink(room){
		let link;
		if (!spawnCode.ableToAfford(room)){
			return
		}
		if (room && room.memory.repairLinkLocation){
			let loc = room.memory.repairLinkLocation.toPos();
			if (loc && room.memory.repairLink){
				let currentLink = Game.getObjectById(room.memory.repairLink);
				if (!currentLink){
					delete room.memory.repairLink;
				} else if (!currentLink.pos.isEqualTo(loc)){
					currentLink.destroy();
					delete room.memory.repairLink;
				} else {
					link = currentLink;
				}
			} else if (loc){
				let newLink = loc.lookAround(LOOK_STRUCTURES, 0, {filter: (s) => s.structureType == STRUCTURE_LINK})[0];
				if (newLink){
					link = newLink;
					room.memory.repairLink = link.id;
				} else if (!room.memory.hostiles && room.storage && room.terminal){
					loc.createConstructionSite(STRUCTURE_LINK);
				}
			}
		} else {
			if (room.memory.repairLink){
				let currentLink = Game.getObjectById(room.memory.repairLink);
				if (!currentLink){
					delete room.memory.repairLink;
				} else {
					currentLink.destroy();
					delete room.memory.repairLink;
				}
			}
		}
		return link
	}

	/*need flag pray+room.name so it isn't ignored by remote
	 Flag layout:
	 spawn needs to be either horizontal or vertical in line
	 spawnname:'prayer+supportroomname' 
	auto building?
	find array for path possible near controller
	build needed building if they dont exist
	taylor to level
	            ter      lab
	    c       s   trans
	            st
	            
	            s.name = pray+supportSpawn.name
	 */
	function pray (prayRoom){
			var controller = prayRoom.controller;
			var spawn = Game.spawns[prayRoom.memory.spawn];
			if (!spawn){
				return
			}
			prayRoom.memory.prayerRoom = true;
			var pos1 = spawn.pos;
			var pspawnnum = spawn.name.slice(4);
			var supportRoom = Game.rooms[pspawnnum];
			let room = prayRoom;
			if (!room || !room.storage){
				return
			}
			if (!room.memory.prayRoute || Game.time % 5000 == 0 || (room.memory.prayRoute && room.memory.prayRoute.length == 0)){
				//start point between controller and spawn
				var start = spawn.room.getPositionAt((controller.pos.x + pos1.x) / 2, (controller.pos.y + pos1.y) / 2);
				if (start){
					var xArr = [0, 0, 0, -1, -2, -2, -2, -2, -1, 0, 0];
					var yArr = [0, 1, 2, 2, 2, 1, -1, -2, -2, -2, -1];
					var posArr = [];
					for (i = 0; i < 11; i++){
						var xDir = controller.pos.x - pos1.x;
						var yDir = controller.pos.y - pos1.y;
						if (xDir == 0){
							if (yDir > 0){
								let pos = spawn.room.getPositionAt(start.x + yArr[i], start.y + xArr[i]);
								posArr.push(pos);
							} else if (yDir < 0){
								let pos = spawn.room.getPositionAt(start.x + yArr[i], start.y - xArr[i]);
								posArr.push(pos);
							}
						} else if (yDir == 0){
							//current
							if (xDir > 0){
								let pos = spawn.room.getPositionAt(start.x + xArr[i], start.y + yArr[i]);
								posArr.push(pos);
							} else if (xDir < 0){
								let pos = spawn.room.getPositionAt(start.x - xArr[i], start.y - yArr[i]);
								posArr.push(pos);
							}
						}

					}
					if (posArr.length > 0){
						var route = posArr.reverse();
						room.memory.prayRoute = route;
						for (let n = 0; n < posArr.length; n++){
							new RoomVisual(spawn.room.name).circle(posArr[n]);
						}
					}
				}
			} else {
				var route = room.memory.prayRoute;
			}


			if (room.memory.monkOrder){
				//check it's current
				let monks = room.memory.monkOrder;
				let newMonks = [];
				for (let i = 0; i < monks.length; i++){
					let monk = Game.getObjectById(monks[i]);
					if (monk){
						newMonks.push(monks[i]);
					}
				}
				let monk0 = Game.getObjectById(newMonks[0]);
				if (monk0 && monk0.ticksToLive > 1420){
					let monkLast = newMonks.shift();
					newMonks.push(monkLast[0]);
				}
				room.memory.monkOrder = newMonks;
			} else if (Game.time % 300 == 0){
				let monks = room.find(FIND_CREEPS, {filter: (c) => c.role == 'monk'});
				let monkOrder = [];
				monks.forEach((m) => monkOrder.push(m.id));
				room.memory.monkOrder = monkOrder;
			}
			if (prayRoom.controller.my && prayRoom.controller.level < 4){
				var supportnum = 5;
				var monkNum = 3;
				var termNum = 0;
			} else if ((prayRoom.controller.my && (prayRoom.controller.level < 6 || !prayRoom.terminal)) && prayRoom.storage){
				var supportnum = 5;
				var monkNum = 3;
				var termNum = 0;
				if (prayRoom.storage.store['energy'] > 500000){
					var supportnum = 0;
					var monkNum = 6;
				}
			} else if (prayRoom.controller.my && prayRoom.storage && prayRoom.terminal && prayRoom.controller.level < 8){
				var termNum = 1;
				var monkNum = 3;
			} else if (prayRoom.controller.my && prayRoom.storage && prayRoom.terminal && prayRoom.controller.level == 8){
				var supportnum = 0;
				var termNum = 1;
				var monkNum = 0;
			} else {
				var supportnum = 0;
				var termNum = 0;
				var monkNum = 0;
			}


			if (Memory.excessEnergy && Memory.excessEnergy < 1000000 && monkNum > 0){
				var monkNum = 2;
			}
			if (((prayRoom.storage && prayRoom.storage.store['energy'] < 50000) && (Memory.excessEnergy && Memory.excessEnergy < 150000)) && monkNum > 0){
				var monkNum = 0;
				var supportnum = 0;
				var termNum = 0;
			}
			if (prayRoom.controller.my && prayRoom.controller.level > 6){
				if (Memory.excessEnergy && Memory.excessEnergy > 1500000 && monkNum > 0 && monkNum < 4){
					var monkNum = 4;
				}
				if (Memory.excessEnergy && Memory.excessEnergy > 2000000 && monkNum > 0 && monkNum < 6){
					var monkNum = 6;
				}
				if (Memory.excessEnergy && Memory.excessEnergy > 2500000 && monkNum > 0 && monkNum < 10){
					var monkNum = 10;
				}
			}
			if (prayRoom.storage.store['energy'] > 700000){
				monkNum += 2;
			}
			if (prayRoom.controller.level == 8 && prayRoom.storage && prayRoom.storage.store['energy'] > 900000){
					Game.rooms[pspawnnum].sendClaimer(prayRoom.name);
				prayRoom.controller.unclaim();
			}
			if (!room.memory.monks || Game.time % 20 == 0){
				room.memory.monks = prayRoom.find(FIND_MY_CREEPS, {filter: (c) => c.role == 'monk'}).length;
			}
			if (!room.memory.lab || Game.time % 10000 == 0){
				var lab = spawn.pos.findInRange(FIND_STRUCTURES, 2, {filter: (s) => s.structureType == STRUCTURE_LAB});
				if (lab[0]){
					room.memory.lab = lab[0].id;
				}
			}
			if (supportRoom && prayRoom.controller.my){
				supportRoom.memory.prayerSupportRoom = {
					supportNum: supportnum,
					monkNum: monkNum,
					termNum: termNum,
					level: prayRoom.controller.level,
					claimNum: 0,
					roomName: prayRoom.name
				};
			} else if (supportRoom && Game.flags['pray' + prayRoom.name]){
				supportRoom.memory.prayerSupportRoom = {
					supportNum: 0,
					monkNum: 0,
					termNum: 0,
					level: 0,
					claimNum: 1,
					roomName: prayRoom.name
				};
			}
			if (prayRoom.controller.my && prayRoom.controller.level < 6){
				var cont = prayRoom.controller.pos.findInRange(FIND_STRUCTURES, 5, {filter: (s) => s.structureType == STRUCTURE_CONTAINER && _.sum(s.store) < s.store.getCapacity()})[0];
				if (cont){
					prayRoom.memory.container = cont.id;
				} else if (!prayRoom.storage || prayRoom.storage.store['energy'] < 500000){
					prayRoom.memory.container = null;
					if (supportRoom.memory.prayerSupportRoom){
						supportRoom.memory.prayerSupportRoom.supportNum = 5;
					}
				}
			} else {
				room.memory.container = null;
			}

			if (!prayRoom.memory.factory && prayRoom.controller.level > 6 && Game.time % 100 === 0){
				let factory = spawn.pos.lookAround(LOOK_STRUCTURES, 2, {filter: (s) => s.structureType == STRUCTURE_FACTORY})[0];
				if (factory){
					prayRoom.memory.factory = factory.id;
				}
			}
			if (prayRoom.terminal && prayRoom.memory.factory && Memory.commodities && Memory.commodities.export){
				let factory = Game.getObjectById(prayRoom.memory.factory);
				if (factory){
					if (!factory.cooldown && factory.store['battery'] > 50){
						factory.produce('energy');
					}
					let q = 200;
					let c = 'battery';
					if (room.total(c) < q * 10){
						//find closest room with c
						let closest;
						let closestRange;
						for (let j in Memory.commodities.export[c]){
							if (j === room.name){
								continue
							}
							if (!closest || Game.map.getRoomLinearDistance(j, room.name) < closestRange){
								closest = j;
								closestRange = Game.map.getRoomLinearDistance(j, room.name);
							}
						}
						if (closest){
							let cRoom = Game.rooms[closest];
							if (cRoom && cRoom.terminal){
								if (cRoom.terminal.send(c, q, room.name) == 0){
									delete Memory.commodities.export[c][closest];
								}
							}
						}
					}
				}
			}


		}

	function runHarassmentManager(room){
			if (!config.autoHarassEnemies){
					return
			}
			let maxLevel = 3;
			for (let i in Game.myRooms){
					if (Game.rooms[i] && Game.rooms[i].controller){
							if (!maxLevel || Game.rooms[i].controller.level > maxLevel){
									maxLevel = Game.rooms[i].controller.level;
							}
					}
			}
			if (Game.time % 1000 === 0){
					for (let i in Memory.ownedRooms){
							let roomMem = Memory.ownedRooms[i];
							if (roomMem.owner && roomMem.owner.isEnemy){
									let dist = getDist(i,room.name);
									if (dist <= 10){
											if (!room.memory.hostileRemotes){
													room.memory.hostileRemotes = {};
											}
											let exits = Game.map.describeExits(i);
											for (let e in exits){
													room.memory.hostileRemotes[exits[e]] = Game.time + 10000;
											}
									}
							}
					}
			}
			if (room && room.storage && room.controller.level >= maxLevel-1 && room.controller.level > 3 && room.total('energy')>room.memory.reserve){
					let lastHarass = 0;
					if (room.memory.lastHarass){
							lastHarass = room.memory.lastHarass;
					}
					if (room.memory.hostileRemotes && Game.time-lastHarass > 3000){
							let options = [
									{type:'H',medics:1,dozers:1,attackers:1},
									{type:'H',medics:1,attackers:2},
									{type:'H',medics:1,snipers:1},
									{type:'H',medics:1,dozers:1},
									{type:'H',medics:2,attackers:2},
							];
							let rand = Math.floor(Math.random()*options.length);
							let ret = requestSquad(room,room.name,options[rand]);
							if (ret === 'OK' || ret === -8){
									room.memory.lastHarass = Game.time;
							}
					}
			}
	}

	let reservationsAllRooms = {};
	let creepReservations = {};
	const spacesNearSource = {};
	let sourcesAll = {};

	function mineRemote(creep){
			if (config.swampyGround){
					console.log('swampy ground');
					creep.rally(1, 3);
					return
			}
			if (creep.room.memory.armedHostiles){
					checkGuardNeeded(creep);
					if (creepReservations[creep.id]){
							deleteReservation$1(creep.id, creepReservations[creep.id]);
					}
					if (creep.room.name !== creep.home.name){
							creep.rally(1);
					}
			}
			if (Game.time % 25 == 0 && creep.num === 1){
					for (let i in creepReservations){
							if (!Game.getObjectById(i)){
									deleteReservation$1(i, creepReservations[i][0]);
							}
					}
					for (let i in reservationsAllRooms[creep.home.name]){
							let reservations = reservationsAllRooms[creep.home.name][i];
							for (let j in reservations){
									reservations[j];
									if (j && (!Game.getObjectById(j) || (creepReservations[j] && creepReservations[j][0] != i))){
											delete reservations[j];
									}
							}
					}
			}
			if (creep.store.getFreeCapacity() === 0 || creep.home.storage){
					if (creepReservations[creep.id]){
							deleteReservation$1(creep.id, creepReservations[creep.id]);
					}
					return
			}
			if (!reservationsAllRooms[creep.home.name]){
					reservationsAllRooms[creep.home.name] = {};
			}
			let reservations = reservationsAllRooms[creep.home.name];
			if (creep.memory.container){
					getFromContainer(creep);
					return
			} else {
					findContainer(creep);
			}
			if (creepReservations[creep.id]){
					mineReservation(creep, creepReservations[creep.id][0]);
			} else {
					//find a remote to mine, save the pos.toString()
					if (creep.home && creep.home.memory.sourcelist){
							let sources = [];
							if (sourcesAll[creep.home.name] && Game.time % 100 != 0){
									sources = sourcesAll[creep.home.name];
							} else {
									for (let i in creep.home.memory.sourcelist){
											if (creep.home.memory.sourcelist[i] < 100 && (!creep.home.memory.storeCont || !Game.getObjectById(creep.home.memory.storeCont) ||
													!creep.home.memory.yak || countRole('yak',creep.home) < creep.home.memory.yak/2
													|| !creep.home.memory.finalSources || !creep.home.memory.finalSources.includes(i))){
													let pos = i.toPos();
													if (pos && pos.roomName && Memory.ownedRooms[pos.roomName]){
															continue
													}
													sources.push([i, creep.home.memory.sourcelist[i]]);
											}
									}
									sources.sort((a, b) => a[1] - b[1]);
									sourcesAll[creep.home.name] = sources;
							}
							for (let i in sources){
									let source = sources[i][0];
									let distance = sources[i][1];
									let pos = source.toPos();
									if (pos && pos.roomName && !creep.home.checkRemoteIsAccessible(pos.roomName)){
											//avoid bad rooms
											continue
									}
									if (Game.rooms[pos.roomName] && Game.rooms[pos.roomName].controller && Game.rooms[pos.roomName].controller.reservation
									&& Game.rooms[pos.roomName].controller.reservation.username !== Game.username){
											continue
									}
									let spacesNear;
									if (!spacesNearSource[source]){
											let neighbours = pos.neighbours(1);
											let count = 0;
											for (let i in neighbours){
													if (neighbours[i].getTerrain() != 'wall'){
															count++;
													}
											}
											spacesNearSource[source] = count;
											spacesNear = count;
									} else {
											spacesNear = spacesNearSource[source];
									}
									let adjust = 3;
									if (distance && distance > 50){
											adjust = 5;
									} else if (distance && distance > 30){
											adjust = 4;
									}
									if (spacesNear < 3){
											adjust = 2;
									}
									if (spacesNear > 1 && (!reservations[source] || Object.values(reservations[source]).length <= (spacesNear * adjust))){
											placeReservation$1(creep, source);
											mineReservation(creep, source);
											return
									}
							}
							creep.rally(3, 3);
							delete creep.memory.remote;
					} else {
							delete creep.memory.remote;
					}
			}
	}

	function mineReservation(creep, targetStr){
			creep.say('mine rem');
			let pos = targetStr.toPos();
			if (pos && !creep.pos.isNearTo(pos)){
					creep.moveTo(pos, {range: 1});
			} else if (pos){
					let source = pos.lookAround(LOOK_SOURCES, 1)[0];
					if (source){
							let ret = creep.harvest(source);
							if (ret === 0){
									creep.isMoving = true;
							} else if (ret === -1){
									let corePresent = checkForCore(creep);
									if (corePresent){
											creep.memory.role = 'recycle';
									}
							}
					}
			}
	}

	function getFromContainer(creep){
			let container = Game.getObjectById(creep.memory.container);
			if (!container && creep.memory.target){
					let pos = creep.memory.target.toPos();
					if (pos){
							creep.moveTo(pos, {range: 1});
					} else {
							delete creep.memory.target;
							delete creep.memory.container;

					}
			} else {
					if (creep.pos.isNearTo(container)){
							creep.remoteWithdraw(container);
							delete creep.memory.target;
							delete creep.memory.container;

					} else {
							creep.moveTo(container, {range: 1});
					}
			}
	}

	function findContainer(creep){
			let mem = creep.home.memory.remoteContainers;
			if (mem){
					for (let i in mem){
							//check
							let contMem = mem[i];
							if (contMem.pos){
									let pos = contMem.pos.toPos();
									if (pos && pos.roomName && creep.home.checkRemoteIsAccessible(pos.roomName) !== false){
											//avoid bad rooms
											continue
									}
							}
							if (contMem.freeEnergy >= creep.store.getCapacity() / 2){
									//reserve and break
									let cont = Game.getObjectById(i);
									if (cont){
											creep.remoteReserve(cont);
											return true
									}
							}
					}
			}
			return false
	}

	function deleteReservation$1(id, target){
			let roomName = creepReservations[id][1];
			if (Game.getObjectById(id)){
					delete Game.getObjectById(id).memory.remote;
			}
			delete creepReservations[id];
			if (roomName){
					let reservations = reservationsAllRooms[roomName];
					if (reservations[target]){
							delete reservations[target][id];
					}
			}
	}

	function placeReservation$1(creep, target){
			creepReservations[creep.id] = [target, creep.home.name];
			let pos = target.toPos();
			if (pos && pos.roomName){
					let reservations = reservationsAllRooms[creep.home.name];
					if (!reservations[target]){
							reservations[target] = {};
					}
					reservations[target][creep.id] = true;
			}
	}

	playerHeap.energyCollectionTargetManager = {};
	let roomCache = {};
	playerHeap.energyCollectionTargetManager.reservationsAllRooms = {};
	playerHeap.energyCollectionTargetManager.creepReservations = {};

	const cpuThreshold = 0;
	const priority = ['harvester','upHauler'];
	let lastReset = {};

	//find energy targets within the room and reserve them so there are not two creeps going for the same energy
	function findEnergyTarget(room, creep){
			//let cpu = Game.cpu.getUsed()
			let ret =  _findEnergyTarget(room, creep);
			//console.log(Game.cpu.getUsed() -
			return ret
	}
	function _findEnergyTarget(room, creep){
			if (!room || !room.name || !creep || !creep.name){
					console.log('energy target mananager error');
					return
			}
			if (!playerHeap.energyCollectionTargetManager.reservationsAllRooms[room.name]){
					playerHeap.energyCollectionTargetManager.reservationsAllRooms[room.name] = {};
			}
			if (!lastReset[room.name]){
					lastReset[room.name] = Game.time;
			}
			let reservations = playerHeap.energyCollectionTargetManager.reservationsAllRooms[room.name];
			if (!lastReset[room.name] || (Game.time - lastReset[room.name]) > 25){
					for (let i in playerHeap.energyCollectionTargetManager.creepReservations){
							if (!Game.getObjectById(i)){
									deleteReservation(i, playerHeap.energyCollectionTargetManager.creepReservations[i][0]);
							}
					}
					lastReset[room.name] = Game.time;
			}
			if (creep.memory.remote && creep.memory.remote < Game.time){
					delete creep.memory.remote;
			}
			if (creep.memory.remote && !config.swampyGround){
					mineRemote(creep);
					creep.memory.remote = Game.time + 5;
			} else if (playerHeap.energyCollectionTargetManager.creepReservations[creep.id]){
					let target = Game.getObjectById(playerHeap.energyCollectionTargetManager.creepReservations[creep.id][0]);
					if (target){
							getFromTarget(creep, target);
					} else {
							delete playerHeap.energyCollectionTargetManager.creepReservations[creep.id];
					}
					return true
			} else {
					if (!roomCache[room.name] || (roomCache[room.name].time != Game.time && Game.cpu.bucket > 5000)
							|| (roomCache[room.name].time < Game.time-5)){
							let drops = room.find(FIND_DROPPED_RESOURCES, {filter: (r) => r.resourceType == 'energy'});
							let conts = room.find(FIND_STRUCTURES, {filter: (s) => s.structureType == STRUCTURE_CONTAINER && s.store['energy'] > 0});
							roomCache[room.name] = {
									drops: drops,
									conts: conts,
									time: Game.time
							};
					}
					let energyCache = roomCache[room.name];
					let targets = [];
					let creepStoreAvailable = creep.store.getFreeCapacity();
					let upCont;
					let drops = energyCache.drops;
					let conts = energyCache.conts;
					if (room.memory.upCont){
							upCont = Game.getObjectById(room.memory.upCont);
					}
					for (let i in drops){
							if (targets.length > 0 && Game.cpu.bucket < cpuThreshold){
									break
							}
							if (creep.num > 5 && !priority.includes(creep.role) && !room.memory.lotsOfDroppedEnergy){
									//stop energy getting used
									break
							}
							let drop = drops[i];
							if (drop){
									if (room.controller.level < 5 && room.memory.upContPos && drop.pos.toString() === room.memory.upContPos
									&& !room.memory.staticUpgradersHelpBuild){
											//dont want to crowd out the upCont
											continue
									}
									if (room.memory.upgraderLoadingPosition && room.memory.manualLoadUpLink && drop.pos.toString() === room.memory.upgraderLoadingPosition){
											//don't collect from supply for praising
											continue
									}
									let amount = drop.amount;
									if (reservations[drop.id]){
											for (let r in reservations[drop.id]){
													amount -= reservations[drop.id][r];
											}
									}
									if ((amount >= creepStoreAvailable && amount >= 500) || (priority.includes(creep.role) && amount >= 50)){
											if ((amount < 2000  || creep.role === 'yak' || (room.controller.progressTotal-room.controller.progress) < 5000 || (room.controller.level === 4 && !room.storage))
													&& creep.role !== 'harvester' && creep.role !== 'builder' && room.memory.fixedBaseOrigin && drop.pos.toString()===room.memory.fixedBaseOrigin){
													//deprioritise store cont energy pile to stop uphaulers bouncing around
													continue
											}
											targets.push(drop);
									}
							}
					}
					for (let i in conts){
							if (targets.length > 0 && Game.cpu.bucket < cpuThreshold){
									break
							}
							let cont = conts[i];
							if (creep.home.memory.upCont && cont.id == creep.home.memory.upCont && creep.role !== 'staticUpgrader' && !creep.home.memory.staticUpgradersHelpBuild){
									continue
							}
							if (creep.home.memory.staticFillerContainer && cont.id === creep.home.memory.staticFillerContainer &&
									(creep.role !== 'staticUpgrader' || !room.memory.staticUpgradersHelpBuild || cont.store['energy'] < 500 || creep.num > 2)){
									continue
							}
							if (creep.home.memory.storeCont && cont.id == creep.home.memory.storeCont &&
									((creep.role !== 'harvester' && cont.store['energy'] < 1000) || creep.home.storage)){
									continue
							}

							if (room.memory.upgraderLoadingPosition && room.memory.manualLoadUpLink && cont.pos.toString() === room.memory.upgraderLoadingPosition){
									//don't collect from supply for praising
									continue
							}
							if (cont){
									let amount = cont.store['energy'];
									if (reservations[cont.id]){
											for (let r in reservations[cont.id]){
													amount -= reservations[cont.id][r];
											}
									}
									if (creep.role === 'builder' && creep.home.controller.level > 3);
									if ((amount >= creepStoreAvailable && amount >= 1000) || (priority.includes(creep.role) && amount >= 50)){
											targets.push(cont);
									}
							}
					}
					if ((creep.role === 'staticUpgrader'|| creep.role === 'builder')
							&& room.memory.storeContPosition && targets.length > 0 && room.memory.staticUpgradersHelpBuild){
							//staticUpgrader building storage
							targets = targets.filter((t)=>t.pos.isEqualTo(room.memory.storeContPosition.toPos()) || (room.memory.staticFillerContainer && t.id === room.memory.staticFillerContainer));
							if (room.storage){
									targets[0] = room.storage;
							}
					}
					if (!targets[0] && room.storage && room.total('energy')>room.memory.reserve && (creep.role !== 'yak' || (creep.memory.role && creep.memory.role !== 'yak'))
							&& ((creep.role !== 'upHauler' && creep.memory.role !== 'upHauler') || (upCont && upCont.store.getFreeCapacity()>0) || creep.room.memory.manualLoadUpLink)){
							targets[0] = room.storage;
					}
					if (playerHeap.energyCollectionTargetManager.creepReservations[creep.id]){
							return true
					}
					if (targets && targets.length > 0){
							if (Game.cpu.bucket > cpuThreshold){
									targets.sort((a, b) => a.pos.getRangeTo(creep) - b.pos.getRangeTo(creep));
							}
							if (creep.memory.lastDropPos && Game.time < creep.memory.lastDropPos.expiry){
									let dropPos = creep.memory.lastDropPos.pos;
									while (targets.length > 0 && targets[0].pos && targets[0].pos.toString() === dropPos){
											targets.shift();
									}
							} else if (creep.memory.lastDropPos){
									delete creep.memory.lastDropPos;
							}
							if (targets[0]){
									placeReservation(creep, targets[0]);
									getFromTarget(creep, targets[0]);
									return true
							}
					} else if ((creep.role === 'builder' || creep.role === 'upgrader') && !config.swampyGround && creep.home.memory.finalSources
							&& creep.home.memory.finalSources.length > 0 && creep.room.controller.level < 3){
							mineRemote(creep);
							creep.memory.remote = Game.time + 5;
					} else if (creep.store.getUsedCapacity() > 0 && (creep.role === 'harvester' || creep.role === 'upHauler')){
							creep.memory.dropping = true;
					} else if (creep.role !== 'yak' && creep.role !== 'harvester' && creep.role !== 'staticUpgrader'){
							creep.rally(2, 3);
					} else {
							delete creep.memory.localEnergyPickUp;
							return false
					}
			}
	}

	function getFromTarget(creep, target){
			if (creep.pos.isNearTo(target)){
					if (target.store){
							//use withdraw
							let amount;
							if (creep.powers){
									amount = creep.store.getFreeCapacity() - 20;
									if (amount > target.store['energy']){
											amount = target.store['energy'];
									}
							}
							creep.withdraw(target, 'energy', amount);
					} else {
							//use pickUp
							creep.pickup(target);
					}
					deleteReservation(creep.id, target.id);
			} else {
					//creep.moveTo(target, {range: 1})
					flowPath(creep,target,1);
			}
	}

	function deleteReservation(id, targetID){
			let roomName = playerHeap.energyCollectionTargetManager.creepReservations[id][1];
			delete playerHeap.energyCollectionTargetManager.creepReservations[id];
			if (roomName){
					let reservations = playerHeap.energyCollectionTargetManager.reservationsAllRooms[roomName];
					if (reservations[targetID]){
							delete reservations[targetID][id];
					}
			}
	}

	function placeReservation(creep, target){
			playerHeap.energyCollectionTargetManager.creepReservations[creep.id] = [target.id, target.pos.roomName];
			if (target.pos && target.pos.roomName){
					let reservations = playerHeap.energyCollectionTargetManager.reservationsAllRooms[target.pos.roomName];
					if (!reservations[target.id]){
							reservations[target.id] = {};
					}
					reservations[target.id][creep.id] = creep.store.getFreeCapacity();
			}
	}

	let sortedMinerals;
	let nukeLaunched = 0;
	playerHeap.lastSupplyToAlly = {};
	playerHeap.lastMineralPath = {};
	function runRoomManager(){
			if (!sortedMinerals){
					sortedMinerals = [...config$1.minerals];
					sortedMinerals.sort((a,b)=> Game.getResourceTotal(a)-Game.getResourceTotal(b));
			}
			let dataRooms = 0;
			let dataSources = 0;
			//main room class
			for (let ro in Game.myRooms){
					let room = Game.myRooms[ro];
					if (room.class === 'outpost'){
							let outpostCPU = Game.cpu.getUsed();
							runTowers(room);
							if (Game.time % 5 == 0){
									mainMemorise(room);
							}
							room.display(`wall level ${room.memory.adjustedLowWallHits}  ${room.memory.lowWall}`);
							if (Game.flags['outpost'+ro]){
									let flag = Game.flags['outpost'+ro];
									if (flag.pos && flag.pos.roomName === ro && room && room.controller && room.controller.level > 2){
											flag.pos.createConstructionSite('tower');
									}
							}
							if (room.hostileList){
									for (let i in room.hostileList){
											let hos = room.hostileList[i];
											if (hos && hos.owner && hos.owner.username && hos.owner.username.isEnemy && hos.body.length > 1){
													if (!room.controller.safeMode && room.controller.safeModeAvailable && !room.controller.safeModeCooldown){
															room.controller.activateSafeMode();
													}
											}
									}
							}
							Memory.stats.cpu['outposts'] += Game.cpu.getUsed() - outpostCPU;
							continue
					}
					if (room.class === 'thoriumMine'){
							let outpostCPU = Game.cpu.getUsed();
							runTowers(room);
							requestSquadsViaCombatManager(room.name,'response');
							if (Game.time % 5 == 0);
							try {
									runThoriumMine(room);
							} catch(err){
									console.log(err.stack.split("at"), 'thorium mine');
							}
							Memory.stats.cpu['thoriumMines'] += Game.cpu.getUsed() - outpostCPU;
							continue
					}
					if (room.class === 'restructuring'){
							//runs memorising finds to each room to save cpu
							var cpupremem = Game.cpu.getUsed();
							if (Game.time % 3 == 0){
									mainMemorise(room);
							}
							var cpupostmem = Game.cpu.getUsed();
							Memory.stats.cpu['mem'] += (cpupostmem - cpupremem);
							//trade
							try {
									var cpupretrade = Game.cpu.getUsed();
									let interval = 20;
									if (Game.cpu.bucket > 9000){
											interval = 10;
									}
									if (Game.time% interval === 0){
											//restructuring
											trade(room);
									}
									var cpuposttrade = Game.cpu.getUsed();
									Memory.stats.cpu['trade'] += (cpuposttrade - cpupretrade);
							} catch (err){
									console.log('trade ' + err.stack.split("at"));
							}
					}
					if (room && room.controller && room.controller.my && (room.class === 'normal'
					|| room.class === 'bunker')){
							let roomClass = room.class;
							dataRooms++;
							if (room.memory.finalSources){
									if (config$1.mapVisual && !config$1.official){
											for (let i in room.memory.finalSources){
													let pos = room.memory.finalSources[i].toPos();
													let colour = '#fc0000';
													if (room.roleList && room.roleList['remoteminer']){
															for (let m in room.roleList['remoteminer']){
																	let miner = room.roleList['remoteminer'][m];
																	if (miner && miner.num === Number.parseInt(i)){
																			colour = '#7CFC00';
																			break
																	}
															}
													}
													Game.map.visual.line(pos, new RoomPosition(25, 25, room.name),{color:colour});
											}
									}
									dataSources = dataSources + room.memory.finalSources.length;
							}
							if (room.storage && room.storeFillRatio && room.storeFillRatio > 0.95){
									if (Game.time % 1000 === 0){
											console.log(`announcement|${Game.shard.name}|store full ${room.name}`);
									}
									console.log(`store full ${room.hyperlink}`);
									if (room.total('energy')>room.memory.reserve*1.5 && room.terminal && room.terminal.store.getFreeCapacity()< 30000){
											room.memory.dump = 'energy';
											console.log(`announcement|${Game.shard.name}|dumping energy ${room.name}`);
											console.log(`dumping energy ${room.hyperlink}`);
									}
							}
							if (room.memory.dump && room.memory.dump === 'energy' && (room.total('energy')< room.memory.reserve*1.3 ||
									 (room.terminal && room.terminal.store.getFreeCapacity()> 50000))){
									delete room.memory.dump;
							}
							if (room.memory.prayerRoom){
									delete room.memory.prayerRoom;
							}
							try {
									if (config$1.scoreCollection && roomClass === 'normal'){
											runScoreManager(room);
									}
							} catch (err){
									console.log('score target ' + err.stack.split("at"));
							}
							try {
									if (roomClass === 'normal'){
											runBrigade(room);
									}
							} catch (err){
									console.log('brigade ' + err.stack.split("at"));
							}
							// for (let r in room.memory.observeRooms){
							// 		let obRoom = room.memory.observeRooms[r]
							// 		Game.map.visual.line(new RoomPosition(25,25,room.name),new RoomPosition(25,25,obRoom))
							// }
							if (config$1.mapVisual && room.memory.observeStatus);
							if (room.memory.defcon < 4 || (room.memory.armedHostiles && (!room.memory.spawn || !Game.spawns[room.memory.spawn]))){
									if (!Memory.blockClaims){
											Memory.blockClaims = {};
									}
									//prevent reclaiming of rooms in danger areas
									Memory.blockClaims[room.name] = Game.time+500000;
							}
							let SKcpu = Game.cpu.getUsed();
							try {
									//lets not sk mine for minerals if we can afford to buy them
									if (room.controller.level > 5 && config$1.mineralCollection  && (Game.time+room.index+5)%200 === 0 && !room.memory.SKMineralTarget && (config$1.official || Game.market.credits < config$1.maxCredits)){

											let canPath = false;
											if (!playerHeap.lastMineralPath[room.name] || playerHeap.lastMineralPath[room.name] < Game.time){
													canPath = true;
											}
											let highestPriorityMineralRoom, priorityRange, priorityMin, bestPath;
											for (let r in room.memory.observeRooms){
													let obRoom = room.memory.observeRooms[r];
													let rally = Game.flags['rally' + room.name];
													let range = Game.map.getRoomLinearDistance(room.name, obRoom);
													if (range > 5){
															continue
													}
													if (room.memory.avoidSKMineral && room.memory.avoidSKMineral[obRoom] && room.memory.avoidSKMineral[obRoom] > Game.time){
															let pos = new RoomPosition(35, 25, obRoom);
															Game.map.visual.text('avoidSKMin', pos, {fontSize: 5});
															continue
													} else if (room.memory.avoidSKMineral && room.memory.avoidSKMineral[obRoom]){
															delete room.memory.avoidSKMineral[obRoom];
													} else {
															let pos = new RoomPosition(25, 25, obRoom);
															let mineralType = Memory.rooms[obRoom] && Memory.rooms[obRoom].SKMineral && Memory.rooms[obRoom].SKMineral.type;
															if (mineralType){
																	Game.map.visual.text(mineralType, pos, {fontSize: 5});
																	if (config$1.mineralCollection && Array.isArray(config$1.mineralCollection) && !config$1.mineralCollection.includes(mineralType)){
																			let pos = new RoomPosition(25, 45, obRoom);
																			Game.map.visual.text('not needed', pos, {fontSize: 5});
																	}
															}
													}
													if (!canPath){
															continue
													}
													if (Memory.rooms[obRoom] && Memory.rooms[obRoom].SKMineral){
															let mineralType = Memory.rooms[obRoom] && Memory.rooms[obRoom].SKMineral.type;
															if (config$1.mineralCollection && Array.isArray(config$1.mineralCollection) && !config$1.mineralCollection.includes(mineralType)){
																	continue
															}
															if (config$1.mineralCollectionLevel && room.controller.level < config$1.mineralCollectionLevel){
																	continue
															}
															if ((!Memory.mineralsNeeded || !Memory.mineralsNeeded[mineralType]) && Game.market.credits > config$1.minCredits && config$1.marketActive){
																	//mining is not essential - check a mineral is cost effective
																	let price;
																	let energyPrice;
																	if (Memory.market && Memory.market.resources && Memory.market.resources[mineralType] && Memory.market.resources[mineralType].w){
																			price = Memory.market.resources[mineralType].w;
																	} else if (Memory.market && Memory.market.resources && Memory.market.resources[mineralType] && Memory.market.resources[mineralType].d){
																			price = Memory.market.resources[mineralType].d;
																	}
																	if (Memory.market && Memory.market.resources && Memory.market.resources['energy'] && Memory.market.resources['energy'].w){
																			energyPrice = Memory.market.resources['energy'].w;
																	} else if (Memory.market && Memory.market.resources && Memory.market.resources['energy'] && Memory.market.resources['energy'].d){
																			energyPrice = Memory.market.resources['energy'].d;
																	}
																	if (price < energyPrice * 3){
																			//mineral is not valuable enough to mine
																			if (!room.memory.avoidSKMineral){
																					room.memory.avoidSKMineral = {};
																			}
																			room.memory.avoidSKMineral[obRoom] = Game.time + 1000;
																			continue
																	}
															}
													}
													if (room.storage && Memory.rooms[obRoom] && Memory.rooms[obRoom].SKMineral && rally && rally.pos && Game.map.getSector(obRoom) === Game.map.getSector(room.name) &&
															room.controller.level >= config$1.mineralCollectionLevel && room.energyCapacityAvailable >= 3000
															&& Number.parseInt(Memory.rooms[obRoom].SKMineral.amount) > 0 && room.total(Memory.rooms[obRoom].SKMineral.type) < config$1.excess){
															//Game.map.visual.text(Memory.rooms[obRoom].SKMineral.type,new RoomPosition(25,25,obRoom))
															if (!Memory.rooms[obRoom].SKMineral.pos || typeof Memory.rooms[obRoom].SKMineral.pos != 'string' || !Memory.rooms[obRoom].SKMineral.pos.toPos()){
																	delete Memory.rooms[obRoom].SKMineral;
																	continue
															}
															room.memory.rally.toPos().highlight();
															let pos = Memory.rooms[obRoom].SKMineral.pos.toPos();
															let min = Memory.rooms[obRoom].SKMineral.type;
															pos.highlight('gold');
															Game.map.visual.text('trying', pos, {fontSize: 5});
															let swampcost = 5;
															if (config$1.swampyGround){
																	swampcost = 2;
															}
															let path = PathFinder.search(rally.pos, {pos: pos, range: 1}, {
																	roomCallback: function (roomName){
																			if (Game.map.isCoreRoom(roomName)){
																					let posA = new RoomPosition(35, 25, roomName);
																					Game.map.visual.text('core', posA, {fontSize: 5});
																					return false
																			}
																			if (Memory.ownedRooms[roomName]){
																					return false
																			}
																			if (Game.map.getRoomType(roomName) == 'SK'){
																					let matrix = Game.map.getSKMatrix(roomName);
																					if (matrix){
																							if (pos && pos.roomName === roomName){
																									let neighbours = pos.neighbours(8, true);
																									for (let n in neighbours){
																											let neighbour = neighbours[n];
																											let terrain = neighbour.getTerrain();
																											if (terrain === 'plain'){
																													matrix.set(neighbour.x, neighbour.y, 1);
																											} else if (terrain === 'swamp'){
																													matrix.set(neighbour.x, neighbour.y, 5);
																											}
																											if (neighbour.onEdge()){
																													matrix.set(neighbour.x, neighbour.y, 30);
																											} else if (neighbour.nearEdge() && neighbour.getTerrain() !== 'wall'){
																													matrix.set(neighbour.x, neighbour.y, 15);
																											}
																									}
																							}
																							return matrix
																					} else {
																							let pos = new RoomPosition(25, 25, roomName);
																							Game.map.visual.text('no matrix', pos);
																							return false
																					}
																			} else {
																					if (Game.rooms[roomName]){
																							return Game.rooms[roomName].structureMatrix
																					}
																			}
																	}, maxOps: 20000, swampCost: swampcost, maxRooms: 30
															});
															let range = 250;
															if (!config$1.official){
																	range = 130;
															}
															if (path && !path.incomplete && (!highestPriorityMineralRoom || priorityRange > path.path.length) && path.path.length < range){
																	//new RoomVisual().poly(path.path)
																	let canOverwrite = false;
																	if (!highestPriorityMineralRoom){
																			canOverwrite = true;
																	}
																	if (sortedMinerals && priorityMin && priorityRange && min){
																			//collect most needed minerals first
																			let minIndex = sortedMinerals.indexOf(min);
																			let priorityIndex = sortedMinerals.indexOf(priorityMin);
																			if (minIndex < priorityIndex || (minIndex === priorityIndex && path.path.length < priorityRange)){
																					canOverwrite = true;
																			}
																	} else if (priorityRange){
																			if (path.path.length < priorityRange){
																					canOverwrite = true;
																			}
																	}

																	if (canOverwrite){
																			Game.map.visual.poly(path.path, {stroke: '#00ff08'});
																			highestPriorityMineralRoom = pos.toString();
																			priorityRange = path.path.length;
																			bestPath = path;
																			priorityMin = min;
																	} else {
																			Game.map.visual.poly(path.path, {stroke: '#ff8400'});
																	}
															} else if (path && !path.incomplete){
																	Game.map.visual.poly(path.path, {stroke: '#ff8400'});
															} else if (path){
																	Game.map.visual.poly(path.path, {stroke: '#FF0000'});
															}
													}
											}
											if (canPath){
													playerHeap.lastMineralPath[room.name] = Game.time + 3000;
											}
											if (canPath && highestPriorityMineralRoom){
													let rally = Game.flags['rally' + room.name];
													Game.map.visual.text('closest', bestPath.path[bestPath.path.length - 1], {fontSize: 5});
													let end = bestPath.path[bestPath.path.length - 1].toString();
													bestPath = PathFinder.serializePath(rally.pos, bestPath);
													room.memory.SKMineralTarget = {
															pos: highestPriorityMineralRoom,
															path: bestPath,
															end: end
													};
											} else if (canPath){
													console.log('no closest', room.name);
											}
									} else if (config$1.mineralCollection && room.memory.SKMineralTarget && config$1.mapVisual){
											//let pos = room.memory.SKMineralTarget.pos.toPos()
											//Game.map.visual.text(room.name, pos);
									} else if (!config$1.mineralCollection){
											delete room.memory.SKMineralTarget;
									}
							} catch (err){
									console.log('SKM ' + err.stack.split("at"));
							}
							Memory.stats.cpu['SKM'] += Game.cpu.getUsed()-SKcpu;
							{
									let roomMiscCPU = Game.cpu.getUsed();
									//misc room stuff
									if (roomClass === 'normal'){
											if (!config$1.conserveCpu && Game.cpu.bucket > 5000){
													let drops = room.find(FIND_DROPPED_RESOURCES);
													for (let i in drops){
															if (drops[i].resourceType === 'energy'){
																	room.logEnergyStats('decay',Math.ceil(drops[i].amount/1000));
															}
													}
													let remoteDrops;
													if (roomCache && roomCache[room.name]){
															remoteDrops = roomCache[room.name];
													}
													if (remoteDrops){
															let drops = remoteDrops.drops;
															for (let i in drops){
																	let drop = Game.getObjectById(drops[i].drop);
																	if (drop){
																			room.logEnergyStats('decay',Math.ceil(drops[i].amount/1000));
																	}
															}
													}
											}
											if (room.controller.level < 4 && room.memory.storeContPosition && room.memory.storeContPosition.toPos() && Game.time % 5 === 0){
													//keep storecontpos clear
													let creep = room.memory.storeContPosition.toPos().lookAround(LOOK_CREEPS,0)[0];
													if (creep && creep.my && creep.countParts('move') === 0){
															let nearCreeps = creep.pos.lookAround(LOOK_CREEPS,1, {filter: (c) => c.my && c.countParts('move')>0});
															let nearCreep = nearCreeps[0];
															nearCreep.cancelOrder('move');
															nearCreep.pull(creep);
															creep.move(nearCreep);
															nearCreep.move(creep);
															nearCreep.skipTurn = true;
															if (creep.ticksToLive < 1300){
																	creep.suicide();
															}
													} else if (creep && creep.my){
															creep.rally(1);
													}
											}
											try {
													if (room.memory.supplyTo && !Game.energyCrisis && !Memory.emergency){
															for (let targetRoomName in room.memory.supplyTo){
																	for (let res in room.memory.supplyTo[targetRoomName]){
																			if (res === 'energy' && Memory.requestingEnergy){
																					continue
																			}
																			if (playerHeap.lastSupplyToAlly[targetRoomName] && playerHeap.lastSupplyToAlly[targetRoomName][res]
																					&& playerHeap.lastSupplyToAlly[targetRoomName][res] > Game.time - 60){
																					//recently supplied to this room - hold
																					//console.log('block recent supply to ',targetRoomName,res)
																					continue
																			}
																			let amountLeft = Number.parseInt(room.memory.supplyTo[targetRoomName][res]);
																			//console.log('supplying',res,'to:',targetRoomName,'from',room.name,' - remaining:',amountLeft)
																			if (amountLeft && amountLeft > 0){
																					if (config$1.canTransfer && config$1.canTransfer === false){
																							room.sendDonor(targetRoomName);
																					} else if (room.terminal && room.terminal.store && room.terminal.store[res] > 1000){
																							let amount = 500;
																							if (res === 'energy' && room.total(res) > room.memory.reserve+10000 && room.terminal.store[res] > 5000){
																									amount = 2500;
																							}
																							let send = room.terminal.send(res, amount, targetRoomName);
																							if (send === 0){
																									let user = 'unknown user';
																									if (Memory.ownedRooms[targetRoomName]){
																											user = Memory.ownedRooms[targetRoomName].owner;
																									}
																									console.log('ally transfer: supplied' ,user, res, 'to', targetRoomName, 'from',room.name);
																									room.memory.supplyTo[targetRoomName][res] -= amount;
																									if (!playerHeap.lastSupplyToAlly[targetRoomName]){
																											playerHeap.lastSupplyToAlly[targetRoomName] = {};
																									}
																									playerHeap.lastSupplyToAlly[targetRoomName][res] = Game.time;
																							}
																					}
																			} else {
																					delete room.memory.supplyTo[targetRoomName][res];
																			}
																	}
															}
													}
											} catch (err){
													console.log('donor ' + err.stack.split("at"));
											}
											if (config$1.harassRooms && config$1.harassRooms[room.name] && (!room.memory.hostileRemotes || Game.time % 5000 === 0)){
													if (!room.memory.hostileRemotes){
															room.memory.hostileRemotes = {};
													}
													let arr = config$1.harassRooms[room.name];
													let toHarass = [];
													for (let a in arr){
															let roomName = arr[a];
															let exits = Game.map.describeExits(roomName);
															for (let i in exits){
																	if (Game.map.getRoomType(exits[i]) === 'normal'){
																			toHarass.push(exits[i]);
																	}
															}
													}
													for (let hr in toHarass){
															room.memory.hostileRemotes[toHarass[hr]] = Game.time + 2000;
													}
											} else if (config$1.autoHarassEnemies){
													for (let i in room.memory.hostileRemotes){
															if (room.memory.hostileRemotes[i] < Game.time){
																	delete room.memory.hostileRemotes[i];
															}
													}
											} else if (Game.time % 100 === 0){
													delete room.memory.hostileRemotes;
											}
											try {
													if (room.memory.hostileRemotes){
															runHarassmentManager(room);
													}
											} catch (err){
													console.log(err);
											}
											if (!room.memory.levels){
													let date = new Date();
													room.memory.levels = {'start': Game.time, 'startTime': date.toUTCString()};
											} else {
													if (!room.memory.levels[room.controller.level]){
															delete room.memory.sites;
															if (room.controller.level === 7){
																	//find SK rooms to mine
																	delete room.memory.nearRoomList;
															}
															if (room.controller.level === 4 && ready()){
																	let structures = access(room.name).structures;
																	if (structures && structures.storage && structures.storage[0]){
																			let pos = structures.storage[0].toPos();
																			if (pos){
																					pos.createConstructionSite('storage');
																			}
																	}
															}
															buildRoom(room);
															room.memory.levels[room.controller.level] = Game.time - room.memory.levels['start'];
															if (room.memory.spawnStats && room.memory.spawnStats.spawning){
																	room.memory.levels[room.controller.level + '-nothing-queued'] = room.memory.spawnStats.nothingQueued / room.memory.spawnStats.ticks;
																	room.memory.levels[room.controller.level + '-low-energy'] = room.memory.spawnStats.lowEnergy / room.memory.spawnStats.ticks;
																	room.memory.levels[room.controller.level + '-spawn-ratio'] = room.memory.spawnStats.spawning / room.memory.spawnStats.ticks;
															}
															delete room.memory.spawnStats;
													}
													if (room.memory.roadsDown && !room.memory.levels.roadsDown){
															room.memory.levels.roadsDown = Game.time - room.memory.levels['start'];
													}
													if (room.storage && !room.memory.levels.storage){
															room.memory.levels.storage = Game.time - room.memory.levels['start'];
													}
													if (room.terminal && !room.memory.levels.terminal){
															room.memory.levels.terminal = Game.time - room.memory.levels['start'];
													}
													if (Game.gcl.level === 2 && !room.memory.levels.gcl2){
															room.memory.levels.gcl2 = Game.time - room.memory.levels['start'];
													}
													if (Game.gcl.level === 3 && !room.memory.levels.gcl3){
															room.memory.levels.gcl3 = Game.time - room.memory.levels['start'];
													}
											}
											if (room.memory.levels['start'] && !room.memory.clearedMemory && Game.time - room.memory.levels['start'] < 50 && Memory.myRooms && Memory.myRooms.length === 1){
													//starting room - clear Memory
													for (let i in Memory){
															if (i !== 'rooms' && i !== 'creeps' && i !== 'stats'){
																	delete Memory[i];
															}
													}
													room.memory.clearedMemory = true;
													return
											}
											if (config$1.symbolCollection && room.storage){
													if (!room.memory.symbolLocations){
															room.memory.symbolLocations = {};
													} else {
															let scoreCollector = 0;
															for (let i in room.memory.symbolLocations){
																	let symbolContainer = room.memory.symbolLocations[i];
																	let targetAmount = config$1.lowSymbolBound;
																	let type = symbolContainer.type;
																	if (Memory.decodersAvailable[type]){
																			targetAmount = config$1.highSymbolBound;
																	}
																	if ((room.storage && room.storage.store.getUsedCapacity() < room.storage.store.getCapacity() * 0.8)){
																			targetAmount = room.total(type) + 10000;
																	}
																	if (room.total(type) > targetAmount || !symbolContainer.expiry || symbolContainer.expiry < Game.time || !symbolContainer.amount || symbolContainer.amount == 0){
																			delete room.memory.symbolLocations[i];
																	} else {
																			scoreCollector++;
																			if (symbolContainer.amount && symbolContainer.amount > 5000){
																					scoreCollector++;
																			}
																	}
															}
															if (!scoreCollector && Memory.symbolDecoders && Memory.symbolDecoders[room.name] && Memory.symbolDecoders[room.name].type){
																	if (room.total(Memory.symbolDecoders[room.name].type) > config$1.highSymbolBound * 0.9){
																			//nearing full, may as well start decoding now
																			scoreCollector = true;
																	}
															}
															room.memory.scoreCollectorNeeded = scoreCollector;
													}
											} else {
													delete room.memory.symbolLocations;
													delete room.memory.scoreCollectorNeeded;
											}
											if (room.memory.fixedBaseDir && room.memory.tempFixedDir){
													delete room.memory.tempFixedDir;
													delete room.memory.tempOrigin;
											}
									}
									if (room && room.memory.factory && roomClass === 'normal'){
											let factory;
											if (room.memory.factory){
													factory = room.activeFactory;
											}
											let level = 0;
											if (factory){
													if (factory.level && factory.effects && factory.effects.length > 0){
															level = factory.level;
													}
													Game.map.visual.text(level, factory.pos, {color: '#c909ff',fontSize:25});
											}
											if (!level && config$1.factoryRooms){
													for (let list in config$1.factoryRooms){
															for (let item in config$1.factoryRooms[list]){
																	if (config$1.factoryRooms[list][item] == room.name){
																			level = list;
																	}
															}
													}
											}
											if (room.memory.factoryOperator && !Game.powerCreeps[room.memory.factoryOperator]){
													delete room.memory.factoryOperator;
											}
									}
									if (checkIfNeedToPauseInfrastructureDueToHarassment(room)){
											room.display('pause infrastructure');
									}
									try {
											adjustRemotesBasedOnSpawnUsage(room);
									} catch (err){
											console.log(err);
									}
									//controller count down
									if (room.controller.level < 8){
											let contcount = room.controller.progressTotal - room.controller.progress;
											if (contcount < 100000){
													new RoomVisual(room.name).text(contcount, room.controller.pos.x, room.controller.pos.y - 1);
											}
									}
									if (Game.cpu.bucket > 3000 && !room.memory.build){
											buildRoom(room);
									}
									if (room.memory.adjustedLowWallHits){
											room.display(`adjusted lowWallHits:  ${room.memory.adjustedLowWallHits}`);
									}
									let blockSafeMode = false;
									if (config$1.blockSafeMode && config$1.blockSafeMode.includes(room.name)){
											blockSafeMode = true;
									}
									if (Game.safemodeActive){
											blockSafeMode = true;
									}
									if (Game.time % 100 === 0 && room.energyCapacityAvailable > 1000){
											if ((room.memory.spawn && Game.spawns[room.memory.spawn]) || room.controller.level > 2){
													let neighbours = room.controller.pos.neighbours(1);
													for (let i in neighbours){
															if (neighbours[i].getTerrain() !== 'wall'){
																	neighbours[i].createConstructionSite('rampart');
															}
													}
											}
									}
									if (Game.flags['nukeSpam'+room.name]){
											let currentNukes = room.find(FIND_NUKES, {filter: (n) => n.timeToLand > (NUKE_LAND_TIME - SAFE_MODE_DURATION)})[0];
											let lowNuke = room.find(FIND_NUKES, {filter: (n) => n.timeToLand < SAFE_MODE_DURATION})[0];
											let nuker;
											if (!currentNukes){
													for (let r in Game.myRooms){
															let myRoom = Game.myRooms[r];
															let range = Game.map.getRoomLinearDistance(room.name,myRoom.name);
															if (range <= 10 && myRoom.memory.nuker){
																	let myNuker = Game.getObjectById(myRoom.memory.nuker);
																	if (myNuker && myNuker.store['energy'] === NUKER_ENERGY_CAPACITY && myNuker.store['G'] === NUKER_GHODIUM_CAPACITY && !myNuker.cooldown){
																			nuker = myNuker;
																			break
																	}
															}
													}
											}
											if (lowNuke && room.controller && !room.controller.safeMode && !room.controller.safeModeCooldown) {
													room.controller.activateSafeMode();
											}
											let best;
											if (!currentNukes && nuker){
													best = new RoomPosition(0,0,room.name);
											}
											console.log('nuke',nuker,best);
											if (best && (!nukeLaunched || Game.time !== nukeLaunched)){
													//console.log('can nuke: ', best, bestCost, room.controller.owner.username)
													console.log(`announcement|${Game.shard.name}|bombard ${room.name} from homeRoom`);
													nuker.launchNuke(best);
													nukeLaunched = Game.time;
											}
									}
									if (!blockSafeMode && (room.controller.ticksToDowngrade < CONTROLLER_DOWNGRADE[room.controller.level] * 0.6 || room.memory.armedHostiles) &&
											room.memory.defcon < 5 && (room.controller.level < 5 || !room.memory.spawn || !Game.spawns[room.memory.spawn] || room.memory.defcon < 3)
											&& (room.controller.safeMode == undefined || room.controller.safeMode < 300)){
											console.log('first safemode bit', room.name);
											if (Game.flags['NS'] && Game.flags['NS'].pos.roomName == room.name){
													let nukes = room.find(FIND_NUKES);
													let nuke;
													for (let i in nukes){
															if (!nuke || nukes[i].timeToLand < nuke.timeToLand){
																	nuke = nukes[i];
															}
													}
													if (!nuke || nuke.timeToLand < 20000){
															room.controller.activateSafeMode();
													}
											} else if (!blockSafeMode && room.controller.safeMode == undefined && room.controller.safeModeAvailable && room.controller.safeModeCooldown == undefined &&
													((room.memory.defcon < 4 && room.controller.ticksToDowngrade < CONTROLLER_DOWNGRADE[room.controller.level] * 0.6) || room.memory.armedHostiles)
													&& (!room.memory.adjustedLowWallHits || room.memory.adjustedLowWallHits < 5000000)){
													console.log('2nd safemode bit', room.name);
													if (!room.memory.nukeDefence && (!room.memory.adjustedLowWallHits || room.memory.adjustedLowWallHits < 100000)){
															room.controller.activateSafeMode();
													} else {
															let nukes = room.find(FIND_NUKES);
															let nuke;
															for (let i in nukes){
																	if (!nuke || nukes[i].timeToLand < nuke.timeToLand){
																			nuke = nukes[i];
																	}
															}
															if (nuke){
																	console.log(nuke, nuke.timeToLand);
															}
															if (nuke && nuke.timeToLand < 20000 && nuke.timeToLand > 5000){
																	room.controller.activateSafeMode();
															} else if (nuke && nuke.timeToLand < 10000 && (!room.memory.adjustedLowWallHits || room.memory.adjustedLowWallHits > 200000)); else if (room.controller.level > 7){
																	room.controller.activateSafeMode();
															}
													}
											}
											Game.notify('UNDER ATTACK', 0);
											Memory.supportNeeded[room.name] = true;
									} else {
											if (Memory.supportNeeded && Memory.supportNeeded[room.name]){
													delete Memory.supportNeeded[room.name];
											}
									}
									Memory.stats.cpu['roomMisc'] += Game.cpu.getUsed() - roomMiscCPU;
							}
							//power creeps - recruiting operators
							if (!room.memory.seasonOperator && roomClass === 'normal' && room.controller.level === 8 && config$1.season &&
									(config$1.season === 'thorium')){
									if (exports.operators){
											for (let j in exports.operators){
													let op = exports.operators[j];
													if (op && op.role == 'season' && !op.memory.home){
															op.memory.home = room.name;
															if (op.memory.home === room.name){
																	room.memory.seasonOperator = op.name;
																	break
															}
													}
											}
									}
							}
							//runs memorising finds to each room to save cpu
							var cpupremem = Game.cpu.getUsed();
							if (Game.time % 3 == 0){
									mainMemorise(room);
							}
							var cpupostmem = Game.cpu.getUsed();
							let spawn;
							if (room.memory.spawn){
									spawn = Game.spawns[room.memory.spawn];
							}
							if (spawn && !config$1.official){
									if (!room.memory.spawnStats){
											room.memory.spawnStats = {
													ticks: 0,
													spawning: 0
											};
									}
									room.memory.spawnStats.ticks++;
									if (spawn.spawning){
											room.memory.spawnStats.spawning++;
									}
							}
							Memory.stats.cpu['mem'] += (cpupostmem - cpupremem);

							//requesting support
							if (!Memory.supportNeeded){
									Memory.supportNeeded = {};
							}
							{ //room remote logic
									let cpuRem1 = Game.cpu.getUsed();
									//reducing yaks and remote miners if low on energy
									if (!room.memory.remoteAdjust){
											room.memory.remoteAdjust = 1;
									}
									if (room.total('energy') < room.memory.reserve * 0.8 && Memory.myRooms && (Game.time + room.index) % 500 == 0){
											if (room.memory.remoteAdjust > 0){
													room.memory.remoteAdjust -= 0.1;
											}
									} else if (room.total('energy') > room.memory.reserve * 0.9 && Memory.myRooms && (Game.time + room.index) % 500 == 0){
											if (room.memory.remoteAdjust < 1){
													room.memory.remoteAdjust += 0.1;
											}
									}
									if (room.memory.remoteAdjust < 0){
											room.memory.remoteAdjust = 0;
									} else if (room.memory.remoteAdjust > 1 || !Number.isFinite() || room.controller.level < 8){
											room.memory.remoteAdjust = 1;
									}

									//remote GC
									if (Game.time % 100 == 0){
											for (let i in room.memory.remoteContainers){
													let contMem = room.memory.remoteContainers[i];
													if (contMem && (!contMem.expiry || Game.time > contMem.expiry)){
															delete room.memory.remoteContainers[i];
													}
											}
									}
									if (room.memory.finalSources){
											for (let i = room.memory.finalSources.length - 1; i > -1; i--){
													if (!room.memory.finalSources[i]){
															room.memory.finalSources.splice(i, 1);
													}
											}
									}
									Memory.stats.cpu['remoteLogic'] += (Game.cpu.getUsed() - cpuRem1);
							}
							let cpuCom1 = Game.cpu.getUsed();
							if ((config$1.official || (config$1.season && config$1.season === 'caravan')) && roomClass === 'normal'){
									run$10(room);
							}
							Memory.stats.cpu['commodity'] += (Game.cpu.getUsed() - cpuCom1);
							//sending support
							let cpuSupport = Game.cpu.getUsed();
							if (!Memory.supportNeeded[room.name] && room.controller.level > 7 && roomClass === 'normal' &&
									(Object.entries(Memory.supportNeeded).length > 0 || room.memory.helpRoom)){
									let helpRoom = undefined;
									for (let i in Memory.supportNeeded){
											if (helpRoom){
													break
											}
											if (!Game.rooms[i] || !Game.rooms[i].controller.my){
													delete Memory.supportNeeded[i];
											}
											let range = Game.map.getRoomLinearDistance(i, room.name);
											if (range <= 7){
													helpRoom = i;
											}
									}
									if (helpRoom){
											room.memory.helpRoom = helpRoom;
									} else {
											if (room.memory.helpRoom){
													delete room.memory.helpRoom;
											}
									}
							}
							if (room.memory.defcon < 4){
									Memory.emergency = true;
							}

							//faceclaims
							if (room.memory.faceClaims && room.memory.faceClaims.length > 0){
									for (let r = room.memory.faceClaims.length-1;r > -1; r--){
											let fcRoomName = room.memory.faceClaims[r];
											if (Game.rooms[fcRoomName] && (!Game.rooms[fcRoomName].controller || !Game.rooms[fcRoomName].controller.owner || Game.rooms[fcRoomName].controller.my || Game.rooms[fcRoomName].controller.level === 8)){
													room.memory.faceClaims.splice(r,1);
											}
									}
									room.memory.faceClaimed = true;
							} else {
									delete room.memory.faceClaimed;
									delete room.memory.faceClaims;
							}

							//path clear up from memory
							if ((Game.time + room.index) % 50 == 0 && room.memory.paths){
									for (var p in room.memory.paths){
											if (room.memory.paths[p][1] < Game.time){
													delete room.memory.paths[p];
											}
									}
							}
							runSupportManager(room);
							Memory.stats.cpu['support'] += (Game.cpu.getUsed() - cpuSupport);
							var cpupreambush = Game.cpu.getUsed();
							//ambushers
							try {
									if (roomClass === 'normal'){
											ambush(room);
									}
							} catch (err){
									console.log('ambush ' + err.stack.split("at"));
							}
							var cpupostambush = Game.cpu.getUsed();
							Memory.stats.cpu['ambush'] += (cpupostambush - cpupreambush);

							var cpuprescout = Game.cpu.getUsed();
							//deploying scouts
							try {
									if ((Memory.myRooms.length === 1 && !room.memory.nearRoomList && room.memory.scout === undefined) ||(Game.time + room.index) % 2000 == 0 ||
											(Game.time % 100 == 0 && Game.cpu.bucket > 100) || (room.controller.level < 3 && Game.time % 25 === 0)){
											runScoutManager(room);
									}
							} catch (err){
									console.log('scout ' + err.stack.split("at"));
							}
							var cpupostscout = Game.cpu.getUsed();
							Memory.stats.cpu['scout'] += (cpupostscout - cpuprescout);

							if (room.controller.level == 8 && room.memory.finalSources && room.memory.finalSources.length < 6 && Game.time % 1000 == 0){
									console.log('remote source number', room.name, room.memory.finalSources.length);
							}


							//trade
							try {
									var cpupretrade = Game.cpu.getUsed();
									let interval = 50;
									if ((room.terminal && room.terminal.pos.lookFor(LOOK_FLAGS).length > 0) || room.memory.prayerSupportRoom || (room.memory.defcon && room.memory.defcon < 5)){
											interval = 10;
									}
									if (room.controller.level < 8 || (Game.flags['ShardTrade'] && Game.flags['ShardTrade'].room && Game.flags['ShardTrade'].room.name == room.name)
									|| room.memory.factoryOperator){
											interval = 20;
									}
									if (room.memory.boostingRequired && !room.memory.blabsFull){
											interval = 10;
									}
									if (Game.time % interval == 0){
											trade(room);
									}
									if ((Game.time + room.index) % 500 == 0 || (Game.cpu.bucket > 7000 && !room.memory.product && Game.time % 50 === 0)){
											chooseReaction(room);
									}
									var cpuposttrade = Game.cpu.getUsed();
									Memory.stats.cpu['trade'] += (cpuposttrade - cpupretrade);
							} catch (err){
									console.log('trade ' + err.stack.split("at"));
							}
							//obs
							var preobs = Game.cpu.getUsed();
							if (roomClass === 'normal' && (Game.cpu.bucket > 0 || Game.flags['PM' + room.name])){
									observe(room);
							}
							var postobs = Game.cpu.getUsed();
							Memory.stats.cpu['obs'] += (postobs - preobs);
							if (room.memory.defcon < 4){
									console.log(`defence alert|${Game.shard.name}|low defcon ... ${room.name} ... ${room.memory.defcon} ... hits: ${Number.parseFloat(room.memory.adjustedLowWallHits/1000000).toFixed(1)}M`);
							}
							let cpuProcessPower = Game.cpu.getUsed();
							//power
							if (roomClass === 'normal' && !Game.energyCrisis && !Memory.emergency && room.ecoStable && (!Game.energyCaution || (Game.market.credits > config$1.maxCredits*0.9 && room.memory.adjustedLowWallHits > (config$1.minWalls[room.controller.level]*0.9)))
									&& !room.memory.armedHostiles && room.memory.defcon === 5 && Memory.excessEnergy &&
									(room.total('energy')>room.memory.reserve*1.1 || (room.total('energy') > room.memory.reserve*1.05 && Memory.noLowLevelTerminals) || (config$1.season && config$1.season === 'thorium' && room.total('energy') > room.memory.reserve*0.9) ||
											(room.total('energy') > room.memory.reserve*0.95 && (Memory.noLowLevelTerminals || Memory.excessEnergy > 200000 || Game.market.credits > config$1.maxCredits) && config$1.official && Game.market.credits > config$1.maxCredits*0.8) )){
									room.memory.canLoadPowerSpawn = true;
							} else {
									delete room.memory.canLoadPowerSpawn;
							}
							let ps;
							if (room.memory.powerspawn){
									ps = Game.getObjectById(room.memory.powerspawn);
							}
							if (ps){
									if (room.memory.canLoadPowerSpawn){
											ps.pos.highlight('green');
									} else {
											ps.pos.highlight('red');
									}
							}
							if ((room.controller.level == 8 || (config$1.season && config$1.season === 'power' && room.controller.level > 4)) &&
									(config$1.processPower || config$1.processPower === undefined) && !room.memory.powerSupportRoom && roomClass === 'normal'){
									if (ps && (!config$1.official || Game.market.credits > config$1.maxCredits || !Game.energyCaution)){
											if (ps.store['power'] >= 1 && ps.store['energy'] >= 50){
													let ret = ps.processPower();
													if (config$1.logEnergy && ret === 0){
															room.logEnergyStats('powerCost', POWER_SPAWN_ENERGY_RATIO);
													}
											}
									}
							}
							Memory.stats.cpu['processPower'] += Game.cpu.getUsed()-cpuProcessPower;
							//todo dont cycle for compounds with small cooldowns in RCL 7
							//labs
							var cpuprelab = Game.cpu.getUsed();
							if (((Game.time % 10 == 0 || (room.controller.level < 8 && Game.time % 2 === 0)) || (Game.cpu.bucket > 9000 && Game.time % 2 == 0) || room.memory.boostingRequired)){
									react(room);
							}
							var cpupostlab = Game.cpu.getUsed();
							Memory.stats.cpu['lab'] += (cpupostlab - cpuprelab);

							//towers
							var cpupretower = Game.cpu.getUsed();
							runTowers(room);
							var cpuposttower = Game.cpu.getUsed();
							Memory.stats.cpu['towers'] += cpuposttower - cpupretower;
							let cpuLink = Game.cpu.getUsed();
							//links
							var importlinks = room.memory.importlinks;
							if (config$1.mapVisual){
									if (room.memory.defcon < 5){
											Game.map.visual.text('\u{26E8}', new RoomPosition(10, 10, room.name), {
													color: '#cf1b0e',
													fontSize: 15,
													opacity: 1
											});
									}
									let energy = room.total('energy');
									if (energy > room.memory.reserve * 1.1){
											Game.map.visual.text('\u{1F7E2}', new RoomPosition(25, 10, room.name));
									} else if (energy > room.memory.reserve){
											Game.map.visual.text('\u{1F7E1}', new RoomPosition(25, 10, room.name));
									} else if (energy > room.memory.reserve * 0.8){
											Game.map.visual.text('\u{1F7E0}', new RoomPosition(25, 10, room.name));
									} else {
											Game.map.visual.text('\u{1F534}', new RoomPosition(25, 10, room.name));
									}
									if (room.memory.alert && room.memory.alert === 'high'){
											Game.map.visual.text('\u{2757}', new RoomPosition(45, 10, room.name));
									}
							}
							var uplink = Game.getObjectById(room.memory.uplink);
							var linkstore = Game.getObjectById(room.memory.linkstore);
							let upLinkTransferThreshold = 150;
							if (room.total('energy') > room.memory.reserve * 1.1 && room.controller.level != 8){
									//likely need to transfer faster to praise quicker
									upLinkTransferThreshold = 300;
							}
							let storeLinks = [];
							if (linkstore){
									storeLinks.push(linkstore);
							}

							if (room.memory.extraLinks){
									for (let l in room.memory.extraLinks){
											let thisLink = Game.getObjectById(l);
											if (thisLink){
													if (room.memory.thoriumSupportLinkPos){
															if (thisLink.pos.toString() === room.memory.thoriumSupportLinkPos){
																	continue
															}
													}
													storeLinks.push(thisLink);
											}
									}
							}
							let repairLink = runRepairLink(room);
							if (Game.flags['supplyLink' + room.name]){
									delete room.memory.repairLinkLocation;
									Game.flags['supplyLink' + room.name].pos.lookAround(LOOK_STRUCTURES, 0, {filter: (s) => s.structureType == STRUCTURE_LINK})[0];
							}
							let linklist = [];
							if (importlinks != undefined && importlinks.length > 0){
									for (let i = 0; i < importlinks.length; i++){
											var link = Game.getObjectById(importlinks[i]);
											if (link && link.cooldown === 0 && link.store['energy'] >= 750 && (room.controller.level === 8 || link.isActive() == true) && (!repairLink || link.id != repairLink.id)){
													linklist.push(link);
											}
									}
							}
							let importLink;
							if ((linklist && linklist.length > 0 && ((uplink && uplink.store['energy'] < upLinkTransferThreshold) || (linkstore && linkstore.store['energy'] < 50))) || room.controller.ticksToDowngrade < CONTROLLER_DOWNGRADE[room.controller.level] - 1000){
									linklist.sort();
									importLink = linklist.sort(function (a, b){
											return (b.energy) - (a.energy)
									})[0];
							} else {
									importLink = null;
							}
							let supportLink;
							if (config$1.season && config$1.season === 'thorium'){
									if (room.memory.thoriumSupportLink){
											supportLink = Game.getObjectById(room.memory.thoriumSupportLink);
									}
									if (!supportLink && room.memory.thoriumSupportLinkPos){
											supportLink = room.memory.thoriumSupportLinkPos.toPos().lookAround(LOOK_STRUCTURES,0,{filter:(s)=>s.structureType === 'link'})[0];
											if (supportLink){
													room.memory.thoriumSupportLink = supportLink.id;
											}
									}
							}
							if (importLink){
									if (uplink && uplink.store['energy'] < upLinkTransferThreshold && room.memory.fillUpLink){
											importLink.transferEnergy(uplink);
											importLink.pos.highlight('green');
									} else if (repairLink && repairLink.store['energy'] < 50 &&
											room.storage.store['energy'] > room.memory.reserve - 15000){
											importLink.transferEnergy(repairLink);
									} else if (linkstore && linkstore.store['energy'] < 50){
											importLink.transferEnergy(linkstore);
									}
							} else if (supportLink && supportLink.store['energy'] < upLinkTransferThreshold && room.storage && room.memory.reserve){
									for (let i in storeLinks){
											let storeLink = storeLinks[i];
											if (storeLink && !storeLink.cooldown && storeLink.store['energy'] > 400){
													storeLink.transferEnergy(supportLink);
													break
											}
									}
							} else if (uplink && uplink.store['energy'] < upLinkTransferThreshold && room.storage && room.memory.reserve && room.memory.fillUpLink){
									for (let i in storeLinks){
											let storeLink = storeLinks[i];
											if (storeLink && !storeLink.cooldown && storeLink.store['energy'] > 400){
													storeLink.transferEnergy(uplink);
													storeLink.pos.highlight('gold');
													break
											}
									}
							} else if (repairLink && repairLink.store['energy'] < 150 && linkstore
									&& (room.storage.store['energy'] > room.memory.reserve || (Game.flags['supplyLink' + room.name] && room.storage.store['energy'] > room.memory.reserve * 0.5))){
									linkstore.transferEnergy(repairLink);
							}
							Memory.stats.cpu['link'] += Game.cpu.getUsed() - cpuLink;
							let ter = Game.cpu.getUsed();
							//contested territory
							if (roomClass === 'normal'){
									assignTerritory(room);
							}
							Memory.stats.cpu['assignTerritory'] += Game.cpu.getUsed() - ter;
					} else if (room.class === 'prayer'){
							if (!Memory.prayerRooms[room.name]){
									Memory.prayerRooms[room.name] = true;
							}
							var cpuprepray = Game.cpu.getUsed();
							pray(room);
							if (Game.time % 2 == 0){
									mainMemorise(room);
							}
							if (Game.time % 10 == 0){
									trade(room);
							}
							var cpupostpray = Game.cpu.getUsed();
							Memory.stats.cpu['pray'] += (cpupostpray - cpuprepray);
					}
			}

			if (dataRooms){
					Memory.data.rooms = dataRooms;
			}
	}

	function run$5(pc){
		let home;
		let num = pc.name.split('-')[1];
		if (pc.memory.home){
			home = Game.rooms[pc.memory.home];
		}
		let rally = Game.flags['rally' + home.name];
		if (home && pc.room.name == home.name){
			if (pc.ticksToLive < 100){
				let psMem = home.memory.powerspawn;
				let ps;
				if (psMem){
					ps = Game.getObjectById(psMem);
				}
				if (ps){
					if (pc.renew(ps) === ERR_NOT_IN_RANGE){
						pc.moveTo(ps, {maxRooms: 1});
					}
				}
			} else if (!home.controller.isPowerEnabled){
				if (pc.enableRoom(home.controller) === ERR_NOT_IN_RANGE){
					pc.moveTo(home.controller, {maxRooms: 1});
				}
			} else if (pc.carry[RESOURCE_OPS] && pc.carry[RESOURCE_OPS] > pc.carryCapacity * 0.75 && home && home.terminal && !home.memory.hostiles){
				let term = home.terminal;
				if (pc.transfer(term, RESOURCE_OPS, pc.carryCapacity * 0.5) === ERR_NOT_IN_RANGE){
					pc.moveTo(term, {maxRooms: 1});
				}
			} else {
				if (_.sum(pc.carry) < pc.carryCapacity && (Game.time + Number.parseInt(num)) % 5 == 0 && home && _.sum(home.storage.store) < home.storage.store.getCapacity() * 0.9 && home.storage.store['ops'] < 50000){
					pc.usePower(PWR_GENERATE_OPS);
				}
				//role specific logic
				if (home.memory.hostiles); else if (rally && !pc.pos.isNearTo(rally)){
					pc.say('rally');
					pc.moveTo(rally, {range: 1});
				}
			}
		}
	}

	var defender = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$5
	});

	function run$4(pc){
		let home;
		let num = pc.name.split('-')[1];

		if (pc.memory.home){
			home = Game.rooms[pc.memory.home];
		}
		if (home){
			if (!pc.memory.s3 || Game.time % 500 == 0){
				let closest;
				let currentDistance = 0;
				if (home.memory.minerPaths){
					for (let i in home.memory.minerPaths){
						let distance = home.memory.minerPaths[i].path.sPath.length;
						if (distance < currentDistance || !closest){
							closest = i;
							currentDistance = distance;
						}
					}
				}
				pc.memory.s3 = closest;
			}
			let rally = Game.flags['rally' + home.name];
			if (pc.ticksToLive < 200){
				pc.say('renew');
				let psMem = home.memory.powerspawn;
				let ps;
				if (psMem){
					ps = Game.getObjectById(psMem);
				}
				if (ps){
					if (pc.renew(ps) === ERR_NOT_IN_RANGE){
						pc.moveTo(ps, {maxRooms: 1});
					}
				}
			} else if (!home.controller.isPowerEnabled){
				pc.say('enable');
				if (pc.enableRoom(home.controller) === ERR_NOT_IN_RANGE){
					pc.moveTo(home.controller, {maxRooms: 1});
				}
			} else if (pc.carry[RESOURCE_OPS] && pc.carry[RESOURCE_OPS] > pc.carryCapacity * 0.75 && home.storage.store['ops'] < 50000 && home.terminal){
				pc.say('deposit');
				let term = home.terminal;
				if (pc.transfer(term, RESOURCE_OPS, pc.carryCapacity * 0.5) === ERR_NOT_IN_RANGE){
					pc.moveTo(term, {maxRooms: 1});
				}
			} else {
				if (_.sum(pc.carry) < pc.carryCapacity && (Game.time + Number.parseInt(num)) % 50 == 0){
					pc.usePower(PWR_GENERATE_OPS);
				}
				//role specific logic
				let s1, s2, min, s3p, s3;
				let s1m = home.memory.s1;
				let s2m = home.memory.s2;
				let minm = home.memory.mineral;
				let terminal = home.terminal;
				let store = home.storage;
				if (s1m){
					s1 = Game.getObjectById(s1m);
				}
				if (s2m){
					s2 = Game.getObjectById(s2m);
				}
				if (minm){
					min = Game.getObjectById(minm);
				}
				if (pc.memory.s3){
					s3p = pc.memory.s3.toPos();
					if (s3p && Game.rooms[s3p.roomName]){
						let source = s3p.lookAround(LOOK_SOURCES, 1)[0];
						if (source){
							s3 = source;
						}
					}
				}
				if (pc.powers[PWR_REGEN_SOURCE] && pc.powers[PWR_REGEN_SOURCE].cooldown > 50){
					s1 = null;
					s2 = null;
					s3 = null;
					delete pc.memory.target;
				}
				if (pc.powers[PWR_REGEN_MINERAL] && pc.powers[PWR_REGEN_MINERAL].cooldown > 0){
					min = null;
				}
				if (pc.powers[PWR_OPERATE_TERMINAL] && pc.powers[PWR_OPERATE_TERMINAL].cooldown > 0){
					terminal = null;
				}
				if (pc.powers[PWR_OPERATE_EXTENSION] && pc.powers[PWR_OPERATE_EXTENSION].cooldown > 0){
					store = null;
				}
				if (!pc.memory.target){
					if (s1 && (!s1.effects || s1.effects.length === 0 || s1.effects[0].ticksRemaining < 20)){
						pc.memory.target = s1.id;
					} else if (s2 && (!s2.effects || s2.effects.length === 0 || s2.effects[0].ticksRemaining < 20)){
						pc.memory.target = s2.id;
					} else if (s3 && (!s3.effects || s3 && (s3.effects.length === 0 || s3.effects[0].ticksRemaining < 50))){
						pc.memory.target = s3.id;
					}
				}
				let target;
				if (pc.memory.target){
					target = Game.getObjectById(pc.memory.target);
					if (!target){
						delete pc.memory.target;
					}
				}
				if (target != undefined){
					pc.say('source');
					if (!pc.pos.inRangeTo(target, 3) && target.room.controller.isPowerEnabled){
						pc.moveTo(target, {range: 3});
					} else if (pc.powers[PWR_REGEN_SOURCE] && pc.powers[PWR_REGEN_SOURCE].cooldown == 0){
						let test = pc.usePower(PWR_REGEN_SOURCE, target);
						if (test == -10){
							if (target.room.controller && pc.enableRoom(target.room.controller) == -9){
								pc.moveTo(target.room.controller, {range: 1});
							}
						} else if (test == -9){
							pc.moveTo(target, {range: 3});
						}
					} else if (pc.room.name != target.room.name){
						pc.moveTo(target);
					}
				} else if (pc.store['ops'] < 200 && home.terminal && home.terminal.store['ops'] > 200){
					if (pc.withdraw(home.terminal, 'ops') == -9){
						pc.moveTo(home.terminal, {range: 1});
					}
				} else if (store && home.energyAvailable < home.energyCapacityAvailable * 0.5 && (!store.effects || store.effects.length === 0 || !store.effects[0].ticksRemaining)){
					pc.say('exts');
					if (pc.usePower(PWR_OPERATE_EXTENSION, store) == ERR_NOT_IN_RANGE){
						pc.moveTo(store, {range: 3});
					} else {
						pc.usePower(PWR_OPERATE_EXTENSION, store);
					}
				} else if (min && (!min.effects || min.effects.length === 0 || !min.effects[0].ticksRemaining) && min.active){
					pc.say('min');
					if (pc.usePower(PWR_REGEN_MINERAL, min) == ERR_NOT_IN_RANGE){
						pc.moveTo(min, {range: 3});
					}
				} else if (pc.carry[RESOURCE_OPS] > 100 && terminal && (!terminal.effects || terminal.effects.length === 0 || !terminal.effects[0].ticksRemaining)){
					pc.say('term');
					if (pc.usePower(PWR_OPERATE_TERMINAL, terminal) == ERR_NOT_IN_RANGE){
						pc.moveTo(terminal, {range: 3});
					}
				} else if (rally && !pc.pos.isNearTo(rally)){
					pc.say('rally');
					pc.moveTo(rally, {range: 1});
				}
			}
		}
	}

	var eco = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$4
	});

	function run$3(pc){
		let deposit = false;
		let home;
		let num = pc.name.split('-')[1];
		if (pc.memory.home){
			home = Game.rooms[pc.memory.home];
		}
		let room = home;
		let costMatrix = undefined;
		if (!home){
			console.log('pc no home', pc);
			return
		}
		if (room.memory.hostiles && room.memory.defenceMatrix){
			let matrix = room.defenceMatrix;
				if (matrix){
						costMatrix = matrix;
				}
		}
		if (!room.memory.hostiles && pc.memory.nap && pc.memory.nap > Game.time && pc.ticksToLive > 200){
				pc.say('z');
				//console.log(pc.pos.hyperlink, 'pc sleeping')
				return
		}
		if (home){
			let rally = Game.flags['rally' + home.name];
			if (pc.ticksToLive < 200){
				pc.say('renew');
				let psMem = home.memory.powerspawn;
				let ps;
				if (psMem){
					ps = Game.getObjectById(psMem);
				}
				if (ps){
					if (pc.renew(ps) === ERR_NOT_IN_RANGE){
						pc.moveTo(ps);
					}
				}
			} else if (pc.hits < (pc.hitsMax * 0.8)){
				let tower = pc.pos.findClosestByRange(FIND_MY_STRUCTURES, {filter: (s) => s.structureType === STRUCTURE_TOWER});
				if (tower && (pc.pos.getRangeTo(tower) < 10 || (pc.home && Game.flags['rally'+pc.home.name] && pc.pos.inRangeTo(Game.flags['rally'+pc.home.name],2)))){
					tower.heal(pc);
				}
				pc.rally(1);
			} else if (!home.controller.isPowerEnabled){
				pc.say('enable');
				if (pc.enableRoom(home.controller) === ERR_NOT_IN_RANGE){
					pc.moveTo(home.controller);
				}
			} else if (pc.store[RESOURCE_OPS] && (pc.store[RESOURCE_OPS] > pc.store.getCapacity() * 0.75 || (deposit )) && home.storage.store['ops'] < 50000 && home.terminal){
				pc.say('deposit');
				let term = home.terminal;
				let amount = pc.carryCapacity * 0.5;
				if (pc.transfer(term, RESOURCE_OPS, amount) === ERR_NOT_IN_RANGE){
					pc.moveTo(term, { costCallback: () => {
							return costMatrix
						}
					});
				}
			} else {
				if (pc.store.getUsedCapacity() < pc.store.getCapacity() && (Game.time + Number.parseInt(num)) % 50 == 0){
					pc.usePower(PWR_GENERATE_OPS);
				}
				//role specific logic
				let factory;
				let squadsSpawning;
				if (home.memory.factory){
					factory = home.activeFactory;
				}
				let fLevel = Number.parseInt(pc.name.split('-')[1]);
				if (factory && fLevel && factory.level && factory.level !== fLevel){
					console.log(pc.name,'factory wrong');
				}
				// if (home.memory.squads){
				// 		for (let i in home.memory.squads){
				// 				let squad = home.memory.squads[i]
				// 				if (squad && squad.type != 'C' && squad.type != 'P'){
				// 						squadsSpawning = true
				// 				}
				// 		}
				// }
				if (!home.memory.hostiles && pc.powers[PWR_OPERATE_SPAWN] && !pc.powers[PWR_OPERATE_SPAWN].cooldown && !room.spawnFree && squadsSpawning){
					pc.say('ext');
					let spawns = room.find(FIND_STRUCTURES, {
						filter: (s) => {
							if (s.structureType != STRUCTURE_SPAWN){
								return false
							}
							let effects = s.effects;
							let noEffect = true;
							if (effects && effects.length > 0){
								effects.forEach((e) => {
									if (e.effect === PWR_OPERATE_SPAWN){
										noEffect = false;
									}
								});
							}
							return noEffect
						}
					});
					let target, power;
					if (spawns && spawns.length > 0){
						target = spawns[0];
						power = PWR_OPERATE_SPAWN;
					}
					console.log(power, target, target.pos, pc.store['ops'] >= POWER_INFO[power].ops, POWER_INFO[power].ops);
					if (power && target && pc.store['ops'] >= POWER_INFO[power].ops){
						if (pc.usePower(power, target) == -9){
							pc.moveTo(target, {
								range: POWER_INFO[power].range, costCallback: () => {
									return costMatrix
								}
							});
						} else {
							console.log('operator F', pc.usePower(power, target));
						}
					} else if (power && pc.store['ops'] < POWER_INFO[power].ops && home.terminal && home.terminal.store['ops'] > 0){
						pc.say('withdraw');
						if (pc.withdraw(home.terminal, 'ops') == -9){
							pc.moveTo(home.terminal, {
								range: 1, costCallback: () => {
									return costMatrix
								}
							});
						}
					}
				} else if (!home.memory.armedHostiles && factory && pc.powers[PWR_OPERATE_FACTORY] && !pc.powers[PWR_OPERATE_FACTORY].cooldown && (pc.powers[PWR_OPERATE_FACTORY].level === Number.parseInt(pc.name.split('-')[1])) && (!factory.effects || factory.effects.length < 1)){
					if (pc.usePower(PWR_OPERATE_FACTORY, factory) == -9){
						pc.moveTo(factory, {range: 3});
					} else if (pc.store['ops'] < POWER_INFO[PWR_OPERATE_FACTORY].ops && home.terminal && home.terminal.store['ops'] > 0){
						pc.say('withdraw');
						if (pc.withdraw(home.terminal, 'ops') == -9){
							pc.moveTo(home.terminal, {range: 1});
						}
					}
				} else if (room.memory.armedHostiles){
					pc.say('hostiles');
					let power;
					let target;
					if (pc.powers[PWR_OPERATE_TOWER] && !pc.powers[PWR_OPERATE_TOWER].cooldown){
						let towers = room.find(FIND_STRUCTURES, {
							filter: (t) => {
								if (t.structureType != STRUCTURE_TOWER){
									return false
								}
								let effects = t.effects;
								let noEffect = true;
								if (effects && effects.length > 0){
									effects.forEach((e) => {
										if (e.effect === PWR_OPERATE_TOWER){
											noEffect = false;
										}
									});
								}
								return noEffect
							}
						});
						if (towers && towers.length > 0){
							target = towers[0];
							power = PWR_OPERATE_TOWER;
						}
					}
					if (!target && pc.powers[PWR_OPERATE_SPAWN] && !pc.powers[PWR_OPERATE_SPAWN].cooldown && !room.spawnFree){
						let spawns = room.find(FIND_STRUCTURES, {
							filter: (s) => {
								if (s.structureType != STRUCTURE_SPAWN){
									return false
								}
								let effects = s.effects;
								let noEffect = true;
								if (effects && effects.length > 0){
									effects.forEach((e) => {
										if (e.effect === PWR_OPERATE_SPAWN){
											noEffect = false;
										}
									});
								}
								return noEffect
							}
						});
						if (spawns && spawns.length > 0){
							target = spawns[0];
							power = PWR_OPERATE_SPAWN;
						}
					}
					if (!target && pc.powers[PWR_FORTIFY] && !pc.powers[PWR_FORTIFY].cooldown && room.memory.lowWall && Game.getObjectById(room.memory.lowWall)){
						let wall = Game.getObjectById(room.memory.lowWall);
						if (wall.pos.lookAround(LOOK_CREEPS, 5, {filter: (c) => !c.my})){
							target = wall;
							power = PWR_FORTIFY;
						}
					}
					if (power && target && pc.store['ops'] >= POWER_INFO[power].ops){
						if (pc.usePower(power, target) == -9){
							pc.moveTo(target, {
								range: POWER_INFO[power].range, costCallback: () => {
									return costMatrix
								}
							});
						}
					} else if (power && pc.store['ops'] < POWER_INFO[power].ops && home.terminal && home.terminal.store['ops'] > 0 && (!home.terminal.effects ||home.terminal.effects.length === 0)){
						pc.say('withdraw');
						if (pc.withdraw(home.terminal, 'ops') == -9){
							pc.moveTo(home.terminal, {
								range: 1, costCallback: () => {
									return costMatrix
								}
							});
						}
					} else if (power && pc.store['ops'] < POWER_INFO[power].ops && home.storage && home.storage.store['ops'] > 0){
						pc.say('withdraw');
						if (pc.withdraw(home.storage, 'ops') == -9){
							pc.moveTo(home.storage, {
								range: 1, costCallback: () => {
									return costMatrix
								}
							});
						}
					}
				} else if (pc.powers[PWR_REGEN_SOURCE] && !pc.powers[PWR_REGEN_SOURCE].cooldown){
					//pc.say('source')
					let source = getSource(home);
					if (source){
						pc.say(source.pos.x+','+source.pos.y);
						let power = PWR_REGEN_SOURCE;
						let target = source;
						if (pc.usePower(power, target) == -9){
							pc.moveTo(target, {
								range: POWER_INFO[power].range, costCallback: () => {
									return costMatrix
								}
							});
						}
					}
				} else if (pc.powers[PWR_REGEN_MINERAL] && !pc.powers[PWR_REGEN_MINERAL].cooldown){
					let mineral = home.mineral;
					if (mineral){
						let power = PWR_REGEN_SOURCE;
						let target = mineral;
						if (pc.usePower(power, target) == -9){
							pc.moveTo(target, {
								range: POWER_INFO[power].range, costCallback: () => {
									return costMatrix
								}
							});
						}
					}
				} else if (rally && !pc.pos.inRangeTo(rally, 1)){
					pc.moveTo(rally, {
						range: 1
					});
				} else if (!rally && !home.memory.hostiles && home.controller && !pc.pos.inRangeTo(home.controller, 3)){
					pc.moveTo(home.controller, {
						range: 3, costCallback: () => {
							return costMatrix
						}
					});
				} else {
						let lowestCoolDown = 10;
						for (let i in pc.powers){
								if (pc.powers[i].cooldown && pc.powers[i].cooldown < lowestCoolDown){
										lowestCoolDown = pc.powers[i].cooldown;
								}
						}
						pc.memory.nap = Game.time + lowestCoolDown;
				}
			}
		}
	}

	var F = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$3
	});

	function run$2(pc){
		let home;
		let num = pc.name.split('-')[1];
		if (pc.memory.home){
			home = Game.rooms[pc.memory.home];
		}
		let rally = Game.flags['rally' + home.name];
		let prayerFlag = Game.flags['priest' + pc.memory.home];
		if (home){
			if (pc.ticksToLive < 300){
				let psMem = home.memory.powerspawn;
				let ps;
				if (psMem){
					ps = Game.getObjectById(psMem);
				}
				if (ps){
					if (pc.renew(ps) === ERR_NOT_IN_RANGE){
						pc.moveTo(ps);
					}
				}
			} else if (!home.controller.isPowerEnabled){
				if (pc.enableRoom(home.controller) === ERR_NOT_IN_RANGE){
					pc.moveTo(home.controller, {maxRooms: 1});
				}
			} else if (pc.carry[RESOURCE_OPS] && pc.carry[RESOURCE_OPS] > pc.carryCapacity * 0.75 && home && home.terminal && !home.memory.hostiles){
				let term = home.terminal;
				if (pc.transfer(term, RESOURCE_OPS, pc.carryCapacity * 0.5) === ERR_NOT_IN_RANGE){
					pc.moveTo(term, {maxRooms: 1});
				}
			} else {
				if (_.sum(pc.carry) < pc.carryCapacity && (Game.time + Number.parseInt(num)) % 5 == 0){
					pc.usePower(PWR_GENERATE_OPS);
				}
				//role specific logic
				if (prayerFlag){
					if (Game.rooms[prayerFlag.pos.roomName]){
						let pRoom = Game.rooms[prayerFlag.pos.roomName];
						if (!pRoom.controller.isPowerEnabled){
							if (pc.enableRoom(pRoom.controller) === ERR_NOT_IN_RANGE){
								pc.moveTo(pRoom.controller);
							}
						} else if (!pc.pos.isEqualTo(prayerFlag.pos)){
							pc.moveTo(prayerFlag);
						} else {
							let store = pRoom.storage;
							if (store && (!store.effects || store.effects.length === 0 || !store.effects[0].ticksRemaining)){
								pc.say('storage');
								pc.usePower(PWR_OPERATE_STORAGE, store);
							}
						}
					} else {
						pc.moveTo(prayerFlag);
					}
				} else if (rally && !pc.pos.isNearTo(rally)){
					pc.say('rally');
					pc.moveTo(rally, {range: 1});
				}
			}
		}
	}

	var priest = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$2
	});

	function run$1(pc){
			const deposit = false;
			let home;
			let num = pc.name.split('-')[1];
			if (pc.memory.home){
					home = Game.rooms[pc.memory.home];
			}
			pc.home = home;
			let room = home;
			let costMatrix = undefined;
			if (room.memory.hostiles && room.memory.defenceMatrix){
					let matrix = room.defenceMatrix;
					if (matrix){
							costMatrix = matrix;
					}
			}
			if (home){
					Game.flags['rally' + home.name];
					if (pc.room.name !== home.name){
							pc.moveTo(home.controller,{range:1});
					}
					if (pc.ticksToLive < 200){
							pc.say('renew');
							let psMem = home.memory.powerspawn;
							let ps;
							if (psMem){
									ps = Game.getObjectById(psMem);
							}
							if (ps){
									if (pc.renew(ps) === ERR_NOT_IN_RANGE){
											pc.moveTo(ps);
									}
							}
					} else if (pc.hits < pc.hitsMax * 0.8){
							pc.rally(1);
							pc.say('me');
							let tower = pc.pos.findClosestByRange(FIND_MY_STRUCTURES, {filter: (s) => s.structureType === STRUCTURE_TOWER});
							if (tower && pc.pos.getRangeTo(tower) < 10){
									tower.heal(pc);
							}
					} else if (!home.controller.isPowerEnabled){
							pc.say('enable');
							if (pc.enableRoom(home.controller) === ERR_NOT_IN_RANGE){
									console.log('enable',pc.moveTo(home.controller));
							}
					} else if (pc.store[RESOURCE_OPS] && (pc.store[RESOURCE_OPS] > pc.store.getCapacity() * 0.75 || (deposit )) && home.storage.store['ops'] < 50000 && home.terminal){
							pc.say('deposit');
							let term = home.terminal;
							let amount = pc.carryCapacity * 0.5;
							if (pc.transfer(term, RESOURCE_OPS, amount) === ERR_NOT_IN_RANGE){
									pc.moveTo(term);
							}
					} else {
							if (pc.store.getUsedCapacity() < pc.store.getCapacity() && (Game.time + Number.parseInt(num)) % 50 == 0){
									pc.usePower(PWR_GENERATE_OPS);
							}
							if (home.memory.armedHostiles){
									let power;
									let target;
									if (pc.powers[PWR_OPERATE_TOWER] && !pc.powers[PWR_OPERATE_TOWER].cooldown){
											let towers = room.find(FIND_STRUCTURES, {
													filter: (t) => {
															if (t.structureType != STRUCTURE_TOWER){
																	return false
															}
															let effects = t.effects;
															let noEffect = true;
															if (effects && effects.length > 0){
																	effects.forEach((e) => {
																			if (e.effect === PWR_OPERATE_TOWER){
																					noEffect = false;
																			}
																	});
															}
															return noEffect
													}
											});
											if (towers && towers.length > 0){
													target = towers[0];
													power = PWR_OPERATE_TOWER;
											}
									}
									if (!target && pc.powers[PWR_OPERATE_SPAWN] && !pc.powers[PWR_OPERATE_SPAWN].cooldown && !room.spawnFree){
											let spawns = room.find(FIND_STRUCTURES, {
													filter: (s) => {
															if (s.structureType != STRUCTURE_SPAWN){
																	return false
															}
															let effects = s.effects;
															let noEffect = true;
															if (effects && effects.length > 0){
																	effects.forEach((e) => {
																			if (e.effect === PWR_OPERATE_SPAWN){
																					noEffect = false;
																			}
																	});
															}
															return noEffect
													}
											});
											if (spawns && spawns.length > 0){
													target = spawns[0];
													power = PWR_OPERATE_SPAWN;
											}
									}
									if (!target && pc.powers[PWR_FORTIFY] && !pc.powers[PWR_FORTIFY].cooldown && room.memory.lowWall && Game.getObjectById(room.memory.lowWall)){
											let wall = Game.getObjectById(room.memory.lowWall);
											if (wall.pos.lookAround(LOOK_CREEPS, 5, {filter: (c) => !c.my})){
													target = wall;
													power = PWR_FORTIFY;
											}
									}
									if (power && target && pc.store['ops'] >= POWER_INFO[power].ops){
											if (pc.usePower(power, target) == -9){
													pc.moveTo(target, {
															range: POWER_INFO[power].range, costCallback: () => {
																	return costMatrix
															}
													});
											}
									} else if (power && pc.store['ops'] < POWER_INFO[power].ops && home.terminal && home.terminal.store['ops'] > 0){
											pc.say('withdraw');
											if (pc.withdraw(home.terminal, 'ops') == -9){
													pc.moveTo(home.terminal, {
															range: 1, costCallback: () => {
																	return costMatrix
															}
													});
											}
									}
							} else if (pc.powers[PWR_REGEN_MINERAL] && (!pc.powers[PWR_REGEN_MINERAL].cooldown || pc.powers[PWR_REGEN_MINERAL].cooldown<20)){
									let mineral = home.mineral;
									if (config.season && config.season === 'thorium'){
											mineral = pc.home.find(FIND_MINERALS,{filter:(m)=>m.mineralType === 'T'})[0];
											if (!mineral){
													mineral = home.mineral;
											}
									}
									if (mineral){
											let power = PWR_REGEN_MINERAL;
											let target = mineral;
											if (pc.usePower(power, target) == -9){
													pc.moveTo(target, {
															range: POWER_INFO[power].range, costCallback: () => {
																	return costMatrix
															}
													});
											}
									}
							} else if (pc.powers[PWR_REGEN_SOURCE] && !pc.powers[PWR_REGEN_SOURCE].cooldown){
									//pc.say('source')
									let source = getSource(home);
									if (source){
											pc.say(source.pos.x+','+source.pos.y);
											let power = PWR_REGEN_SOURCE;
											let target = source;
											if (pc.usePower(power, target) == -9){
													pc.moveTo(target, {
															range: POWER_INFO[power].range, costCallback: () => {
																	return costMatrix
															}
													});
											}
									}
							} else if (pc.powers[PWR_OPERATE_SPAWN] && !pc.powers[PWR_OPERATE_SPAWN].cooldown && !room.spawnFree && room.total('ops')>3000 &&
							pc.store['ops']>100){
									let spawns = room.find(FIND_STRUCTURES, {
											filter: (s) => {
													if (s.structureType != STRUCTURE_SPAWN){
															return false
													}
													let effects = s.effects;
													let noEffect = true;
													if (effects && effects.length > 0){
															effects.forEach((e) => {
																	if (e.effect === PWR_OPERATE_SPAWN){
																			noEffect = false;
																	}
															});
													}
													return noEffect
											}
									});
									let target,power;
									if (spawns && spawns.length > 0){
											target = spawns[0];
											power = PWR_OPERATE_SPAWN;
									}
									if (power && target && pc.usePower(power, target) == -9){
											pc.moveTo(target, {
													range: POWER_INFO[power].range, costCallback: () => {
															return costMatrix
													}
											});
									}
							} else if (pc.store.getFreeCapacity() > 100 && home.storage){
									findEnergyTarget(home, pc);
							} else if (pc.store['energy'] > 0 && home.storage){
									if (pc.transfer(home.storage, 'energy') === -9){
											pc.moveTo(home.storage, {range: 1});
									}
							} else {
									pc.rally(1);
							}
					}
			}
	}

	var season = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run$1
	});

	var silencer = /*#__PURE__*/Object.freeze({
		__proto__: null
	});

	function run(pc){
			let deposit = false;
			let home;
			let num = pc.name.split('-')[1];
			let renew = false;
			if (Game.flags['spawnSupport']){
					home = Game.rooms[Game.flags['spawnSupport'].pos.roomName];
					if (home && pc.memory.home && home.name !== pc.memory.home && pc.room.name === pc.memory.home &&
							pc.ticksToLive > 4000 &&  Memory.rooms[pc.memory.home] && Memory.rooms[pc.memory.home].supportRooms
					&& Memory.rooms[pc.memory.home].supportRooms.rooms){
							let closest, closestRange;
							for (let i in Memory.rooms[pc.memory.home].supportRooms.rooms){
									let range = Game.map.getRoomLinearDistance(i,home.name);
									if (!closest || closestRange> range){
											closest = i;
											closestRange = range;
									}
							}
							if (closest){
									console.log('trying to change spawn support close room to',closest);
									pc.memory.home = closest;
							}
					} else if (home && pc.memory.home && home.name !== pc.memory.home && pc.room.name === pc.memory.home){
							renew = true;
							console.log('force renew spawnSupport');
					}
			}
			if (pc.memory.home){
					home = Game.rooms[pc.memory.home];
			}
			if (pc.room.name !== home.name){
					pc.goTo(home.name);
					return
			}
			let room = home;
			let costMatrix = undefined;
			if (!home){
					console.log('pc no home', pc);
					return
			}
			if (room.memory.hostiles && room.memory.defenceMatrix){
					let matrix = room.defenceMatrix;
					if (matrix){
							costMatrix = matrix;
					}
			}
			if (!room.memory.hostiles && pc.memory.nap && pc.memory.nap > Game.time && pc.ticksToLive > 200){
					pc.say('z');
					//console.log(pc.pos.hyperlink, 'pc sleeping')
					return
			}
			if (home){
					let rally = Game.flags['rally' + home.name];
					if (pc.ticksToLive < 200 || renew){
							pc.say('renew');
							let psMem = home.memory.powerspawn;
							let ps;
							if (psMem){
									ps = Game.getObjectById(psMem);
							}
							if (ps){
									if (pc.renew(ps) === ERR_NOT_IN_RANGE){
											pc.moveTo(ps);
									}
							}
					} else if (pc.hits < (pc.hitsMax * 0.8)){
							let tower = pc.pos.findClosestByRange(FIND_MY_STRUCTURES, {filter: (s) => s.structureType === STRUCTURE_TOWER});
							if (tower && (pc.pos.getRangeTo(tower) < 10 || (pc.home && Game.flags['rally'+pc.home.name] && pc.pos.inRangeTo(Game.flags['rally'+pc.home.name],2)))){
									tower.heal(pc);
							}
							pc.rally(1);
					} else if (!home.controller.isPowerEnabled){
							pc.say('enable');
							if (pc.enableRoom(home.controller) === ERR_NOT_IN_RANGE){
									pc.moveTo(home.controller);
							}
					} else if (pc.store[RESOURCE_OPS] && (pc.store[RESOURCE_OPS] > pc.store.getCapacity() * 0.75 || (deposit )) && home.storage.store['ops'] < 50000 && home.terminal){
							pc.say('deposit');
							let term = home.terminal;
							let amount = pc.carryCapacity * 0.5;
							if (pc.transfer(term, RESOURCE_OPS, amount) === ERR_NOT_IN_RANGE){
									pc.moveTo(term, { costCallback: () => {
													return costMatrix
											}
									});
							}
					} else {
							if (pc.store.getUsedCapacity() < pc.store.getCapacity() && (Game.time + Number.parseInt(num)) % 50 == 0){
									pc.usePower(PWR_GENERATE_OPS);
							}
							let store = home.storage;
							if (!home.memory.armedHostiles && pc.powers[PWR_OPERATE_SPAWN] && !pc.powers[PWR_OPERATE_SPAWN].cooldown && !room.spawnFree && room.memory.activeSiege){
									pc.say('ext');
									let spawns = room.find(FIND_STRUCTURES, {
											filter: (s) => {
													if (s.structureType != STRUCTURE_SPAWN){
															return false
													}
													let effects = s.effects;
													let noEffect = true;
													if (effects && effects.length > 0){
															effects.forEach((e) => {
																	if (e.effect === PWR_OPERATE_SPAWN){
																			noEffect = false;
																	}
															});
													}
													return noEffect
											}
									});
									let target, power;
									if (spawns && spawns.length > 0){
											target = spawns[0];
											power = PWR_OPERATE_SPAWN;
									}
									//console.log(power, target, pc.store['ops'] >= POWER_INFO[power].ops, POWER_INFO[power].ops)
									if (power && target && pc.store['ops'] >= POWER_INFO[power].ops){
											if (pc.usePower(power, target) == -9){
													pc.moveTo(target, {
															range: POWER_INFO[power].range, costCallback: () => {
																	return costMatrix
															}
													});
											} else {
													console.log('operator SS', pc.usePower(power, target));
											}
									} else if (power && pc.store['ops'] < POWER_INFO[power].ops && home.terminal && home.terminal.store['ops'] > 0){
											pc.say('withdraw');
											if (pc.withdraw(home.terminal, 'ops') == -9){
													pc.moveTo(home.terminal, {
															range: 1, costCallback: () => {
																	return costMatrix
															}
													});
											}
									}
							} else if (pc.powers[PWR_OPERATE_EXTENSION] && !pc.powers[PWR_OPERATE_EXTENSION].cooldown && store && home.energyAvailable < home.energyCapacityAvailable * 0.5 && (!store.effects || store.effects.length === 0 || !store.effects[0].ticksRemaining)){
											pc.say('exts');
											if (pc.usePower(PWR_OPERATE_EXTENSION, store) == ERR_NOT_IN_RANGE){
													pc.moveTo(store, {range: 3});
											} else {
													pc.usePower(PWR_OPERATE_EXTENSION, store);
											}
							} else if (room.memory.armedHostiles){
									pc.say('hostiles');
									let power;
									let target;
									if (pc.powers[PWR_OPERATE_TOWER] && !pc.powers[PWR_OPERATE_TOWER].cooldown){
											let towers = room.find(FIND_STRUCTURES, {
													filter: (t) => {
															if (t.structureType != STRUCTURE_TOWER){
																	return false
															}
															let effects = t.effects;
															let noEffect = true;
															if (effects && effects.length > 0){
																	effects.forEach((e) => {
																			if (e.effect === PWR_OPERATE_TOWER){
																					noEffect = false;
																			}
																	});
															}
															return noEffect
													}
											});
											if (towers && towers.length > 0){
													target = towers[0];
													power = PWR_OPERATE_TOWER;
											}
									}
									if (!target && pc.powers[PWR_OPERATE_SPAWN] && !pc.powers[PWR_OPERATE_SPAWN].cooldown && !room.spawnFree){
											let spawns = room.find(FIND_STRUCTURES, {
													filter: (s) => {
															if (s.structureType != STRUCTURE_SPAWN){
																	return false
															}
															let effects = s.effects;
															let noEffect = true;
															if (effects && effects.length > 0){
																	effects.forEach((e) => {
																			if (e.effect === PWR_OPERATE_SPAWN){
																					noEffect = false;
																			}
																	});
															}
															return noEffect
													}
											});
											if (spawns && spawns.length > 0){
													target = spawns[0];
													power = PWR_OPERATE_SPAWN;
											}
									}
									if (!target && pc.powers[PWR_FORTIFY] && !pc.powers[PWR_FORTIFY].cooldown && room.memory.lowWall && Game.getObjectById(room.memory.lowWall)){
											let wall = Game.getObjectById(room.memory.lowWall);
											if (wall.pos.lookAround(LOOK_CREEPS, 5, {filter: (c) => !c.my})){
													target = wall;
													power = PWR_FORTIFY;
											}
									}
									if (power && target && pc.store['ops'] >= POWER_INFO[power].ops){
											if (pc.usePower(power, target) == -9){
													pc.moveTo(target, {
															range: POWER_INFO[power].range, costCallback: () => {
																	return costMatrix
															}
													});
											}
									} else if (power && pc.store['ops'] < POWER_INFO[power].ops && home.terminal && home.terminal.store['ops'] > 0 && (!home.terminal.effects ||home.terminal.effects.length === 0)){
											pc.say('withdraw');
											if (pc.withdraw(home.terminal, 'ops') == -9){
													pc.moveTo(home.terminal, {
															range: 1, costCallback: () => {
																	return costMatrix
															}
													});
											}
									} else if (power && pc.store['ops'] < POWER_INFO[power].ops && home.storage && home.storage.store['ops'] > 0){
											pc.say('withdraw');
											if (pc.withdraw(home.storage, 'ops') == -9){
													pc.moveTo(home.storage, {
															range: 1, costCallback: () => {
																	return costMatrix
															}
													});
											}
									}
							} else if (pc.powers[PWR_REGEN_SOURCE] && !pc.powers[PWR_REGEN_SOURCE].cooldown){
									//pc.say('source')
									let source = getSource(home);
									if (source){
											pc.say(source.pos.x+','+source.pos.y);
											let power = PWR_REGEN_SOURCE;
											let target = source;
											if (pc.usePower(power, target) == -9){
													pc.moveTo(target, {
															range: POWER_INFO[power].range, costCallback: () => {
																	return costMatrix
															}
													});
											}
									}
							} else if (pc.powers[PWR_REGEN_MINERAL] && !pc.powers[PWR_REGEN_MINERAL].cooldown){
									let mineral = home.mineral;
									if (mineral){
											let power = PWR_REGEN_SOURCE;
											let target = mineral;
											if (pc.usePower(power, target) == -9){
													pc.moveTo(target, {
															range: POWER_INFO[power].range, costCallback: () => {
																	return costMatrix
															}
													});
											}
									}
							} else if (rally && !pc.pos.inRangeTo(rally, 1)){
									pc.moveTo(rally, {
											range: 1
									});
							} else if (!rally && !home.memory.hostiles && home.controller && !pc.pos.inRangeTo(home.controller, 3)){
									pc.moveTo(home.controller, {
											range: 3, costCallback: () => {
													return costMatrix
											}
									});
							} else {
									let lowestCoolDown = 10;
									for (let i in pc.powers){
											if (pc.powers[i].cooldown && pc.powers[i].cooldown < lowestCoolDown){
													lowestCoolDown = pc.powers[i].cooldown;
											}
									}
									pc.memory.nap = Game.time + lowestCoolDown;
							}
					}
			}
	}

	var spawnSupport = /*#__PURE__*/Object.freeze({
		__proto__: null,
		run: run
	});

	var OperatorModules = /*#__PURE__*/Object.freeze({
		__proto__: null,
		defender: defender,
		eco: eco,
		F: F,
		priest: priest,
		season: season,
		silencer: silencer,
		spawnSupport: spawnSupport
	});

	for (let i in OperatorModules){
			console.log('initialising',i);
	}
	function runPCs(){
		if (Game.time % 1 === 0 && config.powerCreepSchema){
			autoUpgrade();
		}
		//use to wipe power creeps - only do this if exp period is on
		// delete Memory.powerCreeps
		// for (let i in Game.powerCreeps){
		// 	Game.powerCreeps[i].suicide()
		// 	Game.powerCreeps[i].delete()
		// }
		// return
		for (let i in Game.powerCreeps){
			let pc = Game.powerCreeps[i];
			if (pc.memory && !pc.memory.active){
				pc.memory.active = false;
			}
			let role = pc.name.split('-')[0];
			if (pc.room !== undefined){
				if (pc.className == 'operator' && pc.owner.username == Game.username){
					try {
						if (role){
							let str = role;
							let module = OperatorModules[str];
							if (module){
								module.run(pc);
							}
						}
					} catch (err){
						console.log(err.stack.split("at"));
					}
				} else {
					Memory.foreignPC = pc.name;
				}
			} else if (pc.memory.home){
					console.log('awaitin spawn,',pc.name);
				let room = Game.rooms[pc.memory.home];
				if (!room.memory.factory && role === 'F'){
					delete pc.memory.home;
					continue
				}
				if (role === 'F'){
					let factory = room.activeFactory;
					if (!factory || (factory.level && factory.level.toString() != pc.name.split('-')[1])){
						console.log('bad home', pc.name);
						delete pc.memory.home;
						delete room.memory.factoryOperator;
						continue
					}
				}
				if (room && !room.memory.factoryOperator && role == 'F'){
					room.memory.factoryOperator = pc.name;
				}
				if (room && room.controller && room.controller.my && (room.controller.level > 6 || config.season)){
					let psMem = room.memory.powerspawn;
					let ps;
					if (psMem){
						ps = Game.getObjectById(psMem);
					}
					if (ps){
						pc.spawn(ps);
					} else {
						delete pc.memory.home;
					}
				} else {
					delete pc.memory.home;
				}
			} else if (pc.role === 'F'){
				let pickedRoom, bestDistance,level;
				let averageRoomName;
				if (Memory.market && Memory.market.averageRoomName){
					averageRoomName = Memory.market.averageRoomName;
				}
				let alertList = [];
				let normalList = [];
				for (let i in Game.myRooms){
					let room = Game.myRooms[i];
					if (room.memory.alert){
						alertList.push(room);
					} else {
						normalList.push(room);
					}
				}
				if (Number.parseInt(pc.name.split('-')[1])>3){
					pickRoom(alertList);
				}
				pickRoom(normalList);
				function pickRoom(rooms){
					if (pickedRoom){
						return
					}
					for (let i in rooms){
						let room = rooms[i];
						let distance = 1;
						if (averageRoomName){
							distance = Game.map.getRoomLinearDistance(averageRoomName, room.name);
						}
						if (room && !room.memory.factoryOperator && room.controller.level > 7 && room.memory.powerspawn && room.memory.factory){
							let factory = room.activeFactory;
							let ps = Game.getObjectById(room.memory.powerspawn);
							if (factory && ps && factory.level && factory.level.toString() === pc.name.split('-')[1]){
								pickedRoom = room;
								level = ps.level;
								break
							} else if (Number.parseInt(pc.name.split('-')[1])>3 && room.memory.alert && factory && ps && !factory.level){
								//prioritise alert rooms
								pickedRoom = room;
								level = ps.level;
								break
							}  else if (!room.memory.alert && factory && ps && !factory.level && (!pickedRoom || (distance && distance < bestDistance))){
								pickedRoom = room;
								bestDistance = distance;
								level = 0;
							}
						}
					}
				}
				if (pickedRoom){
					console.log('trying to assign to room', pickedRoom.name, pc.name,'level:',level);
					pc.memory.home = pickedRoom.name;
					pickedRoom.memory.factoryOperator = pc.name;
				}
			} else if (pc.role === 'spawnSupport' && Game.flags['spawnSupport']){
					pc.memory.home = Game.flags['spawnSupport'].pos.roomName;
			} else {
					console.log('pc error,',pc.name);
			}
		}
	}

	function autoUpgrade(){
		if (config.powerCreepSchema){
			let usedLevel = 0;
			for (let i in Game.powerCreeps){
				usedLevel++;
				usedLevel += Game.powerCreeps[i].level;
			}
			if ((usedLevel) >= Game.gpl.level-50 && config.official){
				return
			}
			let powerSpawnCount = 0;
			for (let i in Game.myRooms){
				if (Game.myRooms[i] && Game.myRooms[i].memory.powerspawn && Game.getObjectById(Game.myRooms[i].memory.powerspawn)){
					powerSpawnCount++;
				}
			}
			if (!powerSpawnCount){
				return
			}
			upgradeF();
			for (let i in config.powerCreepSchema){
				let role = i;
				if (role === 'F'){
					continue
				}
				let obj = config.powerCreepSchema[i];
				let roleList = [];
				for (let pc in Game.powerCreeps){
					if (Game.powerCreeps[pc].role === i){
						roleList.push(Game.powerCreeps[pc]);
					}
				}
				if (obj.allRooms && obj.levels){
					if (obj.minLevel){
						//want to get lowest creep to this level before next spawn
						let count = 1;
						while (count < 30){
							let name = i + '-' + count;
							let PC = Game.powerCreeps[name];
							if (PC && PC.level < obj.minLevel){
								console.log('trying to get to min level', name);
								upgrade(PC);
								return
							} else if (!PC){
								break
							}
							count++;
						}
					}
					if (roleList && roleList.length < powerSpawnCount){
						//spawn a new creep
						let count = 1;
						while (count < 30){
							let name = i + '-' + count;
							let PC = Game.powerCreeps[name];
							if (!PC){
								console.log('trying to spawn', name);
								PowerCreep.create(name, POWER_CLASS.OPERATOR);
								return
							}
							count++;
						}
					} else if (roleList){
						let lowest;
						for (let pc in roleList){
							let PC = roleList[pc];
							if (PC && !lowest || PC.level < lowest.level){
								lowest = PC;
							}
						}
						if (lowest){
							console.log('trying to upgrade', lowest.name);
							upgrade(lowest);
							return
						}
					}
				}
			}
		}
	}

	function upgrade(pc){
		let schema = config.powerCreepSchema[pc.role];
		if (schema && schema.levels && schema.levels[pc.level] && Game.time % 10 === 0 && pc.ticksToLive < (POWER_CREEP_LIFE_TIME - 5)){
			console.log('upgrading', pc, 'power:', schema.levels[pc.level], 'try:', pc.upgrade(schema.levels[pc.level]));
		}
	}

	function upgradeF(){
		let list = [];
		if (config.official && Game.shard.name !== 'shard2' && Game.shard.name !== 'DESKTOP-QJS2U9B'){
			return
		}
		if ((!config.season || config.season !== 'caravan') && !config.official){
				return
		}
		for (let pc in Game.powerCreeps){
			if (Game.powerCreeps[pc].role === 'F'){
				list.push(Game.powerCreeps[pc]);
				// Game.powerCreeps[pc].suicide();
				// Game.powerCreeps[pc].delete()
			}
		}
		let currentCreeps = {};
		let upgraded = false;
		for (let i in list){
			//go through current PCs and upgrade
			let pc = list[i];
			let powers = pc.powers;
			let split = pc.name.split('-');
			let factoryLevel = split[1];
			let num = split[2];
			if (!currentCreeps[factoryLevel] || currentCreeps[factoryLevel] < num){
				currentCreeps[factoryLevel] = num;
			}
			if (pc.memory.maxLevel){
				continue
			}
			if (!pc.ticksToLive || pc.ticksToLive > (POWER_CREEP_LIFE_TIME - 5) || !pc.memory.home){
				console.log(pc, 'block');
				upgraded = true;
				continue
			}
			let home = pc.home;
			let targetOps = config.factoryOperatorSchema[factoryLevel].opLevel;
			if (home.memory.alert){
				targetOps = config.factoryOperatorSchema['alert'].opLevel;
			}
			let needFill = false;
			if (!powers[1] || powers[1].level < targetOps){
				//first check gen ops at the right level and if not upgrade
				let check = pc.upgrade(1);
				console.log('1', check, pc);
				if (check === 0){
					upgraded = true;
					continue
				} else if (check === -8){
					needFill = true;
				} else {
					upgraded = true;
					console.log('pc upgrade error');
					break
				}
			}
			if (!powers[19] || powers[19].level < factoryLevel){
				//first check gen ops at the right level and if not upgrade
				let check = pc.upgrade(19);
				if (check === 0){
					upgraded = true;
					continue
				} else if (check === -8){
					needFill = true;
				} else {
					console.log('pc upgrade error');
					break
				}
			}
			if (needFill){
				//need to use other parts to get creep to desired level
				let fillList = config.factoryOperatorSchema[factoryLevel].fillerPowers;
				if (home.memory.alert){
					fillList = config.factoryOperatorSchema['alert'].fillerPowers;
				}
				for (let i in fillList){
					let powerID = fillList[i];
					let check = pc.upgrade(powerID);
					if (check === 0){
						upgraded = true;
						break
					}
				}
			} else if (pc.level > 1){
				pc.memory.maxLevel = true;
			} else {
				upgraded = true;
			}
		}
		if (!upgraded){
			//have not been able to upgrade any of our current creeps so spawn a new creep
			let ratio = config.factoryRatio;
			let nextLevel;
			let nextNum = 1;
			for (let i in ratio){
				if (!currentCreeps[i]){
					nextLevel = i;
					break
				}
			}
			if (!nextLevel){
				let highScore;
				//work out using the ratio the next desired creep
				for (let i in ratio){
					let score = ratio[i] / currentCreeps[i];
					if (!highScore || score > highScore){
						nextLevel = i;
						nextNum = Number.parseInt(currentCreeps[i]) + 1;
						highScore = score;
					}
				}
			}
			if (nextLevel){
				let name = `F-${nextLevel}-${nextNum}`;
				console.log('trying to create', name);
				PowerCreep.create(name, POWER_CLASS.OPERATOR);
				delete Memory.powerCreeps[name];
			}
		}
	}

	let sourceListAll = {};

	function getSource(homeRoom){
		if (!sourceListAll[homeRoom.name] || Game.time > sourceListAll[homeRoom.name].expiry){
			//find 3 sources
			let sources = [];
			if (homeRoom.memory.s1){
				sources.push(homeRoom.memory.s1);
			}
			if (homeRoom.memory.s2){
				sources.push(homeRoom.memory.s2);
			}
			if (homeRoom.memory.finalSources && !homeRoom.memory.alert && (!config.season || config.season !== 'thorium')){
				for (let i in homeRoom.memory.finalSources){
					if (sources.length > 2){
						break
					}
					let pos = homeRoom.memory.finalSources[i].toPos();
					if (pos && pos.roomName && Game.rooms[pos.roomName]){
						let source = pos.lookAround(LOOK_SOURCES, 0)[0];
						if (source){
							sources.push(source.id);
						}
					}
				}
			}
			sourceListAll[homeRoom.name] = {
				sources: sources,
				expiry: Game.time + 5000
			};
		}
		if (sourceListAll[homeRoom.name]){
			if (sourceListAll[homeRoom.name].currentSource){
				let source = Game.getObjectById(sourceListAll[homeRoom.name].currentSource);
				if (source && !source.room.memory.armedHostiles && (source.room.name === homeRoom.name || homeRoom.checkRemoteIsAccessible(source.room.name))
						&& (!homeRoom.memory.underHarassment || source.room.name === homeRoom.name) && (!source.effects || source.effects.length === 0)){
					return source
				}
			}
			let sources = sourceListAll[homeRoom.name].sources;
			for (let i in sources){
				let source = Game.getObjectById(sources[i]);
				if (source && !source.room.memory.armedHostiles && (source.room.name === homeRoom.name ||homeRoom.checkRemoteIsAccessible(source.room.name))
						&& (!homeRoom.memory.underHarassment || source.room.name === homeRoom.name) && (!source.effects || source.effects.length === 0)){
					sourceListAll[homeRoom.name].currentSource = source.id;
					return source
				}
			}
		}
	}

	function runBlockade(room){
		let flag = Game.flags['blockade' + room.name];
		if (!flag){
			return
		}
		let targetRoomName = flag.pos.roomName;
		if (Game.rooms[targetRoomName] && Game.rooms[targetRoomName].controller && !Game.rooms[targetRoomName].controller.owner){
			flag.remove();
		}
		let targetRooms = [];
		if (targetRoomName){
			let exits = Game.map.describeExits(targetRoomName);
			for (let i in exits){
				targetRooms.push(exits[i]);
			}
		}
		if (targetRooms && targetRooms.length > 0){
			for (let i in targetRooms){
				requestSquad(room, targetRooms[i], {type: 'D'});
			}
		}
	}

	let hostileListAllRooms,armedHostileListAllRooms;
	let structureLists = {};
	//reset hostile lists each tick
	function setRoomPrototypeFunctions() {
			let cachedRoomTotals = {};
			hostileListAllRooms = {};
			structureLists = {};
			armedHostileListAllRooms = {};
			/**
			 * canBoost
			 * @param boostArray - the boost array to check
			 * @param partial - only check factors that affect creep body such as heal, tough and move
			 * @returns {boolean}
			 */
			Room.prototype.canBoost = function (boostArray,partial){
					if (!boostArray){
							return false
					}
					for (let i in boostArray){
							let canCheck = true;
							if (partial){
									if (!config$1.squadBoostTypes['move'].includes(boostArray[i]) &&
											!config$1.squadBoostTypes['heal'].includes(boostArray[i]) &&
											!config$1.squadBoostTypes['tough'].includes(boostArray[i])
									){
											canCheck = false;
									}
							}
							let target = 3000;
							let lowerAmount = ['ZH','ZH2O','XZH2O','UH','UH2O','XUH2O','GO','GHO2','XGHO2'];
							if (lowerAmount.includes(boostArray[i])){
									target = 1500;
							}
							if (this.total(boostArray[i]) < target && canCheck){
									return false
							}
					}
					return true
			};
			/**
			 * findStructures -returns an array of structures - the array is a copy so can be altered
			 * @param {array} structureTypes
			 * @param {function} filter - accepts a filter function
			 * @returns {array}
			 */
			Room.prototype.findStructures = function(structureTypes,filter){
					let room = this;
					let list = {};
					if (!structureTypes){
							return []
					}
					if (!structureLists[room.name]){
							let structures = room.find(FIND_STRUCTURES);
							for (let i in structures){
									let structureType = structures[i].structureType;
									if (!list[structureType]){
											list[structureType] = [];
									}
									list[structureType].push(structures[i]);
							}
							structureLists[room.name] = list;
					} else {
							list = structureLists[room.name];
					}
					if (typeof structureTypes === 'string'){
							if (!list[structureTypes]){
									return []
							}
							if (filter){
									return list[structureTypes].filter(filter)
							} else {
									let copy = [...list[structureTypes]];
									return copy
							}
					}
					let ret = [];
					for (let i in structureTypes){
							if (list[structureTypes[i]]){
									ret = ret.concat(list[structureTypes[i]]);
							}
					}
					if (filter){
							return ret.filter(filter)
					}
					return ret
			};
			Room.prototype.assessTotalHostileCreepPower = function(){
					let room = this;
					let totalPower = 0;
					if (room.armedHostileList){
							for (let i in room.armedHostileList){
									let power = room.armedHostileList[i].stats().attack + room.armedHostileList[i].stats().ranged_attack;
									totalPower += power;
							}
					}
					return totalPower
			};
			Room.prototype.assignTerritory = function (){
					let room = this;
					if (!Memory.territory){
							Memory.territory = {};
					}
					Memory.territory[room.name] = true;
			};
			Room.prototype.checkRemoteIsAccessible = function (roomName){
					let room = this;
					if (!this.memory.remoteRooms || !this.memory.remoteRooms[roomName]){
							//console.log(roomname,'is not remote')
							return false
					}
					let mem = this.memory.remoteRooms[roomName];
					if (mem && mem.coreDetected && mem.coreDetected > Game.time){
							return false
					} else if (mem && mem.coreDetected){
							delete this.memory.remoteRooms[roomName].coreDetected;
					}
					for (let i in mem.route){
							let routeRoomName = mem.route[i];
							if (routeRoomName == this.name){
									continue
							}
							if (Game.map.isCoreRoom(routeRoomName) || Memory.ownedRooms[routeRoomName]){
									for (let i in room.memory.finalSources){
											let sourceStr = room.memory.finalSources[i];
											let sourcePos;
											if (sourceStr){
													sourcePos = room.memory.finalSources[i].toPos();
											}
											if (sourcePos && sourcePos.roomName === roomName){
													delete room.memory.sourcelist[sourceStr];
													delete Memory.sources[sourceStr];
													delete room.memory.finalSources[i];
											}
									}
									delete room.memory.remoteRooms[roomName];
									return false
							}
							if (this.memory.remoteRooms[routeRoomName]){
									if (this.memory.remoteRooms[routeRoomName].retreat){
											//console.log(this.name,'room is blocked',roomname)
											return false
									}
							} else {
									if (!config$1.official);
									if ((Memory.ownedRooms && Memory.ownedRooms[roomName]) ||
											(Memory.rooms[roomName] && Memory.rooms[roomName].armedHostiles)){
											return false
									}
							}
					}
					if (mem.guardNeeded){
							return false
					}
					return true
			};
			Room.prototype.display = function (text){
					if (!config$1.display && config$1.display !== undefined){
							return
					}
					if (!this.currentLine){
							this.currentLine = 47;
					} else {
							this.currentLine--;
					}
					new RoomVisual(this.name).text(text, 1, this.currentLine, {align: 'left'});
			};
			Room.prototype.divertSquads = function(destination,type){
					for (let i in Memory.squads){
							if (Memory.squads[i]){
									let squad = Memory.squads[i];
									if (squad && squad.targetRoom === this.name && squad.state === 'moving'){
											Memory.squads[i].targetRoom = destination;
											Memory.squads[i].type = type;
									}
							}
					}
			};
			Room.prototype.getEvents = function (){
					if (!this._events || this._eventsTime != Game.time){
							let room = this;
							let events = room.getEventLog();
							this._events = events;
							this._eventsTime = Game.time;
					}
					return this._events
			};
			Room.prototype.getTimeLastSpawned = function(role){
					if (playerHeap.lastSpawnAll[this.name] && playerHeap.lastSpawnAll[this.name][role]){
							return playerHeap.lastSpawnAll[this.name][role]
					}
			};
			Room.prototype.getTowerPowerMatrix = function (){
					let room = this;
					if ((!Memory.coreRooms || !Memory.coreRooms[room.name])&&(!room.controller || !room.controller.owner)){
							console.log('no tower matrix needed',room.name);
							return new PathFinder.CostMatrix
					}
					let towers = room.find(FIND_STRUCTURES, {filter: (s) => s.structureType === STRUCTURE_TOWER});
					let matrix;
					if (towers && towers.length > 0 && playerHeap.towerPowerMatrixCache[room.name] && playerHeap.towerPowerMatrixCache[room.name].towerAmount == towers.length){
							matrix = PathFinder.CostMatrix.deserialize(playerHeap.towerPowerMatrixCache[room.name].matrix);
					} else if (towers && towers.length > 0){
							let newMatrix = new PathFinder.CostMatrix;
							let activeTowers = [];
							for (let i in towers){
									if ((!room.controller || towers.length > CONTROLLER_STRUCTURES['tower'][room.controller.level]) && !towers[i].isActive() && (!Memory.coreRooms || !Memory.coreRooms[room.name])){
											continue
									}
									activeTowers.push(towers[i]);
							}
							for (let x = 0; x < 50; x++){
									for (let y = 0; y < 50; y++){
											let pos = new RoomPosition(x, y, room.name);
											if (pos.getTerrain() === 'wall'){
													continue
											}
											let posScore = 0;
											for (let i in activeTowers){
													posScore += effectiveness(pos.getRangeTo(activeTowers[i]));
											}
											//reduce by 100 so it fits on a cost matrix, this should give us enough precision, as long as we Math.ceil
											posScore = Math.ceil(posScore / 100);
											newMatrix.set(x, y, posScore);
									}
							}
							if (newMatrix){
									playerHeap.towerPowerMatrixCache[room.name] = {
											matrix: newMatrix.serialize(),
											towerAmount: towers.length
									};
									matrix = newMatrix;
							}
					} else {
							//no towers, return empty matrix
							matrix = new PathFinder.CostMatrix;
					}
					return matrix

					function effectiveness(range){
							let effect = TOWER_POWER_ATTACK;
							if (range > TOWER_OPTIMAL_RANGE){
									if (range > TOWER_FALLOFF_RANGE){
											range = TOWER_FALLOFF_RANGE;
									}
									effect -= effect * TOWER_FALLOFF * (range - TOWER_OPTIMAL_RANGE) / (TOWER_FALLOFF_RANGE - TOWER_OPTIMAL_RANGE);
							}
							return Math.floor(effect);
					}
			};
			Room.prototype.logEnergyStats = function (type, amount){
					let room = this.name;
					if (!Memory.stats.roomEnergy[room]){
							Memory.stats.roomEnergy[room] = {
									'terminalSendFee': 0,
									'linkTax': 0,
									'spawning': 0,
									'build': 0,
									'harvested': 0,
									'repair': 0,
									'powerCost': 0,
									'dealCost': 0,
									'factoryCost': 0,
									'totalSpent': 0,
									'upgrade': 0,
									'decay':0
							};
					}
					if (!Memory.stats.roomEnergy[room][type]){
							Memory.stats.roomEnergy[room][type] = 0;
					}
					Memory.stats.roomEnergy[room][type] += amount;
					if (type != 'harvested'){
							Memory.stats.roomEnergy[room]['totalSpent'] += amount;
					}
					if (!Memory.stats.roomEnergyProfit){
							Memory.stats.roomEnergyProfit = {};
					}
					if (!Memory.stats.roomEnergyProfit[room]){
							Memory.stats.roomEnergyProfit[room] = 0;
					}
					Memory.stats.roomEnergyProfit[room] = (Memory.stats.roomEnergy[room]['harvested'] - Memory.stats.roomEnergy[room]['totalSpent']);
			};
			Room.prototype.lowerDefcon = function (){
					if (this.memory.defcon && this.memory.defcon < 4 && (!this.memory.defconChange || (this.memory.defconChange < Game.time - 3000))){
							this.memory.defconChange = Game.time;
							this.memory.defcon += 1;
					} else if (this.memory.defcon && this.memory.defcon === 4 && this.memory.defconChange < (Game.time - 1000)){
							this.memory.defconChange = Game.time;
							this.memory.defcon += 1;
					}
			};
			Room.prototype.makeBody = function (repeat, adjustToRoads, options){
					let room = this;
					let cost = 0;
					let ret = [];
					let maxParts;
					let movePower = 1;
					let sortValues = {
							'move': 2,
							'carry': 4,
							'ranged_attack': 3,
							'attack': 3,
							'heal': 5,
							'claim': 6
					};
					if (!options || !options.maxParts){
							maxParts = 50;
							if (options && options.level){
									maxParts = 49;
							}
					} else if (options.maxParts){
							maxParts = options.maxParts;
					}
					if (options && options.level){
							let boosts = config$1.boostLevels[options.level];
							let zBoost;
							for (let i in boosts){
									if (config$1.squadBoostTypes && config$1.squadBoostTypes['move'] && config$1.squadBoostTypes['move'].includes(boosts[i])){
											zBoost = boosts[i];
									}
							}
							if (zBoost){
									movePower = BOOSTS['move'][zBoost].fatigue;
							}
					}
					let addMoveParts = true;
					if (options && options.oneMove){
							cost += BODYPART_COST['move'];
							ret.push(MOVE);
							addMoveParts = false;
					}
					if (options && options.oneCarry){
							cost += BODYPART_COST['carry'];
							ret.push(CARRY);
					}
					if (options && options.oneClaim){
							cost += BODYPART_COST['claim'];
							ret.push(CLAIM);
					}
					if (options && options.noMove){
							addMoveParts = false;
					}
					if (options && options.fixedSection && Array.isArray(options.fixedSection)){
							for (let part in options.fixedSection){
									if (BODYPART_COST[options.fixedSection[part]]){
											cost += BODYPART_COST[options.fixedSection[part]];
											ret.push(options.fixedSection[part]);
									}
							}
					}
					let roadsDown = room.memory.roadsDown;
					if (options && options.remoteRoads){
							roadsDown = remoteRoadsPresent(room);
					}
					if (movePower === 1 && adjustToRoads && roadsDown){
							movePower = 2;
					}
					let energyCap = room.energyCapacityAvailable;
					if (options && options.energyAvailable){
							energyCap = room.energyAvailable;
					} else {
							let extensions;
							if (playerHeap.sourceExtensionCache[room.name] && playerHeap.sourceExtensionCache[room.name].expiry > Game.time &&
									playerHeap.sourceExtensionCache[room.name].energyCapacity === room.energyCapacityAvailable){
									extensions = [];
									for (let i in playerHeap.sourceExtensionCache[room.name].extensionIDs){
											extensions.push(Game.getObjectById(playerHeap.sourceExtensionCache[room.name].extensionIDs[i]));
									}
							}
							if (extensions === undefined && room.memory.sourcePositions){
									extensions = [];
									console.log('find source extensions',room.name);
									let positions = [];
									let ids = [];
									for (let sourceId in room.memory.sourcePositions){
											let source = room.memory.sourcePositions[sourceId];
											if (source.e1){
													positions.push(source.e1.toPos());
											}
											if (source.e2){
													positions.push(source.e2.toPos());
											}
									}
									for (let p in positions){
											let extension = positions[p].lookAround(LOOK_STRUCTURES, 0, {filter: (s) => s.structureType === STRUCTURE_EXTENSION})[0];
											if (extension){
													extensions.push(extension);
													ids.push(extension.id);
											}
									}
									playerHeap.sourceExtensionCache[room.name] = {
											extensionIDs :ids,
											expiry : Game.time + 5000,
											energyCapacity : room.energyCapacityAvailable
									};
							}
							if (extensions && extensions.length > 0){
									energyCap -= (4 * EXTENSION_ENERGY_CAPACITY[room.controller.level]);
									for (let e in extensions){
											if (!extensions[e]){
													delete playerHeap.sourceExtensionCache[room.name];
													continue
											}
											energyCap += extensions[e].store['energy'];
									}
							}
					}
					let fatigueBalance = 0;
					let canAffordMoreRepeats = true;
					while (canAffordMoreRepeats){
							let newRepeat = [];
							for (let i in repeat){
									newRepeat.push(repeat[i]);
									if (addMoveParts){
											if (repeat[i] !== 'move'){
													fatigueBalance--;
											} else {
													fatigueBalance += movePower;
											}
											if (fatigueBalance < 0){
													newRepeat.push('move');
													fatigueBalance += movePower;
											}
									}
							}
							while (addMoveParts && fatigueBalance < 0){
									newRepeat.push('move');
									fatigueBalance += movePower;
							}

							let repeatCost = 0;
							for (let i in newRepeat){
									let cost = BODYPART_COST[newRepeat[i]];
									if (cost){
											repeatCost+=cost;
									}
							}
							if (cost + repeatCost <= energyCap && (ret.length + newRepeat.length) <= Number.parseInt(maxParts)){
									ret = ret.concat(newRepeat);
									cost += repeatCost;
							} else {
									canAffordMoreRepeats = false;
							}
					}
					if (options && options.sort){
							ret.sort((a, b) => {
									let valA = 1;
									let valB = 1;
									if (sortValues[a]){
											valA = sortValues[a];
									}
									if (sortValues[b]){
											valB = sortValues[b];
									}
									return valA - valB
							});
							if (ret.length < 50 && cost + BODYPART_COST[MOVE] < energyCap && addMoveParts){
									ret.push(MOVE);
							} else {
									let index = ret.findIndex((p)=>p==='move');
									if (index !== -1){
											ret.splice(index,1);
											ret.push('move');
									}
							}
					}
					return ret
			};
			Room.prototype.nukePosition = function (pos){
					if (this.memory.nuker){
							let nuker = Game.getObjectById(this.memory.nuker);
							if (nuker && pos && pos.roomName && (!Game.rooms[pos.roomName] || !Game.rooms[pos.roomName].controller ||
									!Game.rooms[pos.roomName].controller.my)){
									nuker.launchNuke(pos);
							}
					}
			};
			Room.prototype.pathIsClear = function (origin, target){
					if (origin.pos){
							origin = origin.pos;
					}
					if (target.pos){
							target = target.pos;
					}
					let room = this;
					if (!room.matrix){
							room.matrix = new PathFinder.CostMatrix;
							room.find(FIND_STRUCTURES).forEach(function (struct){
									if (struct.structureType === STRUCTURE_ROAD){
											// Favor roads over plain tiles
											room.matrix.set(struct.pos.x, struct.pos.y, 1);
									} else if (struct.structureType !== STRUCTURE_CONTAINER &&
											(struct.structureType !== STRUCTURE_RAMPART ||
													!struct.my)){
											// Can't walk through non-walkable buildings
											room.matrix.set(struct.pos.x, struct.pos.y, 0xff);
									}
							});
					}
					let path = PathFinder.search(origin, target, {
							maxRooms: 1,
							roomCallback: function (){
									return room.matrix
							}
					});
					if (!path || path.incomplete){
							return false
					} else {
							return true
					}
			};
			Room.prototype.requestSecondRemoteMiner = function (creep,pos,parts){
					let room = this;
					let key = pos.x+','+pos.y+','+pos.roomName;
					if ((!room.memory.armedHostiles && room.memory.defcon && room.memory.defcon === 5 &&
							room.creepList) || this.controller.level < 5){
							let maxParts = undefined;
							if (!parts){
									maxParts = 3;
							} else {
									maxParts = parts*2;
							}
							if (room.creepList && room.creepList.filter((c) => c.name.split(' ')[0] == 'remoteMinerDeputy' && (c.ticksToLive > 200 || c.ticksToLive === undefined) && c.num == key).length === 0){
									let body =  room.makeBody([WORK],true,{oneCarry:true, maxParts:(maxParts+1)});
									if (!canSpawnReserves(room)){
											body =  room.makeBody([WORK],true,{maxParts:maxParts});
									}
									this.spawnCreep('remoteMinerDeputy',body, {creepnumber: key});
									room.requestedToSpawnCreep = true;
							}
					}
			};
			Room.prototype.send = function (target, resource, amount, message){
					let room = this;
					if (!room || !target || !resource || !amount){
							console.log('SEND FAIL');
							return null
					}
					let term = room.terminal;
					let ret = term.send(resource, amount, target, message);
					console.log('SENDING ' + amount + ' ' + resource + ' to target:' + ret);
					return ret
			};
			Room.prototype.sendCaravanHauler = function (target,caravanId,healed){
					let room = this;
					if (room.controller && room.controller.level > 6 && room.terminal && room.ecoStable && room.creepList
							&& room.creepList.filter((c) => c.name.split(' ')[0] == 'caravanHauler' && c.name.split(' ')[1] == target).length < 1){
							let body = this.makeBody([CARRY],false,{maxParts:38});
							if (healed){
									body = this.makeBody([CARRY,TOUGH,HEAL],false,{maxParts:15,sort: true});
							}
							this.spawnCreep('caravanHauler', body, {creepnumber: target,memory:{caravan:caravanId,targetId:target}});
							return true
					}
					return false
			};
			Room.prototype.sendColonists = function (targetRoomName){
					let room = this;
					let numberNeeded = Game.bodySizeToNumberNeeded(20, spawnCode$v.body(room, countRole).body, WORK);
					if (targetRoomName && Game.rooms[targetRoomName]){
							let targetRoom = Game.rooms[targetRoomName];
							if (targetRoom){
									if (targetRoom.controller && targetRoom.controller.safeMode && targetRoom.class !== 'outpost'){
											numberNeeded = numberNeeded * 2;
									} else if (targetRoom.memory.armedHostiles && numberNeeded > 1){
											numberNeeded = 1;
									} else if (room.memory.defcon < 5){
											numberNeeded = numberNeeded * 2;
									}
									if (targetRoom.memory.adjustedLowWallHits > config$1.minWalls[room.controller.level] && targetRoom.terminal && targetRoom.storage && targetRoom.energyCapacityAvailable >
											(EXTENSION_ENERGY_CAPACITY[targetRoom.controller.level] * CONTROLLER_STRUCTURES['extension'][targetRoom.controller.level] * 0.8)){
											numberNeeded = 0;
									}
									if (Game.flags['forceCol' + targetRoom.name] && !targetRoom.memory.armedHostiles){
											numberNeeded = 3;
									}
									if (targetRoom.memory.spawn && Game.spawns[targetRoom.memory.spawn] && numberNeeded > 1){
											numberNeeded = 1;
											if (room.total('energy') < room.memory.reserve){
													numberNeeded = 0;
											}
									}
									if (Game.flags['bunker'+targetRoom.name]){
											numberNeeded = 5;
											if (targetRoom.memory.armedHostiles){
													numberNeeded = 1;
											}
									}

									if (targetRoom.controller && targetRoom.controller.owner && !targetRoom.controller.my){
											numberNeeded = 0;
											if (config$1.allies && config$1.allies.includes(targetRoom.controller.owner.username)){
													if (!targetRoom.controller.safeModeCooldown){
															numberNeeded = 1;
															if (targetRoom.find(FIND_STRUCTURES,{filter:(s)=>s.structureType === 'spawn'})[0]){
																	numberNeeded = 1;
															}
													}
													if (targetRoom.memory.armedHostiles && !config$1.official){
															numberNeeded = 0;
													}
											}
									}
							} else {
									room.sendVisionCreep(targetRoom);
							}

					}
					if (numberNeeded > 3){
							numberNeeded = 3;
					}
					if (config$1.official && numberNeeded < 2){
							numberNeeded = 2;
					}
					if (numberNeeded > 1 && !room.ecoStable){
							numberNeeded = 1;
					}
					console.log('trying sending colonist to',targetRoomName);
					if (targetRoomName && (room.creepList && room.creepList.filter((c) => c.name.split(' ')[0] == 'colonist' && c.name.split(' ')[1] == targetRoomName).length < numberNeeded)){
							this.spawnCreep('colonist', spawnCode$v.body(room,countRole).body, {creepnumber: targetRoomName});
					}
			};
			Room.prototype.sendCoreHauler = function (targetRoom){
					let room = this;
					if (!this.terminal || !this.ecoStable || this.memory.underHarassment || this.memory.armedHostiles || this.controller.level < 7 || this.memory.defcon < 5){
							return
					}
					if (room.controller && room.terminal && room.controller.level > 6 && room.creepList && room.creepList.filter((c) => c.name.split(' ')[0] == 'coreHauler' && c.name.split(' ')[1] == targetRoom).length < 2){
							this.spawnCreep('coreHauler', room.makeBody([CARRY], false), {creepnumber: targetRoom});
							return true
					}
					return false
			};
			Room.prototype.sendThoriumMiners = function (targetRoom,num,haulersNeeded){
					if (!num){
							num = 1;
					}
					let room = this;
					if (!this.terminal || !this.ecoStable || this.memory.underHarassment
							|| this.memory.armedHostiles || this.controller.level < 6 || this.memory.defcon < 5){
							return
					}
					if (targetRoom.name){
							targetRoom = targetRoom.name;
					}
					if (room.controller && room.terminal && room.controller.level > 5 && room.creepList &&
							room.creepList.filter((c) => c.name.split(' ')[0] == 'thoriumMiner'
									&& c.name.split(' ')[1] == targetRoom && (c.ticksToLive > 300 || c.spawning)).length < (1*num)){
							this.spawnCreep('thoriumMiner', spawnCode$4.body(room,countRole).body, {creepnumber: targetRoom});
							return true
					}
					if (haulersNeeded && room.controller && room.terminal && room.controller.level > 5 && room.creepList && room.creepList.filter((c) => c.name.split(' ')[0] == 'thoriumBaseHauler' && c.name.split(' ')[1] == targetRoom).length < 5){
							this.spawnCreep('thoriumBaseHauler', spawnCode$7.body(room,countRole).body, {creepnumber: targetRoom});
							return true
					}
					return false
			};
			Room.prototype.sendClaimer = function (targetRoomName,number){
					let room = this;
					if (room.energyCapacityAvailable < 600){
							return false
					}
					if (!number){
							number = 1;
					}
					if (targetRoomName.name){
							targetRoomName = targetRoomName.name;
					}
					if (targetRoomName && Game.rooms[targetRoomName]){
							let targetRoom = Game.rooms[targetRoomName];
							if (targetRoom && targetRoom.controller && targetRoom.controller.owner && !targetRoom.controller.my  && targetRoom.controller.owner.username !== 'Invader'){
									return
							}
					}
					if (targetRoomName && room.creepList && room.creepList.filter((c) => c.name.split(' ')[0] == 'claimer' && c.name.split(' ')[1] == targetRoomName
							&& (!room.memory.largeClaimer || c.ticksToLive > 300)).length < number){
							room.spawnCreep('claimer', spawnCode$w.body(room,countRole).body, {creepnumber: targetRoomName});
					}
			};
			Room.prototype.sendDepositBlocker = function (targetPos,number){
					let room = this;
					let sendTime = 700;
					if (Memory.deposits[targetPos] && Memory.deposits[targetPos].path && Memory.deposits[targetPos].path.path && Memory.deposits[targetPos].path.path.sPath){
							sendTime = Memory.deposits[targetPos].path.path.sPath.length+200;
					}
					if (targetPos && room.ecoStable && room.creepList.filter((c) => c.name.split(' ')[0] == 'depositBlocker' && ((c.memory.targetPos == targetPos && c.ticksToLive > sendTime) || c.spawning)).length < number){
							for (let i in room.creepList){
									let creep = room.creepList[i];
									if (creep.role === 'depositBlocker' && !creep.memory.targetPos){
											creep.memory.targetPos = targetPos;
											return
									}
							}
							this.spawnCreep('depositBlocker', [MOVE], {memory: {targetPos:targetPos}});
					}
			};
			Room.prototype.sendDonor = function (targetRoom){
					let room = this;
					if (!mem || !this.terminal || !this.ecoStable || this.memory.underHarassment || this.memory.armedHostiles || this.controller.level < 7 || this.memory.defcon < 5){
							return
					}
					if (room.controller && room.terminal && room.controller.level > 6 && room.creepList && room.creepList.filter((c) => c.name.split(' ')[0] == 'donor' && c.name.split(' ')[1] == targetRoom).length < 4
							&& room.creepList.filter((c) => c.name.split(' ')[0] == 'donor').length < 4){
							this.spawnCreep('donor', room.makeBody([CARRY], false), {creepnumber: targetRoom});
							return true
					}
					return false
			};
			Room.prototype.sendExitBlocker = function (targetRoom,numberNeeded,healer){
					let room = this;
					if (room.ecoStable && !room.memory.armedHostiles && room.memory.defcon && room.memory.defcon === 5 &&
							room.creepList){
							let body = [MOVE];
							if (healer){
									body = room.makeBody([HEAL,TOUGH,TOUGH],false,{maxParts:20,sort:true});
							}
							if (room.creepList.filter((c) => c.name.split(' ')[0] == 'exitBlocker' && c.name.split(' ')[1] == targetRoom && (c.ticksToLive > 300 || c.ticksToLive === undefined)).length < numberNeeded){
									room.display(`spawn EB ${numberNeeded}`);
									this.spawnCreep('exitBlocker', body, {creepnumber: targetRoom});
							}
					}
			};
			Room.prototype.sendObserver = function (targetRoom){
					let room = this;
					if (room.controller && room.controller.level > 6 && room.ecoStable && room.creepList && room.creepList.filter((c) => c.name.split(' ')[0] == 'observer' && c.name.split(' ')[1] == targetRoom).length < 1
							&& room.creepList.filter((c) => c.name.split(' ')[0] == 'observer').length < 3){
							this.spawnCreep('observer', [MOVE], {creepnumber: targetRoom});
							return true
					}
					return false
			};
			Room.prototype.sendRCA = function (targetRoom){
					let room = this;
					if (targetRoom && Game.rooms[targetRoom] && Game.rooms[targetRoom].controller.my){
							return false
					}
					if (room.creepList && room.memory.defcon === 5 && (room.total('energy')>room.memory.reserve*0.5 || (room.memory.faceClaimed && room.total('energy')>room.memory.reserve*0.4)) && (!room.memory.RCblock || Game.time > room.memory.RCblock) && room.creepList.filter((c) => c.name.split(' ')[0] == 'RCattack' && c.name.split(' ')[1] == targetRoom).length < 1){
							this.spawnCreep('RCattack', room.makeBody([CLAIM],false), {creepnumber: targetRoom});
							delete room.memory.RCblock;
							return true
					} else {
							return false
					}
			};
			Room.prototype.sendSigner = function (targetRoom){
					if (!config$1.official && Game.cpu.bucket < 9000){
							return
					}
					let room = this;
					if (room.creepList && room.ecoStable && room.creepList.filter((c) => c.name.split(' ')[0] == 'signer' && c.name.split(' ')[1] == targetRoom).length < 1){
							this.spawnCreep('signer', [MOVE], {creepnumber: targetRoom});
					}
			};
			Room.prototype.sendSymbolDecoder = function (targetRoom){
					let room = this;
					let test = true;
					let mem = Memory.symbolDecoders[targetRoom];
					if (!mem || !this.terminal || !this.ecoStable || this.memory.underHarassment || this.memory.armedHostiles || this.controller.level < 7 || this.memory.defcon < 5){
							return
					}
					if (mem.canDecode){
							test = false;
					}
					this.display(`trying to spawn decoder to: ${targetRoom} ${mem.type}`);
					let creepList = room.creepList.filter((c) => c.name.split(' ')[0] == 'symbolDecoder' && c.name.split(' ')[1] == targetRoom);
					let thisCreep = creepList[0];
					if (thisCreep && test){
							return thisCreep
					}
					if (!mem.type || (!test && room.total(mem.type) < 1500) || (!test && mem.level == 7 && room.total(mem.type) < config$1.lowSymbolBound * 0.5) || !this.terminal || !this.ecoStable ||
							this.memory.underHarassment || this.memory.armedHostiles || this.controller.level < 7 || this.memory.defcon < 5){
							if (test){
									return
							} else {
									return creepList
							}
					}
					let sendMax = 6;
					if (room.controller.level == 8 && room.ecoStable){
							sendMax = 10;
					}
					if (test){
							sendMax = 10;
					}
					let individualCap = 1;
					if (room.total(mem.type) > config$1.lowSymbolBound * 0.5 && mem.canDecode){
							individualCap = 3;
					}
					if (mem && mem.canDecode !== false && room.creepList && creepList.length < individualCap
							&& room.creepList.filter((c) => c.name.split(' ')[0] == 'symbolDecoder').length < sendMax){
							let body = room.makeBody([CARRY], false);
							if (test){
									body = [CARRY, MOVE];
							}
							this.spawnCreep('symbolDecoder', body, {creepnumber: targetRoom});
					}
					if (test){
							return false
					}
					return creepList
			};
			Room.prototype.sendVisionCreep = function (targetRoom){
					let room = this;
					if (room.creepList && room.total('energy')>room.memory.reserve * 0.5){
							let noneAlive = room.creepList.filter((c) => c.name.split(' ')[0] == 'vision' && c.name.split(' ')[1] == targetRoom && c.ticksToLive > 200).length < 1;
							if (noneAlive){
									return this.spawnCreep('vision', [MOVE], {creepnumber: targetRoom})
							} else {
									return 'block'
							}
					}
			};
			Room.prototype.sendCoreKiller = function (targetRoom){
					let room = this;
					let numberNeeded = Game.bodySizeToNumberNeeded(10,spawnCode$u.body(room).body,'attack');
					if (room.creepList && room.total('energy')>room.memory.reserve * 0.8 && room.creepList.filter((c) => c.name.split(' ')[0] == 'coreKiller'&& c.name.split(' ')[1] == targetRoom).length < numberNeeded){
							this.spawnCreep('coreKiller', spawnCode$u.body(room).body, {creepnumber: targetRoom});
					}
			};
			Room.prototype.sendWallRemover = function (targetRoom){
					let room = this;
					if (Game.time % 20 == 0 && room.ecoStable && !room.memory.armedHostiles && room.memory.defcon && room.memory.defcon === 5 &&
							(!room.memory.wallRemoverBlocked || Game.time > room.memory.wallRemoverBlocked && room.energyAvailable > 1000) &&
							room.creepList){
							delete room.memory.wallRemoverBlocked;
							if (room.creepList.filter((c) => c.name.split(' ')[0] == 'wallRemover' && c.name.split(' ')[1] == targetRoom && (c.ticksToLive > 200 || c.ticksToLive === undefined)).length < 1){
									this.spawnCreep('wallRemover', room.makeBody([WORK], false, {oneMove: true}), {creepnumber: targetRoom});
							}
							this.spawnPuller(targetRoom);
					}
			};
			Room.prototype.setDefcon = function (defcon){
					if (!defcon || typeof defcon != "number"){
							return
					}
					if (!this.memory.defcon || this.memory.defcon > defcon){
							this.memory.defcon = defcon;
							this.memory.lastAttacked = Game.time;
							let attacker = undefined;
							if (this.memory.hostiles && Game.getObjectById(this.memory.hostiles)){
									attacker = Game.getObjectById(this.memory.hostiles).owner.username;
							}
							let message = `Defcon raised to level ${defcon} in room ${this.name} by ${attacker} at ${Game.time}`;
							console.log(message);
							Game.notify(message);
					}
			};
			Room.prototype.spawnCreep = function (role, body, options){
					if (!playerHeap.lastSpawnAll[this.name]){
							playerHeap.lastSpawnAll[this.name] = {};
					}
					let ret = spawnCreep(role, this.name, body, options);
					if (roleIntervals[role] && ret === 0){
							playerHeap.lastSpawnAll[this.name][role] = Game.time;
					}
					return ret
			};
			Room.prototype.spawnPuller = function (targetRoom, maxParts){
					let room = this;
					if (!maxParts){
							maxParts = 34;
					}
					if (Game.time % 3 == 0 && !room.memory.armedHostiles){
							if (room.memory.armedHostiles){
									return
							}
							let allowed = 1;
							if (room.memory.priorityEnergyRoom && targetRoom === 'staticUpgrader'){
									allowed = 2;
							}
							if (room.creepList && room.creepList.filter((c) => c.name.split(' ')[0] == 'puller' && (c.ticksToLive > 200 || c.ticksToLive === undefined) && c.name.split(' ')[1] == targetRoom).length < allowed){
									let body =  room.makeBody([MOVE], false, {maxParts: maxParts,noMove:true});
									this.spawnCreep('puller',body, {creepnumber: targetRoom});
							}
					}
			};
			Room.prototype.total = function (res){
					let room = this;
					if (!room){
							return null
					}
					if (!cachedRoomTotals[this.name]){
							cachedRoomTotals[this.name] = {};
					} else if (cachedRoomTotals[this.name][res]){
							return cachedRoomTotals[this.name][res]
					}
					let a = 0;
					let b = 0;
					let c = 0;
					let d = 0;

					if (room.storage && room.storage.store[res]){
							if (room.storage.store[res]){
									a = room.storage.store[res];
							}
					}
					if (room.terminal && room.terminal.store[res]){
							if (room.terminal.store[res]){
									b = room.terminal.store[res];
							}
					}
					if (room.memory.factory && room.controller.level > 6){
							let factory = room.activeFactory;
							if (factory && factory.store[res]){
									c = factory.store[res];
							}
					}
					if (room.memory.blabs && res != 'energy'){
							let list = room.memory.blabs;
							for (let i in list){
									let lab = Game.getObjectById(list[i]);
									if (lab && lab.store[res]){
											d += lab.store[res];
									}
							}
					}
					if (room.memory.sblabs && res != 'energy'){
							let list = room.memory.sblabs;
							for (let i in list){
									let lab = Game.getObjectById(list[i]);
									if (lab && lab.store[res]){
											d += lab.store[res];
									}
							}
					}
					if (room.memory.plabs && res != 'energy'){
							let list = room.memory.plabs;
							for (let i in list){
									let lab = Game.getObjectById(list[i]);
									if (lab && lab.store[res]){
											d += lab.store[res];
									}
							}
					}
					if (room.memory.r1lab && res != 'energy'){
							let lab = Game.getObjectById(room.memory.r1lab);
							if (lab && lab.store[res]){
									d += lab.store[res];
							}
					}
					if (room.memory.r2lab && res != 'energy'){
							let lab = Game.getObjectById(room.memory.r2lab);
							if (lab && lab.store[res]){
									d += lab.store[res];
							}
					}
					let total = (a + b + c + d);
					cachedRoomTotals[this.name][res] = total;
					return total
			};
			Room.prototype.wallMatrix = function (){
					let room = this;
					if (!room) return;
					var costs = new PathFinder.CostMatrix;
					var towers = room.find(FIND_STRUCTURES, {filter: (s) => s.structureType === STRUCTURE_TOWER});
					var hostWalls = room.find(FIND_STRUCTURES, {filter: (s) => s.structureType === STRUCTURE_WALL || s.structureType === STRUCTURE_RAMPART});
					var sortWalls = hostWalls.sort((a, b) => a.hits - b.hits);
					hostWalls.forEach(
							(s) => {
									if (s.structureType)
											var towerDamage = 0;
									if (towers.length > 0 && room.controller && room.controller.level > 0){
											for (var t in towers){
													let tower = towers[t];
													if (towers.length <= CONTROLLER_STRUCTURES['tower'][room.controller.level] || tower.isActive()){
															towerDamage += effectiveness(TOWER_POWER_ATTACK, s.pos.getRangeTo(towers[t]));
													}
											}
									}
									let rampcost = 50;
									let rampartsNear = s.pos.findInRange(FIND_STRUCTURES, 1, {filter: (str) => str.structureType == STRUCTURE_RAMPART && str.pos.lookFor(LOOK_STRUCTURES).filter((s) => s.structureType != STRUCTURE_ROAD && s.structureType != STRUCTURE_RAMPART).length < 0}).length;
									if (rampartsNear && rampartsNear > 0){
											rampcost = rampartsNear * 30;
											if (s.structureType == STRUCTURE_RAMPART){
													rampcost = rampcost + 30;
											}
											if (rampcost < 50){
													rampcost = 50;
											}
									}
									costs.set(s.pos.x, s.pos.y, Math.ceil((towerDamage) / 40) + (_.findIndex(sortWalls, (w) => w.id == s.id)/2) + rampcost);
							});
					room.memory.optimalWallMatrix = costs.serialize();
					return costs

					function effectiveness(power, range){
							let effect = power;
							if (range > TOWER_OPTIMAL_RANGE){
									if (range > TOWER_FALLOFF_RANGE){
											range = TOWER_FALLOFF_RANGE;
									}
									effect -= effect * TOWER_FALLOFF * (range - TOWER_OPTIMAL_RANGE) / (TOWER_FALLOFF_RANGE - TOWER_OPTIMAL_RANGE);
							}
							return Math.floor(effect);
					}
			};
			Room.prototype.wallOffExits = function (dir, doneDirections,ramparts){
					let cpu = Game.cpu.getUsed();
					if (!this || !this.name || !this.controller || !this.memory.spawnPos || !this.memory.spawnPos.toPos()){
							return false
					}
					if (!ready()){
							return false
					}
					let findConst = 10;
					if (typeof dir === 'string'){
							dir = Number.parseInt(dir);
					}
					if (dir && (dir === 1 || dir === 3 || dir === 5 || dir === 7)){
							findConst = dir;
					}
					if (doneDirections && Array.isArray(doneDirections) && doneDirections.includes(dir)){
							return
					}
					if (!doneDirections){
							doneDirections = [];
					}
					let exits = this.find(findConst);
					let allExits = {};
					let allSeparateExits = {};
					exits.forEach((e) => {
							let side;
							if (dir && findConst === dir){
									side = dir;
							} else {
									side = e.getEdge();
							}
							if (side){
									if (!allExits[side]){
											allExits[side] = [];
											allSeparateExits[side] = [];
									}
									allExits[side].push(e);
							} else {
									console.log('err no side wall off exits', this);
							}
					});
					let matrix = new PathFinder.CostMatrix;
					let currentWallCount = 0;
					let separateWalls = [];
					for (let side in allExits){
							let separateExits = allSeparateExits[side];
							//sort into order so we can figure out different exits
							allExits[side].sort((a, b) => {
									//used string as keys are always strings, despite dir originally being number
									if (side === '3'){
											return a.y - b.y
									} else if (side === '7'){
											return b.y - a.y
									} else if (side === '1'){
											return a.x - b.x
									} else {
											return b.x - a.x
									}
							});
							let current = 0;
							//find gaps
							for (let exit in allExits[side]){
									let exitPos = allExits[side][exit];
									if (!separateExits[current]){
											separateExits.push([exitPos]);
									} else {
											let currentExitArr = separateExits[current];
											let lastPos = currentExitArr[currentExitArr.length - 1];
											let abs;
											if (side === '3' || side === '7'){
													abs = Math.abs(exitPos.y - lastPos.y);
											} else {
													abs = Math.abs(exitPos.x - lastPos.x);
											}
											if (abs === 1){
													//exitPos is next to last pos so is part of current exit arr
													currentExitArr.push(exitPos);
											} else {
													//exitPos is on a new exit -> make a new
													separateExits.push([exitPos]);
													current++;
											}

									}
							}
							let sideDir = Number.parseInt(side);
							for (let i in separateExits){
									let wallPosArr = [];
									let exitArr = separateExits[i];
									if (exitArr && exitArr.length > 0){
											wallPosArr.push(
													exitArr[0].movePos(map8(sideDir, -3)).movePos(map8(sideDir, -2)),
													exitArr[0].movePos(map8(sideDir, -3)).movePos(map8(sideDir, -3)),
													exitArr[0].movePos(map8(sideDir, -3)).movePos(map8(sideDir, -4))
											);
											exitArr.forEach((e) => {
													let pos = e.movePos(map8(sideDir, 4));
													pos = pos.movePos(map8(sideDir, 4));
													wallPosArr.push(pos);
											});
											wallPosArr.push(
													exitArr[exitArr.length - 1].movePos(map8(sideDir, 3)).movePos(map8(sideDir, 4)),
													exitArr[exitArr.length - 1].movePos(map8(sideDir, 3)).movePos(map8(sideDir, 3)),
													exitArr[exitArr.length - 1].movePos(map8(sideDir, 3)).movePos(map8(sideDir, 2))
											);
									}
									for (let wall in wallPosArr){
											let wallPos = wallPosArr[wall];
											if (wallPos.getTerrain() === 'wall'){
													continue
											} else {
													matrix.set(wallPos.x, wallPos.y, 255);
											}
											if (!separateWalls[currentWallCount]){
													separateWalls.push([wallPos]);
											} else {
													let currentWallArr = separateWalls[currentWallCount];
													let lastPos = currentWallArr[currentWallArr.length - 1];
													let abs;
													if (side === '3' || side === '7'){
															abs = Math.abs(wallPos.y - lastPos.y);
													} else {
															abs = Math.abs(wallPos.x - lastPos.x);
													}
													let block = wallPos.movePos(map8(sideDir, 4));
													if (abs !== undefined && abs <= 1 && block && block.getTerrain() != 'wall'){
															//exitPos is next to last pos so is part of current exit arr
															currentWallArr.push(wallPos);
													} else {
															//exitPos is on a new exit -> make a new
															separateWalls.push([wallPos]);
															currentWallCount++;
													}

											}
									}
									currentWallCount++;
							}

							doneDirections.push(sideDir);
							if (findConst != 10){
									//if near a corner and there is another exit on the side next to this side, and that side is not being walled, need to wall as well
									for (let i in separateExits){
											let separateExit = separateExits[i];
											let ends = [separateExit[0], separateExit[separateExit.length - 1]];
											for (let j in ends){
													//check the ends of each exitarr to see if the exit is near the corner and if so detect if the side needs walling
													let end = ends[j];
													if (end){
															let changeCoOrd = 'x';
															let fixedCoOrd = 'y';
															if (end.x === 0 || end.x === 49){
																	changeCoOrd = 'y';
																	fixedCoOrd = 'x';
															}
															if (changeCoOrd && end[changeCoOrd]){
																	let newFixed;
																	if (end[changeCoOrd] < 4){
																			newFixed = 0;
																	} else if (end[changeCoOrd] > 45){
																			newFixed = 49;
																	}
																	if (newFixed != undefined){
																			let checkCoOrds = [1, 2, 3];
																			if (end[fixedCoOrd] === 49){
																					checkCoOrds = [46, 47, 48];
																			}
																			if (changeCoOrd === 'x'){
																					//new change is y
																					for (let check in checkCoOrds){
																							let pos = this.getPositionAt(newFixed, checkCoOrds[check]);
																							if (pos && pos.isWalkable() && pos.getRangeTo(end) < 4 && pos.getEdge() && (!doneDirections || !doneDirections.includes(pos.getEdge()))){
																									this.wallOffExits(pos.getEdge(), doneDirections,ramparts);
																							}
																					}
																			} else {
																					for (let check in checkCoOrds){
																							let pos = this.getPositionAt(checkCoOrds[check], newFixed);
																							if (pos && pos.isWalkable() && pos.getRangeTo(end) < 4 && pos.getEdge() && (!doneDirections || !doneDirections.includes(pos.getEdge()))){
																									this.wallOffExits(pos.getEdge(), doneDirections,ramparts);
																							}
																					}
																			}
																	}
															}
													}
											}
									}
							}
					}
					let s1, s2, contr;
					if (this.memory && this.memory.s1 && Game.getObjectById(this.memory.s1)){
							let source = Game.getObjectById(this.memory.s1);
							if (source.x < 5 || source.x > 44 || source.y < 5 || source.y < 44){
									s1 = source;
							}
					}
					if (this.memory && this.memory.s2 && Game.getObjectById(this.memory.s2)){
							let source = Game.getObjectById(this.memory.s2);
							if (source.x < 5 || source.x > 44 || source.y < 5 || source.y < 44){
									s2 = source;
							}
					}
					let controllerPos = this.controller.pos;
					if (controllerPos.x < 5 || controllerPos.x > 44 || controllerPos.y < 5 || controllerPos.y < 44){
							contr = controllerPos;
					}
					for (let i in separateWalls){
							let wallPosArr = separateWalls[i];
							let ramparts = [];
							if (wallPosArr && wallPosArr.length > 0){
									if (wallPosArr[0]){
											let path = PathFinder.search(wallPosArr[0], {pos: this.memory.spawnPos.toPos(), range: 1}, {
													roomCallback: () => {
															return matrix
													}, maxRooms: 1, swampCost: 1
											});
											if (!path || path.incomplete){
													path = PathFinder.search(wallPosArr[0], {pos: this.controller.pos, range: 1}, {
															roomCallback: () => {
																	return matrix
															}, maxRooms: 1, swampCost: 1
													});
											}
											if (!path || path.incomplete){
													path = PathFinder.search(wallPosArr[wallPosArr.length - 1], {
															pos: this.memory.spawnPos.toPos(),
															range: 1
													}, {
															roomCallback: () => {
																	return matrix
															}, maxRooms: 1, swampCost: 1
													});
											}
											if (!path || path.incomplete){
													path = PathFinder.search(wallPosArr[wallPosArr.length - 1], {pos: this.controller.pos, range: 1}, {
															roomCallback: () => {
																	return matrix
															}, maxRooms: 1, swampCost: 1
													});
											}
											if (path && path.incomplete){
													//TODO remove this below
													wallPosArr.forEach((w) => {
															let wall = w.lookAround(LOOK_STRUCTURES, 0, {filter: (s) => s.structureType == STRUCTURE_WALL || s.structureType == STRUCTURE_RAMPART});
															if (wall && wall[0] && wall[0].hits < 10000000); else if (wall && wall[0]){
																	console.log('blocking wall at', w);
															}
													});
													continue
											} else {
													new RoomVisual(this.name).poly(path.path);
											}
									}
									if (ramparts.length === 0){
											wallPosArr[Math.floor(wallPosArr.length / 2)].highlight('green');
											ramparts.push((wallPosArr[Math.floor(wallPosArr.length / 2)]).toString());
									}
									let roadPositions;
									if (access(this.name) && access(this.name).roadPositions &&  access(this.name).roadPositions[this.name]){
											roadPositions = access(this.name).roadPositions[this.name];
									}
									wallPosArr.forEach((p) => {
											if ((ramparts.includes(p.toString())) || (s1 && p.isNearTo(s1.pos)) || (s2 && p.isNearTo(s2.pos)) ||
													(contr && p.isNearTo(contr))){
													//p.highlight('green')
													if (p.isWalkable()){
															p.createConstructionSite(STRUCTURE_RAMPART);
													} else {
															let wall = p.lookAround(LOOK_STRUCTURES, 0, {filter: (s) => s.structureType == STRUCTURE_WALL});
															if (wall && wall[0] && wall[0].hits < 10000000){
																	wall[0].destroy();
															} else {
																	console.log('blocking wall at', p);
															}
													}
											} else if (p.roomName){
													//p.highlight()
													let key = p.x+','+p.y;
													if (roadPositions && roadPositions.includes(key)){
															p.createConstructionSite(STRUCTURE_RAMPART);
													} else if (p.lookAround(LOOK_STRUCTURES, 0).length === 0){
															if (ramparts){
																	p.createConstructionSite(STRUCTURE_RAMPART);
															} else {
																	p.createConstructionSite(STRUCTURE_WALL);
															}
													}
											}
									});
							}
					}
					console.log('wallcpu', Game.cpu.getUsed() - cpu);
			};
	}
	function setRoomPrototypeProperties(){
			Object.defineProperty(Room.prototype, 'activeFactory',{
					get(){
							if (this._activeFactory !== undefined){
									return this._activeFactory
							}
							let ret;
							if (this.controller && this.controller.my && this.controller.level > 6){
									if (this.memory.factory){
											ret = Game.getObjectById(this.memory.factory);
									}
									if (!ret && Game.cpu.bucket > 5000){
											//limit trying to find a factory - this is done sporadically in memory manager
											ret = this.findStructures('factory',(s)=>s.my)[0];
											if (ret){
													this.memory.factory = ret.id;
											}
									}
							}
							if (!ret){
									ret = false;
							}
							this._activeFactory = ret;
							return ret
					},
					configurable:true
			});
			Object.defineProperty(Room.prototype,'armedHostileList',{
					get:function(){
							let room = this;
							if (armedHostileListAllRooms[room.name]){
									return armedHostileListAllRooms[room.name];
							}
							let hostiles = room.hostileList;
							let armedHostiles = [];
							for (let i in hostiles){
									let hostile = hostiles[i];
									if (hostile){
											let stats = hostile.stats();
											if (stats.attack>0 || stats.ranged_attack > 0 || (stats.work > 0 && room.controller && room.controller.my && room.memory.defcon < 5)){
													armedHostiles.push(hostile);
											}
									}
							}
							armedHostileListAllRooms[room.name] = armedHostiles;
							return armedHostiles
					},
					configurable:true
			});
			Object.defineProperty(Room.prototype,'cache', {
					get: function (){
							if (!playerHeap.roomCache[this.name]){
									playerHeap.roomCache[this.name] = {};
							}
							return playerHeap.roomCache[this.name]
					},
					enumerable: false,
					configurable: true
			});
			Game.map.getRoomCache = function (name){
					if (!name || !playerHeap.roomCache[name]){
							return
					}
					return playerHeap.roomCache[name]
			};
			Object.defineProperty(Room.prototype,'class', {
					get: function (){
							if (!this._class){
									if (Game.flags['remote' + this.name]){
											this._class = 'remote';
									} else if (this.memory.bunker){
											this._class = 'bunker';
									} else if (Game.flags['outpost' + this.name]){
											this._class = 'outpost';
									} else if (Game.flags['pray' + this.name]){
											this._class = 'prayer';
									} else if (this.controller && this.controller.my && this.memory.restructuring){
											this._class = 'restructuring';
									} else if (this.controller && this.controller.my && config$1.season && config$1.season === 'thorium'
											&& this.memory.isThoriumMine){
											this._class = 'thoriumMine';
									} else if (this.controller && this.controller.my){
											this._class = 'normal';
									} else {
											this._class = false;
									}
							}
							return this._class;
					},
					enumerable: false,
					configurable: true
			});
			Object.defineProperty(Room.prototype,'defenceMatrix', {
					get: function (){
							if (!this._defenceMatrix){
									let costs;
									if (playerHeap.defenceMatrixCache[this.name] && Game.time % 10 !== 0){
											costs = PathFinder.CostMatrix.deserialize(playerHeap.defenceMatrixCache[this.name]);
									} else if (this.memory.defenceMatrix && ready() && access(this.name) && access(this.name).defenceMatrix){
											costs = PathFinder.CostMatrix.deserialize(access(this.name).defenceMatrix);
											if (costs){
													playerHeap.defenceMatrixCache[this.name] = access(this.name).defenceMatrix;
											} else {
													delete this.memory.defenceMatrix;
													return false
											}
									} else {
											delete this.memory.defenceMatrix;
											return false
									}
									this._defenceMatrix = costs;

							}
							return this._defenceMatrix.clone();
					},
					enumerable: false,
					configurable: true
			});
			Object.defineProperty(Room.prototype,'ecoStable', {
					get: function (){
							if (!this._ecoStable){
									let threshold = 0.75;
									if (Memory.myRooms && Memory.myRooms.length < 5){
											threshold = 0.9;
									}
									if (!this.creepList || this.creepList.length < 4 || !this.storage || !this.memory.reserve || this.total('energy') < this.memory.reserve * threshold){
											this._ecoStable = false;
									} else {
											this._ecoStable = true;
									}
							}
							return this._ecoStable;
					},
					enumerable: false,
					configurable: true
			});
			Object.defineProperty(Room.prototype,'hostileList',{
					get:function(){
							let room = this;
							if (hostileListAllRooms[room.name]){
									return hostileListAllRooms[room.name];
							}
							let hostiles = room.find(FIND_HOSTILE_CREEPS,{filter:(c)=>!c.isWhiteListed});
							hostileListAllRooms[room.name] = hostiles;
							return hostiles
					},
					configurable:true
			});
			Object.defineProperty(Room.prototype,'hostileStructureMatrix', {
					get: function (){
							if (!this._hostileStructureMatrix){
									let costs;
									if (playerHeap.hostileStructureMatrixCache[this.name] && Game.time % 10 != 0){
											costs = PathFinder.CostMatrix.deserialize(playerHeap.hostileStructureMatrixCache[this.name]);
									} else {
											costs = new PathFinder.CostMatrix;
											this.find(FIND_CONSTRUCTION_SITES).forEach((site) => {
													if (site.structureType != STRUCTURE_ROAD && site.structureType != STRUCTURE_CONTAINER && site.structureType !== STRUCTURE_RAMPART && !site.my){
															costs.set(site.pos.x, site.pos.y, 0);
													}
											});
											this.find(FIND_STRUCTURES).forEach(function (struct){
													if (struct.structureType === STRUCTURE_ROAD && costs.get(struct.pos.x, struct.pos.y) < 5){
															// Favor roads over plain tiles
															costs.set(struct.pos.x, struct.pos.y, 1);
													} else if (struct.structureType === STRUCTURE_CONTAINER){
															costs.set(struct.pos.x, struct.pos.y, 1);
													} else if (struct.structureType !== STRUCTURE_CONTAINER &&
															(struct.structureType !== STRUCTURE_RAMPART ||
																	!struct.my)){
															let currentCost = costs.get(struct.pos.x, struct.pos.y);
															let val = 5;
															if (struct.hits < 3000){
																	val = 1;
															}
															if (currentCost < val){
																	costs.set(struct.pos.x, struct.pos.y, val);
															}
															if (struct.structureType === STRUCTURE_RAMPART){
																	let val = (struct.hits/150000)+50;
																	if (val < 50){
																			val = 50;
																	} else if (val > 220){
																			val = 220;
																	}
																	costs.set(struct.pos.x, struct.pos.y, val);
															}
															if (struct.pos.getTerrain()== 'wall'){
																	costs.set(struct.pos.x, struct.pos.y, 255);
															}
													}
											});

											playerHeap.hostileStructureMatrixCache[this.name] = costs.serialize();
									}
									this._hostileStructureMatrix = costs;

							}
							return this._hostileStructureMatrix.clone();
					},
					enumerable: false,
					configurable: true
			});
			Object.defineProperty(Room.prototype,'hyperlink',{
					get(){
							return `<a href="#!/room/${Game.shard.name}/${this.name}">[${ this.name }]</a>`;
					},
					configurable:true
			});
			Object.defineProperty(Room.prototype,'index', {
					get: function (){
							if (!Memory.myRooms){
									return 0
							}
							if (!this._index){
									this._index = Memory.myRooms.indexOf(this.name);
							}
							return this._index;
					},
					enumerable: false,
					configurable: true
			});
			Object.defineProperty(Room.prototype,'isEnergyDonor', {
					get: function (){
							if (!this._isEnergyDonor){
									let ret = false;
									if (config$1.energyDonorMinLevel && this.controller.level < config$1.energyDonorMinLevel){
											ret = false;
									} else if (Memory.emergency || Memory.energyCrisis || this.memory.thoriumMineSupportRoom){
											ret = false;
									} else if (Memory.priorityEnergyRoomName && this.name != Memory.priorityEnergyRoomName && !this.memory.armedHostiles
											&& Game.rooms[Memory.priorityEnergyRoomName] && Game.rooms[Memory.priorityEnergyRoomName].total('energy') < Game.rooms[Memory.priorityEnergyRoomName].memory.reserve * 3
											&& !Game.flags['fill' + this.name] && !this.memory.priorityEnergyRoom && this.total('energy') > this.memory.reserve * 0.8 && this.memory.defcon == 5 && this.terminal && this.controller.level > 5){
											ret = true;
									}
									this._isEnergyDonor = ret;
							}
							return this._isEnergyDonor;
					},
					enumerable: false,
					configurable: true
			});
			Object.defineProperty(Room.prototype,'isPrayerDonor', {
					get: function (){
							if (!this._isPrayerDonor){
									//prayerEnergySource should be true if eco power creep is present so terminal is boosted and also if the room is close to a prayer room
									//this way it will import batteries, decompress and supply energy to prayer room
									let prayerEnergySource = false;
									if (Memory.prayerRooms){
											for (let pr in Memory.prayerRooms){
													let range = Game.map.getRoomLinearDistance(pr, this.name);
													if (range <= 5 && Game.flags['PR' + this.name]){
															prayerEnergySource = true;
													}
											}
									}
									this._isPrayerDonor = prayerEnergySource;
							}
							return this._isPrayerDonor;
					},
					enumerable: false,
					configurable: true
			});
			Object.defineProperty(Room.prototype,'isShardTradeRoom',{
					get:function(){
							let room = this;
							if (Game.flags['ShardTrade'] && Game.flags['ShardTrade'].pos && Game.flags['ShardTrade'].pos.roomName === room.name){
									return true
							}
							return false
					},
					configurable:true
			});
			Object.defineProperty(Room.prototype,'mineral',{
					get:function(){
							if (config$1.official){
									return this.find(FIND_MINERALS)[0]
							}
							if (config$1.season && config$1.season === 'thorium'){
									let minerals = this.find(FIND_MINERALS);
									for (let i in minerals){
											if (minerals[i].mineralType !== 'T'){
													return minerals[i]
											}
									}
							}
							return this.find(FIND_MINERALS)[0]
					},
					configurable:true
			});
			Object.defineProperty(Room.prototype,'nukeTime', {
					get: function (){
							if (!this._nukeTime){
									let room = this;
									let time;
									if (room.memory.nukeDefence){
											let nukes = room.find(FIND_NUKES);
											nukes.sort((a, b) => a.timeToLand - b.timeToLand);
											if (nukes[0]){
													time = nukes[0].timeToLand;
											}
									}
									if (time){
											this._nukeTime = time;
									} else {
											this._nukeTime = false;
									}
							}
							return this._nukeTime;
					},
					enumerable: false,
					configurable: true
			});
			Object.defineProperty(Room.prototype,'plannedRamparts',{
					get:function(){
							let room = this;
							if (!ready() || !access(room.name)){
									return false
							}
							let structureCache = access(room.name).structures;
							if (structureCache && structureCache['rampart']){
									return structureCache['rampart']
							}
							return false
					},
					configurable:true
			});
			Object.defineProperty(Room.prototype,'renewDefenceCreeps', {
					get(){
							return this.memory.activateRamparts && (this.memory.armedHostiles || this.class === 'bunker' || Game.flags['defend'+this.name])
					},
					configurable: true
			});
			Object.defineProperty(Room.prototype,'roadMatrix', {
					get: function (){
							let room = this;
							if (!this._roadMatrix){
									let costs;
									if (!this.memory.fixedBaseOrigin){
											return false
									}
									let roomSegment = access(room.name);
									if (!roomSegment || !roomSegment.roadPositions){
											return false
									}
									if (playerHeap.roadMatrixCache[this.name] && Game.time % 25 != 0){
											costs = PathFinder.CostMatrix.deserialize(playerHeap.roadMatrixCache[this.name]);
									} else {
											costs = new PathFinder.CostMatrix;
											for (let x = 0; x < 50; x++){
													for (let y = 0; y < 50; y++){
															costs.set(x, y, 255);
													}
											}
											let roadPositions = getRoadPositions(room.name,room.name);
											for (let i in roadPositions){
													let pos = roadPositions[i];
													costs.set(pos.x, pos.y, 1);
													pos.highlight('green');
											}
											if (!roadPositions || !roadPositions.length || roadPositions.length < 10){
													return false
											}
											let structures = room.find(FIND_STRUCTURES);
											for (let i in structures){
													let structure = structures[i];
													if (structure.structureType != 'road' && structure.structureType != 'container' &&
															(!structure.my || structure.structureType != 'rampart')){
															costs.set(structure.pos.x, structure.pos.y, 255);
													}
											}
											costs = blockKeyPositions(costs,room);
											playerHeap.roadMatrixCache[this.name] = costs.serialize();
									}
									this._roadMatrix = costs;

							}
							return this._roadMatrix;
					},
					enumerable: false,
					configurable: true
			});
			Object.defineProperty(Room.prototype,'sector', {
					get: function (){
							if (!this._sector){
									let name = this.name;
									this._sector = Game.map.getSector(name);
							}
							return this._sector;
					},
					enumerable: false,
					configurable: true
			});
			Object.defineProperty(Room.prototype,'siteNumber', {
					value: 0,
					writable: true,
					enumerable: false,
					configurable: true
			});
			Object.defineProperty(Room.prototype,'spawnFree',{
					get(){
							if (this._spawnFree !== undefined){
									return this._spawnFree
							}
							let ret = false;
							let room = this;
							if (!this.memory.spawnNextFree){
									let spawns = room.findStructures('spawn');
									if (spawns.length > CONTROLLER_STRUCTURES['spawn'][room.controller.level]){
											console.log('extra spawn',room.name);
											console.log('too many spawns',room.name);
											spawns = spawns.filter((s)=>s.isActive());
									}
									let nextFreeIn = 50;
									for (let i in spawns){
											if (i > 0 && this.renewDefenceCreeps){
													continue
											}
											if (!spawns[i].spawning){
													nextFreeIn = 0;
											} else if (spawns[i].spawning.remainingTime-1 < nextFreeIn){
													nextFreeIn = spawns[i].spawning.remainingTime-1;
											}
									}
									this.memory.spawnNextFree = Game.time+nextFreeIn;
							}
							if (Game.time >= this.memory.spawnNextFree){
									ret = true;
									delete this.memory.spawnNextFree;
							}
							this._spawnFree = ret;
							return ret
					},
					configurable:true
			});
			Object.defineProperty(Room.prototype,'storeFillRatio', {
					get: function (){
							if (!this._storeFillRatio){
									let total = 0,used = 0;
									if (this.storage){
											total += this.storage.store.getCapacity();
											used += this.storage.store.getUsedCapacity();
									}
									if (this.terminal){
											total += this.storage.store.getCapacity();
											used += this.storage.store.getUsedCapacity();
									}
									if (total && used){
											this._storeFillRatio = used/total;
									} else {
											this._storeFillRatio = 0;
									}
							}
							return this._storeFillRatio;
					},
					enumerable: false,
					configurable: true
			});
			Object.defineProperty(Room.prototype,'structureMatrix', {
					get: function (){
							if (!this._structureMatrix){
									let costs;
									let interval = 50;
									if (this.memory.hostiles || (this.controller && this.controller.owner && !this.controller.my)){
											interval = 5;
									}
									if (playerHeap.structureMatrixCache[this.name] && (Game.time+Math.round(Math.random()*49)) % interval != 0){
											costs = PathFinder.CostMatrix.deserialize(playerHeap.structureMatrixCache[this.name]);
									} else {
											costs = new PathFinder.CostMatrix;
											this.find(FIND_STRUCTURES).forEach(function (struct){
													if (struct.structureType === STRUCTURE_ROAD && costs.get(struct.pos.x, struct.pos.y) < 255){
															// Favor roads over plain tiles
															costs.set(struct.pos.x, struct.pos.y, 1);
													} else if (struct.structureType === STRUCTURE_CONTAINER){
															costs.set(struct.pos.x, struct.pos.y, 10);
													} else if (struct.structureType === STRUCTURE_PORTAL){
															costs.set(struct.pos.x, struct.pos.y, 20);
													}  else if (struct.structureType !== STRUCTURE_CONTAINER &&
															(struct.structureType !== STRUCTURE_RAMPART ||
																	(!struct.my && (!struct.isWhiteListed || !struct.isPublic)))){
															// Can't walk through non-walkable buildings
															costs.set(struct.pos.x, struct.pos.y, 255);
													}
											});
											this.find(FIND_CONSTRUCTION_SITES).forEach((site) => {
													if (site.structureType != STRUCTURE_ROAD && site.structureType != STRUCTURE_CONTAINER && site.structureType !== STRUCTURE_RAMPART && site.my){
															costs.set(site.pos.x, site.pos.y, 255);
													}
											});
											costs = blockKeyPositions(costs,this,true);
											playerHeap.structureMatrixCache[this.name] = costs.serialize();
									}
									this._structureMatrix = costs;

							}
							return this._structureMatrix.clone();
					},
					enumerable: false,
					configurable: true
			});
			Object.defineProperty(Room.prototype,'type', {
					get: function (){
							if (!this._type){
									let name = this.name;
									let COs = /\w(\d+)\w(\d+)/.exec(name);
									let x = COs[1].charAt(COs[1].length - 1);
									let y = COs[2].charAt(COs[2].length - 1);
									if (x == 0 || y == 0){
											this._type = 'highway';
									} else if (x == 5 && y == 5){
											this._type = 'centre';
									} else if ((x == 4 || x == 5 || x == 6) && (y == 4 || y == 5 || y == 6)){
											this._type = 'SK';
									} else {
											this._type = 'normal';
									}
							}
							return this._type;
					},
					enumerable: false,
					configurable: true
			});
	}

	let militaryCreeps$1 = ['sniper','hybrid','dozer','attacker','medic','exitBlocker','coreHauler'];
	function setCreepNativeProtos(){
			//modifying native functions
			if (!Creep.prototype._attack){
					Creep.prototype._attack = Creep.prototype.attack;
					Creep.prototype.attack = function (target){
							let ret = this._attack(target);
							if (ret === 0){
									this.attackTarget = target;
							}
							return ret
					};
			}
			if (!Creep.prototype._build){
					Creep.prototype._build = Creep.prototype.build;
					Creep.prototype.build = function (target){
							let ret = this._build(target);
							let creep = this;
							if (ret === 0){
									this.building = true;
									creep.pushTowardsTarget = target;
							}
							if (config$1.logEnergy && ret == 0 && target && creep.home){
									let amount = creep.store['energy'];
									if (!creep.memory.buildPower){
											let workParts = 0;
											for (let i in creep.body){
													if (creep.body[i].type === 'work'){
															workParts++;
													}
											}
											creep.memory.buildPower = workParts * BUILD_POWER;
									}
									if (creep.memory.buildPower && creep.memory.buildPower < amount){
											amount = creep.memory.buildPower;
									}
									creep.home.logEnergyStats('build', amount);
							}
							return ret
					};
			}
			if (!Creep.prototype._harvest){
					Creep.prototype._harvest = Creep.prototype.harvest;
					Creep.prototype.harvest = function (target){
							let ret = this._harvest(target);
							let creep = this;
							if (ret === 0 && target.energyCapacity){
									//is a source
									let room = creep.home;
									if (creep.role == 'colonist' && creep.room.controller && creep.room.controller.my){
											room = creep.room;
									}

									let amountHarvested = target.energy;
									// if (creep.store.getFreeCapacity() < amountHarvested && creep.role !== 'remoteminer'){
									// 		amountHarvested = creep.store.getFreeCapacity()
									// }
									if (!creep.memory.harvestPower){
											let workParts = 0;
											for (let i in creep.body){
													if (creep.body[i].type === 'work'){
															workParts++;
													}
											}
											creep.memory.harvestPower = workParts * HARVEST_POWER;
									}
									if (creep.memory.harvestPower && creep.memory.harvestPower < amountHarvested){
											amountHarvested = creep.memory.harvestPower;
									}
									if (room){
											if (!room.memory.cumalativeHarvest){
													room.memory.cumalativeHarvest = {
															amount: 0,
															start: Game.time
													};
											}
											if (room.memory.cumalativeHarvest && Game.time - room.memory.cumalativeHarvest.start <= 1500){
													room.memory.cumalativeHarvest.amount += amountHarvested;
													//record amount harvested for one lifecycle only, if we record more and miss the check this will falsely skew source adjustment
											}
									}
									if (room && config$1.logEnergy && Memory.stats.roomEnergy){
											room.logEnergyStats('harvested', amountHarvested);
									}

							}
							return ret
					};
			}
			if (!Creep.prototype._heal){
					Creep.prototype._heal = Creep.prototype.heal;
					Creep.prototype.heal = function (target){
							let ret = this._heal(target);
							if (ret === 0 && target.my){
									target.guessNextHits(-(this.stats().heal));
							}
							return ret
					};
			}
			if (!Creep.prototype._move){
					Creep.prototype._move = Creep.prototype.move;
					Creep.prototype.move = function (a){
							let creep = this;
							let move = creep._move(a);
							creep.isMoving = true;
							return move
					};
			}
			if (!Creep.prototype._moveTo){
					Creep.prototype._moveTo = Creep.prototype.moveTo;
					Creep.prototype.moveTo = function (pos, options){
							// if (this.powers){
							// 		//powerCreepMoveTo(this, pos, options)
							// 		return
							// }
							if (!Memory.profile){
									Memory.profile = {};
							}
							if (!Memory.profile.moveTo){
									Memory.profile.moveTo = {cpu: 0, count: 0};
							}
							let cpuStart = Game.cpu.getUsed();
							let creep = this;
							if (!creep.hasCustomPathed && creep.shard === Game.shard.name){
									if (!options || (Object.keys(options).length === 1 && options.range != undefined)){
											let range = 1;
											if (options && options.range != undefined){
													range = options.range;
											}
											return creep.useCustomPathing(pos, range)
									} else if (!creep.pos.onEdge() && Object.keys(options).length === 1 && options.maxRooms && options.maxRooms === 1){
											let range = 0;
											return creep.useCustomPathing(pos, range, true)
									} else if (!creep.pos.onEdge() && Object.keys(options).length === 2 && options.range !== undefined && options.maxRooms && options.maxRooms === 1){
											let range = options.range;
											return creep.useCustomPathing(pos, range, true)
									}
							}
							if (pos && !pos.roomName){
									pos = pos.pos;
							}
							if (creep.memory.moveBlock){
									if (creep.memory.moveBlock <= 0){
											delete creep.memory.moveBlock;
									} else {
											creep.memory.moveBlock--;
									}
									if (!creep.room.memory.hostiles){
											return 'hostiles'
									}
							}
							/*
									if (creep.role == 'yak' || creep.role == 'reserve' || creep.role == 'remoteminer' || creep.role == 'remotefixer'){
											if (pos && creep.room.name == pos.roomName){
													delete creep.memory.lPath
													creep._moveTo(pos)
											} else if (creep.memory.lPath){
													if (!creep.memory.dest || creep.memory.dest != pos.toString()){
															delete creep.memory.lPath
													}
													if (creep.moveByPath(creep.memory.lPath)== -5){
															delete creep.memory.lPath
															return
													}
											} else {
													creep.memory.lPath = PathFinder.search(creep.pos,pos,{roomCallback : function(roomName){
															if (Game.map.getRoomType(roomName)=='SK'){
																	return false
															}
													}})
													creep.memory.dest = pos.toString()
													creep.moveByPath(creep.memory.lPath)
											}
											return
									}*/
							if (!options || options == undefined || !options.costCallback){
									if (!options){
											options = {};
									}
									options.costCallback = function (roomName, matrix){
											if (Game.map.getRoomType(roomName) == 'SK'){
													return Game.map.getSKMatrix(roomName)
											}
									};
							}
							let moveRet = creep._moveTo(pos, options);
							if (moveRet === -2){
									if (!pos || !pos.roomName){
											return 'ERR_NO_POS'
									}
									if (creep.room.name !== pos.roomName){
											let exit = Game.map.findExit(creep.room.name, pos.roomName);
											if (exit){
													let exitTile;
													if (exit === 1){
															exitTile = creep.pos.findClosestByPath(FIND_EXIT, {filter: (p) => p.isWalkable(true) && p.y === 0});
													} else if (exit === 3){
															exitTile = creep.pos.findClosestByPath(FIND_EXIT, {filter: (p) => p.isWalkable(true) && p.x === 49});
													} else if (exit === 5){
															exitTile = creep.pos.findClosestByPath(FIND_EXIT, {filter: (p) => p.isWalkable(true) && p.y === 49});
													} else if (exit === 7){
															exitTile = creep.pos.findClosestByPath(FIND_EXIT, {filter: (p) => p.isWalkable(true) && p.x === 0});
													}
													if (exitTile){
															return creep._moveTo(exitTile)
													} else {
															let ns = creep.pos.neighbours(1);
															for (let i in ns){
																	if (ns[i]){
																			let pos = ns[i];
																			if (pos.getTerrain() != 'wall' && pos.lookFor(LOOK_STRUCTURES).filter((s) => s.structureType != STRUCTURE_ROAD && (s.structureType != STRUCTURE_RAMPART || !s.my) && s.structureType != STRUCTURE_CONTAINER).length === 0){
																					creep.move(creep.pos.getDirectionTo(pos));
																					return 0
																			}
																	}
															}
															return -2
													}
											}
									} else {
											creep.memory.moveBlock = 5;
									}
							} else if (moveRet === 0){
									creep.isMoving = true;
							}
							let cpu = Game.cpu.getUsed() - cpuStart;
							Memory.profile.moveTo.count++;
							Memory.profile.moveTo.cpu += cpu;
					};
			}
			if (!Creep.prototype._moveByPath){
					Creep.prototype._moveByPath = Creep.prototype.moveByPath;
					Creep.prototype.moveByPath = function (path){
							let creep = this;
							if (creep._moveByPath(path) == 0){
									creep.isMoving = true;
							}
					};
			}
			if (!Creep.prototype._rangedHeal){
					Creep.prototype._rangedHeal = Creep.prototype.rangedHeal;
					Creep.prototype.rangedHeal = function (target){
							let ret = this._rangedHeal(target);
							if (ret === 0 && target.my){
									target.guessNextHits(-(this.stats().heal / 3));
							}
							return ret
					};
			}
			if (!Creep.prototype._repair){
					Creep.prototype._repair = Creep.prototype.repair;
					Creep.prototype.repair = function (target){
							let ret = this._repair(target);
							let creep = this;
							if (ret === 0){
									creep.pushTowardsTarget = target;
									this.repairing = true;
							}
							if (config$1.logEnergy && ret == 0 && target && creep.home){
									let amount = creep.store['energy'];
									if (!creep.memory.repairPower){
											let workParts = 0;
											for (let i in creep.body){
													if (creep.body[i].type === 'work'){
															workParts++;
													}
											}
											creep.memory.repairPower = workParts;
									}
									if (creep.memory.repairPower && creep.memory.repairPower < amount){
											amount = creep.memory.repairPower;
									}
									creep.home.logEnergyStats('repair', amount);
							}
							return ret
					};
			}
			if (!Creep.prototype._suicide){
					Creep.prototype._suicide = Creep.prototype.suicide;
					Creep.prototype.suicide = function (){
							delete Memory.creeps[this.name];
							removeCreepFromDeathDetection(this.name);
							return this._suicide()
					};
			}
			if (!Creep.prototype._upgradeController){
					Creep.prototype._upgradeController = Creep.prototype.upgradeController;
					Creep.prototype.upgradeController = function (target){
							let ret = this._upgradeController(target);
							let creep = this;
							if (ret === 0){
									creep.pushTowardsTarget = target;
							}
							if (config$1.logEnergy && ret == 0 && target){
									let amount = 0;
									if (target && target.level > 7){
											amount = CONTROLLER_MAX_UPGRADE_PER_TICK;
									} else {
											amount = creep.store['energy'];
									}
									if (creep.store['energy'] < amount){
											amount = creep.store['energy'];
									}
									if (!creep.memory.upPower){
											let workParts = 0;
											for (let i in creep.body){
													if (creep.body[i].type === 'work'){
															workParts++;
													}
											}
											creep.memory.upPower = workParts;
									}
									if (creep.memory.upPower && creep.memory.upPower < amount){
											amount = creep.memory.upPower;
									}
									target.room.logEnergyStats('upgrade', amount);
							}
							return ret
					};
			}

	}
	let bodyCounts = {};
	function setCreepPrototypeFunctions(){
			if (Game.time % 500 === 0){
					bodyCounts = {};
			}
			Creep.prototype.countParts = function (type){
					if (bodyCounts[this.name] && bodyCounts[this.name][type]){
							return bodyCounts[this.name][type]
					}
					let count = 0;
					let creep = this;
					for (let i in creep.body){
							if (creep.body[i].type === type){
									count++;
							}
					}
					if (!bodyCounts[this.name]){
							bodyCounts[this.name] = {};
					}
					bodyCounts[this.name][type] = count;
					return count
			};
			Creep.prototype.dismissPuller = function (){
					let creep = this;
					if (this.memory.puller && Game.getObjectById(this.memory.puller)){
							let puller = Game.getObjectById(this.memory.puller);
							delete puller.memory.pullee;
							delete creep.memory.puller;
							delete puller.memory.role;
					}
			};
			Creep.prototype.stopPulling = function (){
					let creep = this;
					if (this.memory.pullee && Game.getObjectById(this.memory.pullee)){
							let pullee = Game.getObjectById(this.memory.pullee);
							delete pullee.memory.puller;
							delete creep.memory.pullee;
							delete creep.memory.role;
					}

					if (creep.home.memory.pullers){
							for (let i = creep.home.memory.pullers.length - 1; i > -1; i--){
									if (creep.home.memory.pullers[i] === creep.id) {
											creep.home.memory.pullers.splice(i, 1);
									}
							}
					}
			};
			Creep.prototype.findContainer = function (target, range, inOpen){
					if (!range){
							range = 1;
					}
					let creep = this;
					if (target && target.pos && !this.memory.container){
							let container = target.pos.findInRange(FIND_STRUCTURES, range, {filter: (s) => s.structureType == STRUCTURE_CONTAINER})[0];
							if (container){
									creep.memory.container = container.id;
									if (creep.pos.isEqualTo(container)); else {
											creep.moveTo(container);
									}
							} else {
									if (creep.pos.inRangeTo(target, range)){
											let contSite = target.pos.lookAround(LOOK_CONSTRUCTION_SITES, range, {filter: (c) => c && c.structureType == STRUCTURE_CONTAINER})[0];
											let roadSite = target.pos.lookAround(LOOK_CONSTRUCTION_SITES, range, {filter: (c) => c && c.structureType == STRUCTURE_ROAD})[0];
											if (roadSite){
													roadSite.remove();
											}
											if (inOpen){
													let wallsNear = creep.pos.lookAround(LOOK_TERRAIN, 1, {filter: (t) => t.terrain == 'wall'});
													if (wallsNear.length > 0){
															console.log(creep.name, 'unable to place container');
															return
													}
											}
											if (!contSite){
													if (creep.room.memory.lairs){
															let positions = creep.room.memory.SKSitPositions;
															if (positions && positions.length > 0){
																	for (let i in positions){
																			if (positions[i].toPos().isNearTo(target)){
																					positions[i].toPos().createConstructionSite('container');
																			}
																	}
															}
													} else {
															creep.pos.createConstructionSite(STRUCTURE_CONTAINER);
													}
											} else if (creep.store['energy'] == creep.store.getCapacity()){
													creep.build(contSite);
													if (Game.map.getRoomType(creep.room.name) === 'SK'){
															creep.memory.cSite = contSite.id;
													}
											}
									} else {
											creep.moveTo(target, {range: 1});
									}
							}
					} else if (target && target.pos && !this.memory.container){
							let container = Game.getObjectById(this.memory.container);
							if (container && !creep.pos.isEqualTo(container)){
									creep.goTo(container);
							} else if (!container){
									delete creep.memory.container;
							}
					}
			};
			Creep.prototype.findEnergyTarget = function (room){
					if (!this || !this.my || !this.body){
							console.log('find energy target bad input');
					}
					if (!room){
							room = this.home;
					}
					return findEnergyTarget(room, this)
			};
			Creep.prototype.getPuller = function (destinationRoomName){
					let creep = this;
					if (this.memory.puller && Game.getObjectById(this.memory.puller)){
							return Game.getObjectById(this.memory.puller)
					}
					if (creep.home.memory.pullers){
							for (let i = creep.home.memory.pullers.length - 1; i > -1; i--){
									if (Game.getObjectById(creep.home.memory.pullers[i])){
											let puller = Game.getObjectById(creep.home.memory.pullers[i]);
											if (puller && !puller.spawning && (!destinationRoomName || destinationRoomName == puller.num || destinationRoomName == puller.home.name
													|| creep.role === puller.num)){
													creep.memory.puller = creep.home.memory.pullers[i];
													puller.memory.pullee = creep.id;
													creep.home.memory.pullers.splice(i, 1);
													return puller
											}
									} else {
											creep.home.memory.pullers.splice(i, 1);
									}
							}
					}
					//haven't found a puller
					if (creep.role === 'remoteminer' || creep.role === 'remotefixer'){
							let workParts = creep.countParts('work');
							let moveParts;
							if (workParts && config$1.swampyGround && !creep.home.memory.roadsDown){
									moveParts = workParts * 10;
							} else if (workParts && !creep.home.memory.roadsDown){
									moveParts = workParts * 2;
							} else if (workParts){
									moveParts = workParts;
							}
							if (moveParts && moveParts > 50){
									moveParts = 50;
							}
							creep.home.spawnPuller(creep.role, moveParts);
					} else if (creep.ticksToLive < 1480) {
							let moveParts = Math.round(creep.body.length/3);
							creep.home.spawnPuller(creep.role, moveParts);
					}
			};
			Creep.prototype.getType = function (){
					if (!this.body){
							return null
					}
					let body = this.body;
					if (body.length == 1 && body[0].type == 'move'){
							return 'scout'
					}
					let obj = {};
					for (var b in body){
							let part = body[b].type;
							if (part == 'move'); else if (!obj[part]){
									obj[part] = {part: part, amount: 1};
							} else {
									obj[part] = {part: part, amount: 1 + obj[part].amount};
							}
					}
					let arr = [];
					for (var o in obj){
							arr.push(obj[o]);
					}
					let newArr = arr.sort((a, b) => {
							if (a.part == 'carry' && a.amount == b.amount){
									return 1
							} else {
									return b.amount - a.amount
							}
					});
					if (newArr[0] && newArr[0].part && newArr[0].part == 'carry'){
							return 'carrier'
					} else if (newArr[0] && newArr[0].part){
							return (newArr[0].part + 'er')
					} else {
							return undefined
					}
			};
			Creep.prototype.goAndPickup = function (target){
					let creep = this;
					if (!target){
							console.log(this, 'GAP not target');
							return
					}
					let targetRoom = target.roomName;
					if (target.pos){
							targetRoom = target.pos.roomName;
					}
					if (creep.pos.isNearTo(target)){
							creep.pickup(target);
					} else if (creep.room.name != targetRoom){
							creep.goTo(target);
					} else {
							creep.moveTo(target, {range: 1});
					}
			};
			Creep.prototype.goAndTransfer = function (target, resource, range, ignore){
					let creep = this;
					if (!range){
							range = 1;
					}
					if (!target){
							console.log(this, 'GAT not target', target, resource);
							return
					}
					let targetRoom = target.roomName;
					if (target.pos){
							targetRoom = target.pos.roomName;
					}
					if (creep.pos.isNearTo(target)){
							if (resource){
									creep.transfer(target, resource);
							} else {
									for (let i in creep.store){
											if (creep.store[i]>0){
													let amount = creep.store[i];
													if (target.store.getFreeCapacity()< amount){
															amount = target.store.getFreeCapacity();
													}
													creep.transfer(target, i,amount);
													break
											}
									}
							}
					} else if (targetRoom && creep.room.name !=targetRoom){
							creep.goTo(target);
					} else {
							if (ignore){
									creep.moveTo(target, {range: range, ignoreCreeps: ignore});
							} else {
									creep.moveTo(target, {range: range});
							}
					}
			};
			Creep.prototype.goAndWithdraw = function (target, resource, range,amount){
					let creep = this;
					if (!range){
							range = 1;
					}
					if (!target){
							console.log(this, 'GAW not target');
							return
					}
					let roomName = target.roomName;
					if (target.pos){
							roomName = target.pos.roomName;
					}
					if (!amount){
							amount = creep.store.getFreeCapacity();
					}
					if (resource && amount > target.store[resource]){
							amount = target.store[resource];
					}
					if (creep.pos.isNearTo(target)){
							if (resource){
									creep.withdraw(target, resource,amount);
							} else {
									for (let i in target.store){
											if (target.store[i]>0){
													creep.withdraw(target, i);
													break
											}
									}
							}
					} else if (creep.room.name != roomName){
							creep.goTo(target);
					} else {
							creep.moveTo(target, {range: range});
					}
			};
			Creep.prototype.goTo = goTo;
			Creep.prototype.guessNextHits = function(damage){
					if (!this.stats().tough || damage < 0){
							this.nextHits -= damage;
							return
					}
					let currentPart = 0;
					let hitsTally = this.nextHits;
					if (this.hitsMax>this.nextHits){
							currentPart = (this.hitsMax-this.nextHits)/100;
					}
					let damageTally = damage;
					for (let i = Math.floor(currentPart); i < this.body.length;i++){
							let damageAdjust = 1;
							if (this.body[i].type === 'tough' && this.body[i].boost){
									damageAdjust = BOOSTS['tough'][this.body[i].boost];
							}
							let startHits = 100;
							let remainder = this.nextHits%100;
							if (remainder){
									startHits = remainder;
							}
							let hits = Math.round(startHits/damageAdjust);
							if (damageTally > hits){
									hits = 0;
									damageTally -= hits;
							} else {
									hits -= damageTally;
									damageAdjust = 0;
							}
							let newHits = 0;
							if (hits){
									newHits = Math.round(hits*damageAdjust);
							}
							hitsTally -= (startHits-newHits);
							if (damageTally <=0){
									break
							}
					}
					console.log('guessing next hits',this.name,'damage:',damage,'adjusted damage:',this.nextHits-hitsTally);
					this.nextHits = hitsTally;
			};
			Creep.prototype.isBoosted = function (all){
					let creep = this;
					if (!creep){
							return
					}
					if (playerHeap.boostedCreeps && playerHeap.boostedCreeps[this.id]){
							return true
					}
					if (creep.memory && creep.memory.boosted !== undefined){
							return creep.memory.boosted
					}
					for (let i in creep.body){
							if (creep.body[i].boost != undefined && (!all || all === false)){
									if (creep.memory){
											creep.memory.boosted = true;
									}
									return true
							} else if (all && all === true && creep.body[i].boost == undefined){
									if (creep.memory){
											creep.memory.boosted = false;
									}
									return false
							}
					}
					if (all && all === true){
							if (playerHeap.boostedCreeps){
									playerHeap.boostedCreeps[this.id] = true;
							}
							if (creep.memory){
									creep.memory.boosted = true;
							}
							return true
					}
					if (creep.memory){
							creep.memory.boosted = false;
					}
					return false
			};
			Creep.prototype.moveFrom = function (target){
					let n = this.pos.neighbours(1);
					let current = {pos: undefined, score: 0};
					for (let i in n){
							let neighbour = n[i];
							let score = 0;
							if (!neighbour.isWalkable(true)){
									score += -10;
							}
							if (neighbour.getTerrain() == 'swamp' || neighbour.onEdge()){
									score += -5;
							}
							let range = neighbour.getRangeTo(target);
							if (range){
									score += range;
							}
							if (neighbour.lookAround(LOOK_CREEPS, 2, {filter: (c) => !c.my}).length > 0){
									score += -5;
							}
							let nn = neighbour.neighbours(1);
							for (let j in nn){
									let neighboursNeighbour = nn[j];
									if (!neighboursNeighbour.isWalkable){
											score += -1;
									}
							}
							if (current.pos == undefined || score > current.score){
									current.pos = neighbour;
									current.score = score;
							}
					}
					if (current.pos != undefined){
							this.move(this.pos.getDirectionTo(current.pos));
					}
			};
			Creep.prototype.moveUsingSavedPath = function (sPath, startPos, target, options){
					let creep = this;
					let ret = 'ret';
					if (!Memory.stats['cpu.moveUsingSavedPath']);
					let mem = creep.cache;
					let deleteOn = undefined;
					if (options && options.deleteOn){
							deleteOn = options.deleteOn;
					}
					if (options && options.saveLocation){
							mem = options.saveLocation;
					}
					creep.isMoving = true;
					if (!Memory.profile){
							Memory.profile = {};
					}
					if (!Memory.profile.moveUsingSavedPath){
							Memory.profile.moveUsingSavedPath = {cpu: 0, count: 0};
					}
					let startCPU = Game.cpu.getUsed();
					moveUsingSavedPathMain : {
							if (!startPos || startPos.x === undefined || !sPath || creep.fatigue > 0){
									return -10
							}
							let startString = startPos.toString();
							let creepPosString = creep.pos.toString();
							if ((!mem.sPathID) || (mem.sPathID && mem.sPathID !== startString + sPath)){
									//console.log('sPath id error',creep.name,'id:',mem.sPathID,'check:',startString + sPath)
									new RoomVisual(creep.room.name).text('‼️', creep.pos);
									delete mem.sPath;
							}
							mem.sPathID = startString + sPath;
							//no path, need to get one
							if (!mem.sPath){
									new RoomVisual(creep.room.name).text('🔎', creep.pos);
									findStart(startPos, sPath, creep);
							}
							//need to save - current pos and current array pos and serial
							if (mem.sPath && mem.sPath.error){
									if (creep.role == 'remotefixer'){
											creep.moveTo(target, {range: 1});
											delete mem.sPath;
											break moveUsingSavedPathMain
									}
									if (creep.role === 'SKMineralMiner' || creep.role === 'SKMineralMover'){
											console.log(creep.name,'err',JSON.stringify(mem));
											if (Game.time % 5 === 0){
													mem = {};
													creep.wipePath();
													creep.say('reset');
													return
											} else {
													creep.say('SPE1',true);
											}
									}
									if (mem.sPath.error != 'congestion'){
											new RoomVisual(creep.room.name).text('🗑️', creep.pos);
											ret = 'delete';
											creep.moveTo(target, {range: 1});
											break moveUsingSavedPathMain
									} else if (mem.sPath.error === 'congestion'){
											let startCPU2 = Game.cpu.getUsed();
											if (!Memory.profile.moveUsingSavedPathCongestion){
													Memory.profile.moveUsingSavedPathCongestion = {cpu: 0, count: 0};
											}
											cheapMove(target);
											if (mem.sPath.pos){
													let oldPos = mem.sPath.pos.toPos();
													if (oldPos){
															let range = creep.pos.getRangeTo(oldPos);
															if (range > 5){
																	mem.sPath.current += 5;
																	delete mem.sPath.error;
															}
													}
											}
											let change = Game.cpu.getUsed() - startCPU2;
											if (Memory.profile && Memory.profile.moveUsingSavedPathCongestion){
													Memory.profile.moveUsingSavedPathCongestion.cpu += change;
													Memory.profile.moveUsingSavedPathCongestion.count++;
											}
									}
							} else if (mem.sPath){
									let ret2 = 'ret2';
									let str = mem.sPath.path;
									if (mem.sPath.pos && (creepPosString === mem.sPath.pos || (creep.pos.onEdge() && creep.pos.oppositeEdge() && creep.pos.oppositeEdge().toString() === mem.sPath.pos))){
											mem.sPath.stuck += 1;
											creep.say('st'+mem.sPath.stuck);
									} else {
											//new RoomVisual(creep.pos.roomName).text(mem.sPath.current, creep.pos)
											mem.sPath.current = mem.sPath.current + 1;
											mem.sPath.pos = creepPosString;
											mem.sPath.stuck = 0;
											new RoomVisual(creep.pos.roomName).circle(creep.pos, {radius: 0.55, stroke: 'green'});
											ret2 = 'OK';
									}
									if ((str && mem.sPath.current > str.length) || (mem.sPath.stuck && mem.sPath.stuck > 10)){
											//something has gone wrong, reset
											console.log('reset path',creep.name,creep.pos.hyperlink);
											delete mem.sPath;
											return
									}
									if (creep.room.memory.sk && Game.cpu.bucket > 9000 && Game.map.getRoomType(creep.room.name) == 'SK'){
											let nearHostiles = creep.pos.lookAround(LOOK_CREEPS, 3, {filter: (c) => c.owner.username == 'Source Keeper'});
											if (nearHostiles && nearHostiles.length > 0){
													console.log('SK path bad',creep.pos);
													creep.moveTo(target, {range: 1});
													return 'delete'
											}
									}
									let dir = mem.sPath.path.charAt(mem.sPath.current);
									//creep.pos.displayDirection(dir)
									let cancelMove = false;
									if (mem.sPath.stuck > 1){
											if (!dir){
													//can't find next order to move in - expire the route
													mem.sPath.error = true;
											}
											if (dir && creep.pos && creep.pos.movePos(dir)){
													creep.isMoving = true;
													let nextSpot = creep.pos.movePos(dir);
													let nextSpotFree = nextSpot.isWalkable(true);
													if (nextSpot && !nextSpotFree){
															nextSpot.highlight('#800006');
													}
													if (creep.role === 'puller'){
															deleteOn = 2;
													}
													if (creep.role === 'harvester'){
															deleteOn = 3;
													}
													if (nextSpot && !nextSpotFree && Game.rooms[nextSpot.roomName]){
															let inWayCreeps = Memory.inWayCreeps;
															let inWayCreep = nextSpot.creepAtPosition;
															if (inWayCreep && !inWayCreep.my){
																	inWayCreep = undefined;
															}
															//todo rather than deleting the path if there is a blockage, count forward a few steps, make a connecting path, serialize it and add it to sPath
															if (deleteOn && mem.sPath.stuck > deleteOn){
																	creep.say('delOn');
																	creep.moveTo(target, {range: 1});
																	return 'delete'
															}
															if (!inWayCreep && creep.room && creep.room.controller && creep.room.controller.isPowerEnabled){
																	let pc;
																	if (Game.gpl && Game.gpl.level > 0){
																			pc = nextSpot.lookFor(LOOK_POWER_CREEPS)[0];
																	}
																	if (pc){
																			inWayCreep = pc;
																	}
															}
															if (inWayCreep && inWayCreep.role === 'miner1' && creep.role === 'yak'){
																	if (!inWayCreep.memory.inPos){
																			inWayCreep.move(creep);
																			creep.move(inWayCreep);
																			creep.pull(inWayCreep);
																	} else {
																			creep.moveTo(target, {range: 1});
																			return 'delete'
																	}
															} else if (inWayCreep && inWayCreep.role === 'miner1' && inWayCreep.memory.inPos){
																	workAround();
															} else if (inWayCreep && mem.sPath.stuck < 2); else if (inWayCreep && mem.sPath.stuck < 5){
																	dir = Number.parseInt(dir);
																	let pushDir = dir.map8(4);
																	let try1, try2;
																	if (!config$1.official && creep.role !== 'guard'){
																			try1 = inWayCreep.pos.movePos(dir.map8(2));
																			try2 = inWayCreep.pos.movePos(dir.map8(-2));
																	}
																	if (creep.room.class === 'bunker' && creep.room.memory.armedHostiles){
																			inWayCreeps.push([inWayCreep.id, pushDir]);
																	}else if (try1 && try1.isWalkable(true)){
																			inWayCreeps.push([inWayCreep.id, dir.map8(2)]);
																	} else if (try2 && try2.isWalkable(true)){
																			inWayCreeps.push([inWayCreep.id, dir.map8(-2)]);
																	} else {
																			inWayCreeps.push([inWayCreep.id, pushDir]);
																	}
																	if (mem.sPath.stuck > 2 && creep.role !== 'guard' && !creep.room.memory.armedHostiles && (Game.time + creep.num) % 10 === 0){
																			let rand = Math.ceil(Math.random() * 8);
																			if (rand){
																					creep.move(rand);
																					creep.pos.movePos(rand);
																					//newPos.highlight('red')
																			}
																	}
															} else {
																	let canWalk = nextSpot.isWalkable();
																	if (!canWalk){
																			cancelMove = true;
																			let theoreticalPos = PathFinder.validatePath(startPos, sPath, creep.pos,undefined,mem.sPath.current);
																			console.log(creep.name,'validating path',creep.pos.hyperlink,theoreticalPos[0]);
																			if (theoreticalPos && theoreticalPos[0] && theoreticalPos[0]&& !theoreticalPos[0].isEqualTo(creep.pos)){
																					PathFinder.correctPath(sPath, creep, theoreticalPos[0], theoreticalPos[1], startPos);
																					return
																			} else {
																					ret2 = 'delete';
																					creep.blockedByStructure = true;
																			}
																	}
																	if ((mem.sPath.stuck && mem.sPath.stuck > 5)){
																			if (!canWalk && target){
																					//console.log(nextSpot.toString(), ' in way of path, final dest:', startPos, sPath, target, Game.time)
																					Memory.error = `structure in way ${nextSpot.toString()} ${startPos} ${sPath} ${target} ${Game.time}`;
																					mem.sPath.error = 'structure';
																					creep.say('structure');
																					creep.blockedByStructure = true;
																					creep.moveTo(target, {range: 1});
																					ret2 = 'delete';
																			} else if (inWayCreep && mem.sPath.stuck >= 10){
																					mem.sPath.error = 'congestion';
																					console.log('congestion ', creep.pos.toString(), Game.time);
																			} else if (mem.sPath.stuck && mem.sPath.stuck < 10){
																					workAround();
																			} else if (target){
																					mem.sPath.error = creep.pos.toString() + ' block, stuck for ' + mem.sPath.stuck + ' dir ' + dir + ' ' + Game.time;
																			} else {
																					console.log('error no target ->', target, creep.name);
																			}
																	}
															}
															new RoomVisual(creep.pos.roomName).circle(creep.pos, {radius: 0.55, stroke: 'red'});
													} else {
															new RoomVisual(creep.pos.roomName).circle(creep.pos, {radius: 0.55, stroke: 'dark green'});
															//new RoomVisual(creep.pos.roomName).circle(nextSpot, {radius: 0.55, stroke: 'red'})
													}
											}
									}
									if (dir && !cancelMove){
											//creep.say(dir)
											creep.move(dir);
									}
									ret = ret2;
									break moveUsingSavedPathMain
							}
					}
					let change = Game.cpu.getUsed() - startCPU;
					if (!Memory.stats['cpuAv.moveUsingSavedPath']){
							Memory.stats['cpuAv.moveUsingSavedPath'] = change;
					} else {
							Memory.stats['cpuAv.moveUsingSavedPath'] = (Memory.stats['cpu.moveUsingSavedPath'] + change) / 2;
					}
					if (Memory.profile && Memory.profile.moveUsingSavedPath){
							Memory.profile.moveUsingSavedPath.cpu += change;
							Memory.profile.moveUsingSavedPath.count++;
					}
					return ret

					function cheapMove(target){
							creep.pos.highlight('orange');
							if (target && target.roomName && creep.room.name != target.roomName){
									creep.moveTo(target);
							} else if (target && target.pos && target.pos.roomName && creep.room.name != target.pos.roomName){
									creep.goTo(target.pos.roomName);
							} else if (target && creep.room.name == creep.home.name && target.structureType){
									creep.moveTo(target, {
											costCallback: function (roomName, costMatrix){
													costMatrix = new PathFinder.CostMatrix;
													if (Game.rooms[roomName] && Game.rooms[roomName].structureMatrix){
															costMatrix = Game.rooms[roomName].structureMatrix;
													}
													if (creep.role !== 'staticFiller' && creep.role !== 'harvester'){
															 blockKeyPositions(costMatrix, creep.home);
													} else {
															blockKeyPositions(costMatrix, creep.home,true);
													}

											}, range: 1
									});
							} else if (target && creep.room.name == creep.home.name){
									creep.moveTo(target, {
											costCallback: function (roomName, costMatrix){
													costMatrix = new PathFinder.CostMatrix;
													if (Game.rooms[roomName] && Game.rooms[roomName].structureMatrix){
															costMatrix = Game.rooms[roomName].structureMatrix;
													}
													if (creep.role !== 'staticFiller' && creep.role !== 'harvester'){
															blockKeyPositions(costMatrix, creep.home);
													} else {
															blockKeyPositions(costMatrix, creep.home,true);
													}
											}
									});
							} else if (target && target.structureType){
									creep.moveTo(target, {range: 1});
							} else if (target){
									creep.moveTo(target);
							}
					}

					function workAround(){
							let theoreticalPos = PathFinder.validatePath(startPos, sPath, creep.pos,undefined,mem.sPath.current);
							console.log(creep.name,'validating path to work around',creep.pos.hyperlink,theoreticalPos[0]);
							if (theoreticalPos && theoreticalPos[0] && theoreticalPos[1] && theoreticalPos[0]&& theoreticalPos[0].isEqualTo(creep.pos)){
									//use this to jump around a blockage in the path
									let newPos = theoreticalPos[0].movePos(sPath[theoreticalPos[1]]);
									let newNum = theoreticalPos[1]+1;
									while (newPos && sPath[newNum] && !newPos.isWalkable(true)){
											newPos = newPos.movePos(sPath[newNum]);
											newNum++;
									}
									findStart(startPos,sPath,creep,newPos,newNum);
							}
					}

					function findStart(start, sPath, creep, walkable,walknum){
							let startCPU = Game.cpu.getUsed();
							let target = creep.pos;
							let joinPos;
							if (!walkable) {
									joinPos = PathFinder.validatePath(start, sPath, target,'orange');
							}
							if (joinPos){
									walkable = joinPos[0];
									walknum = joinPos[1];
									//joinPos[0].highlight('pink')
							}
							if (creep.pos.onEdge()){
									creep.move(creep.pos.edgeSide().map8(4));
									return
							}
							if (walkable); else if (creep.memory.sPath){
									creep.memory.sPath.error = creep.pos.toString() + ' start';
									return
							}
							PathFinder.correctPath(sPath, creep, walkable, walknum, start, mem);
							let change = Game.cpu.getUsed() - startCPU;
							if (!Memory.profile.moveUsingSavedPathStart){
									Memory.profile.moveUsingSavedPathStart = {cpu: 0, count: 0};
							}
							if (Memory.profile && Memory.profile.moveUsingSavedPathStart){
									Memory.profile.moveUsingSavedPathStart.cpu += change;
									Memory.profile.moveUsingSavedPathStart.count++;
							}
					}
			};
			Creep.prototype.nap = function (){
					let creep = this;
					//wake up
					if (creep.home && !creep.home.idleList){
							creep.home.idleList = {};
					}
					creep.wipePath();
					if (creep.role === 'depositBlocker' && creep.ticksToLive > 50){
							creep.isMoving = true;
					}
					if (creep.home && creep.home.idleList){
							creep.home.idleList[creep.role] = true;
					}
					if (creep.memory.wakeUpTime < Game.time){
							delete creep.memory.wakeUpTime;
					}
					if (!Memory.stats['idle'][creep.role]){
							Memory.stats['idle'][creep.role] = 1;
					} else {
							Memory.stats['idle'][creep.role]++;
					}
					new RoomVisual(creep.room.name).text('Z', creep.pos);
			};
			Creep.prototype.pullTo = function (destination, equalTo){
					let creep = this;
					if (destination.pos){
							destination = destination.pos;
					}
					let dRoomName = destination.roomName;
					if (!dRoomName){
							dRoomName = destination.name;
					}
					if ((equalTo && creep.pos.isEqualTo(destination)) || (!equalTo && creep.pos.isNearTo(destination))){
							creep.dismissPuller();
							return
					}
					let puller = creep.getPuller(dRoomName);
					if (!puller){
							//creep.say('no puller')
							if (creep.countParts('move')>0){
									let range = 1;
									if (equalTo){
											range = 0;
									}
									creep.moveTo(destination,{range:range});
							}
							return
					}
					puller.pulledRole = creep.role;
					if (creep.room.name === puller.room.name){
							new RoomVisual(creep.room.name).line(creep.pos, puller.pos);
					} else {
							creep.say('where my puller?');
					}
					if (puller.pos.isNearToOverEdge(creep) === true){
							puller.pull(creep);
							puller.memory.lastPulled = Game.time;
							if (creep.pos.isNearToOverEdge(puller)){
									creep.move(puller);
							} else {
									creep.moveTo(puller, {range: 0, ignoreCreeps: true});
							}
							if ((!equalTo && !puller.pos.isNearTo(destination)) || (equalTo && !puller.pos.isEqualTo(destination))){
									let range = 1;
									if (equalTo){
											range = 0;
									}
									puller.moveTo(destination, {range: range});
									if (Game.time % 20 === 0 && puller.pos.inRangeTo(destination,2) && creep.role === 'miner1' && destination && destination.roomName){
											let neighbours = destination.neighbours();
											let spotFree;
											for (let i in neighbours){
													if (neighbours[i].isWalkable(true)){
															spotFree = true;
															break
													}
											}
											if (!spotFree){
													creep.dismissPuller();
													creep.startNap(5);
											}
									}
							} else {
									puller.move(puller.pos.getDirectionTo(creep));
									creep.move(puller);
							}
					} else if (puller.pos.isNearToOverEdge(creep) === 'splitOverEdge' && !creep.pos.onEdge() && !creep.pos.nearEdge()){
							puller.say('SOE1');
							puller.moveTo(creep, {range: 1});
							if (creep.countParts('move')>0){
									creep.moveTo(destination, {range: 1});
							}
					} else if (puller.pos.isNearToOverEdge(creep) === 'splitOverEdge'){
							puller.say('SOE2');
							if (creep.countParts('move')>0){
									creep.moveTo(destination, {range: 1});
							} else {
									puller.moveTo(creep, {range: 1});
							}
					} else if (creep.pos.onEdge()){
							puller.say('COE');
							if (creep.countParts('move')>0){
									creep.moveTo(destination, {range: 1});
							}
							console.log('fucking move',puller._moveTo(creep,{range:1}));
					} else {
							puller.moveTo(creep, {range: 1});
							if (creep.countParts('move')>0){
									let range = 1;
									if (equalTo){
											range = 0;
									}
									creep.moveTo(destination,{range:range});
							}
					}
			};
			Creep.prototype.rally = function (range, napTime){
					let creep = this;
					let rally = Game.flags['rally' + creep.home.name];
					if (rally){
							rally = rally.pos;
					}
					if (creep.home.memory.rallyNearSources && (creep.role === 'upHauler' ||
							(creep.role === 'harvester' && !creep.home.storage && (!creep.home.memory.storeCont || !Game.getObjectById(creep.home.memory.storeCont))))){
							rally = creep.home.memory.rallyNearSources.toPos();
							rally.highlight('blue',{radius:1});
							range = 4;
					}
					if (!napTime){
							napTime = 0;
					}
					if (!rally){
							rally = creep.home.controller.pos;
					}
					if (!range){
							range = 1;
					}
					if (rally && !creep.pos.inRangeTo(rally, range)){
							flowPath(creep,rally,range,{addToMatrix:true});
					} else if (napTime){
							creep.startNap(napTime);
					}
			};
			Creep.prototype.remoteReserve = function (cont){
					let creep = this;
					let memory = creep.home.memory.remoteContainers;
					if (memory){
							if (memory[cont.id]){
									let index = memory[cont.id].reservations.findIndex((i) => i[0] == creep.id);
									if (index === -1){
											memory[cont.id].reservations.push([creep.id, creep.store.getCapacity()]);
									}
									memory[cont.id].freeEnergy;
									memory[cont.id].freeEnergy -= creep.store.getCapacity();
							}
					}
					creep.memory.target = cont.pos.toString();
					creep.memory.container = cont.id;
			};
			Creep.prototype.remoteWithdraw = function (cont){
					let creep = this;
					creep.say('remoteW');
					let dif;
					let ret;
					if (cont.store['energy'] === 0){
							creep.say('me');
							let memory = creep.home.memory.remoteContainers;
							if (memory){
									if (memory[cont.id]){
											//plus any difference in amount taken off originally so the count doesn't get wrong
											memory[cont.id].freeEnergy = 0;
									}
							}
							return
					}
					if (cont.store['energy'] < creep.store.getFreeCapacity()){
							ret = creep.withdraw(cont, 'energy', cont.store['energy']);
					} else {
							ret = creep.withdraw(cont, 'energy', creep.store.getFreeCapacity());
					}
					if (ret === 0){
							let memory = creep.home.memory.remoteContainers;
							if (memory){
									if (memory[cont.id]){
											//plus any difference in amount taken off originally so the count doesn't get wrong
											memory[cont.id].freeEnergy += dif;
											let index = memory[cont.id].reservations.findIndex((i) => i[0] == creep.id);
											if (index != -1){
													memory[cont.id].reservations.splice(index, 1);
											}
									}
							}
					} else {
							console.log(ret, 'remoteWithdraw error', creep.pos);
					}
					return ret
			};
			Creep.prototype.renew = function (){
					let creep = this;
					creep.say('renew');
					if (!creep || !creep.home || (!creep.home.storage || creep.home.class === 'thoriumMine')){
							return false
					}
					if (playerHeap.renewList[creep.home.name] && (!Game.getObjectById(playerHeap.renewList[creep.home.name]) ||
							!Game.getObjectById(playerHeap.renewList[creep.home.name]).memory.renewing)){
							delete playerHeap.renewList[creep.home.name];
					}
					if (creep.ticksToLive > 1300){
							delete creep.memory.renewing;
							if (playerHeap.renewList[creep.home.name]){
									delete playerHeap.renewList[creep.home.name];
							}
							return false
					}
					if (playerHeap.renewList[creep.home.name] && playerHeap.renewList[creep.home.name] !== creep.id){
							return false
					}
					if (creep.ticksToLive < 300){
							creep.memory.renewing = true;
							playerHeap.renewList[creep.home.name] = creep.id;
					} else if (!creep.memory.renewing){
							return false
					}
					let spawn = creep.pos.findClosestByRange(FIND_STRUCTURES,{filter:(s)=>s.structureType === 'spawn'});
					if (spawn){
							if (creep.pos.isNearTo(spawn)){
									spawn.renewCreep(creep);
									spawn.isRenewing = true;
							}
							creep.moveTo(spawn,{range:1});
							return true
					}
			};
			Creep.prototype.skirmish = function (target){
					let desiredRange = 3;
					if (target && target.room && target.room == this.room){
							let attack = target.stats().attack;
							let near = this.pos.lookAround(LOOK_CREEPS, 2, {filter: (c) => !c.my && c.stats().attack != undefined})[0];
							if (attack == undefined){
									desiredRange = 1;
							}
							let range = this.pos.getRangeTo(target);
							if (range <= 3 && range > 1){
									this.rangedAttack(target);
							} else if (range == 1){
									this.rangedMassAttack();
							}
							if ((range && range < desiredRange && attack != undefined) || near != undefined){
									//flee
									this.moveFrom(target);
							} else if (range && range > desiredRange){
									//close down
									this.goTo(target, {range: desiredRange, maxRooms: 1});
							} else ;
					}
			};
			Creep.prototype.startNap = function (time){
					let creep = this;
					creep.wipePath();
					//add idling to profiling so we can see if we need to spawn less
					if (!time){
							time = 5;
					}
					creep.memory.wakeUpTime = Game.time + time;
					if (creep.home && !creep.home.idleList){
							creep.home.idleList = {};
					}
					if (creep.home && creep.home.idleList){
							creep.home.idleList[creep.role] = true;
					}
					if (!Memory.stats['idle'][creep.role]){
							Memory.stats['idle'][creep.role] = 1;
					} else {
							Memory.stats['idle'][creep.role]++;
					}
			};
			Creep.prototype.towerHeal = function (room){
					let creep = this;
					creep.say('towerheal');
					creep.wipePath();
					if (creep.ticksToLive < 100 || (_.filter(creep.body, (p) => p.type === 'move').length < creep.body.length * 0.2));
					if (creep.room.name === room.name && !creep.pos.onEdge()){
							let towerlist = [];
							let towers = room.findStructures('tower');
							if (towers.length > CONTROLLER_STRUCTURES['tower'][room.controller.level]){
									towers = towers.filter((s)=>s.isActive());
							}
							if (towers && towers.length > 0){
									for (let n in towers){
											towerlist.push(towers[n]);
									}
							}
							let tower = selectTower(creep,towers,creep.room);
							if (tower && tower.store['energy'] > 500 && !room.memory.armedHostiles){
									if (creep.pos.getRangeTo(tower) <= 5 && !creep.pos.onEdge()){
											tower.heal(creep);
									} else {
											creep.moveTo(tower, {range: 1});
									}
							}
					} else {
							creep.moveTo(room.controller,{range:1});
					}
			};
			Creep.prototype.unboost = function (room){
					let creep = this;
					if (room && creep.home){
							room = creep.home;
					}
					if (!room.memory.boostflag){
							return
					}
					let pos = room.memory.boostflag.toPos();
					if (pos && !creep.pos.isEqualTo(pos)){
							creep._moveTo(pos);
					} else if (pos && room.memory.r1lab && room.memory.r2lab){
							let labs = [Game.getObjectById(room.memory.r1lab), Game.getObjectById(room.memory.r2lab)];
							let choice;
							let wait;
							labs.forEach((lab) => {
									if (!lab.cooldown){
											choice = lab;
									} else if (lab.cooldown < creep.ticksToLive){
											if (!wait || lab.cooldown < wait){
													wait = lab.cooldown;
											}
									}
							});
							let ret = false;
							if (choice){
									ret = choice.unboostCreep(creep);
							} else if (wait){
									creep.startNap(wait);
							} else {
									creep.say('please kill me');
									ret = -5;
							}
							return ret
					}
			};
			Creep.prototype.useCustomPathing = function (target, range, sameRoom){
					let creep = this;
					let startCpu = Game.cpu.getUsed();
					let swamp = 5;
					let plain = 3;
					if (!config$1.conserveCpu){
							swamp = 15;
					}
					if (creep.role == 'claimer'){
							swamp = 1;
							plain = 1;
					}
					if (!remoteRoadsPresent(creep.home)){
							swamp = 3;
							plain = 1;
					}
					if (!Memory.profile.customPathing){
							Memory.profile.customPathing = {cpu: 0, count: 0};
					}

					if (target && target.pos){
							target = target.pos;
					}
					if (!target || !target.roomName){
							creep.say('CuP err');
							console.log('CUP err',target);
							return 'CuP err'
					}
					if (creep.memory.blockCustomPathing && creep.memory.blockCustomPathing === target.toString()){
							if (target){
									let targetRoomName = target.roomName;
									if (!targetRoomName && target.pos){
											targetRoomName = target.pos.roomName;
									}
									if (targetRoomName){
											if (creep.room.name !== targetRoomName){
													creep.goTo(target,{SK:true});
													return 'go to'
											} else {
													delete  creep.memory.blockCustomPathing;
											}
									}
							}
					}
					let maxRooms = 64;
					if (target.roomName && this.room.name === target.roomName && !this.pos.onEdge() && sameRoom){
							maxRooms = 1;
					}
					if (!creep.hasCustomPathed){
							creep.hasCustomPathed = true;
							creep.isMoving = true;
					} else {
							return 'already pathed'
					}
					if (range === undefined){
							range = 1;
							if (target.getTerrain() === 'wall'){
									range = 1;
							}
					}
					if (creep.pos.roomName === target.roomName){
							let rangeTo = creep.pos.getRangeTo(target);
							if (rangeTo <= range){
									return
							} else if (rangeTo === 1 && range === 0){
									if (target.isWalkable()){
											let dir = creep.pos.getDirectionTo(target);
											creep.memory.customPath = {
													target: target.toString(),
													start: creep.pos.toString(),
													path: dir.toString()
											};
									} else {
											return
									}
							}
					}
					if (!creep.memory.customPath || creep.memory.customPath.target != target.toString() || !creep.memory.customPath.path){
							creep.pos.highlight('gold');
							if (creep.pos.onEdge() && target.roomName && (creep.room.name == target.roomName || creep.pos.oppositeEdge().roomName === target.roomName)){
									let dir = creep.pos.edgeSide();
									if (creep.room.name == target.roomName){
											dir = dir.map8(4);
									}
									creep.move(dir);
							}
							let path = savePath(creep.pos, target);
							if (path){
									creep.memory.customPath = {
											target: target.toString(),
											start: creep.pos.toString(),
											path: path
									};
							} else {
									console.log('no path starting nap',creep.name,creep.pos.hyperlink,target.hyperlink);
									if (creep.role === 'observer'){
											delete creep.memory.target;
									}
									creep.memory.blockCustomPathing = target.toString();
									creep.startNap(5);
							}
					}
					if (creep.memory.customPath && creep.memory.customPath.still && creep.memory.customPath.still > 3){
							//creep.pos.highlight('red')
							delete creep.memory.customPath;
							delete creep.cache.customPathData;
					}
					if (creep.memory.customPath){
							if (!creep.fatigue){
									if (creep.memory.customPath.pos == creep.pos.toString()){
											if (!creep.memory.customPath.still){
													creep.memory.customPath.still = 1;
											} else {
													creep.memory.customPath.still++;
											}
									} else {
											creep.memory.customPath.pos = creep.pos.toString();
									}
							}
							if (!creep.cache.customPathData){
									creep.cache.customPathData = {};
							}
							let ret = creep.moveUsingSavedPath(creep.memory.customPath.path, creep.memory.customPath.start.toPos(), creep.memory.customPath.target.toPos(), {
									saveLocation: creep.cache.customPathData,
									deleteOn: 3
							});
							if (ret === 'delete'){
									delete creep.memory.customPath;
									delete creep.cache.customPathData;
							}
							return ret
					}
					let cpu = Game.cpu.getUsed() - startCpu;
					Memory.profile.customPathing.count++;
					Memory.profile.customPathing.cpu += cpu;
					//todo identify cpu cost here
					function savePath(start, target){
							let cpu = Game.cpu.getUsed();
							//find path if loadPath return null and creep is near container (as this means the path will no be on the unwalkable mining spot)
							let path = PathFinder.search(start, {pos: target, range: range}, {
									maxOps: 20000,
									plainCost: plain,
									swampCost: swamp,
									maxRooms: maxRooms,
									roomCallback: function (roomName){
											let room = Game.rooms[roomName];
											let costs = new PathFinder.CostMatrix();
											if (room){
													costs = room.structureMatrix;
											}
											if (!militaryCreeps$1 || !militaryCreeps$1.includes(creep.role)){
													if (Game.map.isCoreRoom(roomName)){
															return false
													}
											}
											if (Game.map.getRoomType(roomName) == 'SK'){
													let otherM = Game.map.getSKMatrix(roomName);
													if (otherM && (Game.map.isCoreRoom(roomName))){
															let merged = PathFinder.mergeMatrix(costs,otherM);
															if (merged){
																	costs = merged;
															}
													} else {
															costs = otherM;
													}
											} else if (room && room.memory.armedHostiles && room.controller && room.controller.my && (creep.role === 'fixer' || creep.role === 'guard' || creep.role === 'fixer')){
													let otherM = room.defenceMatrix;
													if (otherM && otherM.get(start.x,start.y) < 10){
															let merged = PathFinder.mergeMatrix(costs, otherM);
															if (merged){
																	costs = merged;
															}
													}
											} else if (room && room.controller && room.controller.owner && !room.controller.isWhiteListed){
													let otherM = room.getTowerPowerMatrix();
													if (otherM){
															let merged = PathFinder.mergeMatrix(costs, otherM);
															if (merged){
																	costs = merged;
															}
													}
											}
											if (!room) return costs;
											if (!costs && (creep.room.name === roomName || (militaryCreeps$1 && militaryCreeps$1.includes(creep.role)))){
													costs = room.structureMatrix;
											} else if (!costs){
													return false
											}
											if (militaryCreeps$1 && militaryCreeps$1.includes(creep.role) && room.memory.armedHostiles){
													let otherCreeps = creep.room.find(FIND_CREEPS,{filter:(c)=> c.my && c.id !== creep.id &&
																	(c.role !== 'exitBlocker' || creep.role === 'exitBlocker')});
													otherCreeps.forEach((c)=> {
															if (c && c.pos.x && costs.get(c.pos.x, c.pos.y) < 30){
																	costs.set(c.pos.x, c.pos.y, 30);
															}
													});
											}
											if (target && target.roomName && roomName === target.roomName && Game.rooms[target.roomName] && creep.role !== 'harvester'){
													let nearCreeps = target.lookAround(LOOK_CREEPS, 2, {filter: (c) => c.name != creep.name && creep.role !== 'yak'});
													nearCreeps.forEach((c) => {
															let cost = swamp*2;
															if (creep.role === 'depositBlocker' && creep.ticksToLive > 50){
																	cost = 100;
															} else if (creep.role === 'depositBlocker'){
																	cost = 1;
															}
															if (c && c.pos.x && costs.get(c.pos.x, c.pos.y) < 55){
																	costs.set(c.pos.x, c.pos.y, cost);
															}
													});
											}
											if (roomName && roomName == creep.room.name && creep.role !== 'harvester'){
													let nearCreeps = creep.pos.lookAround(LOOK_CREEPS, 2, {filter: (c) => c.name != creep.name && creep.role !== 'yak' && creep.role !== 'upHauler'
																	&& creep.role !== 'harvester'});
													nearCreeps.forEach((c) => {
															if (c && c.pos.x && costs.get(c.pos.x, c.pos.y) < swamp*2){
																	costs.set(c.pos.x, c.pos.y, swamp*2);
															}
													});
											}
											if (room.name === creep.home.name && room.creepList && room.energyCapacityAvailable <= 550){
													//avoiding miners
													let miners = room.creepList.filter((c) => c.role === 'miner1');
													if (creep.role === 'puller');
													if (miners && miners.length > 0){
															miners.forEach((m) => costs.set(m.pos.x, m.pos.y, 50));
													}
											} else if (room.memory.sourcePositions && room.controller.my){
													for (let i in room.memory.sourcePositions){
															if (room.memory.sourcePositions[i].pos){
																	let pos = room.memory.sourcePositions[i].pos.toPos();
																	if (pos && pos.lookAround(LOOK_CREEPS, 0, {filter: (c) => c.role === 'miner1'})[0]){
																			let score = 255;
																			costs.set(pos.x, pos.y, score);
																	}
															}
													}
											}
											if (room && room.controller && room.controller.my && room.memory.upgraderPositions && creep.role !== 'staticUpgrader' &&
													(creep.role !== 'puller' || !creep.pulledRole || creep.pulledRole !== 'staticUpgrader')){
													for (let p in room.memory.upgraderPositions){
															let pos = room.memory.upgraderPositions[p].toPos();
															if (pos && costs.get(pos.x,pos.y)<100){
																	costs.set(pos.x,pos.y,100);
															}
													}
											}
											if (creep.role !== 'staticFiller' && creep.role !== 'harvester'){
													costs = blockKeyPositions(costs,room);
											} else {
													costs = blockKeyPositions(costs,room,true);
											}
											if (sameRoom){
													let exits = room.find(FIND_EXIT);
													exits.forEach((e)=>costs.set(e.x, e.y, 50));
											} else if (target.roomName !== creep.room.name || (room && (!room.controller || room.controller.my))){
													let exitRooms = Game.map.describeExits(room.name);
													for (let i in exitRooms){
															if (Memory.ownedRooms[exitRooms[i]] || Game.map.isCoreRoom(exitRooms[i])){
																	if (Memory.ownedRooms[exitRooms[i]]){
																			let owner = Memory.ownedRooms[exitRooms[i]].owner;
																			if (config$1.allies && config$1.allies.includes(owner)){
																					continue
																			}
																			if (config$1.canAccessRooms && !config$1.canAccessRooms.includes(owner)){
																					continue
																			}
																	}
																	let exits = room.find(i);
																	exits.forEach((e)=>costs.set(e.x, e.y, 50));
															}
													}
											}
											if (target && target.roomName && Game.map.getRoomType(target.roomName) !== 'normal' && target.roomName === room.name && target.lookAround(LOOK_STRUCTURES,0,{filter:(s)=>s.structureType === 'portal'}).length > 0){
													costs.set(target.x,target.y,1);
											}
											return costs;
									},
							});
							let dif = Game.cpu.getUsed()-cpu;
							if (dif > 4){
									console.log('custom path search',dif);
									console.log(creep.name,start,target);
							}
							if (path.incomplete && Game.time % 50 === 0){
									console.log('incomplete', path.ops, path.cost, path.path, 'target:', target, 'range', range);
									creep.goTo(target);
									return null
							} else {
									new RoomVisual(creep.room.name).poly(path, {stroke: 'red', lineStyle: 'dashed'});
							}
							if (path && !path.incomplete){
									//serialize
									let sPath = PathFinder.serializePath(start, path, target);
									//path obj needs serialized path as well as a start pos and end pos
									return sPath
							}
					}
			};
			Creep.prototype.wipePath = function(){
					let creep = this;
					if (creep.memory.lastPathWipe && (Game.time - creep.memory.lastPathWipe)<20){
							//stop repeated wiping breaking pathing
							return
					}
					creep.memory.lastPathWipe = Game.time;
					new RoomVisual(creep.pos.roomName).text('🗑️',creep.pos);
					delete creep.memory.sPath;
					delete creep.cache.sPath;
					delete creep.memory.sPathID;
					delete creep.memory.extPath;
					delete creep.cache.sPathID;
					delete creep.cache.extPath;
					delete creep.memory.customPath;
			};
	}
	let lastCacheClear;
	function setCreepPrototypeProperties(){
			if (!lastCacheClear || Game.time-lastCacheClear>1000){
					for (let i in playerHeap.creepCache){
							if (!Game.creeps[i]){
									delete playerHeap.creepCache[i];
							}
					}
					lastCacheClear = Game.time;
			}
			Object.defineProperty(Creep.prototype, 'cache', {
					get: function (){
							if (!playerHeap.creepCache[this.name]){
									playerHeap.creepCache[this.name] = {};
							}
							return playerHeap.creepCache[this.name]
					},
					enumerable: false,
					configurable: true
			});
			Object.defineProperty(Creep.prototype, 'home', {
					get: function (){
							if (!this._home){
									this._home = Game.rooms[this.name.split(' ')[2]];
							}
							return this._home;
					},
					enumerable: false,
					configurable: true
			});
			Object.defineProperty(Creep.prototype, 'isMoving', {
					get: function (){
							if (!this._isMoving){
									this._isMoving = false;
							}
							return this._isMoving;
					},
					set: function (value){
							this._isMoving = value;
					},
					enumerable: false,
					configurable: true
			});
			Object.defineProperty(Creep.prototype, 'nextHits', {
					get: function (){
							if (!this._nextHits){
									this._nextHits = this.hits;
							}
							return this._nextHits;
					},
					set: function(newVal){
							this._nextHits = newVal;
					},
					configurable: true
			});
			Object.defineProperty(Creep.prototype, 'num', {
					get: function (){
							if (!this._num){
									let num = Number.parseInt(this.name.split(' ')[1]);
									if (isNaN(num) || this.role === 'remoteMinerDeputy'){
											num = this.name.split(' ')[1];
									}
									this._num = num;
							}
							return this._num;
					},
					enumerable: false,
					configurable: true
			});
			Object.defineProperty(Creep.prototype, 'role', {
					get: function (){
							if (!this._role){
									this._role = this.name.split(' ')[0];
							}
							return this._role;
					},
					enumerable: false,
					configurable: true
			});
			Object.defineProperty(Creep.prototype, 'shard', {
					get: function (){
							if (!this._shard){
									this._shard = this.name.split(' ')[3];
							}
							return this._shard;
					},
					enumerable: false,
					configurable: true
			});
			Object.defineProperty(Creep.prototype, 'TTLRespawnDue', {
					get: function (){
							if (!this._respawnDue){
									let creep = this;
									let role = creep.role;
									let ticks = creep.body.length*3;
									let adjust = 5;
									if (creep.home && creep.home.class === 'bunker' &&
											(creep.role === 'fixer' || creep.role === 'guard')){
											return 1
									}
									if (role === 'thoriumMineWorker' || role === 'thoriumMineOverseer'){
											return 1
									}
									if (config$1.official || Game.cpu.bucket < 5000){
											//likely to be spawning less often
											adjust = 20;
									}
									let adjustDictionary = {
											bucket: 0,
											thoriumMineHauler:0,
											thoriumMineFiller:300,
											transfer:50,
											depositMiner: 150,
											depositCarry: 500,
											staticFiller:30,
											harvester:50,
											miner1:50,
											remoteminer:50,
											colonist:300,
											SKMineralMiner:200,
											yak:130,
									};
									if (adjustDictionary[role] != undefined){
											adjust = adjustDictionary[role];
									}
									if (role === 'remoteminer' && creep.memory.timeToSource){
											adjust = creep.memory.timeToSource*1.5;
											if (adjust > 150){
													adjust = 150;
											}
									}
									this._respawnDue = ticks+adjust;
							}
							return this._respawnDue
					},
					enumerable: false,
					configurable: true
			});
	}

	let powerCreepCache = {};
	function setPowerCreepPrototypeFunctions(){
			PowerCreep.prototype._move = Creep.prototype._move;
			PowerCreep.prototype._moveByPath = Creep.prototype._moveByPath;
			PowerCreep.prototype._moveTo = Creep.prototype._moveTo;
			PowerCreep.prototype.goTo = goTo;
			PowerCreep.prototype.moveTo = Creep.prototype.moveTo;
			PowerCreep.prototype.moveUsingSavedPath = Creep.prototype.moveUsingSavedPath;
			PowerCreep.prototype.nap = Creep.prototype.nap;
			PowerCreep.prototype.rally = function (range){
					let creep = this;
					if (!creep.home){
							return
					}
					let rally = Game.flags['rally' + creep.home.name];
					if (rally){
							rally = rally.pos;
					}
					if (!rally){
							rally = creep.home.controller.pos;
					}
					if (!range){
							range = 1;
					}
					if (rally && !creep.pos.inRangeTo(rally, range)){
							creep.moveTo(rally, {range: range});
					}
			};
			PowerCreep.prototype.startNap = Creep.prototype.startNap;
			PowerCreep.prototype.useCustomPathing = Creep.prototype.useCustomPathing;
			PowerCreep.prototype.wipePath = Creep.prototype.wipePath;
	}
	function setPowerCreepPrototypeProperties(){
			Object.defineProperty(PowerCreep.prototype, 'cache', {
					get: function (){
							if (!powerCreepCache[this.name]){
									powerCreepCache[this.name] = {};
							}
							return powerCreepCache[this.name]
					},
					enumerable: false,
					configurable: true
			});
			Object.defineProperty(PowerCreep.prototype, 'home', {
					get: function (){
							if (!this._home){
									if (this.memory.home && Game.rooms[this.memory.home]){
											this._home = Game.rooms[this.memory.home];
									}
							}
							return this._home;
					},
					enumerable: false,
					configurable: true
			});
			Object.defineProperty(PowerCreep.prototype, 'isMoving', {
					get: function (){
							if (!this._isMoving){
									this._isMoving = false;
							}
							return this._isMoving;
					},
					set: function (value){
							this._isMoving = value;
					},
					enumerable: false,
					configurable: true
			});
			Object.defineProperty(PowerCreep.prototype, 'num', {
					get: function (){
							if (!this._role){
									this._role = this.name.split('-')[1];
							}
							return this._role;
					},
					enumerable: false,
					configurable: true
			});
			Object.defineProperty(PowerCreep.prototype, 'role', {
					get: function (){
							if (!this._role){
									this._role = this.name.split('-')[0];
							}
							return this._role;
					},
					enumerable: false,
					configurable: true
			});

	}

	function getRoomLayoutData(roomName){
			let obj = access('roomLayoutData');
			if (ready() && obj){
					if (obj[roomName] && obj[roomName].expiry > Game.time){
							return obj[roomName]
					} else {
							return setRoomLayoutData(roomName)
					}
			} else if (ready()){
					let dataStructure = {dataStructureName: 'roomLayoutData'};
					save('roomLayoutData',undefined,dataStructure);
			}
	}
	function setRoomLayoutData(roomName){
			let obj = access('roomLayoutData');
			if (obj && ready){
					let data = {};
					data.exits = Game.map._describeExits(roomName);
					data.status = Game.map._getRoomStatus(roomName);
					data.expiry = Game.time + 10000 + Math.round(Math.random()*5000);
					save('roomLayoutData',roomName,data);
					return data
			}
	}

	function setMapPrototypes(){
			Game.map.canHighwayMineRoom = function(roomName){
					if (Game.map.getRoomType(roomName) !== 'highway'){
							return false
					}
					if (Memory.dangerRooms && Memory.dangerRooms[roomName]){
							return false
					}
					if (playerHeap.highwayMine && playerHeap.highwayMine[roomName] && playerHeap.highwayMine[roomName].expiry>Game.time){
							return playerHeap.highwayMine[roomName].canMine
					}
					let neighbours = Game.map.roomsAround(roomName,1);
					let canMine = true;
					for (let i in neighbours){
							let statusObj = Game.map.getRoomStatus(neighbours[i]);
							if (statusObj && (statusObj.status === 'novice' || statusObj.status === 'respawn')){
									canMine = false;
							}
					}
					playerHeap.highwayMine[roomName] = {
							canMine:canMine,
							expiry: Game.time+10000
					};
					return canMine
			};
			Game.map.claimSector = function (centreRoom, allies){
					if (!Memory.territory){
							Memory.territory = {};
					}
			};
			Game.map.getHighwaySectors = function (name){
					if (!name || Game.map.getRoomType(name) != 'highway'){
							return
					}
					let side = Game.map.getHighwaySide(name);
					let sector = Game.map.getSector(name);
					if (side && side !== 'corner' && sector){
							let attachedSectors = {};
							let dirs = [1, 3, 5, 7];
							let roomsAround = {};
							for (let i in dirs){
									roomsAround[dirs[i]] = Game.map.moveRoom(name, dirs[i]);
							}
							for (let i in roomsAround){
									let newRoomName = roomsAround[i];
									if (Game.map.getRoomType(newRoomName) != 'highway'){
											attachedSectors[i] = Game.map.getSector(newRoomName);
									}
							}
							return attachedSectors
					} else if (side && sector){
							let attachedSectors = {};
							let dirs = [2, 4, 6, 8];
							let roomsAround = {};
							for (let i in dirs){
									roomsAround[dirs[i]] = Game.map.moveRoom(name, dirs[i]);
							}
							for (let i in roomsAround){
									let newRoomName = roomsAround[i];
									if (Game.map.getRoomType(newRoomName) != 'highway'){
											attachedSectors[i] = Game.map.getSector(newRoomName);
									}
							}
							return attachedSectors
					}
			};
			Game.map.getHighwaySide = function (name){
					let COs = /\w(\d+)\w(\d+)/.exec(name);
					let xEnd = COs[1].charAt(COs[1].length - 1);
					let yEnd = COs[2].charAt(COs[2].length - 1);
					if (xEnd !== undefined && yEnd !== undefined){
							if (xEnd == 0 && yEnd == 0){
									//corner
									return 'corner'
							} else if (xEnd == 0){
									return 'y'
							} else if (yEnd == 0){
									return 'x'
							}
					}
			};
			Game.map.getRoomsInSector = function (name){
					if (!name){
							return
					}
					let sector = Game.map.getSector(name);
					if (!sector){
							return
					}
					let rooms = Game.map.roomsAround(sector, 5);
					return rooms
			};
			Game.map.getRoomType = function (name){
					let COs = /\w(\d+)\w(\d+)/.exec(name);
					if (!COs){
							console.log('no COs',name);
							return
					}
					let x = COs[1].charAt(COs[1].length - 1);
					let y = COs[2].charAt(COs[2].length - 1);
					if (x == 0 || y == 0){
							var ret = 'highway';
					} else if (x == 5 && y == 5){
							var ret = 'centre';
					} else if ((x == 4 || x == 5 || x == 6) && (y == 4 || y == 5 || y == 6)){
							var ret = 'SK';
					} else {
							var ret = 'normal';
					}
					return ret;
			};
			Game.map.getSector = function (name){
					if (!name){
							return
					}
					let split = name.replace(/\d(?!\d)/, 5);
					split = split.replace(/\d$/, 5);
					return split;
			};
			Game.map.getSideOfHighwayWall = function (roomPos){
					if (roomPos && roomPos.roomName && Memory.openHighwayWalls && Memory.openHighwayWalls.rooms && Memory.openHighwayWalls.rooms.includes(roomPos.roomName)){
							return 'open'
					}
					if (roomPos && roomPos.roomName && Game.rooms[roomPos.roomName] && Game.map.getRoomType(roomPos.roomName) == 'highway'
							&& Game.map.getHighwaySide(roomPos.roomName) != 'corner'){
							if (!roomPos.isWalkable()){
									return
							}
							let highwaySide = Game.map.getHighwaySide(roomPos.roomName);
							let centre = new RoomPosition(25, 25, roomPos.roomName);
							let pos1 = new RoomPosition(25, 25, roomPos.roomName);
							let pos2 = new RoomPosition(25, 25, roomPos.roomName);
							if (highwaySide == 'y'){
									pos1.x = 0;
									pos2.x = 49;
							} else {
									pos1.y = 0;
									pos2.y = 49;
							}
							let pos1Dir = pos1.getDirectionTo(centre);
							let pos2Dir = pos2.getDirectionTo(centre);
							while (!pos1.isWalkable()){
									pos1.movePos(pos1Dir, true);
							}
							while (!pos2.isWalkable()){
									pos2.movePos(pos2Dir, true);
							}
							let exitSide;
							let path1 = PathFinder.search(roomPos, {pos: pos1, range: 0}, {
									maxRooms: 1, maxOps: 100, roomCallback: function (roomName){
											if (Game.rooms[roomName]){
													return Game.rooms[roomName].structureMatrix
											}
									}
							});
							let path2 = PathFinder.search(roomPos, {pos: pos2, range: 0}, {
									maxRooms: 1, maxOps: 100, roomCallback: function (roomName){
											if (Game.rooms[roomName]){
													return Game.rooms[roomName].structureMatrix
											}
									}
							});
							if (!path1.incomplete && !path2.incomplete){
									//room is open
									//console.log(roomPos,'room is open, shouldnt be here')
									logHighwayAsOpen(roomPos.roomName);
							} else if (!path1.incomplete){
									pos1.highlight('green');
									pos2.highlight('red');
									exitSide = pos2Dir;
							} else {
									pos2.highlight('green');
									pos1.highlight('red');
									exitSide = pos1Dir;
							}
							let sectors = Game.map.getHighwaySectors(roomPos.roomName);
							if (exitSide && sectors && sectors[exitSide]){
									return sectors[exitSide]
							}
					} else if (roomPos && roomPos.roomName && Game.rooms[roomPos.roomName] && Game.map.getRoomType(roomPos.roomName) == 'highway'){
							if (!roomPos.isWalkable()){
									return
							}
							let corners = {
									2: new RoomPosition(49, 0, roomPos.roomName),
									4: new RoomPosition(49, 49, roomPos.roomName),
									6: new RoomPosition(0, 49, roomPos.roomName),
									8: new RoomPosition(0, 0, roomPos.roomName)
							};
							let cornersArr = [new RoomPosition(49, 0, roomPos.roomName), new RoomPosition(49, 49, roomPos.roomName), new RoomPosition(0, 49, roomPos.roomName), new RoomPosition(0, 0, roomPos.roomName)];
							let corner = roomPos.findClosestByRange(cornersArr);
							if (corner && corners){
									corner.highlight('green');
									for (let i in corners){
											if (corner.isEqualTo(corners[i])){
													return Game.map.getHighwaySectors(roomPos.roomName)[i]
											}
									}
							}
					}
			};
			Game.map.isCoreRoom = function (roomName){
					if (Game.map.getSector(roomName) && Memory.sectors[Game.map.getSector(roomName)]
							&& Memory.sectors[Game.map.getSector(roomName)].invaderCore === roomName){
							return true
					}
					return false
			};
			Game.map.moveRoom = function (start, dir){
					//start is room name
					if (start && start.name){
							start = start.name;
					}
					let COs = start.match(/\d+/g);
					for (let i in COs){
							COs[i] = Number.parseInt(COs[i]);
					}
					let zones = start.match(/\D/g);
					//north east as default
					let obj = {1: [0, 1], 2: [1, 1], 3: [1, 0], 4: [1, -1], 5: [0, -1], 6: [-1, -1], 7: [-1, 0], 8: [-1, 1]};
					let adjust0 = 1, adjust1 = 1;
					//need to adjust result so direction always matches 1 as north 3 as east etc
					if (zones[0] === 'W'){
							adjust0 = -1;
					}
					let zeroTerm = (obj[dir][0] * adjust0);
					if (isNaN(zeroTerm) || (COs[0] + zeroTerm) < 0){
							zeroTerm = 0;
					}
					if (zones[1] === 'S'){
							adjust1 = -1;
					}
					let firstTerm = (obj[dir][1] * adjust1);
					if (isNaN(firstTerm) || (COs[1] + firstTerm) < 0){
							firstTerm = 0;
					}
					let newCOs = [COs[0] + zeroTerm, COs[1] + firstTerm];
					if (newCOs[1] === 0){
							if (zones[1] === 'N' && (dir === 4 || dir === 5 || dir === 6)){
									zones[1] = 'S';
							} else if (zones[1] === 'S' && (dir === 8 || dir === 1 || dir === 2)){
									zones[1] = 'N';
							}
					}
					if (newCOs[0] === 0){
							if (zones[0] === 'E' && (dir === 6 || dir === 7 || dir === 8)){
									zones[0] = 'W';
							} else if (zones[0] === 'W' && (dir === 2 || dir === 3 || dir === 4)){
									zones[0] = 'E';
							}
					}
					let ret = (zones[0] + newCOs[0] + zones[1] + newCOs[1]);
					return ret
			};
			Game.map.roomsAround = function (start, range){
					//start is room name
					if (start && start.name){
							start = start.name;
					}
					let visited = {};
					let toVisit = [];
					for (let i = 1; i < 9; i++){
							let newRoom = Game.map.moveRoom(start, i);
							if (newRoom){
									visited[newRoom] = 1;
									//[roomname,current distance from start]
									toVisit.push([newRoom, 1]);
							}
					}
					if (!range || range === 1){
							toVisit = [];
					}
					while (toVisit.length > 0){
							let currentRoom = toVisit[0][0];
							let currentJump = toVisit[0][1];
							let newJump = currentJump + 1;
							if (newJump <= range){
									for (let i = 1; i < 9; i++){
											let newRoom = Game.map.moveRoom(currentRoom, i);
											if (newRoom && currentRoom != start && !visited[newRoom]){
													visited[newRoom] = newJump;
													//[roomname,current distance from start]
													toVisit.push([newRoom, newJump]);
											}
									}
							}
							toVisit.shift();
					}
					let list = [];
					for (let i in visited){
							list.push(i);
					}
					return list
			};
			if (!Game.map._describeExits){
					Game.map._describeExits = Game.map.describeExits;
					Game.map.describeExits = function(name){
							if (ready()){
									let data = getRoomLayoutData(name);
									if (data && data.exits){
											return data.exits
									} else {
											return Game.map._describeExits(name)
									}
							} else {
									return Game.map._describeExits(name)
							}
					};
			}
			if (!Game.map._getRoomStatus){
					Game.map._getRoomStatus = Game.map.getRoomStatus;
					Game.map.getRoomStatus = function(roomName){
							if (playerHeap.roomStatus && playerHeap.roomStatus[roomName] && playerHeap.roomStatus[roomName].expiry>Game.time){
									return playerHeap.roomStatus[roomName]
							}
							try {
									let status = Game.map._getRoomStatus(roomName);
									if (status && playerHeap.roomStatus){
											playerHeap.roomStatus[roomName] = {
													status:status.status,
													timestamp:status.timestamp,
													expiry : Game.time + 10000
											};
											return playerHeap.roomStatus[roomName]
									}
							} catch (e){
									console.log(e);
							}

							return false
					};
			}
			if (!Game.map.visual._line){
					Game.map.visual._line = Game.map.visual.line;
					Game.map.visual.line= function(pos1,pos2,style){
							let ret;
							if (config.mapVisual){
									ret = Game.map.visual._line(pos1,pos2,style);
							}
							return ret
					};
			}
			if (!Game.map.visual._circle){
					Game.map.visual._circle = Game.map.visual.circle;
					Game.map.visual.circle= function(pos1,style){
							let ret;
							if (config.mapVisual){
									ret = Game.map.visual._circle(pos1,style);
							}
							return ret
					};
			}
			if (!Game.map.visual._rect){
					Game.map.visual._rect = Game.map.visual.rect;
					Game.map.visual.rect= function(topLeft,width,height,style){
							let ret;
							if (config.mapVisual){
									ret = Game.map.visual._rect(topLeft,width,height,style);
							}
							return ret
					};
			}
			if (!Game.map.visual._poly){
					Game.map.visual._poly = Game.map.visual.poly;
					Game.map.visual.poly= function(points,style){
							let ret;
							if (config.mapVisual){
									ret = Game.map.visual._poly(points,style);
							}
							return ret
					};
			}
			if (!Game.map.visual._text){
					Game.map.visual._text = Game.map.visual.text;
					Game.map.visual.text= function(text,pos,style){
							let ret;
							if (config.mapVisual){
									ret = Game.map.visual._text(text,pos,style);
							}
							return ret
					};
			}
	}

	let canPlaceSites = true;
	let siteCheckTime = Game.time;
	let orderGetTime,orderCache;
	let energyCrisis,energyCaution;
	let militaryCreeps = ['sniper','hybrid','dozer','attacker','medic','exitBlocker','coreHauler'];
	function setProtos(){
			global.config = config$1;

			Number.prototype.map8 = function (val){
					if (this > 8 || this < 1){
							console.log('cant map 8', this);
							return this
					}
					return map8(this, val)
			};
			if (!Memory.inWayCreeps){
					Memory.inWayCreeps = [];
			}

			PathFinder.serializePath = function (start, pathObj, target){
					if (!start){
							console.log('no start ser path');
							return
					}
					if (!pathObj){
							console.log('no pathObj ser path');
							return
					}
					let path = pathObj.path;
					if (!path || path.length == 0){
							if (target){
									console.log('no path ser path','start', start,'target', target, JSON.stringify(pathObj));
									return
							}
							console.log('no path ser path','start', start, JSON.stringify(pathObj));
							return
					}
					//need to make sure dir from startpos is included
					let steps = [PathFinder.oneSpaceDir(start.x, path[0].x, start.y, path[0].y)];
					for (let i = 0; i < path.length - 1; i++){
							let pos1 = path[i];
							let pos2 = path[i + 1];
							//don't want to step between rooms so only work out dir for same room
							if (pos1.roomName === pos2.roomName){
									steps.push(PathFinder.oneSpaceDir(pos1.x, pos2.x, pos1.y, pos2.y));
							} else if (pos1.oppositeEdge() && !pos1.oppositeEdge().isEqualTo(pos2)){
									let opp = pos1.oppositeEdge();
									steps.push(opp.x, pos2.x, opp.y, pos2.y);
							}
					}
					//console.log(steps)
					return steps.join('')
			},

					PathFinder.reverseSerializedPath = function (sPath){
							let arr = sPath.split('');
							let newArr = [];
							for (let i = arr.length - 1; i >= 0; i--){
									let dir = map8(arr[i], 4);
									newArr.push(dir);
							}
							return newArr.join('')
					};
			Store.prototype.contains = function (resource){
					//res is arr or string
					if (typeof resource === 'string' && this[resource] && this[resource] > 0){
							return true
					} else if (typeof resource === 'object' && Array.isArray(resource)){
							for (let i in resource){
									if (this[resource[i]] && this[resource[i]] > 0){
											return true
									}
							}
					}
					return false
			};
			Game.generateId = function (){
					return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15)
			};
			Game.getBodyCost = function (body){
					let cost = 0;
					if (!Array.isArray(body)){
							console.log('invalid body');
							return
					}
					for (let i in body){
							if (BODYPART_COST[body[i]] && typeof BODYPART_COST[body[i]] == 'number'){
									cost += BODYPART_COST[body[i]];
							}
					}
					return cost
			};
			Game.bodySizeToNumberNeeded = function (totalParts, body, part){
					//calculates the number of creeps of a body size needed to meet the total number of parts spawned,
					// part signifies if we only want to count that type of part eg to meet a certain amount of work parts
					if (!totalParts){
							return 0
					}
					if (body.body){
							body = body.body;
					}
					if (!body || body.length === 0 || !Array.isArray(body)){
							return
					}
					let number = 0;
					let partsLeft = totalParts;
					while (partsLeft > 0){
							number++;
							if (!part){
									partsLeft -= body.length;
							} else {
									let partCount = 0;
									for (let i in body){
											if (body[i] === part){
													partCount++;
											}
									}
									if (!partCount){
											break
									}
									partsLeft -= partCount;
							}
					}
					return number
			};
			RoomObject.prototype.stats = function (){
					let creep = this;
					if (!this.body){
							return
					}
					if (!this._stats || this._stats['time'] != Game.time){
							let ret = {};
							let toughParts = 0;
							let toughMod = 0;
							for (let i in creep.body){
									let part = creep.body[i];
									let boost = part.boost;
									let type = part.type;
									let boostLevel = 1;
									if (boost){
											boostLevel = BOOSTS[type][boost];
											if (boostLevel){
													boostLevel = Object.values(boostLevel)[0];
											}
									}
									let partList = {
											'work': DISMANTLE_POWER,
											'attack': ATTACK_POWER,
											'ranged_attack': RANGED_ATTACK_POWER,
											'heal': HEAL_POWER,
											'claim': 1
									};
									if (part.hits == 0){
											continue
									}
									if (type === 'tough' && boostLevel !== 1){
											toughParts++;
											toughMod += boostLevel;
									}
									if (!ret[type] && partList[type]){
											ret[type] = boostLevel * partList[type];
									} else if (partList[type]){
											ret[type] += boostLevel * partList[type];
									}
							}
							if (toughParts > 0){
									ret['toughParts'] = toughParts;
									ret['toughPower'] = toughMod / toughParts;
							}
							ret['time'] = Game.time;
							this._stats = ret;
					}
					return this._stats
			};


			console._log = console.log;
			console.log = function (){
					let detailedLog = config$1.detailedLog;
					let log = [];
					for (let i in arguments){
							log.push(arguments[i]);
					}
					log = log.join(' ');
					if (detailedLog && arguments[0] != 'stats' && arguments[0] != 'orders'){
							try {
									let error = new Error(log.toString());
									throw error;
							} catch (err){
									let split = err.stack.split("\n");
									split[0] = log;
									let str = "\n ";
									split[1] = str.concat(split[1]);
									console._log(split);
							}
					} else {
							console._log(log);
					}
			};
			Game.divertSquads = function(originalTargetRoom,destination,type){
					for (let i in Memory.squads){
							if (Memory.squads[i]){
									let squad = Memory.squads[i];
									if (squad && squad.targetRoom === originalTargetRoom && squad.state === 'moving'){
											Memory.squads[i].targetRoom = destination;
											Memory.squads[i].type = type;
									}
							}
					}
			};
			Game.supplyResource = function (resource, amount, roomName, targetRoom){
					let room;
					if (roomName && Game.rooms[roomName]){
							room = Game.rooms[roomName];
					}
					if (room && room.memory){
							if (!room.memory.supplyTo){
									room.memory.supplyTo = {};
							}
							if (!room.memory.supplyTo[targetRoom]){
									room.memory.supplyTo[targetRoom] = {};
							}
							room.memory.supplyTo[targetRoom][resource] = amount;
					}
			};
			RoomPosition.prototype.isNearToOverEdge = function (otherPos){
					if (otherPos.pos){
							otherPos = otherPos.pos;
					}
					if (this.roomName === otherPos.roomName){
							if (this.isNearTo(otherPos)){
									return true
							}
					} else {
							if (this.onEdge() && otherPos.onEdge()){
									//stuck alternating rooms
									return 'offEdge'
							} else if (this.onEdge()){
									if (this.oppositeEdge().isNearTo(otherPos) || this.oppositeEdge().isEqualTo(otherPos)){
											return true
									}
							} else if (otherPos.onEdge()){
									if (otherPos.oppositeEdge().isNearTo(this) || otherPos.oppositeEdge().isEqualTo(this)){
											return true
									}
							} else {
									return 'splitOverEdge'
							}
					}
			};
			if (!Flag.prototype._remove){
					Flag.prototype._remove = Flag.prototype.remove;
					Flag.prototype.remove = function (){
							console.log('removing flag',this);
							this._remove();
					};
			}

			Object.defineProperty(Game, 'myRooms', {
					get: function (){
							if (!this._myRooms){
									let rooms = [];
									for (let i in Game.rooms){
											if (Game.rooms[i] && Game.rooms[i].controller && Game.rooms[i].controller.my){
													rooms.push(Game.rooms[i]);
											}
									}
									this._myRooms = rooms;
							}
							return this._myRooms;
					},
					enumerable: false,
					configurable: true
			});
			Game.boostsStocked = function (boosts){
					if (!boosts || !Array.isArray(boosts) || boosts.length === 0 || !config$1.warboosts){
							return false
					}
					let roomLen = Memory.myRooms.length;
					const modifier = 0.7;
					for (let i in boosts){
							let boost = boosts[i];
							let total = Game.getResourceTotal(boost);
							if (!config$1.warboosts[boost] || (config$1.warboosts[boost] * roomLen * modifier) > total){
									return false
							}
					}
					return true
			};
			Object.defineProperty(Game, 'energyCrisis', {
					get: function (){
							if (!this._energyCrisis){
									if (energyCrisis && energyCrisis.expiry && energyCrisis.expiry > Game.time){
											Memory.energyCrisis = energyCrisis.status;
											return energyCrisis.status
									}
									if (!Memory.energyCrisis){
											Memory.energyCrisis = false;
									}
									let target = 0;
									for (let i in Game.myRooms){
											if (Game.myRooms[i].memory.reserve){
													target += Game.myRooms[i].memory.reserve;
											}
									}
									Memory.energyReserveTarget = target;
									if (Game.getResourceTotal('energy') < target * 0.8 && !Memory.energyCrisis){
											Memory.energyCrisis = true;
									}
									if (Game.getResourceTotal('energy') > target * 0.9 && Memory.energyCrisis){
											Memory.energyCrisis = false;
									}
									if (Memory.energyNeeded && Memory.energyNeeded[0] && Game.rooms[Memory.energyNeeded[0]] && Game.rooms[Memory.energyNeeded[0]].total('energy') < 15000){
											Memory.energyCrisis = true;
									}
									let num = 100;
									if (Game.cpu.bucket < 1000 && config$1.official){
											num = 1000;
									}
									energyCrisis = {
											expiry : Game.time + num,
											status : Memory.energyCrisis
									};
									this._energyCrisis = Memory.energyCrisis;
							}
							return this._energyCrisis;
					},
					enumerable: false,
					configurable: true
			});
			Game.logResources = function (){
					let list = ['RESOURCES: /n'];
					for (let i in RESOURCES_ALL){
							let resource = RESOURCES_ALL[i];
							list.push(`${resource} : ${Game.getResourceTotal(resource)} \n`);
					}
					console.log(list);
			};
			Object.defineProperty(Game, 'energyCaution', {
					get: function (){
							if (!this._energyCaution){
									if (!Memory.energyCaution){
											Memory.energyCaution = false;
									}
									if (energyCaution && energyCaution.expiry && energyCaution.expiry > Game.time){
											Memory.energyCaution = energyCaution.status;
											return energyCaution.status
									}
									let target = 0;
									for (let i in Game.myRooms){
											if (Game.myRooms[i].memory.reserve){
													target += Game.myRooms[i].memory.reserve;
											}
									}
									Memory.energyReserveTarget = target;
									if (Game.getResourceTotal('energy') <= target * 0.95 && !Memory.energyCaution){
											Memory.energyCaution = true;
									}
									if (Game.getResourceTotal('energy') > target && Memory.energyCaution){
											Memory.energyCaution = false;
									}
									if (Memory.energyNeeded && Memory.energyNeeded[0] && Game.rooms[Memory.energyNeeded[0]] && Game.rooms[Memory.energyNeeded[0]].total('energy') < 20000){
											Memory.energyCaution = true;
									}
									let num = 100;
									if (Game.cpu.bucket < 1000 || config$1.official){
											num = 1000;
									}
									energyCaution = {
											expiry : Game.time + num,
											status : Memory.energyCaution
									};
									this._energyCaution = Memory.energyCaution;
							}
							return this._energyCaution;
					},
					enumerable: false,
					configurable: true
			});
			Object.defineProperty(Game, 'energySurplus', {
					get: function (){
							if (!this._energySurplus){
									if (!Memory.energySurplus){
											Memory.energySurplus = false;
									}
									let target = Memory.energyReserveTarget;
									if (Game.getResourceTotal('energy') >= target * 1.5){
											Memory.energySurplus = true;
									}
									if (Game.getResourceTotal('energy') < target * 1.3 && Memory.energySurplus){
											Memory.energySurplus = false;
									}
									this._energySurplus = Memory.energySurplus;
							}
							return this._energyCaution;
					},
					enumerable: false,
					configurable: true
			});
			const resourceTotals = {};
			Game.getResourceTotal = function (res){
					if (resourceTotals[res]){
							return resourceTotals[res]
					}
					let total = 0;
					for (let i in Game.myRooms){
							let room = Game.myRooms[i];
							total += room.total(res);
					}
					resourceTotals[res] = total;
					return total
			};
			Game.auditResource = function (res,sort){
					let levels = [];
					let totalAllRooms = 0;
					for (let i in Game.myRooms){
							let room = Game.myRooms[i];
							let total = room.total(res);
							if (total > 0){
									levels.push(` ${room.name} : ${total}`);
									totalAllRooms += total;
							}
					}
					levels.push(`total: ${totalAllRooms}`);
					console.log(res,levels);
			};
			Game.auditMinerals = function (){
					console.log('Audit minerals:');
					for (let i in config$1.minerals){
							Game.auditResource(config$1.minerals[i]);
					}
			};
			Game.auditBoosts = function (){
					console.log('Audit boosts:');
					for (let i in config$1.warboosts){
							Game.auditResource(i);
					}
			};
			Object.defineProperty(Game,'username',{
					get: function (){
							if (!this._username){
									for (let i in Game.rooms){
											if (Game.rooms[i].controller && Game.rooms[i].controller.my){
													this._username = Game.rooms[i].controller.owner.username;
													break
											}
									}
							}
							return this._username;
					},
					enumerable: false,
					configurable: true
			});
			Object.defineProperty(Game,'safemodeActive',{
					get: function (){
							if (this._safemodeActive === undefined){
									for (let i in Game.myRooms){
											if (Game.myRooms[i].controller.safeMode){
													this._safemodeActive = true;
											}
									}
									if (!this._safemodeActive){
											this._safemodeActive = false;
									}
							}
							return this._safemodeActive;
					},
					enumerable: false,
					configurable: true
			});
			Game.map.getSKMatrix = function (roomName){
					if (!roomName || Game.map.getRoomType(roomName) !== 'SK'){
							return false
					}
					if (playerHeap.SKMatrixCache[roomName]){
							return playerHeap.SKMatrixCache[roomName].clone()
					}
					if (!ready()){
							return false
					}
					playerHeap.SKAvoidLists[roomName] = [];
					let matrix = new PathFinder.CostMatrix;
					let data = access('SKMatrices');
					if (!data){
							let dataStructure = {dataStructureName: 'SKMatrices'};
							save('SKMatrices',undefined,dataStructure);
							return
					}
					if (data[roomName]){
							matrix = PathFinder.CostMatrix.deserialize(data[roomName]);
							if (matrix){
									return matrix
							}
					}
					if (Game.cpu.bucket < 50 || Game.cpu.getUsed()>100){
							return false
					}
					if (Memory.rooms[roomName] && Memory.rooms[roomName].avoidLoci){
							let posArr = [];
							for (let i in Memory.rooms[roomName].avoidLoci){
									posArr.push(Memory.rooms[roomName].avoidLoci[i]);
							}
							for (let p in posArr){
									let neighbours = posArr[p].toPos().neighbours(4, true);
									for (let n in neighbours){
											let neighbour = neighbours[n];
											if (neighbour && neighbour.getTerrain() != 'wall'){
													matrix.set(neighbour.x, neighbour.y, 10);
													playerHeap.SKAvoidLists[roomName].push([neighbour.x, neighbour.y]);
											}
									}
							}
					} else if (Game.rooms[roomName]){
							let room = Game.rooms[roomName];
							let sources = room.find(FIND_SOURCES);
							let lairs = room.find(FIND_STRUCTURES, {filter: (s) => s.structureType == STRUCTURE_KEEPER_LAIR});
							let roads = room.find(FIND_STRUCTURES, {filter: (s) => s.structureType == STRUCTURE_ROAD});
							for (let i in roads){
									matrix.set(roads[i].x, roads[i].y, 1);
							}
							for (let i in sources){
									let n = sources[i].pos.neighbours(4, true);
									for (let j in n){
											let pos = n[j];
											matrix.set(pos.x, pos.y, 10);
											playerHeap.SKAvoidLists[roomName].push([n.x, n.y]);
									}
							}
							for (let i in lairs){
									let n = lairs[i].pos.neighbours(4, true);
									for (let j in n){
											let pos = n[j];
											matrix.set(pos.x, pos.y, 10);
											playerHeap.SKAvoidLists[roomName].push([n.x, n.y]);
									}
							}
					} else {
							return false
					}
					if (matrix){
							playerHeap.SKMatrixCache[roomName] = matrix;
							save('SKMatrices',roomName,matrix.serialize());
					}
					return matrix.clone()
			};
			PathFinder.mergeMatrix = function (a, b){
					if (!a && !b){
							return false
					} else if (a && !b){
							return a
					} else if (!a){
							return b
					}
					let newMatrix = new PathFinder.CostMatrix;
					for (let x = 0; x < 50; x++){
							for (let y = 0; y < 50; y++){
									let aCost = a.get(x, y);
									let bCost = b.get(x, y);
									if (aCost !== undefined && bCost !== undefined){
											if (aCost > bCost){
													newMatrix.set(x, y, aCost);
											} else if (bCost){
													newMatrix.set(x, y, bCost);
											}
									} else if (aCost !== undefined){
											newMatrix.set(x, y, aCost);
									} else if (bCost !== undefined){
											newMatrix.set(x, y, bCost);
									}
							}
					}
					return newMatrix
			};
			PathFinder.applySKMatrix = function(roomName,matrix){
					return Game.map.getSKMatrix(roomName)
			};
			Game.market.report = function (){
					let incoming = Game.market.incomingTransactions;
					let outgoing = Game.market.outgoingTransactions;
					console.log('incoming', JSON.stringify(processTransactions(incoming)));
					console.log('outgoing', JSON.stringify(processTransactions(outgoing)));

					function processTransactions(transactions){
							let obj = {};
							for (let i in transactions){
									let transaction = transactions[i];
									if (transaction.order){
											if (!obj[transaction.resourceType]){
													obj[transaction.resourceType] = {
															amount: 0,
															credits: 0
													};
											}
											obj[transaction.resourceType].amount += transaction.amount;
											obj[transaction.resourceType].credits += transaction.amount * transaction.order.price;
									}
							}
							return obj
					}
			};
			Game.market.getAllCachedOrders = function(onlyCached){
					if ((!orderGetTime || !orderCache || Game.time !== orderGetTime) && !onlyCached){
							orderGetTime = Game.time;
							orderCache = Game.market.getAllOrders();
							if (config$1.logStats){
									console.log('orders', Game.shard.name, JSON.stringify(orderCache));
							}
							return orderCache
					} else if (orderCache){
							return orderCache
					}
			};
			PathFinder.correctPath = function (sPath, creep, walkable, walknum, start, mem){
					//walkable is the pos that we join sPath, walknum is the number we are up to in sPath
					//once the point that we are joining the path is found, find the path to that and replace the start of the the path with the path to the join and change the start pos to current
					let newPath;
					if (!mem){
							mem = creep.memory;
					}
					let currentStuck = 0;
					if (mem.stuck){
							currentStuck = mem.stuck;
					}
					if (!walkable){
							//console.log(creep,creep.pos,'no walkable')
							return
					}
					if (walkable && walkable.roomName){
							//new RoomVisual(walkable.roomName).circle(walkable, {radius: 0.5, stroke: 'red', opacity: 0})
							new RoomVisual(walkable.roomName).line(creep.pos, walkable);
					}
					if (walkable && creep.pos.isEqualTo(walkable)){
							mem.sPath = {
									path: sPath,
									startPos: start.toString(),
									current: walknum,
									stuck: currentStuck,
									pos: creep.pos.toString()
							};
					}
					let swamp = 5;
					let target = walkable;
					if (!mem.sPath || !mem.sPath.error){
							//find a path to the joining point
							let newStartPath = PathFinder.search(creep.pos, {
									pos: target,
									range: 0
							}, {
									roomCallback: function (roomName){
											let room = Game.rooms[roomName];
											let costs = new PathFinder.CostMatrix();
											if (room){
													costs = room.structureMatrix;
											}
											if (!militaryCreeps || !militaryCreeps.includes(creep.role)){
													if (Game.map.isCoreRoom(roomName)){
															return false
													}
											}
											if (Game.map.getRoomType(roomName) == 'SK'){
													let otherM = Game.map.getSKMatrix(roomName);
													if (otherM && (Game.map.isCoreRoom(roomName))){
															let merged = PathFinder.mergeMatrix(costs,otherM);
															if (merged){
																	costs = merged;
															}
													} else {
															costs = otherM;
													}
											} else if (room && room.memory.armedHostiles && room.controller && room.controller.my && (creep.role === 'fixer' || creep.role === 'guard' || creep.role === 'fixer')){
													let otherM = room.defenceMatrix;
													if (otherM && otherM.get(start.x,start.y) < 10){
															let merged = PathFinder.mergeMatrix(costs, otherM);
															if (merged){
																	costs = merged;
															}
													}
											} else if (room && room.controller && room.controller.owner && !room.controller.isWhiteListed){
													let otherM = room.getTowerPowerMatrix();
													if (otherM){
															let merged = PathFinder.mergeMatrix(costs, otherM);
															if (merged){
																	costs = merged;
															}
													}
											}
											if (!room) return costs;
											if (!costs && (creep.room.name === roomName || (militaryCreeps && militaryCreeps.includes(creep.role)))){
													costs = room.structureMatrix;
											} else if (!costs){
													return false
											}
											if (militaryCreeps && militaryCreeps.includes(creep.role) && room.memory.armedHostiles){
													let otherCreeps = creep.room.find(FIND_CREEPS,{filter:(c)=> c.my && c.id !== creep.id &&
																	(c.role !== 'exitBlocker' || creep.role === 'exitBlocker')});
													otherCreeps.forEach((c)=> {
															if (c && c.pos.x && costs.get(c.pos.x, c.pos.y) < 30){
																	costs.set(c.pos.x, c.pos.y, 30);
															}
													});
											}
											if (target && target.roomName && roomName === target.roomName && Game.rooms[target.roomName] && creep.role !== 'harvester'){
													let nearCreeps = target.lookAround(LOOK_CREEPS, 2, {filter: (c) => c.name != creep.name && creep.role !== 'yak'});
													nearCreeps.forEach((c) => {
															let cost = swamp*2;
															if (creep.role === 'depositBlocker' && creep.ticksToLive > 50){
																	cost = 100;
															} else if (creep.role === 'depositBlocker'){
																	cost = 1;
															}
															if (c && c.pos.x && costs.get(c.pos.x, c.pos.y) < 55){
																	costs.set(c.pos.x, c.pos.y, cost);
															}
													});
											}
											if (roomName && roomName == creep.room.name && creep.role !== 'harvester'){
													let nearCreeps = creep.pos.lookAround(LOOK_CREEPS, 2, {filter: (c) => c.name != creep.name && creep.role !== 'yak' && creep.role !== 'upHauler'
																	&& creep.role !== 'harvester'});
													nearCreeps.forEach((c) => {
															if (c && c.pos.x && costs.get(c.pos.x, c.pos.y) < swamp*2){
																	costs.set(c.pos.x, c.pos.y, swamp*2);
															}
													});
											}
											if (room.name === creep.home.name && room.creepList && room.energyCapacityAvailable <= 550){
													//avoiding miners
													let miners = room.creepList.filter((c) => c.role === 'miner1');
													if (creep.role === 'puller');
													if (miners && miners.length > 0){
															miners.forEach((m) => costs.set(m.pos.x, m.pos.y, 50));
													}
											} else if (room.memory.sourcePositions && room.controller.my){
													for (let i in room.memory.sourcePositions){
															if (room.memory.sourcePositions[i].pos){
																	let pos = room.memory.sourcePositions[i].pos.toPos();
																	if (pos && pos.lookAround(LOOK_CREEPS, 0, {filter: (c) => c.role === 'miner1'})[0]){
																			let score = 255;
																			costs.set(pos.x, pos.y, score);
																	}
															}
													}
											}
											if (room && room.controller && room.controller.my && room.memory.upgraderPositions && creep.role !== 'staticUpgrader' &&
													(creep.role !== 'puller' || !creep.pulledRole || creep.pulledRole !== 'staticUpgrader')){
													for (let p in room.memory.upgraderPositions){
															let pos = room.memory.upgraderPositions[p].toPos();
															if (pos && costs.get(pos.x,pos.y)<100){
																	costs.set(pos.x,pos.y,100);
															}
													}
											}
											if (creep.role !== 'staticFiller' && creep.role !== 'harvester'){
													costs = blockKeyPositions(costs,room);
											} else {
													costs = blockKeyPositions(costs,room,true);
											}
											 if (target.roomName !== creep.room.name || (room && (!room.controller || room.controller.my))){
													let exitRooms = Game.map.describeExits(room.name);
													for (let i in exitRooms){
															if (Memory.ownedRooms[exitRooms[i]] || Game.map.isCoreRoom(exitRooms[i])){
																	if (Memory.ownedRooms[exitRooms[i]]){
																			let owner = Memory.ownedRooms[exitRooms[i]].owner;
																			if (config$1.allies && config$1.allies.includes(owner)){
																					continue
																			}
																			if (config$1.canAccessRooms && !config$1.canAccessRooms.includes(owner)){
																					continue
																			}
																	}
																	let exits = room.find(i);
																	exits.forEach((e)=>costs.set(e.x, e.y, 50));
															}
													}
											}
											if (target && target.roomName && Game.map.getRoomType(target.roomName) !== 'normal' && target.roomName === room.name && target.lookAround(LOOK_STRUCTURES,0,{filter:(s)=>s.structureType === 'portal'}).length > 0){
													costs.set(target.x,target.y,1);
											}
											return costs;
									},
							});
							if (newStartPath){
									new RoomVisual(creep.room.name).poly(newStartPath.path, {stroke: 'red', lineStyle: 'dashed'});
							}
							//serialize
							let cutPath = sPath.slice(walknum);
							if (walkable.isEqualTo(creep.pos)){
									//already on path so just use cutPath
									newPath = cutPath;
							} else if (newStartPath){
									let serial = PathFinder.serializePath(creep.pos, newStartPath);
									if (serial && cutPath){
											newPath = serial.concat(cutPath);
											//console.log('b',end,test)
									} else if (serial){
											newPath = serial;
									} else {
											console.log(serial, cutPath, creep.pos, walknum, walkable);
									}
							}
					}
					if (newPath){
							mem.sPath = {
									path: newPath,
									startPos: start.toString(),
									current: 0,
									stuck: currentStuck,
									pos: creep.pos.toString()
							};
					} else if (mem.sPath && mem.sPath.error){
							console.log('new path error', mem.sPath.error);
					} else {
							console.log('no new path', creep.name, creep.pos, walkable, walknum, start);
					}
			};
			RoomPosition.prototype.isOnPath = function (start, path){
					let current = new RoomPosition(start.x, start.y, start.roomName);
					if (!current){
							console.log('isOnPath', 'no start');
							return
					}
					let count = 0;
					while (current && count < path.length){
							if (current.isEqualTo(this)){
									new RoomVisual(current.roomName).circle(current, {radius: 0.5, fill: 'green'});
									return true
							}
							new RoomVisual(current.roomName).circle(current, {radius: 0.5, fill: 'red'});
							current = current.movePos(path[count]);
							count++;
					}
					return false
			};
			PathFinder.validatePath = function (start, path, target, color,throwIfOnPath){
					//either target the number in path or find the number and pos of closest point in path to target
					let desiredCount;
					let nearPos;
					if (target && target.roomName && path){
							//target is pos
							nearPos = target;
							desiredCount = path.length;
					} else if (target && typeof target === 'number'){
							//target is number
							desiredCount = target;
					} else if (!target){
							desiredCount = path.length;
					}
					let startCPU = Game.cpu.getUsed();
					let c = 'gray';
					if (color){
							c = color;
					}
					if (!Memory.profile){
							Memory.profile = {};
					}
					if (!Memory.profile.moveByVal){
							Memory.profile.moveByVal = {cpu: 0, count: 0};
					}
					let block = 0;
					let closest;
					let closestDist;
					let closestCount;
					let currentRoom;
					let count = 0;
					let alreadyOnPath = false;
					//creating a new position object that can be moved
					let currentPos = new RoomPosition(start.x, start.y, start.roomName);
					for (let i = 0; i < path.length; i++){
							if (nearPos){
									if (!currentRoom){
											currentRoom = currentPos.roomName;
									}
									if (currentRoom != currentPos.roomName){
											block = 0;
									}
									if (block > 0 && i < path.length - 2){
											block--;
									} else {
											currentRoom = currentPos.roomName;
											if (currentPos.roomName == nearPos.roomName){
													let dist = currentPos.getRangeTo(nearPos);
													if (!closest || dist < closestDist){
															if (currentPos.isWalkable(true) || dist === 0){
																	closest = currentPos;
																	closestDist = dist;
																	closestCount = count;
																	if (dist === 0){
																			alreadyOnPath = true;
																			break
																	}
															}
													}
													if (closestDist && ((dist > closestDist + 5 && closestDist < 10) || closestDist < 4 && dist > closestDist+1)){
															break
													}
													let change;
													change = Math.floor(dist / 2);
													if (change > path.length - 1 - count){
															change = count;
													}
													if (dist > 3){
															block += change;
													}
											} else {
													let change = 20;
													if (change > path.length - count){
															change = count;
													}
													block += change;
											}
									}
							}
							if (!nearPos && desiredCount && count == desiredCount){
									let change = Game.cpu.getUsed() - startCPU;
									if (Memory.profile && Memory.profile.moveByVal){
											Memory.profile.moveByVal.cpu += change;
											Memory.profile.moveByVal.count++;
									}
									return currentPos
							}
							let dir = path[i];
							let newPos = currentPos.movePos(dir);
							if (newPos){
									currentPos = newPos;
									if (currentPos && Game.rooms[currentPos.roomName]){
											//new RoomVisual(currentPos.roomName).text(count, currentPos, {color: 'black'})
											new RoomVisual(currentPos.roomName).circle(currentPos, {radius: 0.5, fill: c});
									}
							}
							count++;
					}
					if (alreadyOnPath && throwIfOnPath !== undefined && throwIfOnPath === closestCount){
							//current position is correct - likely a bad path so need to throw in order to get it deleted
							return false
					}
					if (closest && closestCount){
							return [closest, closestCount]
					} else {
							return [currentPos, count]
					}
			};
			//finds the dir between two points that are adjacent
			PathFinder.oneSpaceDir = function (x1, x2, y1, y2){
					if (y1 === 49 && y2 === 0){
							y2 = 50;
					} else if (y1 === 0 && y2 === 49){
							y2 = -1;
					}
					if (x1 === 49 && x2 === 0){
							x2 = 50;
					} else if (x1 === 0 && x2 === 49){
							x2 = -1;
					}
					let dir = PathFinder.findDir((x2 - x1), (y2 - y1));
					return dir
			},
					PathFinder.findDir = function (dx, dy){
							let adx = Math.abs(dx);
							let ady = Math.abs(dy);
							if (adx > ady * 2){
									if (dx > 0){
											return RIGHT;
									} else {
											return LEFT;
									}
							} else if (ady > adx * 2){
									if (dy > 0){
											return BOTTOM;
									} else {
											return TOP;
									}
							} else {
									if (dx > 0 && dy > 0){
											return BOTTOM_RIGHT;
									}
									if (dx > 0 && dy < 0){
											return TOP_RIGHT;
									}
									if (dx < 0 && dy > 0){
											return BOTTOM_LEFT;
									}
									if (dx < 0 && dy < 0){
											return TOP_LEFT;
									}
							}
					},
					PathFinder.roadRoute = function (start, target, options){
							if (options && options.SKavoid && options.SKavoid == true){
									var SKavoid = true;
							} else {
									var SKavoid = false;
							}
							if (target.pos){
									target = target.pos;
							}
							let path = PathFinder.search(start, {pos: target, range: 1}, {
									plainCost: 2,
									swampCost: 10,
									roomCallback: function (roomName){
											if (SKavoid == true && Game.map.getRoomType(roomName) == 'SK'){
													return false
											}
											let room = Game.rooms[roomName];
											if (!room) return;
											let costs = new PathFinder.CostMatrix;
											room.find(FIND_STRUCTURES).forEach(function (struct){
													if (struct.structureType === STRUCTURE_ROAD || (struct.structureType === STRUCTURE_CONTAINER && struct.pos.inRangeTo(start, 1))){
															// Favor roads over plain tiles
															costs.set(struct.pos.x, struct.pos.y, 1);
													} else if ((struct.structureType !== STRUCTURE_RAMPART || !struct.my)){
															// Can't walk through non-walkable buildings
															costs.set(struct.pos.x, struct.pos.y, 0xff);
													}
											});
											room.find(FIND_CONSTRUCTION_SITES).forEach(
													function (s){
															if (s.structureType === STRUCTURE_ROAD){
																	costs.set(s.pos.x, s.pos.y, 1);
															}
													}
											);
											return costs;
									},
							});
							if (path.incomplete){
									path = PathFinder.search(target, {pos: start, range: 1}, {
											plainCost: 2,
											swampCost: 10,
											roomCallback: function (roomName){
													if (!roomName){
															return false
													}
													if (SKavoid == true && Game.map.getRoomType(roomName) == 'SK'){
															return false
													}
													let room = Game.rooms[roomName];
													if (!room) return;
													let costs = new PathFinder.CostMatrix;
													room.find(FIND_STRUCTURES).forEach(function (struct){
															if (struct.structureType === STRUCTURE_ROAD){
																	// Favor roads over plain tiles
																	costs.set(struct.pos.x, struct.pos.y, 1);
															} else if (struct.structureType !== STRUCTURE_CONTAINER &&
																	(struct.structureType !== STRUCTURE_RAMPART ||
																			!struct.my)){
																	// Can't walk through non-walkable buildings
																	costs.set(struct.pos.x, struct.pos.y, 0xff);
															}
													});
													room.find(FIND_CONSTRUCTION_SITES).forEach(
															function (s){
																	if (s.structureType === STRUCTURE_ROAD){
																			costs.set(s.pos.x, s.pos.y, 1);
																	}
															}
													);
													return costs;
											},
									});
							}
							return path
					},

					Game.buildRoad = function (path, matrix){
							if (path && path.path.length > 0 && Memory.sites != undefined && Memory.sites < 90){
									//making roads
									let complete = true;
									for (var p in path.path){
											let pathPos = path.path[p];
											if (pathPos && p !== 0 && p !== path.path.length - 1 && Game.rooms[pathPos.roomName]){
													Game.rooms[pathPos.roomName].find(FIND_CONSTRUCTION_SITES).length;
													let look = pathPos.lookFor(LOOK_STRUCTURES);
													if (look.length > 0){
															var road = _.filter(look, (s) => s.structureType === STRUCTURE_ROAD);
															if (!road){
																	pathPos.saveConstructionSite('road');
															}
													} else {
															complete = false;
															pathPos.saveConstructionSite('road');
													}
													if (matrix){
															matrix.set(pathPos.x, pathPos.y, 1);
													}
											}
									}
									return complete
							}
					};
			RoomPosition.prototype.getTerrain = function (){
					let pos = this;
					let terrain;
					if (playerHeap.roomTerrainCache && playerHeap.roomTerrainCache[pos.roomName]){
							terrain = playerHeap.roomTerrainCache[pos.roomName];
					} else {
							terrain = new Room.Terrain(pos.roomName);
							playerHeap.roomTerrainCache[pos.roomName] = terrain;
					}
					switch (terrain.get(pos.x, pos.y)){
							case TERRAIN_MASK_WALL:
									return 'wall';
							case TERRAIN_MASK_SWAMP:
									return 'swamp';
							case 0:
									return 'plain';
					}
			};
			RoomPosition.prototype.saveConstructionSite = function (type){
					let mem = Memory.rooms[this.roomName];
					if (this.onEdge()){
							return
					}
					if (mem){
							if (!mem.plannedSites){
									mem.plannedSites = [];
							}
							if (!mem.plannedSites.find((i) => i[1] == this.toString())){
									mem.plannedSites.push([type, this.toString()]);
							}
					}
			};
			RoomPosition.prototype.highlight = function (colour, options){
					let pos = this;
					if (!colour){
							colour = 'grey';
					}
					let radius, opacity;
					options && options.radius ? radius = options.radius : radius = 0.6;
					options && options.opacity ? opacity = options.opacity : opacity = 0.5;
					new RoomVisual(pos.roomName).circle(pos, {fill: colour, radius: radius, opacity: opacity});
			};
			RoomPosition.prototype.displayDirection = function (dir){
					let pos = this;
					let arrows = [undefined, '🡹', '🡽', '🡺', '🡾', '🡻', '🡿', '🡸', '🡼'];
					if (!dir || !arrows[dir]){
							return
					}
					new RoomVisual(pos.roomName).text(arrows[dir], pos, {color: 'black', font: 1, backgroundPadding: 0});
			};
			RoomPosition.prototype.movePos = function (dir, reusePos, forbidOppositeEdge,highlight){
					let pos = this;
					//only set reusepos to true if you don't need the position elsewhere, it will cause the position to move
					if (!reusePos){
							pos = new RoomPosition(this.x, this.y, this.roomName);
					}
					if (!forbidOppositeEdge && pos.onEdge()){
							let edgeSide = pos.edgeSide();
							if (dir == edgeSide || dir == map8(edgeSide, 1) || dir == map8(edgeSide, -1)){
									pos = pos.oppositeEdge();
							}
					}
					let obj = {1: [0, -1], 2: [1, -1], 3: [1, 0], 4: [1, 1], 5: [0, 1], 6: [-1, 1], 7: [-1, 0], 8: [-1, -1]};
					if (dir && obj[dir] && pos && pos.roomName){
							let x = pos.x;
							let y = pos.y;
							if (x + obj[dir][0] < 0 || x + obj[dir][0] > 49 || y + obj[dir][1] < 0 || y + obj[dir][1] > 49){
									if ((x == 0 || x == 49) && (y == 0 || y == 49)){
											//corner pos, shouldnt need to use function
											return
									}
									if (!forbidOppositeEdge){
											console.log('error on edge movePos', this, pos, dir);
									}
									return null
							}
							pos.x += obj[dir][0];
							pos.y += obj[dir][1];
							return pos
					}
					return null
			};
			RoomPosition.prototype.onEdge = function (){
					if (this.x === 0 || this.y === 0 || this.x === 49 || this.y === 49){
							return true
					} else {
							return false
					}
			};
			RoomPosition.prototype.getEdge = function (){
					if (!this.roomName || !this.onEdge()){
							return false
					}
					if (this.x === 0){
							return 7
					} else if (this.y === 0){
							return 1
					} else if (this.x === 49){
							return 3
					} else if (this.y === 49){
							return 5
					}
			};
			RoomPosition.prototype.nearEdge = function (){
					if (this.x === 1 || this.y === 1 || this.x === 48 || this.y === 48){
							return true
					} else {
							return false
					}
			};
			RoomPosition.prototype.sameEdge = function (compare){
					if (!compare || compare.x === undefined){
							return
					}
					if (!this.onEdge() || !compare.onEdge()){
							return false
					}
					if (this.x === 0 || this.x === 49){
							//horizontal edges
							if (this.y === compare.y){
									return true
							} else {
									return false
							}
					} else if (this.y === 0 || this.y === 49){
							//vertical edges
							if (this.x === compare.x){
									return true
							} else {
									return false
							}
					}
			};
			RoomPosition.prototype.oppositeEdge = function (){
					let exits = Game.map.describeExits(this.roomName);
					let side = this.edgeSide();
					if (exits && side){
							let nextRoom = exits[side];
							if (nextRoom){
									let x = null;
									let y = null;
									if (side == 3){
											x = 0;
											y = this.y;
									} else if (side == 7){
											x = 49;
											y = this.y;
									} else if (side == 1){
											y = 49;
											x = this.x;
									} else if (side == 5){
											y = 0;
											x = this.x;
									}
									if (x != null && y != null){
											return new RoomPosition(x, y, nextRoom)
									} else {
											console.log('opposite edge error', this, nextRoom, x, y);
									}
							}
					}
			};
			RoomPosition.prototype.edgeSide = function (){
					if (this.x === 0){
							return 7
					} else if (this.x === 49){
							return 3
					} else if (this.y === 0){
							return 1
					} else if (this.y === 49){
							return 5
					}
			};
			RoomPosition.prototype.isWalkable = function (creepTog){
					let pos = this;
					if (!this || !this.roomName){
							console.log('isWalkable error', this);
					}
					if (!Game.rooms[this.roomName]){
							return
					}
					if (creepTog){
							if (pos.creepAtPosition){
									return false
							}
							if (pos.lookFor(LOOK_POWER_CREEPS).length !== 0){
									return false
							}
					}
					//use structureMatrix
					let matrix = Game.rooms[this.roomName].structureMatrix;
					if (matrix){
							let cost = matrix.get(pos.x, pos.y);
							if (cost < 255 && pos.getTerrain() != 'wall'){
									if (Memory.rooms[pos.roomName] && Memory.rooms[pos.roomName].sites){
											let site = pos.lookFor(LOOK_CONSTRUCTION_SITES)[0];
											if (site && site.structureType != STRUCTURE_ROAD && site.structureType != STRUCTURE_CONTAINER && site.structureType !== STRUCTURE_RAMPART){
													return false
											}
									}
									return true
							}
					} else if (pos && pos.roomName && Game.rooms[pos.roomName] && pos.lookFor(LOOK_STRUCTURES).filter((s) => s.structureType !== STRUCTURE_ROAD && s.structureType !== STRUCTURE_CONTAINER && s.structureType !== 'portal'
							&& (s.structureType !== STRUCTURE_RAMPART || !s.my)).length === 0 && pos.getTerrain() != 'wall'){
							if (Memory.rooms[pos.roomName] && Memory.rooms[pos.roomName].sites){
									let site = pos.lookFor(LOOK_CONSTRUCTION_SITES)[0];
									if (site && site.structureType != STRUCTURE_ROAD && site.structureType != STRUCTURE_CONTAINER && site.structureType !== STRUCTURE_RAMPART){
											return false
									}
							}
							return true
					}
					return false
			};
			Object.defineProperty(RoomPosition.prototype,'hyperlink',{
					get(){
							return `<a href="#!/room/${Game.shard.name}/${this.roomName}">[${ this.roomName } ${ this.x },${ this.y }]</a>`;
					},
					configurable:true
			});
			Object.defineProperty(RoomPosition.prototype,'freeSpacesAround',{
					get(){
							let ns = this.neighbours(1);
							let freeSpaces = 0;
							for (let n in ns){
									if (ns[n].getTerrain() !== 'wall'){
											freeSpaces++;
									}
							}
							return freeSpaces
					},
					configurable:true
			});
			Object.defineProperty(RoomPosition.prototype,'creepAtPosition',{
					get(){
							if (this._creepAtPosition !== undefined){
									return this._creepAtPosition
							}
							let ret = false;
							let creep = this.lookFor(LOOK_CREEPS)[0];
							if (creep){
									ret = creep;
							}
							this._creepAtPosition = ret;
							return ret
					},
					configurable:true
			});

			/**
			 *
			 * @param boostArray - the boost array to check
			 * @param margin - default 0.5,percentage of targets that we allow boosting at
			 * @param partial - only check factors that affect creep body such as heal, tough and move
			 * @returns {boolean}
			 */
			Game.canBoost = function (boostArray, margin, partial){
					if (!boostArray || !config$1.warboosts){
							return false
					}
					if (!margin){
							margin = 0.5;
					}
					for (let i in boostArray){
							let canCheck = true;
							if (partial){
									if (!config$1.squadBoostTypes['move'].includes(boostArray[i]) &&
											!config$1.squadBoostTypes['heal'].includes(boostArray[i]) &&
											!config$1.squadBoostTypes['tough'].includes(boostArray[i])
									){
											canCheck = false;
									}
							}
							if (!canCheck){
									continue
							}
							//likely enough boost stocked to move it to any room
							let target = config$1.warboosts[boostArray[i]] * Memory.myRooms.length * margin;
							if (margin > 2 && boostArray[i] !== 'UH' && boostArray !== 'KO'){
									//use actual numerical target instead
									target = margin;
							}
							if (!target || Game.getResourceTotal(boostArray[i]) < target){
									console.log('boost check, insufficient', boostArray[i], Game.getResourceTotal(boostArray[i]));
									return false
							}
					}
					return true
			};


			if (!StructureSpawn.prototype._recycleCreep){
					StructureSpawn.prototype._recycleCreep = StructureSpawn.prototype.recycleCreep;
			}
			StructureSpawn.prototype.recycleCreep = function(target){
					delete Memory.creeps[target.name];
					removeCreepFromDeathDetection(target.name);
					this._recycleCreep(target);
			};
			if (!StructureLab.prototype._boostCreep){
					StructureLab.prototype._boostCreep = StructureLab.prototype.boostCreep;
			}
			StructureLab.prototype.boostCreep = function(creep,bodyPartsCount){
					let ret = this._boostCreep(creep,bodyPartsCount);
					if (ret == 0){
							delete creep.memory.boosted;
					}
					return ret
			};
			if (!StructureLink.prototype._transferEnergy){
					StructureLink.prototype._transferEnergy = StructureLink.prototype.transferEnergy;
			}
			StructureLink.prototype.transferEnergy = function (target, amount){
					let ret = this._transferEnergy(target, amount);
					if (target && ret == 0 && config$1.logEnergy){
							let sendAmount = amount;
							if (!amount || this.store['energy'] < amount){
									sendAmount = this.store['energy'];
							}
							this.room.logEnergyStats('linkTax', sendAmount * LINK_LOSS_RATIO);
					}
					return ret
			};
			if (!StructureTerminal.prototype._send){
					StructureTerminal.prototype._send = StructureTerminal.prototype.send;
			}
			StructureTerminal.prototype.send = function (){
					if (this.hasSent){
							return -11
					}
					let ret = this._send(arguments[0], arguments[1], arguments[2], arguments[3]);
					if (ret == 0 && config$1.logEnergy){
							console.log('sending', JSON.stringify(arguments));
							let amount = arguments[1];
							let dest = arguments[2];
							let cost = Game.market.calcTransactionCost(amount, dest, this.room.name);
							this.room.logEnergyStats('terminalSendFee', cost);
					}
					this.hasSent = true;
					return ret
			};
			Game.market.purchaseResource = function (type, amount, maxAmountInRoom, margin){
					if (!margin){
							margin = 0.9;
					}
					if (!type || !amount || !maxAmountInRoom){
							return -10
					}
					if (margin > 3){
							margin = 3;
					} else if (margin < 0.5){
							margin = 0.5;
					}
					if (!Memory.resourcePurchaseQuotas){
							Memory.resourcePurchaseQuotas = {};
					}
					Memory.resourcePurchaseQuotas[type] = {
							amount: amount,
							roomAmount: maxAmountInRoom,
							margin: margin
					};
			};



			if (!RoomPosition.prototype._createConstructionSite){
					RoomPosition.prototype._createConstructionSite = RoomPosition.prototype.createConstructionSite;
					RoomPosition.prototype.createConstructionSite = function (type, name){
							if (!canPlaceSites){
									if (siteCheckTime < Game.time){
											canPlaceSites = true;
									} else {
											return -8
									}
							}
							let siteNumber = 10;
							if (config$1.maxSiteNumber){
									siteNumber = config$1.maxSiteNumber;
							}
							if ((type === 'road' || type === 'extension' || type === 'constructedWall' || type === 'rampart') &&
									Game.rooms[this.roomName] && Game.rooms[this.roomName].siteNumber && Game.rooms[this.roomName].siteNumber > siteNumber){
									return -8
							}
							let ret = this._createConstructionSite(type, name);
							if (ret == -8){
									canPlaceSites = false;
									siteCheckTime = Game.time + 10;
							}
							if (ret == 0 && Game.rooms[this.roomName] && Game.rooms[this.roomName].siteNumber){
									Game.rooms[this.roomName].siteNumber++;
							} else if (ret == 0 && Game.rooms[this.roomName]){
									Game.rooms[this.roomName].siteNumber = 1;
							}
							return ret
					};
			}
			StructureController.prototype.isAtReducedLevel = function (){
					if (!this || !this.owner || !this.my){
							return
					}
					if (!this._isAtReducedLevel){
							this._isAtReducedLevel = false;
							if (this.pos && this.pos.roomName && Memory.rooms[this.pos.roomName]
									&& Memory.rooms[this.pos.roomName].levels){
									for (let i in Memory.rooms[this.pos.roomName].levels){
											if (i && Number.parseInt(i) && Number.parseInt(i) > this.level){
													this._isAtReducedLevel = true;
											}
									}
							}
					}
					return this._isAtReducedLevel
			};

			//need a target position and a dir:0 for towards,4 for away, 2 for horizontal, 1 for diagonal towards and 3 diagonal away, positive is clockwise
			RoomPosition.prototype.strafe = function (target, dir){
					let pos = this;
					let tDir = pos.getDirectionTo(target);
					var newDir = map8(tDir, dir);
					if (newDir){
							var obj = {1: [0, -1], 2: [1, -1], 3: [1, 0], 4: [1, 1], 5: [0, 1], 6: [-1, 1], 7: [-1, 0], 8: [-1, -1]};
							return Game.rooms[pos.roomName].getPositionAt(pos.x + obj[newDir][0], pos.y + obj[newDir][1])
					}
			};
			//use lookForAtArea
			RoomPosition.prototype.lookAround = function (type, range, options){
					let pos = this;
					let arr;
					if (!Game.rooms[pos.roomName]){
							return null
					}
					if (range == 0){
							arr = Game.rooms[pos.roomName].lookForAt(type, pos);
							if (arr && arr.length > 0 && options){
									let filter = arr.filter(options.filter);
									if (filter){
											return filter
									}
									return arr
							} else if (arr){
									return arr
							} else {
									return []
							}
					} else {
							let top = pos.y - range;
							let left = pos.x - range;
							let bottom = pos.y + range;
							let right = pos.x + range;
							if (top < 0){
									top = 0;
							}
							if (left < 0){
									left = 0;
							}
							if (bottom > 49){
									bottom = 49;
							}
							if (right > 49){
									right = 49;
							}
							arr = Game.rooms[pos.roomName].lookForAtArea(type, top, left, bottom, right, true);
					}
					let newarr = [];
					for (let i in arr){
							if (arr[i] && arr[i] != undefined){//sort this out, dont just return these
									for (let j in arr[i]){
											if (j != 'x' && j != 'y' && j != 'type'){
													newarr.push(arr[i][j]);
											}
									}
							}
					}
					if (newarr && newarr.length > 0 && options && options.filter){
							newarr = newarr.filter(options.filter);
							if (!newarr){
									newarr = [];
							}
					}
					return newarr
			};
			//find neighbours
			RoomPosition.prototype.neighbours = function (range, all, highlight){
					let pos = this;
					if (!pos){
							return null
					}
					let arr = [];
					if (range === 1 || range === undefined){
							for (let i = 1; i < 9; i++){
									let newPos = pos.movePos(i, false, true);
									if (newPos && newPos.roomName && newPos.roomName === pos.roomName){
											if (newPos){
													if (highlight){
															newPos.highlight();
													}
													arr.push(newPos);
											}
									}
							}
							return arr
					}
					let toVisitList = [pos];
					let visitedPositions = {};
					visitedPositions[pos] = {distance: 0};
					let foundNeighbours = [];
					while (toVisitList.length > 0){
							let current = toVisitList.shift();
							let currentDistance = visitedPositions[current].distance;
							if (currentDistance && currentDistance > range){
									break
							}
							if (currentDistance && currentDistance > 0 && (currentDistance == range || all)){
									foundNeighbours.push(current);
							}
							let nearPositions;
							if (current && current.x != undefined && visitedPositions[current] && !visitedPositions[current].direction){
									nearPositions = current.neighbours();
							} else if (current && current.x != undefined && visitedPositions[current] && visitedPositions[current].direction){
									let dir = visitedPositions[current].direction;
									nearPositions = [current.movePos(dir.map8(-1), false, true), current.movePos(dir, false, true), current.movePos(dir.map8(1), false, true)];
							}
							if (nearPositions){
									for (let i in nearPositions){
											if (nearPositions[i] && current && visitedPositions[nearPositions[i]] === undefined && currentDistance !== undefined){
													toVisitList.push(nearPositions[i]);
													let newDir = visitedPositions[current].direction;
													if (!newDir){
															newDir = Number.parseInt(i) + 1;
													} else {
															newDir = newDir.map8(Number.parseInt(i) - 1);
													}
													visitedPositions[nearPositions[i]] = {
															distance: currentDistance + 1,
															direction: newDir
													};
											}
									}
							}
					}
					// if (foundNeighbours){
					// 		for (let i in foundNeighbours){
					// 				foundNeighbours[i].highlight()
					// 		}
					// }
					return foundNeighbours
			};

			function map8(val, jump){
					let count = jump;
					let ret = Number.parseInt(val);
					while (count != 0){
							if (count < 0){
									ret = ret - 1;
									count = count + 1;
							} else {
									ret = ret + 1;
									count = count - 1;
							}
							if (ret === 9){
									ret = 1;
							}
							if (ret === 0){
									ret = 8;
							}
					}
					return ret
			}
			String.prototype.isRoomName = function (){
					if (!this){
							return
					}
					try {
							if (/\w\d+\w\d+/.exec(this)){
									//console.log(this,'is a room name')
									return true
							}
							//console.log(this,'is NOT a room name')
							return false
					} catch(err){
							console.log('isRoomName',err);
					}
			};
			String.prototype.toPos = function (){
					let string = this;
					try {
							if (!this){
									return
							}
							let split0 = string.split(' ');
							if (split0.length < 4){
									return
							}
							let split1 = split0[3].split(',');
							let x = Number.parseInt(split1[0]);
							let y = Number.parseInt(split1[1].slice(0, -1));
							if (x != null && x != undefined && y != null && y != undefined && x > -1 && x < 50 && y > -1 && y < 50){
									let room = Game.rooms[split0[1]];
									let pos = new RoomPosition(x, y, split0[1]);
									if (pos){
											return pos
									} else {
											return null
									}
							}
					} catch (err){
							console.log(err, ',', this, ':', typeof this, '\n', 'toPos' + err.stack.split("at"));
					}
			};
			Object.defineProperty(String.prototype, 'isEnemy', {
					get: function (){
							if (this._isEnemy === undefined){
									let ret = false;
									let str = this.toString();
									if ((!config$1.allies || !config$1.allies.includes(str)) && Game.username !== str){
											if (config$1.attackAll || (config$1.enemies && config$1.enemies.includes(str))){
													ret = true;
											}
									}
									this._isEnemy = ret;
							}
							// if (this._isEnemy){
							// 		console.log(this.toString(),'is enemy')
							// } else {
							// 		console.log(this.toString(),'is not enemy')
							// }
							return this._isEnemy;
					},
					enumerable: false,
					configurable: true
			});
			Object.defineProperty(RoomObject.prototype, 'isWhiteListed', {
					get: function (){
							if (!this.owner){return false}
							if (!this._isWhiteListed){
									let ret = false;
									let obj = this;
									let user = obj.owner.username;
									if (obj.my){
											ret = true;
									} else if (obj.body && obj.spawning){
											ret = true;
									} else if (this.stats() && (this.stats().attack > 0 ||this.stats().ranged_attack > 0 ||this.stats().claim > 0) &&
											config$1.adjustedAllies && config$1.adjustedAllies.includes(user) && Memory.dangerRooms[this.room.name]){
											ret = true;
									} else if (config$1.allies && config$1.allies.includes(user)){
											ret = true;
									} else if (config$1.attackAll){
											ret = false;
									} else if ((Memory.whiteListRevoked && Memory.whiteListRevoked.includes(user)) ||
											(config$1.blackList && config$1.blackList.includes(user)) || user == 'Source Keeper' || user == 'Invader'){
											ret = false;
									} else if (config$1.whiteListAll){
											ret = true;
									} else if (config$1.whiteList && config$1.whiteList.includes(user) && (!obj.room.controller || !obj.room.controller.my)){
											ret = true;
									} else if (config$1.totalWhiteList && config$1.totalWhiteList.includes(user)){
											ret = true;
									} else if ((config$1.allowCivRoomAccess && config$1.allowCivRoomAccess.includes(user)) || (config$1.whiteList && config$1.whiteList.includes(user))){
											let stats = obj.stats();
											if (!stats.attack && !stats.ranged_attack && !stats.work){
													ret = true;
											}
									}
									this._isWhiteListed = ret;
							}
							return this._isWhiteListed;
					},
					enumerable: false,
					configurable: true
			});
			Object.defineProperty(StructureTerminal, 'hasSent', {
					get: function (){
							if (!this._hasSent){
									this._hasSent = false;
							}
							return this._hasSent;
					},
					enumerable: false,
					configurable: true
			});
			if (!StructureTerminal.prototype._send){
					StructureTerminal.prototype._send = StructureTerminal.prototype.send;
					StructureTerminal.prototype.send = function (){
							let sent = this._send(arguments[0], arguments[1], arguments[2], arguments[3]);
							if (sent == 0){ console.log('sending',arguments[0], arguments[1], arguments[2], arguments[3]);
									this.hasSent = true;
							}
							return sent
					};
			}
			setMapPrototypes();
			setRoomPrototypeFunctions();
			setRoomPrototypeProperties();
			setCreepNativeProtos();
			setCreepPrototypeFunctions();
			setCreepPrototypeProperties();
			setPowerCreepPrototypeFunctions();
			setPowerCreepPrototypeProperties();
			for (let i in Game.creeps){
					Game.creeps[i].isMoving = false;
			}
	}

	let globalId;
	let GlobalCount = 0;
	function runReport(){
			let obj = {};
			if (!Memory.boostProductionNeeded){
					Memory.boostProductionNeeded = {};
			}
			if (!Memory.urgentBoostProductionNeeded){
					Memory.urgentBoostProductionNeeded = {};
			}
			if (!Memory.mineralsNeeded){
					Memory.mineralsNeeded = {};
			}
			let resList = ['H', 'O', 'L', 'K', 'Z', 'U', 'X', 'G', 'UO', 'power', 'energy', 'metal', 'silicon', 'biomass', 'mist'];
			if (config$1.season){
					if (config$1.season === 'thorium'){
							resList.push('T');
					}
			}
			let roomCount = 0;
			for (let i in Game.rooms){
					let room = Game.rooms[i];
					if (room.controller && room.controller.my){
							roomCount++;
							for (let r in resList){
									if (!obj[resList[r]]){
											obj[resList[r]] = roomtotal(resList[r], room);
									} else {
											obj[resList[r]] += roomtotal(resList[r], room);
									}
							}
							for (let w in config$1.warboosts){
									if (!obj[w]){
											obj[w] = roomtotal(w, room);
									} else {
											obj[w] += roomtotal(w, room);
									}
							}
							for (let c in COMMODITIES){
									let commodityObj = COMMODITIES[c];
									if (commodityObj && !resList.includes(c)){
											if (!obj[c]){
													obj[c] = roomtotal(c, room);
											} else {
													obj[c] += roomtotal(c, room);
											}
									}
							}
					}
			}
			if (config$1.symbolCollection){
					for (let i in SYMBOLS){
							let amount = Game.getResourceTotal(SYMBOLS[i]);
							obj[SYMBOLS[i]] = amount;
					}
			}
			for (let i in obj){
					let res = obj[i];
					Memory.stats['report.resources.' + i] = res;
					if (config$1.warboosts[i]){
							let amountNeeded = config$1.warboosts[i] * roomCount;
							if (res < amountNeeded*0.5){
									Memory.urgentBoostProductionNeeded[i] = true;
							} else {
									delete Memory.urgentBoostProductionNeeded[i];
							}
							if (res < amountNeeded || (Game.market.credits > config$1.maxCredits*2.5 && res < amountNeeded*1.2)){
									Memory.boostProductionNeeded[i] = true;
									if (Game.market.credits > config$1.maxCredits*2){
											let margin = 1;
											let ratio = res/amountNeeded;
											let adjust = Math.pow(ratio,0.5);
											margin = 1+(1-adjust);
											if (margin > 2){
													margin = 2;
											} else if (margin < 1){
													margin = 1;
											}
											if (config$1.marketActive){
													Game.market.purchaseResource(i,100000,config$1.warboosts[i],margin);
											}
									}
							} else {
									delete Memory.boostProductionNeeded[i];
							}
					}
					if (config$1.minerals.includes(i)){
							let amountNeeded = config$1.mineralTarget* 0.5 * roomCount;
							if (res < amountNeeded){
									Memory.mineralsNeeded[i] = true;
							} else {
									delete Memory.mineralsNeeded[i];
							}
					}
			}
			obj.credits = Game.market.credits;
			if (Memory.creditLimit){
					if (Game.market.credits > Memory.creditLimit){
							Memory.creditLimit = Game.market.credits;
					}
			} else {
					Memory.creditLimit = Game.market.credits;
			}
			if (Memory.creditLimit > 10000000){
					Memory.creditLimit = 10000000;
			}
			let date = new Date();
			let hours = date.getHours();
			let excess = Memory.excessEnergy;
			Game.notify(`Report at ${hours}: 
        ${JSON.stringify(obj)}
        excess energy: ${excess}`, 360);

			try {
					let reportString = JSON.stringify(obj);
					if (reportString){
							console.log(`report|${Game.shard.name}|${reportString}`);
					} else {
							console.log('report string error');
					}
			} catch(err){
					console.log(err);
			}

			function roomtotal(res, room){
					if (!room){
							return null
					}
					if (room.storage && room.storage.store[res]){
							var a = room.storage.store[res];
					} else {
							var a = 0;
					}
					if (room.terminal && room.terminal.store[res]){
							var b = room.terminal.store[res];
					} else {
							var b = 0;
					}
					return (a + b)
			}
	}
	function start(){
			if (Memory.stats){
					if (Game.cpu.getUsed() > 50 && GlobalCount > 30){
							console.log(`Reset runtime due to cpu of ${Game.cpu.getUsed()}`);
							Game.cpu.halt();
					}
			}
			if (Game.time % 1000 === 0){
					console.log(`report|${Game.shard.name}|bucket:${Game.cpu.bucket} credits:${Game.market.credits} emergency:${Memory.emergency} energyCrisis:${Memory.energyCrisis}`);
			}
			if (config$1.official && Game.cpu.bucket === 10000){
					//why is the bucket high? error?
					console.log(`announcement|${Game.shard.name}|possible error - bucket full`);
			}
			if (Game.time % 10 === 0 && Memory.myRooms){
					let creepLength = Object.keys(Game.creeps).length;
					if (creepLength < Memory.myRooms.length){
							//why so few creeps?
							console.log(`announcement|${Game.shard.name}|possible error - few creeps`);
					}
			}
			if (!globalId){
					globalId = Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
			}
			if (Game.shard.name == 'shard2');
			if (GlobalCount != undefined){
					GlobalCount += 1;
					let heap = Game.cpu.getHeapStatistics();
					heap.timeSinceReset = GlobalCount;
					Memory.stats.heap = heap;
					if (GlobalCount % 10 == 0){
							console.log('time since last reset: ' + GlobalCount, 'bucket: ' + Game.cpu.bucket,
									`Used ${Game.cpu.getHeapStatistics().total_heap_size / 1000000}Mb / ${Game.cpu.getHeapStatistics().heap_size_limit / 1000000}Mb`);

							if (Memory.start){
									console.log(`Colony age: ${Game.time - Memory.start}`);
							}
					}
			}
	}

	/*
	 Flag layout:
	 //PLACE THESE: boost+roomName && rally+roomName
	 'siege-homeRoomName-1-A-0-0-0-B'
	 - siege states thisflag is for sieging
	 - 1 states the spawn used to supply squads
	 - this number is the number of the chain
	 - A states the option for type of siege (R - Raze, T - Test , D - Defence, L - Loot, Ca - Capture)
	 - the first number is number of dozers
	 - the second number is number of attackers
	 - the third number is number of snipers
	 - boosted or not(Y or N)
	 - all will spawn with 1 associated medic
	 
	 need this to decide buildings destroyed - find path to buildings once room can be seen - place doze flag on these
	 check flags such as rally and boost are present before requesting spawn
	 if room in safe mode or key building destroyed or if defence test over - move to next target or prevent spawning && suicide creeps && delete flag

	 
	 */
	var time;

	function siege(homeRoom){
			let current;
			if (Game.time % 100 != 0 && !homeRoom.memory.siege){
				return
			}
			if (!time || time != Game.time){
				for (var f in Game.flags){
					var flag = Game.flags[f];
					var array = flag.name.split('-');
					if (array[0] == 'WP');
					if (array[0] === 'siege' && array.length > 7){
						let hname = array[1];
						let home = Game.rooms[hname];
						if (home && Game.flags['rally' + hname]){
							//saving active sieges
							if (!home.memory.siege){
								home.memory.siege = {};
							}
							home.memory.siege[array[2]] = {
								Flag: flag.name,
								Type: array[3],
								Dozers: array[4],
								Attackers: array[5],
								Snipers: array[6],
								Boost: array[7],
								Medics: (array[8] || undefined)
							};
						} else {
							console.log('SIEGE ERROR - siege flags not found at ' + hname);
						}
					}
				}
				time = Game.time;
			}
			if (homeRoom.memory.siege){
				for (let i in homeRoom.memory.siege){
					if (Game.flags[homeRoom.memory.siege[i].Flag]){
						if (!current || i < current){
							current = i;
						}
					} else {
						delete homeRoom.memory.siege[i];
					}
				}
			}
			if (homeRoom.memory.siege){
				//console.log(JSON.stringify(homeRoom.memory.siege))
				if (current){
					var siegeObj = homeRoom.memory.siege[current];
					if (siegeObj){
						//siege memory object for boosting, spawning, targetflag, suicide, target - write to this for instructions for the squads
						//checking the options
						var flag = Game.flags[siegeObj.Flag];
						//boost
						var boost = siegeObj.Boost;
						let roomName;
						if (flag && flag.pos && flag.pos.roomName){
							roomName = flag.pos.roomName;
							flag.pos;
						}
						//room specific variables
						if (flag && flag.room && flag.pos){
							var room = flag.room;


							if ((siegeObj.Type == 'D' || (room && room.controller && room.controller.safeMode == undefined) || siegeObj.Type == 'Ca')){
								if (room && room.controller && room.controller.safeMode != undefined && !room.controller.my){
									homeRoom.memory.siegeBlock[room.name] = Game.time + room.controller.safeMode;
								}
								var doz = siegeObj.Dozers;
								var att = siegeObj.Attackers;
								var snip = siegeObj.Snipers;

							} else if (siegeObj.Type != 'D' && siegeObj.Type != 'Ca' && siegeObj.Type != 'T'){
								//remove flag
								Game.flags[siegeObj.Flag].remove();
							} else if (siegeObj.Type == 'D' || siegeObj.Type == 'Ca'){
								var doz = siegeObj.Dozers;
								var att = siegeObj.Attackers;
								var snip = siegeObj.Snipers;
							}
						} else {
							var doz = siegeObj.Dozers;
							var att = siegeObj.Attackers;
							var snip = siegeObj.Snipers;
						}
						let block = false;
						if (homeRoom.memory.siegeBlock && roomName && homeRoom.memory.siegeBlock[roomName]
							&& homeRoom.memory.siegeBlock[roomName] > Game.time){
							console.log('siege blocked for', homeRoom.name);
							block = true;
						}
						var medic = Number.parseInt(doz) + Number.parseInt(att) + Number.parseInt(snip);
						if (medic < 2 && boost == true){
							medic = 1;
						}
						if (siegeObj.Medics){
							medic = siegeObj.Medics;
						}
						/*
						if (siegeObj.Type == 'Ca' && room){
								var tombs = room.find(FIND_TOMBSTONES,{filter: (t)=>t.creep.ticksToLive > 1})
								var hostile = room.find(FIND_HOSTILE_CREEPS)
								if (tombs || hostile.length > 5){
										boost = 3
								}
						}*/
						if (siegeObj.Type == 'Ca' && flag && flag.pos.roomName){
							if (Game.map.getRoomLinearDistance(flag.pos.roomName, homeRoom.name) <= 10 && (!room || (room.controller && room.controller.safemode))){
								block = true;
							}
						}
						if (siegeObj.type == 'T'){
							boost = 0;
						}
						if (!block){
							requestSquad(homeRoom, flag.pos.roomName, {
								dozers: Number.parseInt(doz),
								attackers: Number.parseInt(att),
								snipers: Number.parseInt(snip),
								medics: Number.parseInt(medic),
								boosted: Number.parseInt(boost),
								type: siegeObj.Type,
								flag: flag.name
							});
						}
					}
				} else {
					delete homeRoom.memory.siege;
				}
			} else {
				delete homeRoom.memory.squad;
				delete homeRoom.memory.siege;
			}

		}

	function stats(){
			let logCPU = false;
			var rooms = Game.rooms;
			Game.spawns;
			let my8Rooms = [];
			let roomPerformanceInterval = 5000;
			let labsIdle  = 0;
			for (let roomKey in rooms){
				let room = Game.rooms[roomKey];
				var isMyRoom = (room.controller ? room.controller.my : 0);
				if (isMyRoom){
						let labIdle = 0, product = 0,boosting = 0;
						if (room.memory.product){
								product = 1;
						}
						if (room.memory.boostingRequired){
								boosting = 1;
						}
						if (!room.memory.boostingRequired && room.terminal && room.controller.level > 5 && room.memory.labCooldownOver && room.memory.labCooldownOver < Game.time -20){
								labsIdle++;
								labIdle = 1;
						}
						if (!Memory.stats.labDataByRoom){
								Memory.stats.labDataByRoom = {};
						}
						if (room.memory.terminal && room.controller.level > 5){
								Memory.stats.labDataByRoom[room.name] = {
										product:product,
										idle:labIdle,
										boosting: boosting
								};
						}
					if (room.controller.level = (Game.time % roomPerformanceInterval == 0 || !Memory.roomPerformanceList)){
						if (!room.memory.energyContributed){
							room.memory.energyContributed = 0;
						}
						// let index = __.sortedIndexBy(my8Rooms, {
						// 	room: room.name,
						// 	val: room.memory.energyContributed
						// }, function (o){
						// 	return o.val
						// })
							let index = my8Rooms.findIndex((r)=>{
									return r.val > room.memory.energyContributed
							});
						if (index){
							my8Rooms.splice(index, 0, {room: room.name, val: room.memory.energyContributed});
						} else {
							my8Rooms.push({room: room.name, val: room.memory.energyContributed});
						}
						room.memory.energyContributed = 0;
					}
					if (Game.time % 2000 == 0){
						if (room.storage && room.storage.my === true){
							if (_.sum(room.storage.store) > room.storage.store.getCapacity() * 0.85){
								Game.notify('STORAGE WARNING : room ' + room.name + ' storage is at ' + Math.floor((_.sum(room.storage.store) / room.storage.store.getCapacity()) * 100) + ' percent');
							}
						}
						if (room.terminal && room.terminal.my === true){
							if (_.sum(room.terminal.store) > room.terminal.store.getCapacity() * 0.85){
								Game.notify('STORAGE WARNING : room ' + room.name + ' terminal is at ' + Math.floor((_.sum(room.terminal.store) / room.terminal.store.getCapacity()) * 100) + ' percent');
							}
						}
					}
						Memory.stats['rooms.' + room.name + '.RCLProgress']=room.controller.progress;
						if (room.controller.progressTotal){
								Memory.stats['rooms.' + room.name + '.RCLProgressLeft']=room.controller.progressTotal-room.controller.progress;
						} else if (Memory.stats['rooms.' + room.name + '.RCLProgressLeft']) {
								delete Memory.stats['rooms.' + room.name + '.RCLProgressLeft'];
						}
						if (room.memory.walls){
								Memory.stats['rooms.' + room.name + '.wallsHits']=room.memory.walls;
						}
						if (room.memory.adjustedLowWallHits){
								Memory.stats['rooms.' + room.name + '.lowWallHits']=room.memory.adjustedLowWallHits;
						}
						if (!config.official){
								Memory.stats['rooms.' + room.name + '.RCL']=room.controller.level;
								Memory.stats['rooms.'+room.name+'.fillPercentage']= (room.energyAvailable/room.energyCapacityAvailable)*100;
						}
						if (!Memory.stats.spawnsInUse || Game.time % 100){
								Memory.stats.spawnsInUse = {};
								Memory.stats.spawnsTotal = {};
								Memory.stats.spawnUsePercent = {};
						}
						if (Game.cpu.bucket > 9000 && !config.official){
								let spawns = room.findStructures('spawn',(s)=>s.my);
								if (spawns){
										let total = spawns.length;
										let spawning = 0;
										for (let s in spawns){
												if (spawns[s] && spawns[s].spawning){
														spawning++;
												}
										}
										Memory.stats.spawnsTotal[room.name] += total;
										Memory.stats.spawnsInUse[room.name] += spawning;
										Memory.stats.spawnUsePercent[room.name] = (spawning/total)*100;
								} else {
										Memory.stats.spawnsTotal[room.name] = 0;
										Memory.stats.spawnsInUse[room.name] = 0;
										Memory.stats.spawnUsePercent[room.name] = 0;
								}
						} else {
								Memory.stats.spawnsTotal[room.name] = 0;
								Memory.stats.spawnsInUse[room.name] = 0;
								Memory.stats.spawnUsePercent[room.name] = 0;
						}
					if (Game.time % 500 == 0 && false){
						if (room.storage && room.terminal && false){
							for (var i = 0; i < RESOURCES_ALL.length; i++){
								if (room.storage.store[RESOURCES_ALL[i]]){
									var storageStore = room.storage.store[RESOURCES_ALL[i]];
								} else {
									var storageStore = 0;
								}
								if (room.terminal.store[RESOURCES_ALL[i]]){
									var termStore = room.terminal.store[RESOURCES_ALL[i]];
								} else {
									var termStore = 0;
								}

								Memory.stats['rooms.' + room.name + '.stores.' + RESOURCES_ALL[i]] = termStore + storageStore;

							}
						}
					}
				} else {
					delete Memory.stats['rooms.' + room.name + '.myRoom'];
				}
			}
			Memory.stats['labsIdle'] = labsIdle;
			if (Game.time % roomPerformanceInterval == 0 || !Memory.roomPerformanceList){
				Memory.roomPerformanceList = my8Rooms;
			}
			if (Memory.sourceLimit){
				Memory.stats['sourceLimit'] = Memory.sourceLimit;
			}
			let emergency = 0, energyCrisis = 0, energyCaution = 0;
			if (Memory.emergency){
				emergency = 1;
			}
			if (Game.energyCrisis){
				energyCrisis = 1;
			}
			if (Game.energyCaution){
					energyCaution = 1;
			}
			Memory.stats['emergency'] = emergency;
			Memory.stats['energyCrisis'] = energyCrisis;
			Memory.stats['energyCaution'] = energyCaution;
			Memory.stats['gcl.progress'] = Game.gcl.progress;
			Memory.stats['creeps.population'] = Game.creeps.length;
			Memory.stats['credits'] = Game.market.credits;
			Memory.stats['gcl.progressTotal'] = Game.gcl.progressTotal;
			Memory.stats['gcl.level'] = Game.gcl.level;
			Memory.stats.cpu['bucket'] = Game.cpu.bucket;
			Memory.stats.cpu['limit'] = Game.cpu.limit;
			Memory.stats.cpu['getUsed'] = Game.cpu.getUsed();
			Memory.stats['time'] = Game.time;
			if (config.logStats && (Game.time + (Math.ceil(Math.random()) * 50))){
				console.log('stats', Game.shard.name, JSON.stringify(Memory.stats));
			}
			if (Game.time % 1500 === 0){
					delete Memory.stats.cumulativeCPU;
			}
			if (Memory.stats.cumulativeCPU && Memory.stats.cumulativeCPU.count !== undefined && logCPU){
					Memory.stats.cumulativeCPU.count++;
					for (let i in Memory.stats.cumulativeCPU){
							if (i === 'count'){
									continue
							}
							let average = Memory.stats.cumulativeCPU[i]/Memory.stats.cumulativeCPU.count;
							if (average > Game.cpu.limit/100){
									console.log(`average cpu for ${i} : ${average}`);
							}
					}
			}
			let coveredCPU = 0;
			for (let i in Memory.stats.cpu){
					let name = i;
					let value = Memory.stats.cpu[i];
					if (name === 'bucket'||name === 'count' || name === 'limit' || name === 'getUsed'){
							continue
					}
					coveredCPU += value;
			}
			Memory.stats.coverageAmount = coveredCPU;
			Memory.stats.coveredPercent = coveredCPU/Memory.stats.cpu['getUsed']*100;
			for (let i in Memory.stats.cpu){
				let name = i;
				let value = Memory.stats.cpu[i];
				if (!Memory.stats.cumulativeCPU){
					Memory.stats.cumulativeCPU = {
							count:0
					};
				}
				if (name === 'bucket'||name === 'count'){
					continue
				}
				if (!Memory.stats.cumulativeCPU[name]){
					Memory.stats.cumulativeCPU[name] = 0;
				}
				Memory.stats.cumulativeCPU[name] += value;
			}
		}

	//remember to defang -> Memory.priority swc off
	exports.operators = [];
	//dissi memHack
	global.lastMemoryTick = undefined;
	function tryInitSameMemory(){
			if (lastMemoryTick && global.LastMemory && Game.time == (lastMemoryTick + 1)){
					delete global.Memory;
					global.Memory = global.LastMemory;
					RawMemory._parsed = global.LastMemory;
			} else {
					Memory;
					global.LastMemory = RawMemory._parsed;
			}
			lastMemoryTick = Game.time;
	}

	module.exports.loop = function (){
			tryInitSameMemory();
			Memory.priority = "power";
			if (config$1.swc){
					Memory.priority = 'swc';
			}
			if (!Memory.stats){
					Memory.stats = {};
			}
			Memory.stats.cpu = {'mem':0,'ext':0,'commodity':0,'siege':0,'trade':0,'combat':0,'scout':0,'obs':0,'ambush':0,
					'link':0,'observer':0,'power':0,'rooms':0,'lab':0,'towers':0, 'thoriumMines':0,'pray':0,'spawn':0,'memStart':0,'defence':0,'roomMisc':0,
					'assignTerritory':0, 'outposts':0,'remoteLogic':0,'support':0,'processPower':0,'SKM':0};
			Memory.stats.cpu['mainStart'] = Game.cpu.getUsed();
			let memStartCpu = Game.cpu.getUsed();
			start();
			setUp();
			garbageCollection();
			Memory.stats.cpu['memStart'] = Game.cpu.getUsed()-memStartCpu;
			if (config$1.season && config$1.season === 'power'){
					for (let i in Memory.contestedRooms){
							let pos = new RoomPosition(25, 25, i);
							Game.map.visual.text('contested', pos);
					}
			}
			try {
					let cpupreproto = Game.cpu.getUsed();
					setProtos();
					let cpupostproto = Game.cpu.getUsed();
					Memory.stats.cpu['proto'] = cpupostproto - cpupreproto;
			} catch (err){
					console.log(err.stack.split("at"));
			}
			if (config$1.season && config$1.season === 'caravan'){
					logScoreStored();
			}
			let preTrade = Game.cpu.getUsed();
			if (Game.time % 100 === 0 && config$1.logStats){
					logHistory();
			}
			Memory.stats.cpu['tradeHistory'] = Game.cpu.getUsed()-preTrade;
			//memorise key info for all rooms
			for (let i in Game.rooms){
					let room = Game.rooms[i];
					let cpuprerooms = Game.cpu.getUsed();
					if (room.controller && room.controller.my){
							Memory.myRooms.push(room.name);
							room.memory.activeGuards = [];
							if (Memory.mineralsWithAccess && Game.time % 500 == 0){
									let mineral = room.mineral;
									if (mineral && mineral.mineralType){
											if (!Memory.mineralsWithAccess[mineral.mineralType]){
													Memory.mineralsWithAccess[mineral.mineralType] = 0;
											}
											Memory.mineralsWithAccess[mineral.mineralType]++;
									}
							}
					}
					rMemorise(room);
					let cpupostrooms = Game.cpu.getUsed();
					Memory.stats.cpu['rooms'] += cpupostrooms - cpuprerooms;
			}
			//segments
			let cpupreseg = Game.cpu.getUsed();
			try {
					run$14();
			} catch (err){
					console.log('Segment error ' + err.stack.split("at"));
			}
			let cpupostseg = Game.cpu.getUsed();
			Memory.stats.cpu['seg'] = cpupostseg - cpupreseg;
			let cpuCombat = Game.cpu.getUsed();
			try {
					runSquadManager();
					tidy();
			} catch (err){
					console.log('squads ' + err.stack.split("at"));
			}
			Memory.stats.cpu['combat'] += Game.cpu.getUsed() - cpuCombat;
			let cpuEmpire = Game.cpu.getUsed();
			runEmpireManager();
			Memory.stats.cpu['empire'] = Game.cpu.getUsed() - cpuEmpire;
			let cpuPCs = Game.cpu.getUsed();
			//runPCs powercreeps if possible
			if ((Game.shard.name == 'shard2' || !config$1.official) && Game.powerCreeps){
					try {
							runPCs();
					} catch (err){
							console.log(err.stack.split("at"));
					}
					exports.operators = [];
					for (let i in Game.powerCreeps){
							let pc = Game.powerCreeps[i];
							if (pc.className == 'operator'){
									exports.operators.push(pc);
							}
					}
			}
			Memory.stats.cpu['PCs'] = Game.cpu.getUsed() - cpuPCs;
			var date = new Date();
			var hours = date.getHours();
			if (!Memory.report){
					Memory.report = {};
			}
			if (Memory.report.hour === undefined || (hours && Memory.report.hour != hours) || Memory.excessEnergy === undefined){
					if (hours % 6 === 0){
							delete Memory.stats.roomEnergyProfit;
							delete Memory.stats.cumulativeCPU;
					}
					runReport();
					Memory.report.hour = hours;
			}


			let cpuMarket = Game.cpu.getUsed();
			//market
			try {
					runMarketManager();
			} catch (err){
					console.log(err.stack.split("at"));
			}
			Memory.stats.cpu['market'] = Game.cpu.getUsed() - cpuMarket;

			let cpuprerouting = Game.cpu.getUsed();
			try {
					if (!Memory.nextClaims){
							Memory.nextClaims = {};
					}
					if (config$1.needVision){
							for (let r in config$1.needVision){
									let roomName = config$1.needVision[r];
									sendVisionCreep(roomName);
							}
					}
					if (config$1.highwayWalls && config$1.breakHighwayWalls && Memory.highwayWalls){
							if (!Memory.reachableSectors){
									Memory.reachableSectors = {};
							}
							// for (let i in Memory.lastObserved){
							// 		let pos = new RoomPosition(45,15,i)
							// 		Game.map.visual.text('o', pos,{fontSize:10})
							// }
							if (Game.time % 100 == 0){
									let mySectors = [];
									for (let r in Game.myRooms){
											let roomName = Game.myRooms[r].name;
											let sector = Game.map.getSector(roomName);
											if (!Memory.reachableSectors[sector]){
													Memory.reachableSectors[sector] = true;
											}
											if (!mySectors.includes(sector)){
													mySectors.push(sector);
											}
									}
									let allRooms = [];
									for (let s in Memory.reachableSectors){
											if (Memory.openHighwayWalls && Memory.openHighwayWalls.sectors && Memory.openHighwayWalls.sectors[s]){
													for (let i in Memory.openHighwayWalls.sectors[s]){
															if (!Memory.reachableSectors[i]){
																	Memory.reachableSectors[i] = true;
															}
													}
											}
											let distance = 100;
											for (let ms in mySectors){
													let range = Game.map.getRoomLinearDistance(mySectors[ms], s);
													if (range < distance){
															distance = range;
													}
											}
											if (distance <= 20){
													let rooms = Game.map.getRoomsInSector(s);
													allRooms = allRooms.concat(rooms);
											}
									}
									let sentObserver = {};

									function shuffleArray(array){
											for (let i = array.length - 1; i > 0; i--){
													const j = Math.floor(Math.random() * (i + 1));
													[array[i], array[j]] = [array[j], array[i]];
											}
									}

									shuffleArray(allRooms);
									for (let i in allRooms){
											let checkRoom = allRooms[i];
											if (!Memory.lastObserved){
													Memory.lastObserved = {};
											}
											if (!Memory.lastObserved[checkRoom] || Game.time - Memory.lastObserved[checkRoom] > 5000){
													let nearestRoom, nearestDistance, normalObserve;
													for (let i in Memory.myRooms){
															let range = Game.map.getRoomLinearDistance(Memory.myRooms[i], checkRoom);
															if (range <= 10 && Game.rooms[Memory.myRooms[i]].controller.level == 8){
																	normalObserve = true;
																	break
															}
															if (range <= 20 && Game.rooms[Memory.myRooms[i]] && Game.rooms[Memory.myRooms[i]].controller &&
																	Game.rooms[Memory.myRooms[i]].controller.level > 6 && (!nearestRoom || nearestDistance > range)){
																	nearestRoom = Memory.myRooms[i];
																	nearestDistance = range;
															}
													}
													if (!normalObserve && nearestRoom && !sentObserver[nearestRoom]){
															let canSend = Game.rooms[nearestRoom].sendObserver(checkRoom);
															if (canSend){
																	sentObserver[nearestRoom] = true;
															}
													}
											}
									}
							}
							for (let r in config$1.breakHighwayWalls){
									let roomName = config$1.breakHighwayWalls[r];
									if (Memory.openHighwayWalls && Memory.openHighwayWalls.rooms && Memory.openHighwayWalls.rooms.includes(roomName)){
											continue
									}
									let nearestRoom;
									let nearestDistance;
									for (let i in Memory.myRooms){
											if (Game.map.getRoomLinearDistance(Memory.myRooms[i], roomName) < 10){
													let route = Game.map.findRoute(Memory.myRooms[i], roomName);
													if (Game.rooms[Memory.myRooms[i]] && Game.rooms[Memory.myRooms[i]].controller &&
															Game.rooms[Memory.myRooms[i]].controller.level > 6 && (!nearestRoom || route.length < nearestDistance)){
															nearestRoom = Memory.myRooms[i];
															nearestDistance = route.length;
													}
											}
									}
									if (nearestRoom){
											Game.rooms[nearestRoom].sendWallRemover(roomName);
									}
							}
					}
					if (((config$1.nextClaims && config$1.nextClaims.length > 0) || canAutoExpand()) && Memory.myRooms.length > 0 && (Memory.myRooms.length < Game.gcl.level) && (config$1.nextClaims || Memory.nextClaims)){
							let configClaims = [];
							if (config$1.nextClaims && (!config$1.official || Game.shard.name === 'shard2')){
									for (let i in config$1.nextClaims){
											let name = config$1.nextClaims[i];
											let room = Game.rooms[name];
											if (!room || !room.controller.my){
													configClaims.push(name);
											}
									}
							}
							if (configClaims && configClaims.length > 0){
									for (let c in configClaims){
											organiseClaim(configClaims[c]);
									}
							} else if (canAutoExpand() && Memory.nextClaims){
									for (let c in Memory.nextClaims){
											organiseClaim(c);
									}
							}
					}

					function organiseClaim(nextClaim){
							if (!Memory.myRooms.includes(nextClaim)){
									let nearestRoom;
									let nearestDistance;
									for (let i in Memory.myRooms){
											if (Game.map.getRoomLinearDistance(Memory.myRooms[i], nextClaim) < 12){
													let route = Game.map.findRoute(Memory.myRooms[i], nextClaim);
													if (Game.rooms[Memory.myRooms[i]] && (!nearestRoom || route.length < nearestDistance)){
															nearestRoom = Memory.myRooms[i];
															nearestDistance = route.length;
													}
											}
									}
									let pos = new RoomPosition(25, 25, nextClaim);
									let cancelPlace = false;
									if (nearestRoom){
											if (config$1.mapVisual){
													Game.map.visual.text('claim',pos,{color:'#f00000'});
													Game.map.visual.line(new RoomPosition(25,25,nearestRoom),pos,{color:'#f00000',lineStyle:'dashed'});
											}
											if (Game.time % 100 === 0){
													console.log('next claim', nextClaim, 'nearest:', nearestRoom, 'cancelPlace:', cancelPlace);
											}
											if (Game.rooms[nextClaim] && Game.rooms[nextClaim].controller.reservation &&
													Game.rooms[nextClaim].controller.reservation.username == 'Invader'){
													requestSquadsViaCombatManager(nextClaim, 'C', {maxLevel: 0,noMedic:true});
													let freeSpots = 0;
													let neighbours = Game.rooms[nextClaim].controller.pos.neighbours();
													for (let i in neighbours){
															if (neighbours[i].getTerrain()!== 'wall'){
																	freeSpots++;
															}
													}
													if (freeSpots > 4){
															freeSpots = 4;
													}
													Game.rooms[nearestRoom].sendClaimer(pos.roomName,freeSpots);
											} else if (!cancelPlace && Game.rooms[nextClaim]){
													console.log('send claim and col');
													Game.rooms[nearestRoom].sendColonists(pos.roomName);
													Game.rooms[nearestRoom].sendClaimer(pos.roomName);
											} else {
													//get vision
													Game.rooms[nearestRoom].sendVisionCreep(nextClaim);
											}
									}
							}
					}
			} catch (err){
					console.log(err.stack.split("at"));
					Game.notify(err);
			}

			Memory.stats.cpu['routing'] = Game.cpu.getUsed() - cpuprerouting;
			var cpuprerun = Game.cpu.getUsed();
			runCreeps();
			var cpupostrun = Game.cpu.getUsed();
			Memory.stats.cpu['run'] = cpupostrun - cpuprerun;
			let interval = 1000/Memory.myRooms.length;
			if (interval > 300 && Game.cpu.bucket > 9000){
					interval = 300;
			}
			if (!config$1.official && interval > 100 && Game.cpu.bucket > 9500){
					interval = 100;
			}
			let cpubuild1 = Game.cpu.getUsed();
			if (Game.myRooms){
					for (let i in Game.myRooms){
							let room = Game.myRooms[i];
							if (room.class && room.class !== 'normal'){
									continue
							}
							if (!room.memory.build || room.memory.build != config$1.buildVer){
									console.log(room.name, 'not built');
									if (Game.cpu.bucket < 500){
											setFreezeToBuild(3);
									}
							}
							if ((Game.shard.name == 'shard2' || !config$1.official) && (!room.memory.build || room.memory.build != config$1.buildVer) && (Game.time + (room.index*3)) % 20 == 0){
									buildRoom(room);
							} else if (room.controller.level < 3 && !room.memory.sites && !room.memory.spawn && (Game.time % 20 === 0 || Memory.myRooms.length === 1)){
									buildRoom((room));
							} else if (!room.memory.sites && Game.time % 10 === 0 && room.energyCapacityAvailable < CONTROLLER_STRUCTURES['extension'][room.controller.level]*50){
									buildRoom((room));
							}
					}
			}
			if (((Game.time + 13) % 10000) == 0 || !Memory.lastbuilt || (Memory.lastbuilt && (Memory.lastbuilt + interval) < Game.time && Game.cpu.bucket > 0)){
					try {
							buildRoom();
					} catch (err){
							console.log(err.stack.split("at"));
					}
					Memory.lastbuilt = Game.time;
			}
			Memory.stats.cpu['build'] = Game.cpu.getUsed() - cpubuild1;
			var cpuglobal1 = Game.cpu.getUsed();
			setPrices();
			if ((Game.time+5) % 10 === 0){
					handleTransactions();
			}
			var cpuglobal2 = Game.cpu.getUsed();
			Memory.stats.cpu['global'] = cpuglobal2 - cpuglobal1;

			//delete global paths that have expired
			if (Game.time % 50 == 0){
					for (var p in Memory.globalPaths){
							if (Memory.globalPaths[p][1] < Game.time){
									delete Memory.globalPaths[p];
							}
					}
			}
			//remove emergency status
			if (Game.time % 50 == 0){
					Memory.emergency = false;
					delete Memory.requestingEnergy;
			}
			//powerThreshold
			if (Game.time % 5000 === 0){
					setProfitablePowerThreshold();
			}
			//data memory for amount of rooms, amount of sources
			if (!Memory.data){
					Memory.data = {};
			}
			//run the key functions of the rooms first to ensure they execute
			for (let ro in Game.rooms){
					if (Game.rooms[ro] && Game.rooms[ro].controller && Game.rooms[ro].controller.my){
							Game.rooms[ro].display('class:' + Game.rooms[ro].class);
					}
					if (Game.rooms[ro] && Game.rooms[ro].controller && Game.rooms[ro].controller.my && Game.rooms[ro].class === 'normal'){
							let room = Game.rooms[ro];

							//siege
							let cpuSiege = Game.cpu.getUsed();
							try {
									runBlockade(room);
									siege(room);
							} catch (err){
									console.log('siege ' + err.stack.split("at"));
							}
							Memory.stats.cpu['siege'] += Game.cpu.getUsed() - cpuSiege;
							let cpuDefence = Game.cpu.getUsed();
							try {
									runDefenceManager(room);
							} catch (err){
									console.log('defence ' + err.stack.split("at"));
							}
							Memory.stats.cpu['defence'] += Game.cpu.getUsed() - cpuDefence;
					}
					if (Game.rooms[ro] && Game.rooms[ro].controller && Game.rooms[ro].controller.my && Game.rooms[ro].class === 'bunker'){
							let room = Game.rooms[ro];
							let cpuDefence = Game.cpu.getUsed();
							try {
									runDefenceManager(room);
							} catch (err){
									console.log('defence ' + err.stack.split("at"));
							}
							Memory.stats.cpu['defence'] += Game.cpu.getUsed() - cpuDefence;
					}
			}
			runRoomManager();
			if (Game.time % 15 == 0){
					for (let i in Memory.rooms){
							if (!Game.rooms[i] && (Game.map.getRoomType(i) != 'SK' && Game.map.getRoomType(i) != 'centre')){
									delete Memory.rooms[i];
							} else if (Memory.rooms[i].isThoriumMine && Game.rooms[i] &&
									Game.rooms[i].controller && !Game.rooms[i].controller.owner){
									delete Memory.rooms[i];
							}
					}
			}
			let cpuCommod = Game.cpu.getUsed();
			set$1();
			Memory.stats.cpu['commodity'] += Game.cpu.getUsed()-cpuCommod;
			//Spawn exec loop
			for (let i in Game.rooms){
					let cpuprespawn = Game.cpu.getUsed();
					if (Game.rooms[i] && Game.rooms[i].controller && Game.rooms[i].controller.my){
							let room = Game.rooms[i];
							//spawn loop
							if (Game.cpu.bucket === 10000 || room.memory.hostiles || !config$1.official){
									var spawnTimeVariable = 1;
							} else if (Game.cpu.bucket > 9000){
									var spawnTimeVariable = 4;
							} else if (Game.cpu.bucket <= 9000 && Game.cpu.bucket > 8000){
									var spawnTimeVariable = 8;
							} else {
									var spawnTimeVariable = 10;
							}
							if (spawnTimeVariable > 5 && room.memory.boostingRequired){
									spawnTimeVariable = 5;
							}
							if ((Game.time + room.index) % spawnTimeVariable == 0 && (room.spawnFree == true || room.class === 'bunker') && (Game.rooms[i].class === 'normal' || Game.rooms[i].class === 'restructuring'
									|| (Game.rooms[i].class === 'bunker' && Game.rooms[i].controller.level > 2))){
									if (room.class === 'bunker' && (!room.memory.spawn || !Game.spawns[room.memory.spawn])){
											continue
									}
									if ((!room.memory.spawnEnergyBlock || room.energyAvailable >= room.memory.spawnEnergyBlock) || (!room.memory.spawnBlockTime || Game.time > room.memory.spawnBlockTime)){
											let ret = runSpawnManager(room);
											//console.log('spawning',i,ret)
											room.spawnRet = ret;
									} else {
											room.display('spawn blocked');
									}
							} else {
									room.display(`spawn pause, spawns free: ${room.spawnFree}`);
							}
							if (!room.spawnFree && (Game.time % 5 === 0 ||
									(room.memory.spawnCongestion && (Game.time-room.memory.spawnCongestion)<5))){
									let spawn = room.findStructures('spawn',(s)=>s.spawning && s.spawning.remainingTime === 1)[0];
									if (spawn){
											if (room.class === 'bunker' && room.memory.armedHostiles){
													spawn.spawning.cancel();
													room.memory.highPrioritySpawnBlock = Game.time + 50;
											} else {
													let neighbouringCreeps = spawn.pos.lookAround(LOOK_CREEPS,2,{filter:
																	(c)=>c.my && c.role !== 'transfer' && c.role !== 'staticFiller'
													});
													if (neighbouringCreeps.length > 3 || (room.memory.spawnCongestion && (Game.time-room.memory.spawnCongestion)<5)){
															for (let c in neighbouringCreeps){
																	neighbouringCreeps.rally(1);
															}
													} else if (neighbouringCreeps.length > 3){
															room.memory.spawnCongestion = Game.time;
													}
											}
									}
							} else if ((room.memory.spawnCongestion && (Game.time-room.memory.spawnCongestion)>5)){
									delete room.memory.spawnCongestion;
							}
							if (room.memory.walls){
									Memory.stats['room.' + room.name + '.walllevel'] = room.memory.walls;
							}
							let cpupostspawn = Game.cpu.getUsed();
							Memory.stats.cpu['spawn'] += cpupostspawn - cpuprespawn;
					}
			}
			let cpuprecollisions = Game.cpu.getUsed();
			handleCollisions();
			let cpupostcollisions = Game.cpu.getUsed();
			function handleCollisions(){
					let inWayCreeps = Memory.inWayCreeps;
					if (inWayCreeps && inWayCreeps.length > 0){
							let names = [];
							for (let i in inWayCreeps){
									let creep = Game.getObjectById(inWayCreeps[i][0]);
									if (creep){
											names.push(creep.name);
									} else {
											continue
									}
									//todo smarter way of clearing blockages - add to creep cache if ismoving and increment count,
									// clear this counter if intent performed (but add it back if intent is being moved by collision manager)
									if (creep && (!creep.isMoving || (Game.time %10 === 0 && !creep.powers && creep.countParts('work')===0 && (creep.countParts('move')>5 ||creep.store.getUsedCapacity()=== 0)))
											&& ((creep.role != 'transfer') || (creep.home.memory.spawn && Game.spawns[creep.home.memory.spawn] && creep.pos.isNearTo(Game.spawns[creep.home.memory.spawn])))){
											if (creep.pushTowardsTarget && !creep.pos.isNearTo(creep.pushTowardsTarget)){
													creep.moveTo(creep.pushTowardsTarget,{range:1});
													continue
											}
											let newDir = inWayCreeps[i][1];
											let newPos = creep.pos.movePos(newDir);
											let moved;
											if (newPos && newPos.isWalkable() && creep.role != 'depositCarry'){
													moved = creep._move(newDir);
													new RoomVisual(creep.room.name).text('🥾', creep.pos);
											} else {
													for (i = 1; i < 9; i++){
															let pos = creep.pos.movePos(i);
															if (pos.isWalkable(true)){
																	new RoomVisual(creep.room.name).text('🥾', creep.pos);
																	moved = creep._move(i);
																	break
															}
													}
											}
											if (moved === 0){
													//now moved, force a repath so it won't resume pathing from the wrong position
													creep.wipePath();
													delete creep.memory.customPathData;
													delete creep.memory.customPath;
											}
									}
							}
							Memory.inWayCreeps = [];
					}
			}
			Memory.stats.cpu['collisions'] = cpupostcollisions - cpuprecollisions;
			saveAllPendingSegmentData();
			if (Memory.profile){
					//GoTo.log()
					for (let i in Memory.profile){
							let mem = Memory.profile[i];
							if (mem.cpu && mem.count){
									if (mem.count > 500000){
											mem.cpu = 0;
											mem.count = 0;
									}
							}
					}
			}
			if (config$1.profileFunctions){
					profileAllFunctions();
			}
			if (config$1.debugSpawning){
					for (let i in Game.spawns){
							let spawn = Game.spawns[i];
							if (!Memory.debugSpawns){
									Memory.debugSpawns = {};
							}
							if (!Memory.debugSpawns[spawn.room.name]){
									Memory.debugSpawns[spawn.room.name] = {};
							}
							if (!Memory.debugSpawns[spawn.room.name][i]){
									Memory.debugSpawns[spawn.room.name][i] = [];
							}
							let spawnArray = Memory.debugSpawns[spawn.room.name][i];
							if (spawnArray && spawnArray.length > 3000){
									spawnArray.shift();
							}
							if (spawn.spawning){
									let creep = Game.creeps[spawn.spawning.name];
									let index = 500;
									if (creep){
											let role = creep.role;
											index = roles.indexOf(role);
									}
									spawnArray.push(index);
							} else {
									let str = 'p';
									let room = spawn.room;
									if ((room.memory.spawnEnergyBlock && room.energyAvailable < room.memory.spawnEnergyBlock)){
											str = 'e';
									} else if ((room.memory.spawnBlockTime && Game.time <= room.memory.spawnBlockTime)){
											str = 'b';
									}
									if (room.spawnRet){
											str = room.spawnRet.charAt(0);
									}
									let percent = spawn.room.energyAvailable/spawn.room.energyCapacityAvailable.toFixed(1);
									str = str+percent;
									spawnArray.push(str);
							}
					}
					if (Game.time % 1000 === 0){
							for (let i in Memory.debugSpawns){
									for (let j in Memory.debugSpawns[i]){
											let array = Memory.debugSpawns[i][j];
											let total = 0;
											let idle = 0;
											let block = 0;
											let energyBlock = 0;
											let nBlock = 0;
											array.forEach((item)=>{
															if (typeof item === 'string'){
																	idle++;
																	let char = item.charAt(0);
																	if (char === 'b'){
																			block++;
																	} else if (char === 'e'){
																			energyBlock++;
																	} else if (char === 'n'){
																			nBlock++;
																	}
															}
															total++;
													}
											);
											console.log('spawn percent',j,idle/total);
											console.log('block percent',j,block/total);
											console.log('energy block percent',j,energyBlock/total);
											console.log('nothing queued percent',j,nBlock/total);
									}
							}
					}
			}
			 else {
					 delete Memory.debugSpawns;
			}
			// if (Game.rooms['E26N17']){
			// 		console.log('fixerparts',spawnCode.isRequired(Game.rooms['E26N17'],countRole,false,true),spawnCode.isRequired(Game.rooms['E26N17'],countRole,false),JSON.stringify(spawnCode.body(Game.rooms['E26N17'],countRole)))
			// 		if (Game.rooms['E26N17'].memory.fixerSpawnLastPartsNeeded){
			// 				console.log('last fixer parts',Game.rooms['E26N17'].memory.fixerSpawnLastPartsNeeded)
			// 		}
			// }
			if (Game.time % 3 === 0);
			let cpuStats = Game.cpu.getUsed();
			stats();
			Memory.stats.cpu['stats'] = Game.cpu.getUsed()-cpuStats;
	};
	let nearestHomeRoomToRoom = {};
	let blockVisionCreep = {};
	function sendVisionCreep(roomName){
			let nearestRoom;
			let nearestDistance;
			if (blockVisionCreep[roomName] && blockVisionCreep[roomName] > Game.time){
					return
			}
			if (nearestHomeRoomToRoom[roomName] && nearestHomeRoomToRoom[roomName].expiry > Game.time){
					nearestRoom = nearestHomeRoomToRoom[roomName].homeRoom;
			}
			if (!nearestRoom){
					for (let i in Memory.myRooms){
							if (Game.map.getRoomLinearDistance(Memory.myRooms[i], roomName) < 10 || config$1.portalTravelEnabled || Game.shard.name === 'shard0'){
									let route = Game.map.findRoute(Memory.myRooms[i], roomName);
									if (Game.rooms[Memory.myRooms[i]] && (!nearestRoom || route.length < nearestDistance)){
											nearestRoom = Memory.myRooms[i];
											nearestDistance = route.length;
									}
							}
					}
					if (nearestRoom){
							nearestHomeRoomToRoom[roomName]={
									expiry:Game.time+5000,
									homeRoom:nearestRoom
							};
					}
			}
			if (nearestRoom){
					console.log('sending vision to',roomName, 'from', nearestRoom);
					let ret = Game.rooms[nearestRoom].sendVisionCreep(roomName);
					if (ret === 'block'){
							blockVisionCreep[roomName] = Game.time + 200;
					}
			}
	}

	exports.sendVisionCreep = sendVisionCreep;

	Object.defineProperty(exports, '__esModule', { value: true });

	return exports;

})({});
